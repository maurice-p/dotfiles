"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright 2024 The MathWorks, Inc.
const vscode = require("vscode");
const Notifications_1 = require("../Notifications");
const LineRangeTree_1 = require("./LineRangeTree");
const Decorations_1 = require("./Decorations");
const sectionsCacheByPath = new Map();
let previousFocusedEditor;
class SectionStylingService {
    constructor(context) {
        this.context = context;
    }
    initialize(client) {
        this.context.subscriptions.push(client.onNotification(Notifications_1.default.MatlabSections, (data) => this._onNewSectionsGenerated(data)));
        // Listen to cursor change to highlight the section
        this.context.subscriptions.push(vscode.window.onDidChangeTextEditorSelection((event) => this._handleTextEditorSelectionChange(event)));
        // Clear the active blue borders for focus out
        this.context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor((editor) => this._handleEditorFocusChange(editor)));
        this.context.subscriptions.push(vscode.window.onDidChangeWindowState((windowFocusState) => this._handleWindowLostFocus(windowFocusState)));
        this.context.subscriptions.push(vscode.workspace.onDidChangeTextDocument((event) => this._onDocumentChange(event)));
        this.context.subscriptions.push(vscode.workspace.onDidCloseTextDocument((document) => this._onDocumentClose(document)));
    }
    _onDocumentChange(event) {
        const filePath = decodeURIComponent(event.document.uri.toString());
        const sectionCache = sectionsCacheByPath.get(filePath);
        if (sectionCache === undefined || event.contentChanges.length === 0) {
            return;
        }
        // As content changes enable isSectionCreationInProgress flag, so cursor changes will not renders sections with cache.
        // This flag will reset once the sections are regenerated by matlab
        sectionCache.isSectionCreationInProgress = true;
    }
    _onNewSectionsGenerated(sectionsData) {
        const decodedUri = decodeURIComponent(sectionsData.uri);
        const editorInTheWindow = vscode.window.visibleTextEditors.find((editor) => {
            const textEditorURI = this._getDecodedURI(editor);
            return (textEditorURI === decodedUri);
        });
        if (editorInTheWindow === undefined) {
            return;
        }
        this._preProcessAndSaveSectionByEditor(sectionsData, decodedUri, editorInTheWindow);
        this._postProcessSectionsData(sectionsData, editorInTheWindow);
    }
    _preProcessAndSaveSectionByEditor(sectionsData, decodedUri, editorInTheWindow) {
        const { sectionRanges } = sectionsData;
        sectionRanges.sort((a, b) => a.start.line - b.start.line);
        const isSectionAddedAtStart = this._addFirstSectionIfNotExists(sectionRanges);
        // Creates a tree of sections and saves it in the sectionsData cache
        // Used for retrieving the active section to highlight
        sectionsData.sectionsTree = new LineRangeTree_1.default(sectionRanges);
        sectionsData.isSectionCreationInProgress = false;
        sectionsData.implictSectionAtStart = isSectionAddedAtStart;
        sectionsCacheByPath.set(decodedUri, sectionsData);
    }
    // Add first section if not exists otherwise the cursor will not highlight the section
    _addFirstSectionIfNotExists(sectionRanges) {
        var _a;
        if (sectionRanges.length === 0) {
            return false;
        }
        const firstSection = sectionRanges[0];
        const startLine = (_a = firstSection === null || firstSection === void 0 ? void 0 : firstSection.start) === null || _a === void 0 ? void 0 : _a.line;
        if (startLine === 0) {
            return false;
        }
        const newStartLine = 0;
        const newEndLine = startLine - 1;
        const range = new vscode.Range(newStartLine, 0, newEndLine, 0);
        sectionRanges.unshift(range);
        return true;
    }
    _postProcessSectionsData(sectionsData, editorInTheWindow) {
        const { sectionRanges } = sectionsData;
        if (sectionRanges !== undefined && sectionRanges.length === 0) {
            // If there are no sections, clear the decorations
            this._clearDecorations(editorInTheWindow);
            return;
        }
        const activeEditor = this._getActiveEditor();
        if (activeEditor !== undefined && activeEditor === editorInTheWindow) {
            const cursorPosition = editorInTheWindow.selection.active;
            if (cursorPosition !== undefined) {
                // Highlight active sections to blue and inactive sections to grey
                this._highlightSections(activeEditor, sectionsData, cursorPosition);
                return;
            }
        }
        // Highlight all sections to grey
        this._highlightSections(editorInTheWindow, sectionsData, null);
    }
    _clearDecorations(editorInTheWindow) {
        this._setDecorations(editorInTheWindow, { blue: { top: [], bottom: [] }, grey: { top: [], bottom: [] } }, []);
    }
    _getDecodedURI(editor) {
        return decodeURIComponent(editor.document.uri.toString());
    }
    _handleWindowLostFocus(windowState) {
        if (!windowState.focused) {
            const activeEditor = this._getActiveEditor();
            // Clear the blue borders when the window lost focus
            if (activeEditor != null) {
                this._clearBlueDecorations(activeEditor);
            }
        }
    }
    _handleEditorFocusChange(editor) {
        if (previousFocusedEditor !== undefined && previousFocusedEditor !== editor) {
            // Clear the blue borders for previous editors when new editor is focused
            this._clearBlueDecorations(previousFocusedEditor);
        }
        previousFocusedEditor = editor;
    }
    _handleTextEditorSelectionChange(event) {
        const editor = event.textEditor;
        const cursorPosition = editor.selection.active;
        const editorSections = sectionsCacheByPath.get(this._getDecodedURI(editor));
        if ((editorSections === null || editorSections === void 0 ? void 0 : editorSections.isSectionCreationInProgress) === true) {
            // Don't highlight sections if section creation is in progress
            // This will create sections with cache data which will be wrong
            return;
        }
        if (editorSections != null) {
            // Don't highlight sections if there is an error
            this._highlightSections(editor, editorSections, cursorPosition);
        }
    }
    _onDocumentClose(document) {
        // Remove sections from cache when document is closed
        const decodedURI = decodeURIComponent(document.uri.toString());
        sectionsCacheByPath.delete(decodedURI);
    }
    _clearBlueDecorations(previousEditor) {
        const decodedUri = this._getDecodedURI(previousEditor);
        const sections = sectionsCacheByPath.get(decodedUri);
        if (sections !== undefined && sections.isSectionCreationInProgress === false) {
            this._highlightSections(previousEditor, sections, null);
        }
    }
    _getActiveEditor() {
        return vscode.window.activeTextEditor;
    }
    /**
     * Highlights sections in the editor with grey lines if no cursor is present
     * Highlights active section (cursor present) in the editor with blue lines and others in grey line
     * Bold the first line of the sections
     */
    _highlightSections(editor, sections, activeCursorPosition) {
        const startAndEndLines = this._sectionsToStartAndEndLines(sections.sectionRanges);
        const allStartLinesRange = this._generateRanges(startAndEndLines.startLines);
        const lastLineinSection = startAndEndLines.endLines.sort((a, b) => a - b)[startAndEndLines.endLines.length - 1];
        let stylingRanges;
        if (activeCursorPosition !== null) {
            let cursorPositionLine = activeCursorPosition.line;
            if (cursorPositionLine > lastLineinSection) {
                cursorPositionLine = lastLineinSection;
            }
            const focusedSectionRange = this._findFocusedSectionRange(sections, cursorPositionLine);
            if (focusedSectionRange !== undefined) {
                stylingRanges = this._getBlueAndGreyRanges(startAndEndLines, focusedSectionRange);
            }
            else {
                stylingRanges = { blue: { top: [], bottom: [] }, grey: this._getGreyRanges(startAndEndLines) };
            }
        }
        else {
            stylingRanges = { blue: { top: [], bottom: [] }, grey: this._getGreyRanges(startAndEndLines) };
        }
        this._filterFirstAndLastSection(stylingRanges, lastLineinSection, editor.document);
        if (sections.implictSectionAtStart === true) {
            // Remove as the first section is implicit
            allStartLinesRange.shift();
        }
        this._setDecorations(editor, stylingRanges, allStartLinesRange);
    }
    _getBlueAndGreyRanges(startAndEndLines, focusedSectionRange) {
        const focusedStartLine = focusedSectionRange.start.line;
        const focusedEndLine = focusedSectionRange.end.line;
        const { startLines, endLines } = startAndEndLines;
        const startLinesWithoutFocusLine = startLines.filter((startLine) => {
            // Remove the start lines if the start is coinciding with
            // focus start or
            // start line is after the focused end line
            // so we can color them blue
            return !((startLine === focusedStartLine) || (startLine === (focusedEndLine + 1)));
        });
        const endLinesWithoutFocusLine = endLines.filter((endLine) => {
            // Remove the end lines if the end is coinciding with
            // focus end or
            // before the focus end line or
            // is it already part of the start lines
            return !(endLine === focusedEndLine ||
                endLine === (focusedStartLine - 1) ||
                startLines.includes(endLine + 1));
        });
        const blue = { top: [], bottom: [] };
        const isTheEndLineAdjacentToStartLine = startLines.includes(focusedEndLine + 1);
        const topBordersToStyle = [focusedStartLine];
        const bottomLineNumbersToStyle = [];
        if (isTheEndLineAdjacentToStartLine) {
            // Style using top borders if the end line is adjacent to the start line
            topBordersToStyle.push(focusedEndLine + 1);
        }
        else {
            bottomLineNumbersToStyle.push(focusedEndLine);
        }
        blue.top = this._generateRanges(topBordersToStyle);
        blue.bottom = this._generateRanges(bottomLineNumbersToStyle);
        return {
            blue,
            grey: {
                top: this._generateRanges(startLinesWithoutFocusLine),
                bottom: this._generateRanges(endLinesWithoutFocusLine)
            }
        };
    }
    _getGreyRanges(startAndEndLines) {
        const { startLines, endLines } = startAndEndLines;
        const endLinesFiltered = endLines.filter((endLine) => !startLines.includes(endLine + 1));
        return { top: this._generateRanges(startLines), bottom: this._generateRanges(endLinesFiltered) };
    }
    _setDecorations(editor, stylingRange, allStartLinesRange) {
        editor.setDecorations(Decorations_1.blueBorderTopDecoration, stylingRange.blue.top);
        editor.setDecorations(Decorations_1.blueBorderBottomDecoration, stylingRange.blue.bottom);
        editor.setDecorations(Decorations_1.greyBorderTopDecoration, stylingRange.grey.top);
        editor.setDecorations(Decorations_1.greyBorderBottomDecoration, stylingRange.grey.bottom);
        editor.setDecorations(Decorations_1.fontWeightBoldDecoration, allStartLinesRange);
    }
    _generateRanges(lines) {
        return lines.map((line) => new vscode.Range(line, 0, line, Infinity));
    }
    _findFocusedSectionRange(sections, lineNumber) {
        let activeSection;
        if (lineNumber !== undefined && sections.sectionsTree !== undefined) {
            activeSection = sections.sectionsTree.find(lineNumber);
        }
        return activeSection;
    }
    _sectionsToStartAndEndLines(sectionRanges) {
        const startLines = new Set();
        const endLines = new Set();
        sectionRanges.forEach((sectionRange) => {
            const startingIndex = sectionRange.start.line;
            const endingIndex = sectionRange.end.line;
            startLines.add(startingIndex);
            endLines.add(endingIndex);
        });
        return { startLines: Array.from(startLines), endLines: Array.from(endLines) };
    }
    _filterFirstAndLastSection(stylingRanges, endingLineOfSections, document) {
        const filterByLineNumber = (lineNumber) => (position) => !(position.start.line === lineNumber);
        const startingLineOfDocument = 0;
        stylingRanges.blue.top = stylingRanges.blue.top.filter(filterByLineNumber(startingLineOfDocument));
        stylingRanges.grey.top = stylingRanges.grey.top.filter(filterByLineNumber(startingLineOfDocument));
        stylingRanges.blue.bottom = stylingRanges.blue.bottom.filter(filterByLineNumber(endingLineOfSections));
        stylingRanges.grey.bottom = stylingRanges.grey.bottom.filter(filterByLineNumber(endingLineOfSections));
    }
}
exports.default = SectionStylingService;
//# sourceMappingURL=SectionStylingService.js.map
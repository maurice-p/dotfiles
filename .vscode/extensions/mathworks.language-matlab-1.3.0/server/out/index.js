/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vscode/debugadapter/lib/debugSession.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/debugSession.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSession = exports.ErrorDestination = exports.MemoryEvent = exports.InvalidatedEvent = exports.ProgressEndEvent = exports.ProgressUpdateEvent = exports.ProgressStartEvent = exports.CapabilitiesEvent = exports.LoadedSourceEvent = exports.ModuleEvent = exports.BreakpointEvent = exports.ThreadEvent = exports.OutputEvent = exports.ExitedEvent = exports.TerminatedEvent = exports.InitializedEvent = exports.ContinuedEvent = exports.StoppedEvent = exports.CompletionItem = exports.Module = exports.Breakpoint = exports.Variable = exports.Thread = exports.StackFrame = exports.Scope = exports.Source = void 0;
const protocol_1 = __webpack_require__(/*! ./protocol */ "./node_modules/@vscode/debugadapter/lib/protocol.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@vscode/debugadapter/lib/messages.js");
const runDebugAdapter_1 = __webpack_require__(/*! ./runDebugAdapter */ "./node_modules/@vscode/debugadapter/lib/runDebugAdapter.js");
const url_1 = __webpack_require__(/*! url */ "url");
class Source {
    constructor(name, path, id = 0, origin, data) {
        this.name = name;
        this.path = path;
        this.sourceReference = id;
        if (origin) {
            this.origin = origin;
        }
        if (data) {
            this.adapterData = data;
        }
    }
}
exports.Source = Source;
class Scope {
    constructor(name, reference, expensive = false) {
        this.name = name;
        this.variablesReference = reference;
        this.expensive = expensive;
    }
}
exports.Scope = Scope;
class StackFrame {
    constructor(i, nm, src, ln = 0, col = 0) {
        this.id = i;
        this.source = src;
        this.line = ln;
        this.column = col;
        this.name = nm;
    }
}
exports.StackFrame = StackFrame;
class Thread {
    constructor(id, name) {
        this.id = id;
        if (name) {
            this.name = name;
        }
        else {
            this.name = 'Thread #' + id;
        }
    }
}
exports.Thread = Thread;
class Variable {
    constructor(name, value, ref = 0, indexedVariables, namedVariables) {
        this.name = name;
        this.value = value;
        this.variablesReference = ref;
        if (typeof namedVariables === 'number') {
            this.namedVariables = namedVariables;
        }
        if (typeof indexedVariables === 'number') {
            this.indexedVariables = indexedVariables;
        }
    }
}
exports.Variable = Variable;
class Breakpoint {
    constructor(verified, line, column, source) {
        this.verified = verified;
        const e = this;
        if (typeof line === 'number') {
            e.line = line;
        }
        if (typeof column === 'number') {
            e.column = column;
        }
        if (source) {
            e.source = source;
        }
    }
    setId(id) {
        this.id = id;
    }
}
exports.Breakpoint = Breakpoint;
class Module {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}
exports.Module = Module;
class CompletionItem {
    constructor(label, start, length = 0) {
        this.label = label;
        this.start = start;
        this.length = length;
    }
}
exports.CompletionItem = CompletionItem;
class StoppedEvent extends messages_1.Event {
    constructor(reason, threadId, exceptionText) {
        super('stopped');
        this.body = {
            reason: reason
        };
        if (typeof threadId === 'number') {
            this.body.threadId = threadId;
        }
        if (typeof exceptionText === 'string') {
            this.body.text = exceptionText;
        }
    }
}
exports.StoppedEvent = StoppedEvent;
class ContinuedEvent extends messages_1.Event {
    constructor(threadId, allThreadsContinued) {
        super('continued');
        this.body = {
            threadId: threadId
        };
        if (typeof allThreadsContinued === 'boolean') {
            this.body.allThreadsContinued = allThreadsContinued;
        }
    }
}
exports.ContinuedEvent = ContinuedEvent;
class InitializedEvent extends messages_1.Event {
    constructor() {
        super('initialized');
    }
}
exports.InitializedEvent = InitializedEvent;
class TerminatedEvent extends messages_1.Event {
    constructor(restart) {
        super('terminated');
        if (typeof restart === 'boolean' || restart) {
            const e = this;
            e.body = {
                restart: restart
            };
        }
    }
}
exports.TerminatedEvent = TerminatedEvent;
class ExitedEvent extends messages_1.Event {
    constructor(exitCode) {
        super('exited');
        this.body = {
            exitCode: exitCode
        };
    }
}
exports.ExitedEvent = ExitedEvent;
class OutputEvent extends messages_1.Event {
    constructor(output, category = 'console', data) {
        super('output');
        this.body = {
            category: category,
            output: output
        };
        if (data !== undefined) {
            this.body.data = data;
        }
    }
}
exports.OutputEvent = OutputEvent;
class ThreadEvent extends messages_1.Event {
    constructor(reason, threadId) {
        super('thread');
        this.body = {
            reason: reason,
            threadId: threadId
        };
    }
}
exports.ThreadEvent = ThreadEvent;
class BreakpointEvent extends messages_1.Event {
    constructor(reason, breakpoint) {
        super('breakpoint');
        this.body = {
            reason: reason,
            breakpoint: breakpoint
        };
    }
}
exports.BreakpointEvent = BreakpointEvent;
class ModuleEvent extends messages_1.Event {
    constructor(reason, module) {
        super('module');
        this.body = {
            reason: reason,
            module: module
        };
    }
}
exports.ModuleEvent = ModuleEvent;
class LoadedSourceEvent extends messages_1.Event {
    constructor(reason, source) {
        super('loadedSource');
        this.body = {
            reason: reason,
            source: source
        };
    }
}
exports.LoadedSourceEvent = LoadedSourceEvent;
class CapabilitiesEvent extends messages_1.Event {
    constructor(capabilities) {
        super('capabilities');
        this.body = {
            capabilities: capabilities
        };
    }
}
exports.CapabilitiesEvent = CapabilitiesEvent;
class ProgressStartEvent extends messages_1.Event {
    constructor(progressId, title, message) {
        super('progressStart');
        this.body = {
            progressId: progressId,
            title: title
        };
        if (typeof message === 'string') {
            this.body.message = message;
        }
    }
}
exports.ProgressStartEvent = ProgressStartEvent;
class ProgressUpdateEvent extends messages_1.Event {
    constructor(progressId, message) {
        super('progressUpdate');
        this.body = {
            progressId: progressId
        };
        if (typeof message === 'string') {
            this.body.message = message;
        }
    }
}
exports.ProgressUpdateEvent = ProgressUpdateEvent;
class ProgressEndEvent extends messages_1.Event {
    constructor(progressId, message) {
        super('progressEnd');
        this.body = {
            progressId: progressId
        };
        if (typeof message === 'string') {
            this.body.message = message;
        }
    }
}
exports.ProgressEndEvent = ProgressEndEvent;
class InvalidatedEvent extends messages_1.Event {
    constructor(areas, threadId, stackFrameId) {
        super('invalidated');
        this.body = {};
        if (areas) {
            this.body.areas = areas;
        }
        if (threadId) {
            this.body.threadId = threadId;
        }
        if (stackFrameId) {
            this.body.stackFrameId = stackFrameId;
        }
    }
}
exports.InvalidatedEvent = InvalidatedEvent;
class MemoryEvent extends messages_1.Event {
    constructor(memoryReference, offset, count) {
        super('memory');
        this.body = { memoryReference, offset, count };
    }
}
exports.MemoryEvent = MemoryEvent;
var ErrorDestination;
(function (ErrorDestination) {
    ErrorDestination[ErrorDestination["User"] = 1] = "User";
    ErrorDestination[ErrorDestination["Telemetry"] = 2] = "Telemetry";
})(ErrorDestination = exports.ErrorDestination || (exports.ErrorDestination = {}));
;
class DebugSession extends protocol_1.ProtocolServer {
    constructor(obsolete_debuggerLinesAndColumnsStartAt1, obsolete_isServer) {
        super();
        const linesAndColumnsStartAt1 = typeof obsolete_debuggerLinesAndColumnsStartAt1 === 'boolean' ? obsolete_debuggerLinesAndColumnsStartAt1 : false;
        this._debuggerLinesStartAt1 = linesAndColumnsStartAt1;
        this._debuggerColumnsStartAt1 = linesAndColumnsStartAt1;
        this._debuggerPathsAreURIs = false;
        this._clientLinesStartAt1 = true;
        this._clientColumnsStartAt1 = true;
        this._clientPathsAreURIs = false;
        this._isServer = typeof obsolete_isServer === 'boolean' ? obsolete_isServer : false;
        this.on('close', () => {
            this.shutdown();
        });
        this.on('error', (error) => {
            this.shutdown();
        });
    }
    setDebuggerPathFormat(format) {
        this._debuggerPathsAreURIs = format !== 'path';
    }
    setDebuggerLinesStartAt1(enable) {
        this._debuggerLinesStartAt1 = enable;
    }
    setDebuggerColumnsStartAt1(enable) {
        this._debuggerColumnsStartAt1 = enable;
    }
    setRunAsServer(enable) {
        this._isServer = enable;
    }
    /**
     * A virtual constructor...
     */
    static run(debugSession) {
        (0, runDebugAdapter_1.runDebugAdapter)(debugSession);
    }
    shutdown() {
        if (this._isServer || this._isRunningInline()) {
            // shutdown ignored in server mode
        }
        else {
            // wait a bit before shutting down
            setTimeout(() => {
                process.exit(0);
            }, 100);
        }
    }
    sendErrorResponse(response, codeOrMessage, format, variables, dest = ErrorDestination.User) {
        let msg;
        if (typeof codeOrMessage === 'number') {
            msg = {
                id: codeOrMessage,
                format: format
            };
            if (variables) {
                msg.variables = variables;
            }
            if (dest & ErrorDestination.User) {
                msg.showUser = true;
            }
            if (dest & ErrorDestination.Telemetry) {
                msg.sendTelemetry = true;
            }
        }
        else {
            msg = codeOrMessage;
        }
        response.success = false;
        response.message = DebugSession.formatPII(msg.format, true, msg.variables);
        if (!response.body) {
            response.body = {};
        }
        response.body.error = msg;
        this.sendResponse(response);
    }
    runInTerminalRequest(args, timeout, cb) {
        this.sendRequest('runInTerminal', args, timeout, cb);
    }
    dispatchRequest(request) {
        const response = new messages_1.Response(request);
        try {
            if (request.command === 'initialize') {
                var args = request.arguments;
                if (typeof args.linesStartAt1 === 'boolean') {
                    this._clientLinesStartAt1 = args.linesStartAt1;
                }
                if (typeof args.columnsStartAt1 === 'boolean') {
                    this._clientColumnsStartAt1 = args.columnsStartAt1;
                }
                if (args.pathFormat !== 'path') {
                    this.sendErrorResponse(response, 2018, 'debug adapter only supports native paths', null, ErrorDestination.Telemetry);
                }
                else {
                    const initializeResponse = response;
                    initializeResponse.body = {};
                    this.initializeRequest(initializeResponse, args);
                }
            }
            else if (request.command === 'launch') {
                this.launchRequest(response, request.arguments, request);
            }
            else if (request.command === 'attach') {
                this.attachRequest(response, request.arguments, request);
            }
            else if (request.command === 'disconnect') {
                this.disconnectRequest(response, request.arguments, request);
            }
            else if (request.command === 'terminate') {
                this.terminateRequest(response, request.arguments, request);
            }
            else if (request.command === 'restart') {
                this.restartRequest(response, request.arguments, request);
            }
            else if (request.command === 'setBreakpoints') {
                this.setBreakPointsRequest(response, request.arguments, request);
            }
            else if (request.command === 'setFunctionBreakpoints') {
                this.setFunctionBreakPointsRequest(response, request.arguments, request);
            }
            else if (request.command === 'setExceptionBreakpoints') {
                this.setExceptionBreakPointsRequest(response, request.arguments, request);
            }
            else if (request.command === 'configurationDone') {
                this.configurationDoneRequest(response, request.arguments, request);
            }
            else if (request.command === 'continue') {
                this.continueRequest(response, request.arguments, request);
            }
            else if (request.command === 'next') {
                this.nextRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepIn') {
                this.stepInRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepOut') {
                this.stepOutRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepBack') {
                this.stepBackRequest(response, request.arguments, request);
            }
            else if (request.command === 'reverseContinue') {
                this.reverseContinueRequest(response, request.arguments, request);
            }
            else if (request.command === 'restartFrame') {
                this.restartFrameRequest(response, request.arguments, request);
            }
            else if (request.command === 'goto') {
                this.gotoRequest(response, request.arguments, request);
            }
            else if (request.command === 'pause') {
                this.pauseRequest(response, request.arguments, request);
            }
            else if (request.command === 'stackTrace') {
                this.stackTraceRequest(response, request.arguments, request);
            }
            else if (request.command === 'scopes') {
                this.scopesRequest(response, request.arguments, request);
            }
            else if (request.command === 'variables') {
                this.variablesRequest(response, request.arguments, request);
            }
            else if (request.command === 'setVariable') {
                this.setVariableRequest(response, request.arguments, request);
            }
            else if (request.command === 'setExpression') {
                this.setExpressionRequest(response, request.arguments, request);
            }
            else if (request.command === 'source') {
                this.sourceRequest(response, request.arguments, request);
            }
            else if (request.command === 'threads') {
                this.threadsRequest(response, request);
            }
            else if (request.command === 'terminateThreads') {
                this.terminateThreadsRequest(response, request.arguments, request);
            }
            else if (request.command === 'evaluate') {
                this.evaluateRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepInTargets') {
                this.stepInTargetsRequest(response, request.arguments, request);
            }
            else if (request.command === 'gotoTargets') {
                this.gotoTargetsRequest(response, request.arguments, request);
            }
            else if (request.command === 'completions') {
                this.completionsRequest(response, request.arguments, request);
            }
            else if (request.command === 'exceptionInfo') {
                this.exceptionInfoRequest(response, request.arguments, request);
            }
            else if (request.command === 'loadedSources') {
                this.loadedSourcesRequest(response, request.arguments, request);
            }
            else if (request.command === 'dataBreakpointInfo') {
                this.dataBreakpointInfoRequest(response, request.arguments, request);
            }
            else if (request.command === 'setDataBreakpoints') {
                this.setDataBreakpointsRequest(response, request.arguments, request);
            }
            else if (request.command === 'readMemory') {
                this.readMemoryRequest(response, request.arguments, request);
            }
            else if (request.command === 'writeMemory') {
                this.writeMemoryRequest(response, request.arguments, request);
            }
            else if (request.command === 'disassemble') {
                this.disassembleRequest(response, request.arguments, request);
            }
            else if (request.command === 'cancel') {
                this.cancelRequest(response, request.arguments, request);
            }
            else if (request.command === 'breakpointLocations') {
                this.breakpointLocationsRequest(response, request.arguments, request);
            }
            else if (request.command === 'setInstructionBreakpoints') {
                this.setInstructionBreakpointsRequest(response, request.arguments, request);
            }
            else {
                this.customRequest(request.command, response, request.arguments, request);
            }
        }
        catch (e) {
            this.sendErrorResponse(response, 1104, '{_stack}', { _exception: e.message, _stack: e.stack }, ErrorDestination.Telemetry);
        }
    }
    initializeRequest(response, args) {
        // This default debug adapter does not support conditional breakpoints.
        response.body.supportsConditionalBreakpoints = false;
        // This default debug adapter does not support hit conditional breakpoints.
        response.body.supportsHitConditionalBreakpoints = false;
        // This default debug adapter does not support function breakpoints.
        response.body.supportsFunctionBreakpoints = false;
        // This default debug adapter implements the 'configurationDone' request.
        response.body.supportsConfigurationDoneRequest = true;
        // This default debug adapter does not support hovers based on the 'evaluate' request.
        response.body.supportsEvaluateForHovers = false;
        // This default debug adapter does not support the 'stepBack' request.
        response.body.supportsStepBack = false;
        // This default debug adapter does not support the 'setVariable' request.
        response.body.supportsSetVariable = false;
        // This default debug adapter does not support the 'restartFrame' request.
        response.body.supportsRestartFrame = false;
        // This default debug adapter does not support the 'stepInTargets' request.
        response.body.supportsStepInTargetsRequest = false;
        // This default debug adapter does not support the 'gotoTargets' request.
        response.body.supportsGotoTargetsRequest = false;
        // This default debug adapter does not support the 'completions' request.
        response.body.supportsCompletionsRequest = false;
        // This default debug adapter does not support the 'restart' request.
        response.body.supportsRestartRequest = false;
        // This default debug adapter does not support the 'exceptionOptions' attribute on the 'setExceptionBreakpoints' request.
        response.body.supportsExceptionOptions = false;
        // This default debug adapter does not support the 'format' attribute on the 'variables', 'evaluate', and 'stackTrace' request.
        response.body.supportsValueFormattingOptions = false;
        // This debug adapter does not support the 'exceptionInfo' request.
        response.body.supportsExceptionInfoRequest = false;
        // This debug adapter does not support the 'TerminateDebuggee' attribute on the 'disconnect' request.
        response.body.supportTerminateDebuggee = false;
        // This debug adapter does not support delayed loading of stack frames.
        response.body.supportsDelayedStackTraceLoading = false;
        // This debug adapter does not support the 'loadedSources' request.
        response.body.supportsLoadedSourcesRequest = false;
        // This debug adapter does not support the 'logMessage' attribute of the SourceBreakpoint.
        response.body.supportsLogPoints = false;
        // This debug adapter does not support the 'terminateThreads' request.
        response.body.supportsTerminateThreadsRequest = false;
        // This debug adapter does not support the 'setExpression' request.
        response.body.supportsSetExpression = false;
        // This debug adapter does not support the 'terminate' request.
        response.body.supportsTerminateRequest = false;
        // This debug adapter does not support data breakpoints.
        response.body.supportsDataBreakpoints = false;
        /** This debug adapter does not support the 'readMemory' request. */
        response.body.supportsReadMemoryRequest = false;
        /** The debug adapter does not support the 'disassemble' request. */
        response.body.supportsDisassembleRequest = false;
        /** The debug adapter does not support the 'cancel' request. */
        response.body.supportsCancelRequest = false;
        /** The debug adapter does not support the 'breakpointLocations' request. */
        response.body.supportsBreakpointLocationsRequest = false;
        /** The debug adapter does not support the 'clipboard' context value in the 'evaluate' request. */
        response.body.supportsClipboardContext = false;
        /** The debug adapter does not support stepping granularities for the stepping requests. */
        response.body.supportsSteppingGranularity = false;
        /** The debug adapter does not support the 'setInstructionBreakpoints' request. */
        response.body.supportsInstructionBreakpoints = false;
        /** The debug adapter does not support 'filterOptions' on the 'setExceptionBreakpoints' request. */
        response.body.supportsExceptionFilterOptions = false;
        this.sendResponse(response);
    }
    disconnectRequest(response, args, request) {
        this.sendResponse(response);
        this.shutdown();
    }
    launchRequest(response, args, request) {
        this.sendResponse(response);
    }
    attachRequest(response, args, request) {
        this.sendResponse(response);
    }
    terminateRequest(response, args, request) {
        this.sendResponse(response);
    }
    restartRequest(response, args, request) {
        this.sendResponse(response);
    }
    setBreakPointsRequest(response, args, request) {
        this.sendResponse(response);
    }
    setFunctionBreakPointsRequest(response, args, request) {
        this.sendResponse(response);
    }
    setExceptionBreakPointsRequest(response, args, request) {
        this.sendResponse(response);
    }
    configurationDoneRequest(response, args, request) {
        this.sendResponse(response);
    }
    continueRequest(response, args, request) {
        this.sendResponse(response);
    }
    nextRequest(response, args, request) {
        this.sendResponse(response);
    }
    stepInRequest(response, args, request) {
        this.sendResponse(response);
    }
    stepOutRequest(response, args, request) {
        this.sendResponse(response);
    }
    stepBackRequest(response, args, request) {
        this.sendResponse(response);
    }
    reverseContinueRequest(response, args, request) {
        this.sendResponse(response);
    }
    restartFrameRequest(response, args, request) {
        this.sendResponse(response);
    }
    gotoRequest(response, args, request) {
        this.sendResponse(response);
    }
    pauseRequest(response, args, request) {
        this.sendResponse(response);
    }
    sourceRequest(response, args, request) {
        this.sendResponse(response);
    }
    threadsRequest(response, request) {
        this.sendResponse(response);
    }
    terminateThreadsRequest(response, args, request) {
        this.sendResponse(response);
    }
    stackTraceRequest(response, args, request) {
        this.sendResponse(response);
    }
    scopesRequest(response, args, request) {
        this.sendResponse(response);
    }
    variablesRequest(response, args, request) {
        this.sendResponse(response);
    }
    setVariableRequest(response, args, request) {
        this.sendResponse(response);
    }
    setExpressionRequest(response, args, request) {
        this.sendResponse(response);
    }
    evaluateRequest(response, args, request) {
        this.sendResponse(response);
    }
    stepInTargetsRequest(response, args, request) {
        this.sendResponse(response);
    }
    gotoTargetsRequest(response, args, request) {
        this.sendResponse(response);
    }
    completionsRequest(response, args, request) {
        this.sendResponse(response);
    }
    exceptionInfoRequest(response, args, request) {
        this.sendResponse(response);
    }
    loadedSourcesRequest(response, args, request) {
        this.sendResponse(response);
    }
    dataBreakpointInfoRequest(response, args, request) {
        this.sendResponse(response);
    }
    setDataBreakpointsRequest(response, args, request) {
        this.sendResponse(response);
    }
    readMemoryRequest(response, args, request) {
        this.sendResponse(response);
    }
    writeMemoryRequest(response, args, request) {
        this.sendResponse(response);
    }
    disassembleRequest(response, args, request) {
        this.sendResponse(response);
    }
    cancelRequest(response, args, request) {
        this.sendResponse(response);
    }
    breakpointLocationsRequest(response, args, request) {
        this.sendResponse(response);
    }
    setInstructionBreakpointsRequest(response, args, request) {
        this.sendResponse(response);
    }
    /**
     * Override this hook to implement custom requests.
     */
    customRequest(command, response, args, request) {
        this.sendErrorResponse(response, 1014, 'unrecognized request', null, ErrorDestination.Telemetry);
    }
    //---- protected -------------------------------------------------------------------------------------------------
    convertClientLineToDebugger(line) {
        if (this._debuggerLinesStartAt1) {
            return this._clientLinesStartAt1 ? line : line + 1;
        }
        return this._clientLinesStartAt1 ? line - 1 : line;
    }
    convertDebuggerLineToClient(line) {
        if (this._debuggerLinesStartAt1) {
            return this._clientLinesStartAt1 ? line : line - 1;
        }
        return this._clientLinesStartAt1 ? line + 1 : line;
    }
    convertClientColumnToDebugger(column) {
        if (this._debuggerColumnsStartAt1) {
            return this._clientColumnsStartAt1 ? column : column + 1;
        }
        return this._clientColumnsStartAt1 ? column - 1 : column;
    }
    convertDebuggerColumnToClient(column) {
        if (this._debuggerColumnsStartAt1) {
            return this._clientColumnsStartAt1 ? column : column - 1;
        }
        return this._clientColumnsStartAt1 ? column + 1 : column;
    }
    convertClientPathToDebugger(clientPath) {
        if (this._clientPathsAreURIs !== this._debuggerPathsAreURIs) {
            if (this._clientPathsAreURIs) {
                return DebugSession.uri2path(clientPath);
            }
            else {
                return DebugSession.path2uri(clientPath);
            }
        }
        return clientPath;
    }
    convertDebuggerPathToClient(debuggerPath) {
        if (this._debuggerPathsAreURIs !== this._clientPathsAreURIs) {
            if (this._debuggerPathsAreURIs) {
                return DebugSession.uri2path(debuggerPath);
            }
            else {
                return DebugSession.path2uri(debuggerPath);
            }
        }
        return debuggerPath;
    }
    //---- private -------------------------------------------------------------------------------
    static path2uri(path) {
        if (process.platform === 'win32') {
            if (/^[A-Z]:/.test(path)) {
                path = path[0].toLowerCase() + path.substr(1);
            }
            path = path.replace(/\\/g, '/');
        }
        path = encodeURI(path);
        let uri = new url_1.URL(`file:`); // ignore 'path' for now
        uri.pathname = path; // now use 'path' to get the correct percent encoding (see https://url.spec.whatwg.org)
        return uri.toString();
    }
    static uri2path(sourceUri) {
        let uri = new url_1.URL(sourceUri);
        let s = decodeURIComponent(uri.pathname);
        if (process.platform === 'win32') {
            if (/^\/[a-zA-Z]:/.test(s)) {
                s = s[1].toLowerCase() + s.substr(2);
            }
            s = s.replace(/\//g, '\\');
        }
        return s;
    }
    /*
    * If argument starts with '_' it is OK to send its value to telemetry.
    */
    static formatPII(format, excludePII, args) {
        return format.replace(DebugSession._formatPIIRegexp, function (match, paramName) {
            if (excludePII && paramName.length > 0 && paramName[0] !== '_') {
                return match;
            }
            return args[paramName] && args.hasOwnProperty(paramName) ?
                args[paramName] :
                match;
        });
    }
}
exports.DebugSession = DebugSession;
DebugSession._formatPIIRegexp = /{([^}]+)}/g;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdTZXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2RlYnVnU2Vzc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztnR0FHZ0c7OztBQUdoRyx5Q0FBNEM7QUFDNUMseUNBQTZDO0FBQzdDLHVEQUFvRDtBQUNwRCw2QkFBMEI7QUFHMUIsTUFBYSxNQUFNO0lBS2xCLFlBQW1CLElBQVksRUFBRSxJQUFhLEVBQUUsS0FBYSxDQUFDLEVBQUUsTUFBZSxFQUFFLElBQVU7UUFDMUYsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxNQUFNLEVBQUU7WUFDTCxJQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztTQUM1QjtRQUNELElBQUksSUFBSSxFQUFFO1lBQ0gsSUFBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7U0FDL0I7SUFDRixDQUFDO0NBQ0Q7QUFoQkQsd0JBZ0JDO0FBRUQsTUFBYSxLQUFLO0lBS2pCLFlBQW1CLElBQVksRUFBRSxTQUFpQixFQUFFLFlBQXFCLEtBQUs7UUFDN0UsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztJQUM1QixDQUFDO0NBQ0Q7QUFWRCxzQkFVQztBQUVELE1BQWEsVUFBVTtJQWF0QixZQUFtQixDQUFTLEVBQUUsRUFBVSxFQUFFLEdBQVksRUFBRSxLQUFhLENBQUMsRUFBRSxNQUFjLENBQUM7UUFDdEYsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQXBCRCxnQ0FvQkM7QUFFRCxNQUFhLE1BQU07SUFJbEIsWUFBbUIsRUFBVSxFQUFFLElBQVk7UUFDMUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLElBQUksRUFBRTtZQUNULElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ2pCO2FBQU07WUFDTixJQUFJLENBQUMsSUFBSSxHQUFHLFVBQVUsR0FBRyxFQUFFLENBQUM7U0FDNUI7SUFDRixDQUFDO0NBQ0Q7QUFaRCx3QkFZQztBQUVELE1BQWEsUUFBUTtJQUtwQixZQUFtQixJQUFZLEVBQUUsS0FBYSxFQUFFLE1BQWMsQ0FBQyxFQUFFLGdCQUF5QixFQUFFLGNBQXVCO1FBQ2xILElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLENBQUM7UUFDOUIsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDZCxJQUFLLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztTQUMvRDtRQUNELElBQUksT0FBTyxnQkFBZ0IsS0FBSyxRQUFRLEVBQUU7WUFDaEIsSUFBSyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1NBQ25FO0lBQ0YsQ0FBQztDQUNEO0FBaEJELDRCQWdCQztBQUVELE1BQWEsVUFBVTtJQUd0QixZQUFtQixRQUFpQixFQUFFLElBQWEsRUFBRSxNQUFlLEVBQUUsTUFBZTtRQUNwRixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixNQUFNLENBQUMsR0FBNkIsSUFBSSxDQUFDO1FBQ3pDLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQzdCLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ2Q7UUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtZQUMvQixDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztTQUNsQjtRQUNELElBQUksTUFBTSxFQUFFO1lBQ1gsQ0FBQyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7U0FDbEI7SUFDRixDQUFDO0lBRU0sS0FBSyxDQUFDLEVBQVU7UUFDckIsSUFBaUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQzNDLENBQUM7Q0FDRjtBQXBCRCxnQ0FvQkM7QUFFRCxNQUFhLE1BQU07SUFJbEIsWUFBbUIsRUFBbUIsRUFBRSxJQUFZO1FBQ25ELElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbEIsQ0FBQztDQUNEO0FBUkQsd0JBUUM7QUFFRCxNQUFhLGNBQWM7SUFLMUIsWUFBbUIsS0FBYSxFQUFFLEtBQWEsRUFBRSxTQUFpQixDQUFDO1FBQ2xFLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3RCLENBQUM7Q0FDRDtBQVZELHdDQVVDO0FBRUQsTUFBYSxZQUFhLFNBQVEsZ0JBQUs7SUFLdEMsWUFBbUIsTUFBYyxFQUFFLFFBQWlCLEVBQUUsYUFBc0I7UUFDM0UsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDWCxNQUFNLEVBQUUsTUFBTTtTQUNkLENBQUM7UUFDRixJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUNoQyxJQUFtQyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1NBQzlEO1FBQ0QsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7WUFDckMsSUFBbUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQztTQUMvRDtJQUNGLENBQUM7Q0FDRDtBQWpCRCxvQ0FpQkM7QUFFRCxNQUFhLGNBQWUsU0FBUSxnQkFBSztJQUt4QyxZQUFtQixRQUFnQixFQUFFLG1CQUE2QjtRQUNqRSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLFFBQVEsRUFBRSxRQUFRO1NBQ2xCLENBQUM7UUFFRixJQUFJLE9BQU8sbUJBQW1CLEtBQUssU0FBUyxFQUFFO1lBQ2QsSUFBSyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztTQUNwRjtJQUNGLENBQUM7Q0FDRDtBQWZELHdDQWVDO0FBRUQsTUFBYSxnQkFBaUIsU0FBUSxnQkFBSztJQUMxQztRQUNDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN0QixDQUFDO0NBQ0Q7QUFKRCw0Q0FJQztBQUVELE1BQWEsZUFBZ0IsU0FBUSxnQkFBSztJQUN6QyxZQUFtQixPQUFhO1FBQy9CLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwQixJQUFJLE9BQU8sT0FBTyxLQUFLLFNBQVMsSUFBSSxPQUFPLEVBQUU7WUFDNUMsTUFBTSxDQUFDLEdBQWtDLElBQUksQ0FBQztZQUM5QyxDQUFDLENBQUMsSUFBSSxHQUFHO2dCQUNSLE9BQU8sRUFBRSxPQUFPO2FBQ2hCLENBQUM7U0FDRjtJQUNGLENBQUM7Q0FDRDtBQVZELDBDQVVDO0FBRUQsTUFBYSxXQUFZLFNBQVEsZ0JBQUs7SUFLckMsWUFBbUIsUUFBZ0I7UUFDbEMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDWCxRQUFRLEVBQUUsUUFBUTtTQUNsQixDQUFDO0lBQ0gsQ0FBQztDQUNEO0FBWEQsa0NBV0M7QUFFRCxNQUFhLFdBQVksU0FBUSxnQkFBSztJQU9yQyxZQUFtQixNQUFjLEVBQUUsV0FBbUIsU0FBUyxFQUFFLElBQVU7UUFDMUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDWCxRQUFRLEVBQUUsUUFBUTtZQUNsQixNQUFNLEVBQUUsTUFBTTtTQUNkLENBQUM7UUFDRixJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7WUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ3RCO0lBQ0YsQ0FBQztDQUNEO0FBakJELGtDQWlCQztBQUVELE1BQWEsV0FBWSxTQUFRLGdCQUFLO0lBTXJDLFlBQW1CLE1BQWMsRUFBRSxRQUFnQjtRQUNsRCxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLE1BQU0sRUFBRSxNQUFNO1lBQ2QsUUFBUSxFQUFFLFFBQVE7U0FDbEIsQ0FBQztJQUNILENBQUM7Q0FDRDtBQWJELGtDQWFDO0FBRUQsTUFBYSxlQUFnQixTQUFRLGdCQUFLO0lBTXpDLFlBQW1CLE1BQWMsRUFBRSxVQUFvQztRQUN0RSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLE1BQU0sRUFBRSxNQUFNO1lBQ2QsVUFBVSxFQUFFLFVBQVU7U0FDdEIsQ0FBQztJQUNILENBQUM7Q0FDRDtBQWJELDBDQWFDO0FBRUQsTUFBYSxXQUFZLFNBQVEsZ0JBQUs7SUFNckMsWUFBbUIsTUFBcUMsRUFBRSxNQUE0QjtRQUNyRixLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLE1BQU0sRUFBRSxNQUFNO1lBQ2QsTUFBTSxFQUFFLE1BQU07U0FDZCxDQUFDO0lBQ0gsQ0FBQztDQUNEO0FBYkQsa0NBYUM7QUFFRCxNQUFhLGlCQUFrQixTQUFRLGdCQUFLO0lBTTNDLFlBQW1CLE1BQXFDLEVBQUUsTUFBNEI7UUFDckYsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDWCxNQUFNLEVBQUUsTUFBTTtZQUNkLE1BQU0sRUFBRSxNQUFNO1NBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRDtBQWJELDhDQWFDO0FBRUQsTUFBYSxpQkFBa0IsU0FBUSxnQkFBSztJQUszQyxZQUFtQixZQUF3QztRQUMxRCxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLFlBQVksRUFBRSxZQUFZO1NBQzFCLENBQUM7SUFDSCxDQUFDO0NBQ0Q7QUFYRCw4Q0FXQztBQUVELE1BQWEsa0JBQW1CLFNBQVEsZ0JBQUs7SUFNNUMsWUFBbUIsVUFBa0IsRUFBRSxLQUFhLEVBQUUsT0FBZ0I7UUFDckUsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDWCxVQUFVLEVBQUUsVUFBVTtZQUN0QixLQUFLLEVBQUUsS0FBSztTQUNaLENBQUM7UUFDRixJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixJQUF5QyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ2xFO0lBQ0YsQ0FBQztDQUNEO0FBaEJELGdEQWdCQztBQUVELE1BQWEsbUJBQW9CLFNBQVEsZ0JBQUs7SUFLN0MsWUFBbUIsVUFBa0IsRUFBRSxPQUFnQjtRQUN0RCxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ1gsVUFBVSxFQUFFLFVBQVU7U0FDdEIsQ0FBQztRQUNGLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQy9CLElBQTBDLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7U0FDbkU7SUFDRixDQUFDO0NBQ0Q7QUFkRCxrREFjQztBQUVELE1BQWEsZ0JBQWlCLFNBQVEsZ0JBQUs7SUFLMUMsWUFBbUIsVUFBa0IsRUFBRSxPQUFnQjtRQUN0RCxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNYLFVBQVUsRUFBRSxVQUFVO1NBQ3RCLENBQUM7UUFDRixJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixJQUF1QyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ2hFO0lBQ0YsQ0FBQztDQUNEO0FBZEQsNENBY0M7QUFFRCxNQUFhLGdCQUFpQixTQUFRLGdCQUFLO0lBTzFDLFlBQW1CLEtBQXdDLEVBQUUsUUFBaUIsRUFBRSxZQUFxQjtRQUNwRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxFQUNYLENBQUM7UUFDRixJQUFJLEtBQUssRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztTQUN4QjtRQUNELElBQUksUUFBUSxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1NBQzlCO1FBQ0QsSUFBSSxZQUFZLEVBQUU7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1NBQ3RDO0lBQ0YsQ0FBQztDQUNEO0FBckJELDRDQXFCQztBQUVELE1BQWEsV0FBWSxTQUFRLGdCQUFLO0lBT3JDLFlBQW1CLGVBQXVCLEVBQUUsTUFBYyxFQUFFLEtBQWE7UUFDeEUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDO0lBQ2hELENBQUM7Q0FDRDtBQVhELGtDQVdDO0FBRUQsSUFBWSxnQkFHWDtBQUhELFdBQVksZ0JBQWdCO0lBQzNCLHVEQUFRLENBQUE7SUFDUixpRUFBYSxDQUFBO0FBQ2QsQ0FBQyxFQUhXLGdCQUFnQixHQUFoQix3QkFBZ0IsS0FBaEIsd0JBQWdCLFFBRzNCO0FBQUEsQ0FBQztBQUVGLE1BQWEsWUFBYSxTQUFRLHlCQUFjO0lBWS9DLFlBQW1CLHdDQUFrRCxFQUFFLGlCQUEyQjtRQUNqRyxLQUFLLEVBQUUsQ0FBQztRQUVSLE1BQU0sdUJBQXVCLEdBQUcsT0FBTyx3Q0FBd0MsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLHdDQUF3QyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDakosSUFBSSxDQUFDLHNCQUFzQixHQUFHLHVCQUF1QixDQUFDO1FBQ3RELElBQUksQ0FBQyx3QkFBd0IsR0FBRyx1QkFBdUIsQ0FBQztRQUN4RCxJQUFJLENBQUMscUJBQXFCLEdBQUcsS0FBSyxDQUFDO1FBRW5DLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7UUFDakMsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQztRQUNuQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1FBRWpDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxpQkFBaUIsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFFcEYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVNLHFCQUFxQixDQUFDLE1BQWM7UUFDMUMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLE1BQU0sS0FBSyxNQUFNLENBQUM7SUFDaEQsQ0FBQztJQUVNLHdCQUF3QixDQUFDLE1BQWU7UUFDOUMsSUFBSSxDQUFDLHNCQUFzQixHQUFHLE1BQU0sQ0FBQztJQUN0QyxDQUFDO0lBRU0sMEJBQTBCLENBQUMsTUFBZTtRQUNoRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsTUFBTSxDQUFDO0lBQ3hDLENBQUM7SUFFTSxjQUFjLENBQUMsTUFBZTtRQUNwQyxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQWlDO1FBQ2xELElBQUEsaUNBQWUsRUFBQyxZQUFZLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRU0sUUFBUTtRQUNkLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtZQUM5QyxrQ0FBa0M7U0FDbEM7YUFBTTtZQUNOLGtDQUFrQztZQUNsQyxVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakIsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ1I7SUFDRixDQUFDO0lBRVMsaUJBQWlCLENBQUMsUUFBZ0MsRUFBRSxhQUE2QyxFQUFFLE1BQWUsRUFBRSxTQUFlLEVBQUUsT0FBeUIsZ0JBQWdCLENBQUMsSUFBSTtRQUU1TCxJQUFJLEdBQTJCLENBQUM7UUFDaEMsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7WUFDdEMsR0FBRyxHQUEyQjtnQkFDN0IsRUFBRSxFQUFXLGFBQWE7Z0JBQzFCLE1BQU0sRUFBRSxNQUFNO2FBQ2QsQ0FBQztZQUNGLElBQUksU0FBUyxFQUFFO2dCQUNkLEdBQUcsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2FBQzFCO1lBQ0QsSUFBSSxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxFQUFFO2dCQUNqQyxHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQzthQUNwQjtZQUNELElBQUksSUFBSSxHQUFHLGdCQUFnQixDQUFDLFNBQVMsRUFBRTtnQkFDdEMsR0FBRyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7YUFDekI7U0FDRDthQUFNO1lBQ04sR0FBRyxHQUFHLGFBQWEsQ0FBQztTQUNwQjtRQUVELFFBQVEsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLFFBQVEsQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDbkIsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFHLENBQUM7U0FDcEI7UUFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7UUFFMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRU0sb0JBQW9CLENBQUMsSUFBaUQsRUFBRSxPQUFlLEVBQUUsRUFBMkQ7UUFDMUosSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUF5QyxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVTLGVBQWUsQ0FBQyxPQUE4QjtRQUV2RCxNQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkMsSUFBSTtZQUNILElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUU7Z0JBQ3JDLElBQUksSUFBSSxHQUE4QyxPQUFPLENBQUMsU0FBUyxDQUFDO2dCQUV4RSxJQUFJLE9BQU8sSUFBSSxDQUFDLGFBQWEsS0FBSyxTQUFTLEVBQUU7b0JBQzVDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO2lCQUMvQztnQkFDRCxJQUFJLE9BQU8sSUFBSSxDQUFDLGVBQWUsS0FBSyxTQUFTLEVBQUU7b0JBQzlDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO2lCQUNuRDtnQkFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssTUFBTSxFQUFFO29CQUMvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSwwQ0FBMEMsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQ3JIO3FCQUFNO29CQUNOLE1BQU0sa0JBQWtCLEdBQXNDLFFBQVEsQ0FBQztvQkFDdkUsa0JBQWtCLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztvQkFDN0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNqRDthQUVEO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxhQUFhLENBQWdDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRXhGO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxhQUFhLENBQWdDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRXhGO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUU7Z0JBQzVDLElBQUksQ0FBQyxpQkFBaUIsQ0FBb0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFaEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFdBQVcsRUFBRTtnQkFDM0MsSUFBSSxDQUFDLGdCQUFnQixDQUFtQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUU5RjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsY0FBYyxDQUFpQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUUxRjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssZ0JBQWdCLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxxQkFBcUIsQ0FBd0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFeEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLHdCQUF3QixFQUFFO2dCQUN4RCxJQUFJLENBQUMsNkJBQTZCLENBQWdELFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRXhIO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyx5QkFBeUIsRUFBRTtnQkFDekQsSUFBSSxDQUFDLDhCQUE4QixDQUFpRCxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUUxSDtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssbUJBQW1CLEVBQUU7Z0JBQ25ELElBQUksQ0FBQyx3QkFBd0IsQ0FBMkMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFOUc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLGVBQWUsQ0FBa0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFNUY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBOEIsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFcEY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLGFBQWEsQ0FBZ0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFeEY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFNBQVMsRUFBRTtnQkFDekMsSUFBSSxDQUFDLGNBQWMsQ0FBaUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFMUY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLGVBQWUsQ0FBa0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFNUY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGlCQUFpQixFQUFFO2dCQUNqRCxJQUFJLENBQUMsc0JBQXNCLENBQXlDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRTFHO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxjQUFjLEVBQUU7Z0JBQzlDLElBQUksQ0FBQyxtQkFBbUIsQ0FBc0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFcEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBOEIsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFcEY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtnQkFDdkMsSUFBSSxDQUFDLFlBQVksQ0FBK0IsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFdEY7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFlBQVksRUFBRTtnQkFDNUMsSUFBSSxDQUFDLGlCQUFpQixDQUFvQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUVoRztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO2dCQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFnQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUV4RjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssV0FBVyxFQUFFO2dCQUMzQyxJQUFJLENBQUMsZ0JBQWdCLENBQW1DLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRTlGO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxhQUFhLEVBQUU7Z0JBQzdDLElBQUksQ0FBQyxrQkFBa0IsQ0FBcUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFbEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGVBQWUsRUFBRTtnQkFDL0MsSUFBSSxDQUFDLG9CQUFvQixDQUF1QyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUV0RztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO2dCQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFnQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUV4RjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsY0FBYyxDQUFpQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFdkU7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGtCQUFrQixFQUFFO2dCQUNsRCxJQUFJLENBQUMsdUJBQXVCLENBQTBDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRTVHO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxVQUFVLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxlQUFlLENBQWtDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRTVGO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxlQUFlLEVBQUU7Z0JBQy9DLElBQUksQ0FBQyxvQkFBb0IsQ0FBdUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFdEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGFBQWEsRUFBRTtnQkFDN0MsSUFBSSxDQUFDLGtCQUFrQixDQUFxQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUVsRztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssYUFBYSxFQUFFO2dCQUM3QyxJQUFJLENBQUMsa0JBQWtCLENBQXFDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRWxHO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxlQUFlLEVBQUU7Z0JBQy9DLElBQUksQ0FBQyxvQkFBb0IsQ0FBdUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFdEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGVBQWUsRUFBRTtnQkFDL0MsSUFBSSxDQUFDLG9CQUFvQixDQUF1QyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUV0RztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssb0JBQW9CLEVBQUU7Z0JBQ3BELElBQUksQ0FBQyx5QkFBeUIsQ0FBNEMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFaEg7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLG9CQUFvQixFQUFFO2dCQUNwRCxJQUFJLENBQUMseUJBQXlCLENBQTRDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRWhIO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUU7Z0JBQzVDLElBQUksQ0FBQyxpQkFBaUIsQ0FBb0MsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFaEc7aUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGFBQWEsRUFBRTtnQkFDN0MsSUFBSSxDQUFDLGtCQUFrQixDQUFxQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUVsRztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssYUFBYSxFQUFFO2dCQUM3QyxJQUFJLENBQUMsa0JBQWtCLENBQXFDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRWxHO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxhQUFhLENBQWdDLFFBQVEsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBRXhGO2lCQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxxQkFBcUIsRUFBRTtnQkFDckQsSUFBSSxDQUFDLDBCQUEwQixDQUE2QyxRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUVsSDtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssMkJBQTJCLEVBQUU7Z0JBQzNELElBQUksQ0FBQyxnQ0FBZ0MsQ0FBbUQsUUFBUSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFFOUg7aUJBQU07Z0JBQ04sSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUEyQixRQUFRLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNuRztTQUNEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNIO0lBQ0YsQ0FBQztJQUVTLGlCQUFpQixDQUFDLFFBQTBDLEVBQUUsSUFBOEM7UUFFckgsdUVBQXVFO1FBQ3ZFLFFBQVEsQ0FBQyxJQUFJLENBQUMsOEJBQThCLEdBQUcsS0FBSyxDQUFDO1FBRXJELDJFQUEyRTtRQUMzRSxRQUFRLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxHQUFHLEtBQUssQ0FBQztRQUV4RCxvRUFBb0U7UUFDcEUsUUFBUSxDQUFDLElBQUksQ0FBQywyQkFBMkIsR0FBRyxLQUFLLENBQUM7UUFFbEQseUVBQXlFO1FBQ3pFLFFBQVEsQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLEdBQUcsSUFBSSxDQUFDO1FBRXRELHNGQUFzRjtRQUN0RixRQUFRLENBQUMsSUFBSSxDQUFDLHlCQUF5QixHQUFHLEtBQUssQ0FBQztRQUVoRCxzRUFBc0U7UUFDdEUsUUFBUSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFdkMseUVBQXlFO1FBQ3pFLFFBQVEsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1FBRTFDLDBFQUEwRTtRQUMxRSxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztRQUUzQywyRUFBMkU7UUFDM0UsUUFBUSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsR0FBRyxLQUFLLENBQUM7UUFFbkQseUVBQXlFO1FBQ3pFLFFBQVEsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEdBQUcsS0FBSyxDQUFDO1FBRWpELHlFQUF5RTtRQUN6RSxRQUFRLENBQUMsSUFBSSxDQUFDLDBCQUEwQixHQUFHLEtBQUssQ0FBQztRQUVqRCxxRUFBcUU7UUFDckUsUUFBUSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLENBQUM7UUFFN0MseUhBQXlIO1FBQ3pILFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBRS9DLCtIQUErSDtRQUMvSCxRQUFRLENBQUMsSUFBSSxDQUFDLDhCQUE4QixHQUFHLEtBQUssQ0FBQztRQUVyRCxtRUFBbUU7UUFDbkUsUUFBUSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsR0FBRyxLQUFLLENBQUM7UUFFbkQscUdBQXFHO1FBQ3JHLFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBRS9DLHVFQUF1RTtRQUN2RSxRQUFRLENBQUMsSUFBSSxDQUFDLGdDQUFnQyxHQUFHLEtBQUssQ0FBQztRQUV2RCxtRUFBbUU7UUFDbkUsUUFBUSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsR0FBRyxLQUFLLENBQUM7UUFFbkQsMEZBQTBGO1FBQzFGLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1FBRXhDLHNFQUFzRTtRQUN0RSxRQUFRLENBQUMsSUFBSSxDQUFDLCtCQUErQixHQUFHLEtBQUssQ0FBQztRQUV0RCxtRUFBbUU7UUFDbkUsUUFBUSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7UUFFNUMsK0RBQStEO1FBQy9ELFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBRS9DLHdEQUF3RDtRQUN4RCxRQUFRLENBQUMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLEtBQUssQ0FBQztRQUU5QyxvRUFBb0U7UUFDcEUsUUFBUSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxLQUFLLENBQUM7UUFFaEQsb0VBQW9FO1FBQ3BFLFFBQVEsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEdBQUcsS0FBSyxDQUFDO1FBRWpELCtEQUErRDtRQUMvRCxRQUFRLENBQUMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztRQUU1Qyw0RUFBNEU7UUFDNUUsUUFBUSxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsR0FBRyxLQUFLLENBQUM7UUFFekQsa0dBQWtHO1FBQ2xHLFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBRS9DLDJGQUEyRjtRQUMzRixRQUFRLENBQUMsSUFBSSxDQUFDLDJCQUEyQixHQUFHLEtBQUssQ0FBQztRQUVsRCxrRkFBa0Y7UUFDbEYsUUFBUSxDQUFDLElBQUksQ0FBQyw4QkFBOEIsR0FBRyxLQUFLLENBQUM7UUFFckQsbUdBQW1HO1FBQ25HLFFBQVEsQ0FBQyxJQUFJLENBQUMsOEJBQThCLEdBQUcsS0FBSyxDQUFDO1FBRXJELElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGlCQUFpQixDQUFDLFFBQTBDLEVBQUUsSUFBdUMsRUFBRSxPQUErQjtRQUMvSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRVMsYUFBYSxDQUFDLFFBQXNDLEVBQUUsSUFBMEMsRUFBRSxPQUErQjtRQUMxSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxhQUFhLENBQUMsUUFBc0MsRUFBRSxJQUEwQyxFQUFFLE9BQStCO1FBQzFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGdCQUFnQixDQUFDLFFBQXlDLEVBQUUsSUFBc0MsRUFBRSxPQUErQjtRQUM1SSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxjQUFjLENBQUMsUUFBdUMsRUFBRSxJQUFvQyxFQUFFLE9BQStCO1FBQ3RJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLHFCQUFxQixDQUFDLFFBQThDLEVBQUUsSUFBMkMsRUFBRSxPQUErQjtRQUMzSixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyw2QkFBNkIsQ0FBQyxRQUFzRCxFQUFFLElBQW1ELEVBQUUsT0FBK0I7UUFDbkwsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsOEJBQThCLENBQUMsUUFBdUQsRUFBRSxJQUFvRCxFQUFFLE9BQStCO1FBQ3RMLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLHdCQUF3QixDQUFDLFFBQWlELEVBQUUsSUFBOEMsRUFBRSxPQUErQjtRQUNwSyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxlQUFlLENBQUMsUUFBd0MsRUFBRSxJQUFxQyxFQUFFLE9BQStCO1FBQ3pJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLFdBQVcsQ0FBQyxRQUFvQyxFQUFFLElBQWlDLEVBQUUsT0FBK0I7UUFDN0gsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsYUFBYSxDQUFDLFFBQXNDLEVBQUUsSUFBbUMsRUFBRSxPQUErQjtRQUNuSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxjQUFjLENBQUMsUUFBdUMsRUFBRSxJQUFvQyxFQUFFLE9BQStCO1FBQ3RJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGVBQWUsQ0FBQyxRQUF3QyxFQUFFLElBQXFDLEVBQUUsT0FBK0I7UUFDekksSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsc0JBQXNCLENBQUMsUUFBK0MsRUFBRSxJQUE0QyxFQUFFLE9BQStCO1FBQzlKLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLG1CQUFtQixDQUFDLFFBQTRDLEVBQUUsSUFBeUMsRUFBRSxPQUErQjtRQUNySixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxXQUFXLENBQUMsUUFBb0MsRUFBRSxJQUFpQyxFQUFFLE9BQStCO1FBQzdILElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLFlBQVksQ0FBQyxRQUFxQyxFQUFFLElBQWtDLEVBQUUsT0FBK0I7UUFDaEksSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsYUFBYSxDQUFDLFFBQXNDLEVBQUUsSUFBbUMsRUFBRSxPQUErQjtRQUNuSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxjQUFjLENBQUMsUUFBdUMsRUFBRSxPQUErQjtRQUNoRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyx1QkFBdUIsQ0FBQyxRQUFnRCxFQUFFLElBQTZDLEVBQUUsT0FBK0I7UUFDakssSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsaUJBQWlCLENBQUMsUUFBMEMsRUFBRSxJQUF1QyxFQUFFLE9BQStCO1FBQy9JLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGFBQWEsQ0FBQyxRQUFzQyxFQUFFLElBQW1DLEVBQUUsT0FBK0I7UUFDbkksSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsZ0JBQWdCLENBQUMsUUFBeUMsRUFBRSxJQUFzQyxFQUFFLE9BQStCO1FBQzVJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGtCQUFrQixDQUFDLFFBQTJDLEVBQUUsSUFBd0MsRUFBRSxPQUErQjtRQUNsSixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxvQkFBb0IsQ0FBQyxRQUE2QyxFQUFFLElBQTBDLEVBQUUsT0FBK0I7UUFDeEosSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsZUFBZSxDQUFDLFFBQXdDLEVBQUUsSUFBcUMsRUFBRSxPQUErQjtRQUN6SSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxvQkFBb0IsQ0FBQyxRQUE2QyxFQUFFLElBQTBDLEVBQUUsT0FBK0I7UUFDeEosSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsa0JBQWtCLENBQUMsUUFBMkMsRUFBRSxJQUF3QyxFQUFFLE9BQStCO1FBQ2xKLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGtCQUFrQixDQUFDLFFBQTJDLEVBQUUsSUFBd0MsRUFBRSxPQUErQjtRQUNsSixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxvQkFBb0IsQ0FBQyxRQUE2QyxFQUFFLElBQTBDLEVBQUUsT0FBK0I7UUFDeEosSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsb0JBQW9CLENBQUMsUUFBNkMsRUFBRSxJQUEwQyxFQUFFLE9BQStCO1FBQ3hKLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLHlCQUF5QixDQUFDLFFBQWtELEVBQUUsSUFBK0MsRUFBRSxPQUErQjtRQUN2SyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyx5QkFBeUIsQ0FBQyxRQUFrRCxFQUFFLElBQStDLEVBQUUsT0FBK0I7UUFDdkssSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsaUJBQWlCLENBQUMsUUFBMEMsRUFBRSxJQUF1QyxFQUFFLE9BQStCO1FBQy9JLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLGtCQUFrQixDQUFDLFFBQTJDLEVBQUUsSUFBd0MsRUFBRSxPQUErQjtRQUNsSixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUyxrQkFBa0IsQ0FBQyxRQUEyQyxFQUFFLElBQXdDLEVBQUUsT0FBK0I7UUFDbEosSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsYUFBYSxDQUFDLFFBQXNDLEVBQUUsSUFBbUMsRUFBRSxPQUErQjtRQUNuSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFUywwQkFBMEIsQ0FBQyxRQUFtRCxFQUFFLElBQWdELEVBQUUsT0FBK0I7UUFDMUssSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRVMsZ0NBQWdDLENBQUMsUUFBeUQsRUFBRSxJQUFzRCxFQUFFLE9BQStCO1FBQzVMLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ08sYUFBYSxDQUFDLE9BQWUsRUFBRSxRQUFnQyxFQUFFLElBQVMsRUFBRSxPQUErQjtRQUNwSCxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxzQkFBc0IsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEcsQ0FBQztJQUVELGtIQUFrSDtJQUV4RywyQkFBMkIsQ0FBQyxJQUFZO1FBQ2pELElBQUksSUFBSSxDQUFDLHNCQUFzQixFQUFFO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7U0FDbkQ7UUFDRCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3BELENBQUM7SUFFUywyQkFBMkIsQ0FBQyxJQUFZO1FBQ2pELElBQUksSUFBSSxDQUFDLHNCQUFzQixFQUFFO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7U0FDbkQ7UUFDRCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3BELENBQUM7SUFFUyw2QkFBNkIsQ0FBQyxNQUFjO1FBQ3JELElBQUksSUFBSSxDQUFDLHdCQUF3QixFQUFFO1lBQ2xDLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDekQ7UUFDRCxPQUFPLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQzFELENBQUM7SUFFUyw2QkFBNkIsQ0FBQyxNQUFjO1FBQ3JELElBQUksSUFBSSxDQUFDLHdCQUF3QixFQUFFO1lBQ2xDLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDekQ7UUFDRCxPQUFPLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQzFELENBQUM7SUFFUywyQkFBMkIsQ0FBQyxVQUFrQjtRQUN2RCxJQUFJLElBQUksQ0FBQyxtQkFBbUIsS0FBSyxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDNUQsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7Z0JBQzdCLE9BQU8sWUFBWSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUN6QztpQkFBTTtnQkFDTixPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDekM7U0FDRDtRQUNELE9BQU8sVUFBVSxDQUFDO0lBQ25CLENBQUM7SUFFUywyQkFBMkIsQ0FBQyxZQUFvQjtRQUN6RCxJQUFJLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDNUQsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Z0JBQy9CLE9BQU8sWUFBWSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUMzQztpQkFBTTtnQkFDTixPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDM0M7U0FDRDtRQUNELE9BQU8sWUFBWSxDQUFDO0lBQ3JCLENBQUM7SUFFRCw4RkFBOEY7SUFFdEYsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFZO1FBRW5DLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7WUFDakMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN6QixJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDOUM7WUFDRCxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXZCLElBQUksR0FBRyxHQUFHLElBQUksU0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsd0JBQXdCO1FBQ3BELEdBQUcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsdUZBQXVGO1FBQzVHLE9BQU8sR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFFTyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQWlCO1FBRXhDLElBQUksR0FBRyxHQUFHLElBQUksU0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1lBQ2pDLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDM0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzNCO1FBQ0QsT0FBTyxDQUFDLENBQUM7SUFDVixDQUFDO0lBSUQ7O01BRUU7SUFDTSxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQWEsRUFBRSxVQUFtQixFQUFFLElBQTZCO1FBQ3pGLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLEVBQUUsVUFBUyxLQUFLLEVBQUUsU0FBUztZQUM3RSxJQUFJLFVBQVUsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO2dCQUMvRCxPQUFPLEtBQUssQ0FBQzthQUNiO1lBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDakIsS0FBSyxDQUFDO1FBQ1IsQ0FBQyxDQUFDLENBQUE7SUFDSCxDQUFDOztBQXhtQkYsb0NBeW1CQztBQWZlLDZCQUFnQixHQUFHLFlBQVksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBEZWJ1Z1Byb3RvY29sIH0gZnJvbSAnQHZzY29kZS9kZWJ1Z3Byb3RvY29sJztcbmltcG9ydCB7IFByb3RvY29sU2VydmVyIH0gZnJvbSAnLi9wcm90b2NvbCc7XG5pbXBvcnQgeyBSZXNwb25zZSwgRXZlbnQgfSBmcm9tICcuL21lc3NhZ2VzJztcbmltcG9ydCB7IHJ1bkRlYnVnQWRhcHRlciB9IGZyb20gJy4vcnVuRGVidWdBZGFwdGVyJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5cblxuZXhwb3J0IGNsYXNzIFNvdXJjZSBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuU291cmNlIHtcblx0bmFtZTogc3RyaW5nO1xuXHRwYXRoOiBzdHJpbmc7XG5cdHNvdXJjZVJlZmVyZW5jZTogbnVtYmVyO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHBhdGg/OiBzdHJpbmcsIGlkOiBudW1iZXIgPSAwLCBvcmlnaW4/OiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5zb3VyY2VSZWZlcmVuY2UgPSBpZDtcblx0XHRpZiAob3JpZ2luKSB7XG5cdFx0XHQoPGFueT50aGlzKS5vcmlnaW4gPSBvcmlnaW47XG5cdFx0fVxuXHRcdGlmIChkYXRhKSB7XG5cdFx0XHQoPGFueT50aGlzKS5hZGFwdGVyRGF0YSA9IGRhdGE7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBTY29wZSBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuU2NvcGUge1xuXHRuYW1lOiBzdHJpbmc7XG5cdHZhcmlhYmxlc1JlZmVyZW5jZTogbnVtYmVyO1xuXHRleHBlbnNpdmU6IGJvb2xlYW47XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgcmVmZXJlbmNlOiBudW1iZXIsIGV4cGVuc2l2ZTogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLnZhcmlhYmxlc1JlZmVyZW5jZSA9IHJlZmVyZW5jZTtcblx0XHR0aGlzLmV4cGVuc2l2ZSA9IGV4cGVuc2l2ZTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU3RhY2tGcmFtZSBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuU3RhY2tGcmFtZSB7XG5cdGlkOiBudW1iZXI7XG5cdG5hbWU6IHN0cmluZztcblx0c291cmNlPzogRGVidWdQcm90b2NvbC5Tb3VyY2U7XG5cdGxpbmU6IG51bWJlcjtcblx0Y29sdW1uOiBudW1iZXI7XG5cdGVuZExpbmU/OiBudW1iZXI7XG5cdGVuZENvbHVtbj86IG51bWJlcjtcblx0Y2FuUmVzdGFydD86IGJvb2xlYW47XG5cdGluc3RydWN0aW9uUG9pbnRlclJlZmVyZW5jZT86IHN0cmluZztcblx0bW9kdWxlSWQ/OiBudW1iZXIgfCBzdHJpbmc7XG5cdHByZXNlbnRhdGlvbkhpbnQ/OiAnbm9ybWFsJyB8ICdsYWJlbCcgfCAnc3VidGxlJztcblxuXHRwdWJsaWMgY29uc3RydWN0b3IoaTogbnVtYmVyLCBubTogc3RyaW5nLCBzcmM/OiBTb3VyY2UsIGxuOiBudW1iZXIgPSAwLCBjb2w6IG51bWJlciA9IDApIHtcblx0XHR0aGlzLmlkID0gaTtcblx0XHR0aGlzLnNvdXJjZSA9IHNyYztcblx0XHR0aGlzLmxpbmUgPSBsbjtcblx0XHR0aGlzLmNvbHVtbiA9IGNvbDtcblx0XHR0aGlzLm5hbWUgPSBubTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVGhyZWFkIGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5UaHJlYWQge1xuXHRpZDogbnVtYmVyO1xuXHRuYW1lOiBzdHJpbmc7XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKGlkOiBudW1iZXIsIG5hbWU6IHN0cmluZykge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHRpZiAobmFtZSkge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5uYW1lID0gJ1RocmVhZCAjJyArIGlkO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVmFyaWFibGUgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLlZhcmlhYmxlIHtcblx0bmFtZTogc3RyaW5nO1xuXHR2YWx1ZTogc3RyaW5nO1xuXHR2YXJpYWJsZXNSZWZlcmVuY2U6IG51bWJlcjtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCByZWY6IG51bWJlciA9IDAsIGluZGV4ZWRWYXJpYWJsZXM/OiBudW1iZXIsIG5hbWVkVmFyaWFibGVzPzogbnVtYmVyKSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy52YXJpYWJsZXNSZWZlcmVuY2UgPSByZWY7XG5cdFx0aWYgKHR5cGVvZiBuYW1lZFZhcmlhYmxlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdCg8RGVidWdQcm90b2NvbC5WYXJpYWJsZT50aGlzKS5uYW1lZFZhcmlhYmxlcyA9IG5hbWVkVmFyaWFibGVzO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGluZGV4ZWRWYXJpYWJsZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQoPERlYnVnUHJvdG9jb2wuVmFyaWFibGU+dGhpcykuaW5kZXhlZFZhcmlhYmxlcyA9IGluZGV4ZWRWYXJpYWJsZXM7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBCcmVha3BvaW50IGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5CcmVha3BvaW50IHtcblx0dmVyaWZpZWQ6IGJvb2xlYW47XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHZlcmlmaWVkOiBib29sZWFuLCBsaW5lPzogbnVtYmVyLCBjb2x1bW4/OiBudW1iZXIsIHNvdXJjZT86IFNvdXJjZSkge1xuXHRcdHRoaXMudmVyaWZpZWQgPSB2ZXJpZmllZDtcblx0XHRjb25zdCBlOiBEZWJ1Z1Byb3RvY29sLkJyZWFrcG9pbnQgPSB0aGlzO1xuXHRcdGlmICh0eXBlb2YgbGluZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdGUubGluZSA9IGxpbmU7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgY29sdW1uID09PSAnbnVtYmVyJykge1xuXHRcdFx0ZS5jb2x1bW4gPSBjb2x1bW47XG5cdFx0fVxuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdGUuc291cmNlID0gc291cmNlO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBzZXRJZChpZDogbnVtYmVyKSB7XG5cdFx0KHRoaXMgYXMgRGVidWdQcm90b2NvbC5CcmVha3BvaW50KS5pZCA9IGlkO1xuIFx0fVxufVxuXG5leHBvcnQgY2xhc3MgTW9kdWxlIGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5Nb2R1bGUge1xuXHRpZDogbnVtYmVyIHwgc3RyaW5nO1xuXHRuYW1lOiBzdHJpbmc7XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKGlkOiBudW1iZXIgfCBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9uSXRlbSBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuQ29tcGxldGlvbkl0ZW0ge1xuXHRsYWJlbDogc3RyaW5nO1xuXHRzdGFydDogbnVtYmVyO1xuXHRsZW5ndGg6IG51bWJlcjtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IobGFiZWw6IHN0cmluZywgc3RhcnQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIgPSAwKSB7XG5cdFx0dGhpcy5sYWJlbCA9IGxhYmVsO1xuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU3RvcHBlZEV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLlN0b3BwZWRFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRyZWFzb246IHN0cmluZztcblx0fTtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IocmVhc29uOiBzdHJpbmcsIHRocmVhZElkPzogbnVtYmVyLCBleGNlcHRpb25UZXh0Pzogc3RyaW5nKSB7XG5cdFx0c3VwZXIoJ3N0b3BwZWQnKTtcblx0XHR0aGlzLmJvZHkgPSB7XG5cdFx0XHRyZWFzb246IHJlYXNvblxuXHRcdH07XG5cdFx0aWYgKHR5cGVvZiB0aHJlYWRJZCA9PT0gJ251bWJlcicpIHtcblx0XHRcdCh0aGlzIGFzIERlYnVnUHJvdG9jb2wuU3RvcHBlZEV2ZW50KS5ib2R5LnRocmVhZElkID0gdGhyZWFkSWQ7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgZXhjZXB0aW9uVGV4dCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdCh0aGlzIGFzIERlYnVnUHJvdG9jb2wuU3RvcHBlZEV2ZW50KS5ib2R5LnRleHQgPSBleGNlcHRpb25UZXh0O1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgQ29udGludWVkRXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuQ29udGludWVkRXZlbnQge1xuXHRib2R5OiB7XG5cdFx0dGhyZWFkSWQ6IG51bWJlcjtcblx0fTtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IodGhyZWFkSWQ6IG51bWJlciwgYWxsVGhyZWFkc0NvbnRpbnVlZD86IGJvb2xlYW4pIHtcblx0XHRzdXBlcignY29udGludWVkJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0dGhyZWFkSWQ6IHRocmVhZElkXG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2YgYWxsVGhyZWFkc0NvbnRpbnVlZCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHQoPERlYnVnUHJvdG9jb2wuQ29udGludWVkRXZlbnQ+dGhpcykuYm9keS5hbGxUaHJlYWRzQ29udGludWVkID0gYWxsVGhyZWFkc0NvbnRpbnVlZDtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIEluaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuSW5pdGlhbGl6ZWRFdmVudCB7XG5cdHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcignaW5pdGlhbGl6ZWQnKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVGVybWluYXRlZEV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLlRlcm1pbmF0ZWRFdmVudCB7XG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihyZXN0YXJ0PzogYW55KSB7XG5cdFx0c3VwZXIoJ3Rlcm1pbmF0ZWQnKTtcblx0XHRpZiAodHlwZW9mIHJlc3RhcnQgPT09ICdib29sZWFuJyB8fCByZXN0YXJ0KSB7XG5cdFx0XHRjb25zdCBlOiBEZWJ1Z1Byb3RvY29sLlRlcm1pbmF0ZWRFdmVudCA9IHRoaXM7XG5cdFx0XHRlLmJvZHkgPSB7XG5cdFx0XHRcdHJlc3RhcnQ6IHJlc3RhcnRcblx0XHRcdH07XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBFeGl0ZWRFdmVudCBleHRlbmRzIEV2ZW50IGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5FeGl0ZWRFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRleGl0Q29kZTogbnVtYmVyXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKGV4aXRDb2RlOiBudW1iZXIpIHtcblx0XHRzdXBlcignZXhpdGVkJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0ZXhpdENvZGU6IGV4aXRDb2RlXG5cdFx0fTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgT3V0cHV0RXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuT3V0cHV0RXZlbnQge1xuXHRib2R5OiB7XG5cdFx0Y2F0ZWdvcnk6IHN0cmluZyxcblx0XHRvdXRwdXQ6IHN0cmluZyxcblx0XHRkYXRhPzogYW55XG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKG91dHB1dDogc3RyaW5nLCBjYXRlZ29yeTogc3RyaW5nID0gJ2NvbnNvbGUnLCBkYXRhPzogYW55KSB7XG5cdFx0c3VwZXIoJ291dHB1dCcpO1xuXHRcdHRoaXMuYm9keSA9IHtcblx0XHRcdGNhdGVnb3J5OiBjYXRlZ29yeSxcblx0XHRcdG91dHB1dDogb3V0cHV0XG5cdFx0fTtcblx0XHRpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmJvZHkuZGF0YSA9IGRhdGE7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRFdmVudCBleHRlbmRzIEV2ZW50IGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5UaHJlYWRFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRyZWFzb246IHN0cmluZyxcblx0XHR0aHJlYWRJZDogbnVtYmVyXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHJlYXNvbjogc3RyaW5nLCB0aHJlYWRJZDogbnVtYmVyKSB7XG5cdFx0c3VwZXIoJ3RocmVhZCcpO1xuXHRcdHRoaXMuYm9keSA9IHtcblx0XHRcdHJlYXNvbjogcmVhc29uLFxuXHRcdFx0dGhyZWFkSWQ6IHRocmVhZElkXG5cdFx0fTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgQnJlYWtwb2ludEV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLkJyZWFrcG9pbnRFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRyZWFzb246IHN0cmluZyxcblx0XHRicmVha3BvaW50OiBEZWJ1Z1Byb3RvY29sLkJyZWFrcG9pbnRcblx0fTtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IocmVhc29uOiBzdHJpbmcsIGJyZWFrcG9pbnQ6IERlYnVnUHJvdG9jb2wuQnJlYWtwb2ludCkge1xuXHRcdHN1cGVyKCdicmVha3BvaW50Jyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0cmVhc29uOiByZWFzb24sXG5cdFx0XHRicmVha3BvaW50OiBicmVha3BvaW50XG5cdFx0fTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgTW9kdWxlRXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuTW9kdWxlRXZlbnQge1xuXHRib2R5OiB7XG5cdFx0cmVhc29uOiAnbmV3JyB8ICdjaGFuZ2VkJyB8ICdyZW1vdmVkJyxcblx0XHRtb2R1bGU6IERlYnVnUHJvdG9jb2wuTW9kdWxlXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHJlYXNvbjogJ25ldycgfCAnY2hhbmdlZCcgfCAncmVtb3ZlZCcsIG1vZHVsZTogRGVidWdQcm90b2NvbC5Nb2R1bGUpIHtcblx0XHRzdXBlcignbW9kdWxlJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0cmVhc29uOiByZWFzb24sXG5cdFx0XHRtb2R1bGU6IG1vZHVsZVxuXHRcdH07XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIExvYWRlZFNvdXJjZUV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLkxvYWRlZFNvdXJjZUV2ZW50IHtcblx0Ym9keToge1xuXHRcdHJlYXNvbjogJ25ldycgfCAnY2hhbmdlZCcgfCAncmVtb3ZlZCcsXG5cdFx0c291cmNlOiBEZWJ1Z1Byb3RvY29sLlNvdXJjZVxuXHR9O1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihyZWFzb246ICduZXcnIHwgJ2NoYW5nZWQnIHwgJ3JlbW92ZWQnLCBzb3VyY2U6IERlYnVnUHJvdG9jb2wuU291cmNlKSB7XG5cdFx0c3VwZXIoJ2xvYWRlZFNvdXJjZScpO1xuXHRcdHRoaXMuYm9keSA9IHtcblx0XHRcdHJlYXNvbjogcmVhc29uLFxuXHRcdFx0c291cmNlOiBzb3VyY2Vcblx0XHR9O1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBDYXBhYmlsaXRpZXNFdmVudCBleHRlbmRzIEV2ZW50IGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5DYXBhYmlsaXRpZXNFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRjYXBhYmlsaXRpZXM6IERlYnVnUHJvdG9jb2wuQ2FwYWJpbGl0aWVzXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKGNhcGFiaWxpdGllczogRGVidWdQcm90b2NvbC5DYXBhYmlsaXRpZXMpIHtcblx0XHRzdXBlcignY2FwYWJpbGl0aWVzJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0Y2FwYWJpbGl0aWVzOiBjYXBhYmlsaXRpZXNcblx0XHR9O1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1N0YXJ0RXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuUHJvZ3Jlc3NTdGFydEV2ZW50IHtcblx0Ym9keToge1xuXHRcdHByb2dyZXNzSWQ6IHN0cmluZyxcblx0XHR0aXRsZTogc3RyaW5nXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHByb2dyZXNzSWQ6IHN0cmluZywgdGl0bGU6IHN0cmluZywgbWVzc2FnZT86IHN0cmluZykge1xuXHRcdHN1cGVyKCdwcm9ncmVzc1N0YXJ0Jyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0cHJvZ3Jlc3NJZDogcHJvZ3Jlc3NJZCxcblx0XHRcdHRpdGxlOiB0aXRsZVxuXHRcdH07XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuXHRcdFx0KHRoaXMgYXMgRGVidWdQcm90b2NvbC5Qcm9ncmVzc1N0YXJ0RXZlbnQpLmJvZHkubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1VwZGF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLlByb2dyZXNzVXBkYXRlRXZlbnQge1xuXHRib2R5OiB7XG5cdFx0cHJvZ3Jlc3NJZDogc3RyaW5nXG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHByb2dyZXNzSWQ6IHN0cmluZywgbWVzc2FnZT86IHN0cmluZykge1xuXHRcdHN1cGVyKCdwcm9ncmVzc1VwZGF0ZScpO1xuXHRcdHRoaXMuYm9keSA9IHtcblx0XHRcdHByb2dyZXNzSWQ6IHByb2dyZXNzSWRcblx0XHR9O1xuXHRcdGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdCh0aGlzIGFzIERlYnVnUHJvdG9jb2wuUHJvZ3Jlc3NVcGRhdGVFdmVudCkuYm9keS5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb2dyZXNzRW5kRXZlbnQgZXh0ZW5kcyBFdmVudCBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuUHJvZ3Jlc3NFbmRFdmVudCB7XG5cdGJvZHk6IHtcblx0XHRwcm9ncmVzc0lkOiBzdHJpbmdcblx0fTtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IocHJvZ3Jlc3NJZDogc3RyaW5nLCBtZXNzYWdlPzogc3RyaW5nKSB7XG5cdFx0c3VwZXIoJ3Byb2dyZXNzRW5kJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdFx0cHJvZ3Jlc3NJZDogcHJvZ3Jlc3NJZFxuXHRcdH07XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuXHRcdFx0KHRoaXMgYXMgRGVidWdQcm90b2NvbC5Qcm9ncmVzc0VuZEV2ZW50KS5ib2R5Lm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgSW52YWxpZGF0ZWRFdmVudCBleHRlbmRzIEV2ZW50IGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5JbnZhbGlkYXRlZEV2ZW50IHtcblx0Ym9keToge1xuXHRcdGFyZWFzPzogRGVidWdQcm90b2NvbC5JbnZhbGlkYXRlZEFyZWFzW107XG5cdFx0dGhyZWFkSWQ/OiBudW1iZXI7XG5cdFx0c3RhY2tGcmFtZUlkPzogbnVtYmVyO1xuXHR9O1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihhcmVhcz86IERlYnVnUHJvdG9jb2wuSW52YWxpZGF0ZWRBcmVhc1tdLCB0aHJlYWRJZD86IG51bWJlciwgc3RhY2tGcmFtZUlkPzogbnVtYmVyKSB7XG5cdFx0c3VwZXIoJ2ludmFsaWRhdGVkJyk7XG5cdFx0dGhpcy5ib2R5ID0ge1xuXHRcdH07XG5cdFx0aWYgKGFyZWFzKSB7XG5cdFx0XHR0aGlzLmJvZHkuYXJlYXMgPSBhcmVhcztcblx0XHR9XG5cdFx0aWYgKHRocmVhZElkKSB7XG5cdFx0XHR0aGlzLmJvZHkudGhyZWFkSWQgPSB0aHJlYWRJZDtcblx0XHR9XG5cdFx0aWYgKHN0YWNrRnJhbWVJZCkge1xuXHRcdFx0dGhpcy5ib2R5LnN0YWNrRnJhbWVJZCA9IHN0YWNrRnJhbWVJZDtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIE1lbW9yeUV2ZW50IGV4dGVuZHMgRXZlbnQgaW1wbGVtZW50cyBEZWJ1Z1Byb3RvY29sLk1lbW9yeUV2ZW50IHtcblx0Ym9keToge1xuXHRcdG1lbW9yeVJlZmVyZW5jZTogc3RyaW5nO1xuXHRcdG9mZnNldDogbnVtYmVyO1xuXHRcdGNvdW50OiBudW1iZXI7XG5cdH07XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKG1lbW9yeVJlZmVyZW5jZTogc3RyaW5nLCBvZmZzZXQ6IG51bWJlciwgY291bnQ6IG51bWJlcikge1xuXHRcdHN1cGVyKCdtZW1vcnknKTtcblx0XHR0aGlzLmJvZHkgPSB7IG1lbW9yeVJlZmVyZW5jZSwgb2Zmc2V0LCBjb3VudCB9O1xuXHR9XG59XG5cbmV4cG9ydCBlbnVtIEVycm9yRGVzdGluYXRpb24ge1xuXHRVc2VyID0gMSxcblx0VGVsZW1ldHJ5ID0gMlxufTtcblxuZXhwb3J0IGNsYXNzIERlYnVnU2Vzc2lvbiBleHRlbmRzIFByb3RvY29sU2VydmVyIHtcblxuXHRwcml2YXRlIF9kZWJ1Z2dlckxpbmVzU3RhcnRBdDE6IGJvb2xlYW47XG5cdHByaXZhdGUgX2RlYnVnZ2VyQ29sdW1uc1N0YXJ0QXQxOiBib29sZWFuO1xuXHRwcml2YXRlIF9kZWJ1Z2dlclBhdGhzQXJlVVJJczogYm9vbGVhbjtcblxuXHRwcml2YXRlIF9jbGllbnRMaW5lc1N0YXJ0QXQxOiBib29sZWFuO1xuXHRwcml2YXRlIF9jbGllbnRDb2x1bW5zU3RhcnRBdDE6IGJvb2xlYW47XG5cdHByaXZhdGUgX2NsaWVudFBhdGhzQXJlVVJJczogYm9vbGVhbjtcblxuXHRwcm90ZWN0ZWQgX2lzU2VydmVyOiBib29sZWFuO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihvYnNvbGV0ZV9kZWJ1Z2dlckxpbmVzQW5kQ29sdW1uc1N0YXJ0QXQxPzogYm9vbGVhbiwgb2Jzb2xldGVfaXNTZXJ2ZXI/OiBib29sZWFuKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IGxpbmVzQW5kQ29sdW1uc1N0YXJ0QXQxID0gdHlwZW9mIG9ic29sZXRlX2RlYnVnZ2VyTGluZXNBbmRDb2x1bW5zU3RhcnRBdDEgPT09ICdib29sZWFuJyA/IG9ic29sZXRlX2RlYnVnZ2VyTGluZXNBbmRDb2x1bW5zU3RhcnRBdDEgOiBmYWxzZTtcblx0XHR0aGlzLl9kZWJ1Z2dlckxpbmVzU3RhcnRBdDEgPSBsaW5lc0FuZENvbHVtbnNTdGFydEF0MTtcblx0XHR0aGlzLl9kZWJ1Z2dlckNvbHVtbnNTdGFydEF0MSA9IGxpbmVzQW5kQ29sdW1uc1N0YXJ0QXQxO1xuXHRcdHRoaXMuX2RlYnVnZ2VyUGF0aHNBcmVVUklzID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jbGllbnRMaW5lc1N0YXJ0QXQxID0gdHJ1ZTtcblx0XHR0aGlzLl9jbGllbnRDb2x1bW5zU3RhcnRBdDEgPSB0cnVlO1xuXHRcdHRoaXMuX2NsaWVudFBhdGhzQXJlVVJJcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5faXNTZXJ2ZXIgPSB0eXBlb2Ygb2Jzb2xldGVfaXNTZXJ2ZXIgPT09ICdib29sZWFuJyA/IG9ic29sZXRlX2lzU2VydmVyIDogZmFsc2U7XG5cblx0XHR0aGlzLm9uKCdjbG9zZScsICgpID0+IHtcblx0XHRcdHRoaXMuc2h1dGRvd24oKTtcblx0XHR9KTtcblx0XHR0aGlzLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuXHRcdFx0dGhpcy5zaHV0ZG93bigpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHVibGljIHNldERlYnVnZ2VyUGF0aEZvcm1hdChmb3JtYXQ6IHN0cmluZykge1xuXHRcdHRoaXMuX2RlYnVnZ2VyUGF0aHNBcmVVUklzID0gZm9ybWF0ICE9PSAncGF0aCc7XG5cdH1cblxuXHRwdWJsaWMgc2V0RGVidWdnZXJMaW5lc1N0YXJ0QXQxKGVuYWJsZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2RlYnVnZ2VyTGluZXNTdGFydEF0MSA9IGVuYWJsZTtcblx0fVxuXG5cdHB1YmxpYyBzZXREZWJ1Z2dlckNvbHVtbnNTdGFydEF0MShlbmFibGU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9kZWJ1Z2dlckNvbHVtbnNTdGFydEF0MSA9IGVuYWJsZTtcblx0fVxuXG5cdHB1YmxpYyBzZXRSdW5Bc1NlcnZlcihlbmFibGU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9pc1NlcnZlciA9IGVuYWJsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHZpcnR1YWwgY29uc3RydWN0b3IuLi5cblx0ICovXG5cdHB1YmxpYyBzdGF0aWMgcnVuKGRlYnVnU2Vzc2lvbjogdHlwZW9mIERlYnVnU2Vzc2lvbikge1xuXHRcdHJ1bkRlYnVnQWRhcHRlcihkZWJ1Z1Nlc3Npb24pO1xuXHR9XG5cblx0cHVibGljIHNodXRkb3duKCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLl9pc1NlcnZlciB8fCB0aGlzLl9pc1J1bm5pbmdJbmxpbmUoKSkge1xuXHRcdFx0Ly8gc2h1dGRvd24gaWdub3JlZCBpbiBzZXJ2ZXIgbW9kZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB3YWl0IGEgYml0IGJlZm9yZSBzaHV0dGluZyBkb3duXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0cHJvY2Vzcy5leGl0KDApO1xuXHRcdFx0fSwgMTAwKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2VuZEVycm9yUmVzcG9uc2UocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVzcG9uc2UsIGNvZGVPck1lc3NhZ2U6IG51bWJlciB8IERlYnVnUHJvdG9jb2wuTWVzc2FnZSwgZm9ybWF0Pzogc3RyaW5nLCB2YXJpYWJsZXM/OiBhbnksIGRlc3Q6IEVycm9yRGVzdGluYXRpb24gPSBFcnJvckRlc3RpbmF0aW9uLlVzZXIpOiB2b2lkIHtcblxuXHRcdGxldCBtc2cgOiBEZWJ1Z1Byb3RvY29sLk1lc3NhZ2U7XG5cdFx0aWYgKHR5cGVvZiBjb2RlT3JNZXNzYWdlID09PSAnbnVtYmVyJykge1xuXHRcdFx0bXNnID0gPERlYnVnUHJvdG9jb2wuTWVzc2FnZT4ge1xuXHRcdFx0XHRpZDogPG51bWJlcj4gY29kZU9yTWVzc2FnZSxcblx0XHRcdFx0Zm9ybWF0OiBmb3JtYXRcblx0XHRcdH07XG5cdFx0XHRpZiAodmFyaWFibGVzKSB7XG5cdFx0XHRcdG1zZy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVzdCAmIEVycm9yRGVzdGluYXRpb24uVXNlcikge1xuXHRcdFx0XHRtc2cuc2hvd1VzZXIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlc3QgJiBFcnJvckRlc3RpbmF0aW9uLlRlbGVtZXRyeSkge1xuXHRcdFx0XHRtc2cuc2VuZFRlbGVtZXRyeSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1zZyA9IGNvZGVPck1lc3NhZ2U7XG5cdFx0fVxuXG5cdFx0cmVzcG9uc2Uuc3VjY2VzcyA9IGZhbHNlO1xuXHRcdHJlc3BvbnNlLm1lc3NhZ2UgPSBEZWJ1Z1Nlc3Npb24uZm9ybWF0UElJKG1zZy5mb3JtYXQsIHRydWUsIG1zZy52YXJpYWJsZXMpO1xuXHRcdGlmICghcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0cmVzcG9uc2UuYm9keSA9IHsgfTtcblx0XHR9XG5cdFx0cmVzcG9uc2UuYm9keS5lcnJvciA9IG1zZztcblxuXHRcdHRoaXMuc2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0fVxuXG5cdHB1YmxpYyBydW5JblRlcm1pbmFsUmVxdWVzdChhcmdzOiBEZWJ1Z1Byb3RvY29sLlJ1bkluVGVybWluYWxSZXF1ZXN0QXJndW1lbnRzLCB0aW1lb3V0OiBudW1iZXIsIGNiOiAocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUnVuSW5UZXJtaW5hbFJlc3BvbnNlKSA9PiB2b2lkKSB7XG5cdFx0dGhpcy5zZW5kUmVxdWVzdCgncnVuSW5UZXJtaW5hbCcsIGFyZ3MsIHRpbWVvdXQsIGNiIGFzIChyOiBEZWJ1Z1Byb3RvY29sLlJlc3BvbnNlKSA9PiB2b2lkKTtcblx0fVxuXG5cdHByb3RlY3RlZCBkaXNwYXRjaFJlcXVlc3QocmVxdWVzdDogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cblx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShyZXF1ZXN0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAocmVxdWVzdC5jb21tYW5kID09PSAnaW5pdGlhbGl6ZScpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSA8RGVidWdQcm90b2NvbC5Jbml0aWFsaXplUmVxdWVzdEFyZ3VtZW50cz4gcmVxdWVzdC5hcmd1bWVudHM7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBhcmdzLmxpbmVzU3RhcnRBdDEgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdHRoaXMuX2NsaWVudExpbmVzU3RhcnRBdDEgPSBhcmdzLmxpbmVzU3RhcnRBdDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbHVtbnNTdGFydEF0MSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2xpZW50Q29sdW1uc1N0YXJ0QXQxID0gYXJncy5jb2x1bW5zU3RhcnRBdDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXJncy5wYXRoRm9ybWF0ICE9PSAncGF0aCcpIHtcblx0XHRcdFx0XHR0aGlzLnNlbmRFcnJvclJlc3BvbnNlKHJlc3BvbnNlLCAyMDE4LCAnZGVidWcgYWRhcHRlciBvbmx5IHN1cHBvcnRzIG5hdGl2ZSBwYXRocycsIG51bGwsIEVycm9yRGVzdGluYXRpb24uVGVsZW1ldHJ5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBpbml0aWFsaXplUmVzcG9uc2UgPSA8RGVidWdQcm90b2NvbC5Jbml0aWFsaXplUmVzcG9uc2U+IHJlc3BvbnNlO1xuXHRcdFx0XHRcdGluaXRpYWxpemVSZXNwb25zZS5ib2R5ID0ge307XG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsaXplUmVxdWVzdChpbml0aWFsaXplUmVzcG9uc2UsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnbGF1bmNoJykge1xuXHRcdFx0XHR0aGlzLmxhdW5jaFJlcXVlc3QoPERlYnVnUHJvdG9jb2wuTGF1bmNoUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnYXR0YWNoJykge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFJlcXVlc3QoPERlYnVnUHJvdG9jb2wuQXR0YWNoUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnZGlzY29ubmVjdCcpIHtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0UmVxdWVzdCg8RGVidWdQcm90b2NvbC5EaXNjb25uZWN0UmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAndGVybWluYXRlJykge1xuXHRcdFx0XHR0aGlzLnRlcm1pbmF0ZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuVGVybWluYXRlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAncmVzdGFydCcpIHtcblx0XHRcdFx0dGhpcy5yZXN0YXJ0UmVxdWVzdCg8RGVidWdQcm90b2NvbC5SZXN0YXJ0UmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2V0QnJlYWtwb2ludHMnKSB7XG5cdFx0XHRcdHRoaXMuc2V0QnJlYWtQb2ludHNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlNldEJyZWFrcG9pbnRzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2V0RnVuY3Rpb25CcmVha3BvaW50cycpIHtcblx0XHRcdFx0dGhpcy5zZXRGdW5jdGlvbkJyZWFrUG9pbnRzUmVxdWVzdCg8RGVidWdQcm90b2NvbC5TZXRGdW5jdGlvbkJyZWFrcG9pbnRzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2V0RXhjZXB0aW9uQnJlYWtwb2ludHMnKSB7XG5cdFx0XHRcdHRoaXMuc2V0RXhjZXB0aW9uQnJlYWtQb2ludHNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlNldEV4Y2VwdGlvbkJyZWFrcG9pbnRzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnY29uZmlndXJhdGlvbkRvbmUnKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJhdGlvbkRvbmVSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLkNvbmZpZ3VyYXRpb25Eb25lUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnY29udGludWUnKSB7XG5cdFx0XHRcdHRoaXMuY29udGludWVSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLkNvbnRpbnVlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnbmV4dCcpIHtcblx0XHRcdFx0dGhpcy5uZXh0UmVxdWVzdCg8RGVidWdQcm90b2NvbC5OZXh0UmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc3RlcEluJykge1xuXHRcdFx0XHR0aGlzLnN0ZXBJblJlcXVlc3QoPERlYnVnUHJvdG9jb2wuU3RlcEluUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc3RlcE91dCcpIHtcblx0XHRcdFx0dGhpcy5zdGVwT3V0UmVxdWVzdCg8RGVidWdQcm90b2NvbC5TdGVwT3V0UmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc3RlcEJhY2snKSB7XG5cdFx0XHRcdHRoaXMuc3RlcEJhY2tSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlN0ZXBCYWNrUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAncmV2ZXJzZUNvbnRpbnVlJykge1xuXHRcdFx0XHR0aGlzLnJldmVyc2VDb250aW51ZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuUmV2ZXJzZUNvbnRpbnVlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAncmVzdGFydEZyYW1lJykge1xuXHRcdFx0XHR0aGlzLnJlc3RhcnRGcmFtZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuUmVzdGFydEZyYW1lUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnZ290bycpIHtcblx0XHRcdFx0dGhpcy5nb3RvUmVxdWVzdCg8RGVidWdQcm90b2NvbC5Hb3RvUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAncGF1c2UnKSB7XG5cdFx0XHRcdHRoaXMucGF1c2VSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlBhdXNlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc3RhY2tUcmFjZScpIHtcblx0XHRcdFx0dGhpcy5zdGFja1RyYWNlUmVxdWVzdCg8RGVidWdQcm90b2NvbC5TdGFja1RyYWNlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2NvcGVzJykge1xuXHRcdFx0XHR0aGlzLnNjb3Blc1JlcXVlc3QoPERlYnVnUHJvdG9jb2wuU2NvcGVzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAndmFyaWFibGVzJykge1xuXHRcdFx0XHR0aGlzLnZhcmlhYmxlc1JlcXVlc3QoPERlYnVnUHJvdG9jb2wuVmFyaWFibGVzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2V0VmFyaWFibGUnKSB7XG5cdFx0XHRcdHRoaXMuc2V0VmFyaWFibGVSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlNldFZhcmlhYmxlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc2V0RXhwcmVzc2lvbicpIHtcblx0XHRcdFx0dGhpcy5zZXRFeHByZXNzaW9uUmVxdWVzdCg8RGVidWdQcm90b2NvbC5TZXRFeHByZXNzaW9uUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAnc291cmNlJykge1xuXHRcdFx0XHR0aGlzLnNvdXJjZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuU291cmNlUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5jb21tYW5kID09PSAndGhyZWFkcycpIHtcblx0XHRcdFx0dGhpcy50aHJlYWRzUmVxdWVzdCg8RGVidWdQcm90b2NvbC5UaHJlYWRzUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICd0ZXJtaW5hdGVUaHJlYWRzJykge1xuXHRcdFx0XHR0aGlzLnRlcm1pbmF0ZVRocmVhZHNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlRlcm1pbmF0ZVRocmVhZHNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdldmFsdWF0ZScpIHtcblx0XHRcdFx0dGhpcy5ldmFsdWF0ZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuRXZhbHVhdGVSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdzdGVwSW5UYXJnZXRzJykge1xuXHRcdFx0XHR0aGlzLnN0ZXBJblRhcmdldHNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlN0ZXBJblRhcmdldHNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdnb3RvVGFyZ2V0cycpIHtcblx0XHRcdFx0dGhpcy5nb3RvVGFyZ2V0c1JlcXVlc3QoPERlYnVnUHJvdG9jb2wuR290b1RhcmdldHNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdjb21wbGV0aW9ucycpIHtcblx0XHRcdFx0dGhpcy5jb21wbGV0aW9uc1JlcXVlc3QoPERlYnVnUHJvdG9jb2wuQ29tcGxldGlvbnNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdleGNlcHRpb25JbmZvJykge1xuXHRcdFx0XHR0aGlzLmV4Y2VwdGlvbkluZm9SZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLkV4Y2VwdGlvbkluZm9SZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdsb2FkZWRTb3VyY2VzJykge1xuXHRcdFx0XHR0aGlzLmxvYWRlZFNvdXJjZXNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLkxvYWRlZFNvdXJjZXNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdkYXRhQnJlYWtwb2ludEluZm8nKSB7XG5cdFx0XHRcdHRoaXMuZGF0YUJyZWFrcG9pbnRJbmZvUmVxdWVzdCg8RGVidWdQcm90b2NvbC5EYXRhQnJlYWtwb2ludEluZm9SZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdzZXREYXRhQnJlYWtwb2ludHMnKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0YUJyZWFrcG9pbnRzUmVxdWVzdCg8RGVidWdQcm90b2NvbC5TZXREYXRhQnJlYWtwb2ludHNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdyZWFkTWVtb3J5Jykge1xuXHRcdFx0XHR0aGlzLnJlYWRNZW1vcnlSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlJlYWRNZW1vcnlSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICd3cml0ZU1lbW9yeScpIHtcblx0XHRcdFx0dGhpcy53cml0ZU1lbW9yeVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuV3JpdGVNZW1vcnlSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdkaXNhc3NlbWJsZScpIHtcblx0XHRcdFx0dGhpcy5kaXNhc3NlbWJsZVJlcXVlc3QoPERlYnVnUHJvdG9jb2wuRGlzYXNzZW1ibGVSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdjYW5jZWwnKSB7XG5cdFx0XHRcdHRoaXMuY2FuY2VsUmVxdWVzdCg8RGVidWdQcm90b2NvbC5DYW5jZWxSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdicmVha3BvaW50TG9jYXRpb25zJykge1xuXHRcdFx0XHR0aGlzLmJyZWFrcG9pbnRMb2NhdGlvbnNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLkJyZWFrcG9pbnRMb2NhdGlvbnNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIGlmIChyZXF1ZXN0LmNvbW1hbmQgPT09ICdzZXRJbnN0cnVjdGlvbkJyZWFrcG9pbnRzJykge1xuXHRcdFx0XHR0aGlzLnNldEluc3RydWN0aW9uQnJlYWtwb2ludHNSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlNldEluc3RydWN0aW9uQnJlYWtwb2ludHNSZXNwb25zZT4gcmVzcG9uc2UsIHJlcXVlc3QuYXJndW1lbnRzLCByZXF1ZXN0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jdXN0b21SZXF1ZXN0KHJlcXVlc3QuY29tbWFuZCwgPERlYnVnUHJvdG9jb2wuUmVzcG9uc2U+IHJlc3BvbnNlLCByZXF1ZXN0LmFyZ3VtZW50cywgcmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhpcy5zZW5kRXJyb3JSZXNwb25zZShyZXNwb25zZSwgMTEwNCwgJ3tfc3RhY2t9JywgeyBfZXhjZXB0aW9uOiBlLm1lc3NhZ2UsIF9zdGFjazogZS5zdGFjayB9LCBFcnJvckRlc3RpbmF0aW9uLlRlbGVtZXRyeSk7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIGluaXRpYWxpemVSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkluaXRpYWxpemVSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5Jbml0aWFsaXplUmVxdWVzdEFyZ3VtZW50cyk6IHZvaWQge1xuXG5cdFx0Ly8gVGhpcyBkZWZhdWx0IGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBjb25kaXRpb25hbCBicmVha3BvaW50cy5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzQ29uZGl0aW9uYWxCcmVha3BvaW50cyA9IGZhbHNlO1xuXG5cdFx0Ly8gVGhpcyBkZWZhdWx0IGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBoaXQgY29uZGl0aW9uYWwgYnJlYWtwb2ludHMuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0hpdENvbmRpdGlvbmFsQnJlYWtwb2ludHMgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgZnVuY3Rpb24gYnJlYWtwb2ludHMuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0Z1bmN0aW9uQnJlYWtwb2ludHMgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGltcGxlbWVudHMgdGhlICdjb25maWd1cmF0aW9uRG9uZScgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzQ29uZmlndXJhdGlvbkRvbmVSZXF1ZXN0ID0gdHJ1ZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgaG92ZXJzIGJhc2VkIG9uIHRoZSAnZXZhbHVhdGUnIHJlcXVlc3QuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0V2YWx1YXRlRm9ySG92ZXJzID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlZmF1bHQgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnc3RlcEJhY2snIHJlcXVlc3QuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c1N0ZXBCYWNrID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlZmF1bHQgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnc2V0VmFyaWFibGUnIHJlcXVlc3QuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c1NldFZhcmlhYmxlID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlZmF1bHQgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAncmVzdGFydEZyYW1lJyByZXF1ZXN0LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNSZXN0YXJ0RnJhbWUgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICdzdGVwSW5UYXJnZXRzJyByZXF1ZXN0LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNTdGVwSW5UYXJnZXRzUmVxdWVzdCA9IGZhbHNlO1xuXG5cdFx0Ly8gVGhpcyBkZWZhdWx0IGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ2dvdG9UYXJnZXRzJyByZXF1ZXN0LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNHb3RvVGFyZ2V0c1JlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICdjb21wbGV0aW9ucycgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzQ29tcGxldGlvbnNSZXF1ZXN0ID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlZmF1bHQgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAncmVzdGFydCcgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzUmVzdGFydFJlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVmYXVsdCBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICdleGNlcHRpb25PcHRpb25zJyBhdHRyaWJ1dGUgb24gdGhlICdzZXRFeGNlcHRpb25CcmVha3BvaW50cycgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzRXhjZXB0aW9uT3B0aW9ucyA9IGZhbHNlO1xuXG5cdFx0Ly8gVGhpcyBkZWZhdWx0IGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ2Zvcm1hdCcgYXR0cmlidXRlIG9uIHRoZSAndmFyaWFibGVzJywgJ2V2YWx1YXRlJywgYW5kICdzdGFja1RyYWNlJyByZXF1ZXN0LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNWYWx1ZUZvcm1hdHRpbmdPcHRpb25zID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ2V4Y2VwdGlvbkluZm8nIHJlcXVlc3QuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0V4Y2VwdGlvbkluZm9SZXF1ZXN0ID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ1Rlcm1pbmF0ZURlYnVnZ2VlJyBhdHRyaWJ1dGUgb24gdGhlICdkaXNjb25uZWN0JyByZXF1ZXN0LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydFRlcm1pbmF0ZURlYnVnZ2VlID0gZmFsc2U7XG5cblx0XHQvLyBUaGlzIGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWxheWVkIGxvYWRpbmcgb2Ygc3RhY2sgZnJhbWVzLlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNEZWxheWVkU3RhY2tUcmFjZUxvYWRpbmcgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnbG9hZGVkU291cmNlcycgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzTG9hZGVkU291cmNlc1JlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnbG9nTWVzc2FnZScgYXR0cmlidXRlIG9mIHRoZSBTb3VyY2VCcmVha3BvaW50LlxuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNMb2dQb2ludHMgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAndGVybWluYXRlVGhyZWFkcycgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzVGVybWluYXRlVGhyZWFkc1JlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnc2V0RXhwcmVzc2lvbicgcmVxdWVzdC5cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzU2V0RXhwcmVzc2lvbiA9IGZhbHNlO1xuXG5cdFx0Ly8gVGhpcyBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICd0ZXJtaW5hdGUnIHJlcXVlc3QuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c1Rlcm1pbmF0ZVJlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8vIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IGRhdGEgYnJlYWtwb2ludHMuXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0RhdGFCcmVha3BvaW50cyA9IGZhbHNlO1xuXG5cdFx0LyoqIFRoaXMgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAncmVhZE1lbW9yeScgcmVxdWVzdC4gKi9cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzUmVhZE1lbW9yeVJlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8qKiBUaGUgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnZGlzYXNzZW1ibGUnIHJlcXVlc3QuICovXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0Rpc2Fzc2VtYmxlUmVxdWVzdCA9IGZhbHNlO1xuXG5cdFx0LyoqIFRoZSBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICdjYW5jZWwnIHJlcXVlc3QuICovXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0NhbmNlbFJlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8qKiBUaGUgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnYnJlYWtwb2ludExvY2F0aW9ucycgcmVxdWVzdC4gKi9cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzQnJlYWtwb2ludExvY2F0aW9uc1JlcXVlc3QgPSBmYWxzZTtcblxuXHRcdC8qKiBUaGUgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnY2xpcGJvYXJkJyBjb250ZXh0IHZhbHVlIGluIHRoZSAnZXZhbHVhdGUnIHJlcXVlc3QuICovXG5cdFx0cmVzcG9uc2UuYm9keS5zdXBwb3J0c0NsaXBib2FyZENvbnRleHQgPSBmYWxzZTtcblxuXHRcdC8qKiBUaGUgZGVidWcgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHN0ZXBwaW5nIGdyYW51bGFyaXRpZXMgZm9yIHRoZSBzdGVwcGluZyByZXF1ZXN0cy4gKi9cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzU3RlcHBpbmdHcmFudWxhcml0eSA9IGZhbHNlO1xuXG5cdFx0LyoqIFRoZSBkZWJ1ZyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICdzZXRJbnN0cnVjdGlvbkJyZWFrcG9pbnRzJyByZXF1ZXN0LiAqL1xuXHRcdHJlc3BvbnNlLmJvZHkuc3VwcG9ydHNJbnN0cnVjdGlvbkJyZWFrcG9pbnRzID0gZmFsc2U7XG5cblx0XHQvKiogVGhlIGRlYnVnIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCAnZmlsdGVyT3B0aW9ucycgb24gdGhlICdzZXRFeGNlcHRpb25CcmVha3BvaW50cycgcmVxdWVzdC4gKi9cblx0XHRyZXNwb25zZS5ib2R5LnN1cHBvcnRzRXhjZXB0aW9uRmlsdGVyT3B0aW9ucyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGRpc2Nvbm5lY3RSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkRpc2Nvbm5lY3RSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5EaXNjb25uZWN0QXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHRcdHRoaXMuc2h1dGRvd24oKTtcblx0fVxuXG5cdHByb3RlY3RlZCBsYXVuY2hSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkxhdW5jaFJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkxhdW5jaFJlcXVlc3RBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgYXR0YWNoUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5BdHRhY2hSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5BdHRhY2hSZXF1ZXN0QXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHRlcm1pbmF0ZVJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuVGVybWluYXRlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuVGVybWluYXRlQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlc3RhcnRSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlJlc3RhcnRSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5SZXN0YXJ0QXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldEJyZWFrUG9pbnRzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5TZXRCcmVha3BvaW50c1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlNldEJyZWFrcG9pbnRzQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldEZ1bmN0aW9uQnJlYWtQb2ludHNSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlNldEZ1bmN0aW9uQnJlYWtwb2ludHNSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TZXRGdW5jdGlvbkJyZWFrcG9pbnRzQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldEV4Y2VwdGlvbkJyZWFrUG9pbnRzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5TZXRFeGNlcHRpb25CcmVha3BvaW50c1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlNldEV4Y2VwdGlvbkJyZWFrcG9pbnRzQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGNvbmZpZ3VyYXRpb25Eb25lUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5Db25maWd1cmF0aW9uRG9uZVJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkNvbmZpZ3VyYXRpb25Eb25lQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KTogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGNvbnRpbnVlUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5Db250aW51ZVJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkNvbnRpbnVlQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KSA6IHZvaWQge1xuXHRcdHRoaXMuc2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0fVxuXG5cdHByb3RlY3RlZCBuZXh0UmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5OZXh0UmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuTmV4dEFyZ3VtZW50cywgcmVxdWVzdD86IERlYnVnUHJvdG9jb2wuUmVxdWVzdCkgOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc3RlcEluUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5TdGVwSW5SZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TdGVwSW5Bcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpIDogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHN0ZXBPdXRSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlN0ZXBPdXRSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TdGVwT3V0QXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KSA6IHZvaWQge1xuXHRcdHRoaXMuc2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0fVxuXG5cdHByb3RlY3RlZCBzdGVwQmFja1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU3RlcEJhY2tSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TdGVwQmFja0FyZ3VtZW50cywgcmVxdWVzdD86IERlYnVnUHJvdG9jb2wuUmVxdWVzdCkgOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmV2ZXJzZUNvbnRpbnVlUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5SZXZlcnNlQ29udGludWVSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5SZXZlcnNlQ29udGludWVBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpIDogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlc3RhcnRGcmFtZVJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVzdGFydEZyYW1lUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuUmVzdGFydEZyYW1lQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KSA6IHZvaWQge1xuXHRcdHRoaXMuc2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0fVxuXG5cdHByb3RlY3RlZCBnb3RvUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5Hb3RvUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuR290b0FyZ3VtZW50cywgcmVxdWVzdD86IERlYnVnUHJvdG9jb2wuUmVxdWVzdCkgOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcGF1c2VSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlBhdXNlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuUGF1c2VBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpIDogdm9pZCB7XG5cdFx0dGhpcy5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNvdXJjZVJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU291cmNlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuU291cmNlQXJndW1lbnRzLCByZXF1ZXN0PzogRGVidWdQcm90b2NvbC5SZXF1ZXN0KSA6IHZvaWQge1xuXHRcdHRoaXMuc2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0fVxuXG5cdHByb3RlY3RlZCB0aHJlYWRzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5UaHJlYWRzUmVzcG9uc2UsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgdGVybWluYXRlVGhyZWFkc1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuVGVybWluYXRlVGhyZWFkc1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlRlcm1pbmF0ZVRocmVhZHNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc3RhY2tUcmFjZVJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU3RhY2tUcmFjZVJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlN0YWNrVHJhY2VBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2NvcGVzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5TY29wZXNSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TY29wZXNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgdmFyaWFibGVzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5WYXJpYWJsZXNSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5WYXJpYWJsZXNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0VmFyaWFibGVSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlNldFZhcmlhYmxlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuU2V0VmFyaWFibGVBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0RXhwcmVzc2lvblJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU2V0RXhwcmVzc2lvblJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlNldEV4cHJlc3Npb25Bcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZXZhbHVhdGVSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkV2YWx1YXRlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuRXZhbHVhdGVBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc3RlcEluVGFyZ2V0c1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU3RlcEluVGFyZ2V0c1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlN0ZXBJblRhcmdldHNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZ290b1RhcmdldHNSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkdvdG9UYXJnZXRzUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuR290b1RhcmdldHNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgY29tcGxldGlvbnNSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkNvbXBsZXRpb25zUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuQ29tcGxldGlvbnNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZXhjZXB0aW9uSW5mb1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuRXhjZXB0aW9uSW5mb1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkV4Y2VwdGlvbkluZm9Bcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgbG9hZGVkU291cmNlc1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuTG9hZGVkU291cmNlc1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkxvYWRlZFNvdXJjZXNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZGF0YUJyZWFrcG9pbnRJbmZvUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5EYXRhQnJlYWtwb2ludEluZm9SZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5EYXRhQnJlYWtwb2ludEluZm9Bcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0RGF0YUJyZWFrcG9pbnRzUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5TZXREYXRhQnJlYWtwb2ludHNSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5TZXREYXRhQnJlYWtwb2ludHNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVhZE1lbW9yeVJlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVhZE1lbW9yeVJlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlJlYWRNZW1vcnlBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgd3JpdGVNZW1vcnlSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLldyaXRlTWVtb3J5UmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuV3JpdGVNZW1vcnlBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZGlzYXNzZW1ibGVSZXF1ZXN0KHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLkRpc2Fzc2VtYmxlUmVzcG9uc2UsIGFyZ3M6IERlYnVnUHJvdG9jb2wuRGlzYXNzZW1ibGVBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgY2FuY2VsUmVxdWVzdChyZXNwb25zZTogRGVidWdQcm90b2NvbC5DYW5jZWxSZXNwb25zZSwgYXJnczogRGVidWdQcm90b2NvbC5DYW5jZWxBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgYnJlYWtwb2ludExvY2F0aW9uc1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuQnJlYWtwb2ludExvY2F0aW9uc1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLkJyZWFrcG9pbnRMb2NhdGlvbnNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0SW5zdHJ1Y3Rpb25CcmVha3BvaW50c1JlcXVlc3QocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuU2V0SW5zdHJ1Y3Rpb25CcmVha3BvaW50c1Jlc3BvbnNlLCBhcmdzOiBEZWJ1Z1Byb3RvY29sLlNldEluc3RydWN0aW9uQnJlYWtwb2ludHNBcmd1bWVudHMsIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRSZXNwb25zZShyZXNwb25zZSk7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGUgdGhpcyBob29rIHRvIGltcGxlbWVudCBjdXN0b20gcmVxdWVzdHMuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgY3VzdG9tUmVxdWVzdChjb21tYW5kOiBzdHJpbmcsIHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlJlc3BvbnNlLCBhcmdzOiBhbnksIHJlcXVlc3Q/OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHR0aGlzLnNlbmRFcnJvclJlc3BvbnNlKHJlc3BvbnNlLCAxMDE0LCAndW5yZWNvZ25pemVkIHJlcXVlc3QnLCBudWxsLCBFcnJvckRlc3RpbmF0aW9uLlRlbGVtZXRyeSk7XG5cdH1cblxuXHQvLy0tLS0gcHJvdGVjdGVkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRwcm90ZWN0ZWQgY29udmVydENsaWVudExpbmVUb0RlYnVnZ2VyKGxpbmU6IG51bWJlcik6IG51bWJlciB7XG5cdFx0aWYgKHRoaXMuX2RlYnVnZ2VyTGluZXNTdGFydEF0MSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NsaWVudExpbmVzU3RhcnRBdDEgPyBsaW5lIDogbGluZSArIDE7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jbGllbnRMaW5lc1N0YXJ0QXQxID8gbGluZSAtIDEgOiBsaW5lO1xuXHR9XG5cblx0cHJvdGVjdGVkIGNvbnZlcnREZWJ1Z2dlckxpbmVUb0NsaWVudChsaW5lOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGlmICh0aGlzLl9kZWJ1Z2dlckxpbmVzU3RhcnRBdDEpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jbGllbnRMaW5lc1N0YXJ0QXQxID8gbGluZSA6IGxpbmUgLSAxO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2xpZW50TGluZXNTdGFydEF0MSA/IGxpbmUgKyAxIDogbGluZTtcblx0fVxuXG5cdHByb3RlY3RlZCBjb252ZXJ0Q2xpZW50Q29sdW1uVG9EZWJ1Z2dlcihjb2x1bW46IG51bWJlcik6IG51bWJlciB7XG5cdFx0aWYgKHRoaXMuX2RlYnVnZ2VyQ29sdW1uc1N0YXJ0QXQxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xpZW50Q29sdW1uc1N0YXJ0QXQxID8gY29sdW1uIDogY29sdW1uICsgMTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NsaWVudENvbHVtbnNTdGFydEF0MSA/IGNvbHVtbiAtIDEgOiBjb2x1bW47XG5cdH1cblxuXHRwcm90ZWN0ZWQgY29udmVydERlYnVnZ2VyQ29sdW1uVG9DbGllbnQoY29sdW1uOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGlmICh0aGlzLl9kZWJ1Z2dlckNvbHVtbnNTdGFydEF0MSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NsaWVudENvbHVtbnNTdGFydEF0MSA/IGNvbHVtbiA6IGNvbHVtbiAtIDE7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jbGllbnRDb2x1bW5zU3RhcnRBdDEgPyBjb2x1bW4gKyAxIDogY29sdW1uO1xuXHR9XG5cblx0cHJvdGVjdGVkIGNvbnZlcnRDbGllbnRQYXRoVG9EZWJ1Z2dlcihjbGllbnRQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICh0aGlzLl9jbGllbnRQYXRoc0FyZVVSSXMgIT09IHRoaXMuX2RlYnVnZ2VyUGF0aHNBcmVVUklzKSB7XG5cdFx0XHRpZiAodGhpcy5fY2xpZW50UGF0aHNBcmVVUklzKSB7XG5cdFx0XHRcdHJldHVybiBEZWJ1Z1Nlc3Npb24udXJpMnBhdGgoY2xpZW50UGF0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gRGVidWdTZXNzaW9uLnBhdGgydXJpKGNsaWVudFBhdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2xpZW50UGF0aDtcblx0fVxuXG5cdHByb3RlY3RlZCBjb252ZXJ0RGVidWdnZXJQYXRoVG9DbGllbnQoZGVidWdnZXJQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICh0aGlzLl9kZWJ1Z2dlclBhdGhzQXJlVVJJcyAhPT0gdGhpcy5fY2xpZW50UGF0aHNBcmVVUklzKSB7XG5cdFx0XHRpZiAodGhpcy5fZGVidWdnZXJQYXRoc0FyZVVSSXMpIHtcblx0XHRcdFx0cmV0dXJuIERlYnVnU2Vzc2lvbi51cmkycGF0aChkZWJ1Z2dlclBhdGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIERlYnVnU2Vzc2lvbi5wYXRoMnVyaShkZWJ1Z2dlclBhdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVidWdnZXJQYXRoO1xuXHR9XG5cblx0Ly8tLS0tIHByaXZhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdHByaXZhdGUgc3RhdGljIHBhdGgydXJpKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG5cblx0XHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdFx0aWYgKC9eW0EtWl06Ly50ZXN0KHBhdGgpKSB7XG5cdFx0XHRcdHBhdGggPSBwYXRoWzBdLnRvTG93ZXJDYXNlKCkgKyBwYXRoLnN1YnN0cigxKTtcblx0XHRcdH1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHR9XG5cdFx0cGF0aCA9IGVuY29kZVVSSShwYXRoKTtcblxuXHRcdGxldCB1cmkgPSBuZXcgVVJMKGBmaWxlOmApO1x0Ly8gaWdub3JlICdwYXRoJyBmb3Igbm93XG5cdFx0dXJpLnBhdGhuYW1lID0gcGF0aDtcdC8vIG5vdyB1c2UgJ3BhdGgnIHRvIGdldCB0aGUgY29ycmVjdCBwZXJjZW50IGVuY29kaW5nIChzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnKVxuXHRcdHJldHVybiB1cmkudG9TdHJpbmcoKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIHVyaTJwYXRoKHNvdXJjZVVyaTogc3RyaW5nKTogc3RyaW5nIHtcblxuXHRcdGxldCB1cmkgPSBuZXcgVVJMKHNvdXJjZVVyaSk7XG5cdFx0bGV0IHMgPSBkZWNvZGVVUklDb21wb25lbnQodXJpLnBhdGhuYW1lKTtcblx0XHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdFx0aWYgKC9eXFwvW2EtekEtWl06Ly50ZXN0KHMpKSB7XG5cdFx0XHRcdHMgPSBzWzFdLnRvTG93ZXJDYXNlKCkgKyBzLnN1YnN0cigyKTtcblx0XHRcdH1cblx0XHRcdHMgPSBzLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gcztcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIF9mb3JtYXRQSUlSZWdleHAgPSAveyhbXn1dKyl9L2c7XG5cblx0Lypcblx0KiBJZiBhcmd1bWVudCBzdGFydHMgd2l0aCAnXycgaXQgaXMgT0sgdG8gc2VuZCBpdHMgdmFsdWUgdG8gdGVsZW1ldHJ5LlxuXHQqL1xuXHRwcml2YXRlIHN0YXRpYyBmb3JtYXRQSUkoZm9ybWF0OnN0cmluZywgZXhjbHVkZVBJSTogYm9vbGVhbiwgYXJnczoge1trZXk6IHN0cmluZ106IHN0cmluZ30pOiBzdHJpbmcge1xuXHRcdHJldHVybiBmb3JtYXQucmVwbGFjZShEZWJ1Z1Nlc3Npb24uX2Zvcm1hdFBJSVJlZ2V4cCwgZnVuY3Rpb24obWF0Y2gsIHBhcmFtTmFtZSkge1xuXHRcdFx0aWYgKGV4Y2x1ZGVQSUkgJiYgcGFyYW1OYW1lLmxlbmd0aCA+IDAgJiYgcGFyYW1OYW1lWzBdICE9PSAnXycpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFyZ3NbcGFyYW1OYW1lXSAmJiBhcmdzLmhhc093blByb3BlcnR5KHBhcmFtTmFtZSkgP1xuXHRcdFx0XHRhcmdzW3BhcmFtTmFtZV0gOlxuXHRcdFx0XHRtYXRjaDtcblx0XHR9KVxuXHR9XG59XG4iXX0=

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/handles.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/handles.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Handles = void 0;
class Handles {
    constructor(startHandle) {
        this.START_HANDLE = 1000;
        this._handleMap = new Map();
        this._nextHandle = typeof startHandle === 'number' ? startHandle : this.START_HANDLE;
    }
    reset() {
        this._nextHandle = this.START_HANDLE;
        this._handleMap = new Map();
    }
    create(value) {
        var handle = this._nextHandle++;
        this._handleMap.set(handle, value);
        return handle;
    }
    get(handle, dflt) {
        return this._handleMap.get(handle) || dflt;
    }
}
exports.Handles = Handles;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9oYW5kbGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O2dHQUdnRzs7O0FBRWhHLE1BQWEsT0FBTztJQU9uQixZQUFtQixXQUFvQjtRQUwvQixpQkFBWSxHQUFHLElBQUksQ0FBQztRQUdwQixlQUFVLEdBQUcsSUFBSSxHQUFHLEVBQWEsQ0FBQztRQUd6QyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sV0FBVyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQ3RGLENBQUM7SUFFTSxLQUFLO1FBQ1gsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQWEsQ0FBQztJQUN4QyxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQVE7UUFDckIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuQyxPQUFPLE1BQU0sQ0FBQztJQUNmLENBQUM7SUFFTSxHQUFHLENBQUMsTUFBYyxFQUFFLElBQVE7UUFDbEMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDNUMsQ0FBQztDQUNEO0FBekJELDBCQXlCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgY2xhc3MgSGFuZGxlczxUPiB7XG5cblx0cHJpdmF0ZSBTVEFSVF9IQU5ETEUgPSAxMDAwO1xuXG5cdHByaXZhdGUgX25leHRIYW5kbGUgOiBudW1iZXI7XG5cdHByaXZhdGUgX2hhbmRsZU1hcCA9IG5ldyBNYXA8bnVtYmVyLCBUPigpO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihzdGFydEhhbmRsZT86IG51bWJlcikge1xuXHRcdHRoaXMuX25leHRIYW5kbGUgPSB0eXBlb2Ygc3RhcnRIYW5kbGUgPT09ICdudW1iZXInID8gc3RhcnRIYW5kbGUgOiB0aGlzLlNUQVJUX0hBTkRMRTtcblx0fVxuXG5cdHB1YmxpYyByZXNldCgpOiB2b2lkIHtcblx0XHR0aGlzLl9uZXh0SGFuZGxlID0gdGhpcy5TVEFSVF9IQU5ETEU7XG5cdFx0dGhpcy5faGFuZGxlTWFwID0gbmV3IE1hcDxudW1iZXIsIFQ+KCk7XG5cdH1cblxuXHRwdWJsaWMgY3JlYXRlKHZhbHVlOiBUKTogbnVtYmVyIHtcblx0XHR2YXIgaGFuZGxlID0gdGhpcy5fbmV4dEhhbmRsZSsrO1xuXHRcdHRoaXMuX2hhbmRsZU1hcC5zZXQoaGFuZGxlLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIGhhbmRsZTtcblx0fVxuXG5cdHB1YmxpYyBnZXQoaGFuZGxlOiBudW1iZXIsIGRmbHQ/OiBUKTogVCB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU1hcC5nZXQoaGFuZGxlKSB8fCBkZmx0O1xuXHR9XG59XG4iXX0=

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/internalLogger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/internalLogger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalLogger = void 0;
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const logger_1 = __webpack_require__(/*! ./logger */ "./node_modules/@vscode/debugadapter/lib/logger.js");
/**
 * Manages logging, whether to console.log, file, or VS Code console.
 * Encapsulates the state specific to each logging session
 */
class InternalLogger {
    constructor(logCallback, isServer) {
        /** Dispose and allow exit to continue normally */
        this.beforeExitCallback = () => this.dispose();
        this._logCallback = logCallback;
        this._logToConsole = isServer;
        this._minLogLevel = logger_1.LogLevel.Warn;
        this.disposeCallback = (signal, code) => {
            this.dispose();
            // Exit with 128 + value of the signal code.
            // https://nodejs.org/api/process.html#process_exit_codes
            code = code || 2; // SIGINT
            code += 128;
            process.exit(code);
        };
    }
    async setup(options) {
        this._minLogLevel = options.consoleMinLogLevel;
        this._prependTimestamp = options.prependTimestamp;
        // Open a log file in the specified location. Overwritten on each run.
        if (options.logFilePath) {
            if (!path.isAbsolute(options.logFilePath)) {
                this.log(`logFilePath must be an absolute path: ${options.logFilePath}`, logger_1.LogLevel.Error);
            }
            else {
                const handleError = (err) => this.sendLog(`Error creating log file at path: ${options.logFilePath}. Error: ${err.toString()}\n`, logger_1.LogLevel.Error);
                try {
                    await fs.promises.mkdir(path.dirname(options.logFilePath), { recursive: true });
                    this.log(`Verbose logs are written to:\n`, logger_1.LogLevel.Warn);
                    this.log(options.logFilePath + '\n', logger_1.LogLevel.Warn);
                    this._logFileStream = fs.createWriteStream(options.logFilePath);
                    this.logDateTime();
                    this.setupShutdownListeners();
                    this._logFileStream.on('error', err => {
                        handleError(err);
                    });
                }
                catch (err) {
                    handleError(err);
                }
            }
        }
    }
    logDateTime() {
        let d = new Date();
        let dateString = d.getUTCFullYear() + '-' + `${d.getUTCMonth() + 1}` + '-' + d.getUTCDate();
        const timeAndDateStamp = dateString + ', ' + getFormattedTimeString();
        this.log(timeAndDateStamp + '\n', logger_1.LogLevel.Verbose, false);
    }
    setupShutdownListeners() {
        process.on('beforeExit', this.beforeExitCallback);
        process.on('SIGTERM', this.disposeCallback);
        process.on('SIGINT', this.disposeCallback);
    }
    removeShutdownListeners() {
        process.removeListener('beforeExit', this.beforeExitCallback);
        process.removeListener('SIGTERM', this.disposeCallback);
        process.removeListener('SIGINT', this.disposeCallback);
    }
    dispose() {
        return new Promise(resolve => {
            this.removeShutdownListeners();
            if (this._logFileStream) {
                this._logFileStream.end(resolve);
                this._logFileStream = null;
            }
            else {
                resolve();
            }
        });
    }
    log(msg, level, prependTimestamp = true) {
        if (this._minLogLevel === logger_1.LogLevel.Stop) {
            return;
        }
        if (level >= this._minLogLevel) {
            this.sendLog(msg, level);
        }
        if (this._logToConsole) {
            const logFn = level === logger_1.LogLevel.Error ? console.error :
                level === logger_1.LogLevel.Warn ? console.warn :
                    null;
            if (logFn) {
                logFn((0, logger_1.trimLastNewline)(msg));
            }
        }
        // If an error, prepend with '[Error]'
        if (level === logger_1.LogLevel.Error) {
            msg = `[${logger_1.LogLevel[level]}] ${msg}`;
        }
        if (this._prependTimestamp && prependTimestamp) {
            msg = '[' + getFormattedTimeString() + '] ' + msg;
        }
        if (this._logFileStream) {
            this._logFileStream.write(msg);
        }
    }
    sendLog(msg, level) {
        // Truncate long messages, they can hang VS Code
        if (msg.length > 1500) {
            const endsInNewline = !!msg.match(/(\n|\r\n)$/);
            msg = msg.substr(0, 1500) + '[...]';
            if (endsInNewline) {
                msg = msg + '\n';
            }
        }
        if (this._logCallback) {
            const event = new logger_1.LogOutputEvent(msg, level);
            this._logCallback(event);
        }
    }
}
exports.InternalLogger = InternalLogger;
function getFormattedTimeString() {
    let d = new Date();
    let hourString = _padZeroes(2, String(d.getUTCHours()));
    let minuteString = _padZeroes(2, String(d.getUTCMinutes()));
    let secondString = _padZeroes(2, String(d.getUTCSeconds()));
    let millisecondString = _padZeroes(3, String(d.getUTCMilliseconds()));
    return hourString + ':' + minuteString + ':' + secondString + '.' + millisecondString + ' UTC';
}
function _padZeroes(minDesiredLength, numberToPad) {
    if (numberToPad.length >= minDesiredLength) {
        return numberToPad;
    }
    else {
        return String('0'.repeat(minDesiredLength) + numberToPad).slice(-minDesiredLength);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxMb2dnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW50ZXJuYWxMb2dnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Z0dBR2dHOzs7QUFFaEcseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUU3QixxQ0FBNEg7QUFFNUg7OztHQUdHO0FBQ0gsTUFBYSxjQUFjO0lBbUIxQixZQUFZLFdBQXlCLEVBQUUsUUFBa0I7UUFUekQsa0RBQWtEO1FBQzFDLHVCQUFrQixHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQVNqRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNoQyxJQUFJLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQztRQUU5QixJQUFJLENBQUMsWUFBWSxHQUFHLGlCQUFRLENBQUMsSUFBSSxDQUFDO1FBRWxDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxNQUFjLEVBQUUsSUFBWSxFQUFFLEVBQUU7WUFDdkQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRWYsNENBQTRDO1lBQzVDLHlEQUF5RDtZQUN6RCxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVM7WUFDM0IsSUFBSSxJQUFJLEdBQUcsQ0FBQztZQUVaLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEIsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBK0I7UUFDakQsSUFBSSxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUM7UUFDL0MsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztRQUVsRCxzRUFBc0U7UUFDdEUsSUFBSSxPQUFPLENBQUMsV0FBVyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyx5Q0FBeUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLGlCQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekY7aUJBQU07Z0JBQ04sTUFBTSxXQUFXLEdBQUcsQ0FBQyxHQUFVLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsb0NBQW9DLE9BQU8sQ0FBQyxXQUFXLFlBQVksR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsaUJBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFeEosSUFBSTtvQkFDSCxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ2hGLElBQUksQ0FBQyxHQUFHLENBQUMsZ0NBQWdDLEVBQUUsaUJBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksRUFBRSxpQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUVwRCxJQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ2hFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDbkIsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7b0JBQzlCLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBRTt3QkFDckMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNsQixDQUFDLENBQUMsQ0FBQztpQkFDSDtnQkFBQyxPQUFPLEdBQUcsRUFBRTtvQkFDYixXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ2pCO2FBQ0Q7U0FDRDtJQUNGLENBQUM7SUFFTyxXQUFXO1FBQ2xCLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDbkIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzVGLE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxHQUFHLElBQUksR0FBRyxzQkFBc0IsRUFBRSxDQUFDO1FBQ3RFLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxFQUFFLGlCQUFRLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFTyxzQkFBc0I7UUFDN0IsT0FBTyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDbEQsT0FBTyxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU8sdUJBQXVCO1FBQzlCLE9BQU8sQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzlELE9BQU8sQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUN4RCxPQUFPLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVNLE9BQU87UUFDYixPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1lBQy9CLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO2FBQzNCO2lCQUFNO2dCQUNOLE9BQU8sRUFBRSxDQUFDO2FBQ1Y7UUFDRixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFTSxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQWUsRUFBRSxnQkFBZ0IsR0FBRyxJQUFJO1FBQy9ELElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxpQkFBUSxDQUFDLElBQUksRUFBRTtZQUN4QyxPQUFPO1NBQ1A7UUFFRCxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3ZCLE1BQU0sS0FBSyxHQUNWLEtBQUssS0FBSyxpQkFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxQyxLQUFLLEtBQUssaUJBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDeEMsSUFBSSxDQUFDO1lBRU4sSUFBSSxLQUFLLEVBQUU7Z0JBQ1YsS0FBSyxDQUFDLElBQUEsd0JBQWUsRUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQzVCO1NBQ0Q7UUFFRCxzQ0FBc0M7UUFDdEMsSUFBSSxLQUFLLEtBQUssaUJBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDN0IsR0FBRyxHQUFHLElBQUksaUJBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztTQUNwQztRQUVELElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLGdCQUFnQixFQUFFO1lBQy9DLEdBQUcsR0FBRyxHQUFHLEdBQUcsc0JBQXNCLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQy9CO0lBQ0YsQ0FBQztJQUVPLE9BQU8sQ0FBQyxHQUFXLEVBQUUsS0FBZTtRQUMzQyxnREFBZ0Q7UUFDaEQsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksRUFBRTtZQUN0QixNQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNoRCxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO1lBQ3BDLElBQUksYUFBYSxFQUFFO2dCQUNsQixHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQzthQUNqQjtTQUNEO1FBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3RCLE1BQU0sS0FBSyxHQUFHLElBQUksdUJBQWMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN6QjtJQUNGLENBQUM7Q0FDRDtBQWxKRCx3Q0FrSkM7QUFFRCxTQUFTLHNCQUFzQjtJQUM5QixJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ25CLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEQsSUFBSSxZQUFZLEdBQUcsVUFBVSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1RCxJQUFJLFlBQVksR0FBRyxVQUFVLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVELElBQUksaUJBQWlCLEdBQUcsVUFBVSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLE9BQU8sVUFBVSxHQUFHLEdBQUcsR0FBRyxZQUFZLEdBQUcsR0FBRyxHQUFHLFlBQVksR0FBRyxHQUFHLEdBQUcsaUJBQWlCLEdBQUcsTUFBTSxDQUFDO0FBQ2hHLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxnQkFBd0IsRUFBRSxXQUFtQjtJQUNoRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLElBQUksZ0JBQWdCLEVBQUU7UUFDM0MsT0FBTyxXQUFXLENBQUM7S0FDbkI7U0FBTTtRQUNOLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0tBQ25GO0FBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBMb2dMZXZlbCwgSUxvZ0NhbGxiYWNrLCB0cmltTGFzdE5ld2xpbmUsIExvZ091dHB1dEV2ZW50LCBJSW50ZXJuYWxMb2dnZXJPcHRpb25zLCBJSW50ZXJuYWxMb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbi8qKlxuICogTWFuYWdlcyBsb2dnaW5nLCB3aGV0aGVyIHRvIGNvbnNvbGUubG9nLCBmaWxlLCBvciBWUyBDb2RlIGNvbnNvbGUuXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIHNwZWNpZmljIHRvIGVhY2ggbG9nZ2luZyBzZXNzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbExvZ2dlciBpbXBsZW1lbnRzIElJbnRlcm5hbExvZ2dlciB7XG5cdHByaXZhdGUgX21pbkxvZ0xldmVsOiBMb2dMZXZlbDtcblx0cHJpdmF0ZSBfbG9nVG9Db25zb2xlOiBib29sZWFuO1xuXG5cdC8qKiBMb2cgaW5mbyB0aGF0IG1lZXRzIG1pbkxvZ0xldmVsIGlzIHNlbnQgdG8gdGhpcyBjYWxsYmFjay4gKi9cblx0cHJpdmF0ZSBfbG9nQ2FsbGJhY2s6IElMb2dDYWxsYmFjaztcblxuXHQvKiogV3JpdGUgc3RlYW0gZm9yIGxvZyBmaWxlICovXG5cdHByaXZhdGUgX2xvZ0ZpbGVTdHJlYW06IGZzLldyaXRlU3RyZWFtO1xuXG5cdC8qKiBEaXNwb3NlIGFuZCBhbGxvdyBleGl0IHRvIGNvbnRpbnVlIG5vcm1hbGx5ICovXG5cdHByaXZhdGUgYmVmb3JlRXhpdENhbGxiYWNrID0gKCkgPT4gdGhpcy5kaXNwb3NlKCk7XG5cblx0LyoqIERpc3Bvc2UgYW5kIGV4aXQgKi9cblx0cHJpdmF0ZSBkaXNwb3NlQ2FsbGJhY2s7XG5cblx0LyoqIFdoZXRoZXIgdG8gYWRkIGEgdGltZXN0YW1wIHRvIG1lc3NhZ2VzIGluIHRoZSBsb2dmaWxlICovXG5cdHByaXZhdGUgX3ByZXBlbmRUaW1lc3RhbXA6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IobG9nQ2FsbGJhY2s6IElMb2dDYWxsYmFjaywgaXNTZXJ2ZXI/OiBib29sZWFuKSB7XG5cdFx0dGhpcy5fbG9nQ2FsbGJhY2sgPSBsb2dDYWxsYmFjaztcblx0XHR0aGlzLl9sb2dUb0NvbnNvbGUgPSBpc1NlcnZlcjtcblxuXHRcdHRoaXMuX21pbkxvZ0xldmVsID0gTG9nTGV2ZWwuV2FybjtcblxuXHRcdHRoaXMuZGlzcG9zZUNhbGxiYWNrID0gKHNpZ25hbDogc3RyaW5nLCBjb2RlOiBudW1iZXIpID0+IHtcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXG5cdFx0XHQvLyBFeGl0IHdpdGggMTI4ICsgdmFsdWUgb2YgdGhlIHNpZ25hbCBjb2RlLlxuXHRcdFx0Ly8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19leGl0X2NvZGVzXG5cdFx0XHRjb2RlID0gY29kZSB8fCAyOyAvLyBTSUdJTlRcblx0XHRcdGNvZGUgKz0gMTI4O1xuXG5cdFx0XHRwcm9jZXNzLmV4aXQoY29kZSk7XG5cdFx0fTtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBzZXR1cChvcHRpb25zOiBJSW50ZXJuYWxMb2dnZXJPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5fbWluTG9nTGV2ZWwgPSBvcHRpb25zLmNvbnNvbGVNaW5Mb2dMZXZlbDtcblx0XHR0aGlzLl9wcmVwZW5kVGltZXN0YW1wID0gb3B0aW9ucy5wcmVwZW5kVGltZXN0YW1wO1xuXG5cdFx0Ly8gT3BlbiBhIGxvZyBmaWxlIGluIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uIE92ZXJ3cml0dGVuIG9uIGVhY2ggcnVuLlxuXHRcdGlmIChvcHRpb25zLmxvZ0ZpbGVQYXRoKSB7XG5cdFx0XHRpZiAoIXBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmxvZ0ZpbGVQYXRoKSkge1xuXHRcdFx0XHR0aGlzLmxvZyhgbG9nRmlsZVBhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBwYXRoOiAke29wdGlvbnMubG9nRmlsZVBhdGh9YCwgTG9nTGV2ZWwuRXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyOiBFcnJvcikgPT4gdGhpcy5zZW5kTG9nKGBFcnJvciBjcmVhdGluZyBsb2cgZmlsZSBhdCBwYXRoOiAke29wdGlvbnMubG9nRmlsZVBhdGh9LiBFcnJvcjogJHtlcnIudG9TdHJpbmcoKX1cXG5gLCBMb2dMZXZlbC5FcnJvcik7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBmcy5wcm9taXNlcy5ta2RpcihwYXRoLmRpcm5hbWUob3B0aW9ucy5sb2dGaWxlUGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXHRcdFx0XHRcdHRoaXMubG9nKGBWZXJib3NlIGxvZ3MgYXJlIHdyaXR0ZW4gdG86XFxuYCwgTG9nTGV2ZWwuV2Fybik7XG5cdFx0XHRcdFx0dGhpcy5sb2cob3B0aW9ucy5sb2dGaWxlUGF0aCArICdcXG4nLCBMb2dMZXZlbC5XYXJuKTtcblxuXHRcdFx0XHRcdHRoaXMuX2xvZ0ZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLmxvZ0ZpbGVQYXRoKTtcblx0XHRcdFx0XHR0aGlzLmxvZ0RhdGVUaW1lKCk7XG5cdFx0XHRcdFx0dGhpcy5zZXR1cFNodXRkb3duTGlzdGVuZXJzKCk7XG5cdFx0XHRcdFx0dGhpcy5fbG9nRmlsZVN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuXHRcdFx0XHRcdFx0aGFuZGxlRXJyb3IoZXJyKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0aGFuZGxlRXJyb3IoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgbG9nRGF0ZVRpbWUoKTogdm9pZCB7XG5cdFx0bGV0IGQgPSBuZXcgRGF0ZSgpO1xuXHRcdGxldCBkYXRlU3RyaW5nID0gZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICsgYCR7ZC5nZXRVVENNb250aCgpICsgMX1gICsgJy0nICsgZC5nZXRVVENEYXRlKCk7XG5cdFx0Y29uc3QgdGltZUFuZERhdGVTdGFtcCA9IGRhdGVTdHJpbmcgKyAnLCAnICsgZ2V0Rm9ybWF0dGVkVGltZVN0cmluZygpO1xuXHRcdHRoaXMubG9nKHRpbWVBbmREYXRlU3RhbXAgKyAnXFxuJywgTG9nTGV2ZWwuVmVyYm9zZSwgZmFsc2UpO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXR1cFNodXRkb3duTGlzdGVuZXJzKCk6IHZvaWQge1xuXHRcdHByb2Nlc3Mub24oJ2JlZm9yZUV4aXQnLCB0aGlzLmJlZm9yZUV4aXRDYWxsYmFjayk7XG5cdFx0cHJvY2Vzcy5vbignU0lHVEVSTScsIHRoaXMuZGlzcG9zZUNhbGxiYWNrKTtcblx0XHRwcm9jZXNzLm9uKCdTSUdJTlQnLCB0aGlzLmRpc3Bvc2VDYWxsYmFjayk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZVNodXRkb3duTGlzdGVuZXJzKCk6IHZvaWQge1xuXHRcdHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2JlZm9yZUV4aXQnLCB0aGlzLmJlZm9yZUV4aXRDYWxsYmFjayk7XG5cdFx0cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignU0lHVEVSTScsIHRoaXMuZGlzcG9zZUNhbGxiYWNrKTtcblx0XHRwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdTSUdJTlQnLCB0aGlzLmRpc3Bvc2VDYWxsYmFjayk7XG5cdH1cblxuXHRwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHR0aGlzLnJlbW92ZVNodXRkb3duTGlzdGVuZXJzKCk7XG5cdFx0XHRpZiAodGhpcy5fbG9nRmlsZVN0cmVhbSkge1xuXHRcdFx0XHR0aGlzLl9sb2dGaWxlU3RyZWFtLmVuZChyZXNvbHZlKTtcblx0XHRcdFx0dGhpcy5fbG9nRmlsZVN0cmVhbSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgbG9nKG1zZzogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwsIHByZXBlbmRUaW1lc3RhbXAgPSB0cnVlKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuX21pbkxvZ0xldmVsID09PSBMb2dMZXZlbC5TdG9wKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGxldmVsID49IHRoaXMuX21pbkxvZ0xldmVsKSB7XG5cdFx0XHR0aGlzLnNlbmRMb2cobXNnLCBsZXZlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2xvZ1RvQ29uc29sZSkge1xuXHRcdFx0Y29uc3QgbG9nRm4gPVxuXHRcdFx0XHRsZXZlbCA9PT0gTG9nTGV2ZWwuRXJyb3IgPyBjb25zb2xlLmVycm9yIDpcblx0XHRcdFx0bGV2ZWwgPT09IExvZ0xldmVsLldhcm4gPyBjb25zb2xlLndhcm4gOlxuXHRcdFx0XHRudWxsO1xuXG5cdFx0XHRpZiAobG9nRm4pIHtcblx0XHRcdFx0bG9nRm4odHJpbUxhc3ROZXdsaW5lKG1zZykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIGFuIGVycm9yLCBwcmVwZW5kIHdpdGggJ1tFcnJvcl0nXG5cdFx0aWYgKGxldmVsID09PSBMb2dMZXZlbC5FcnJvcikge1xuXHRcdFx0bXNnID0gYFske0xvZ0xldmVsW2xldmVsXX1dICR7bXNnfWA7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3ByZXBlbmRUaW1lc3RhbXAgJiYgcHJlcGVuZFRpbWVzdGFtcCkge1xuXHRcdFx0bXNnID0gJ1snICsgZ2V0Rm9ybWF0dGVkVGltZVN0cmluZygpICsgJ10gJyArIG1zZztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbG9nRmlsZVN0cmVhbSkge1xuXHRcdFx0dGhpcy5fbG9nRmlsZVN0cmVhbS53cml0ZShtc2cpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc2VuZExvZyhtc2c6IHN0cmluZywgbGV2ZWw6IExvZ0xldmVsKTogdm9pZCB7XG5cdFx0Ly8gVHJ1bmNhdGUgbG9uZyBtZXNzYWdlcywgdGhleSBjYW4gaGFuZyBWUyBDb2RlXG5cdFx0aWYgKG1zZy5sZW5ndGggPiAxNTAwKSB7XG5cdFx0XHRjb25zdCBlbmRzSW5OZXdsaW5lID0gISFtc2cubWF0Y2goLyhcXG58XFxyXFxuKSQvKTtcblx0XHRcdG1zZyA9IG1zZy5zdWJzdHIoMCwgMTUwMCkgKyAnWy4uLl0nO1xuXHRcdFx0aWYgKGVuZHNJbk5ld2xpbmUpIHtcblx0XHRcdFx0bXNnID0gbXNnICsgJ1xcbic7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2xvZ0NhbGxiYWNrKSB7XG5cdFx0XHRjb25zdCBldmVudCA9IG5ldyBMb2dPdXRwdXRFdmVudChtc2csIGxldmVsKTtcblx0XHRcdHRoaXMuX2xvZ0NhbGxiYWNrKGV2ZW50KTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVGltZVN0cmluZygpOiBzdHJpbmcge1xuXHRsZXQgZCA9IG5ldyBEYXRlKCk7XG5cdGxldCBob3VyU3RyaW5nID0gX3BhZFplcm9lcygyLCBTdHJpbmcoZC5nZXRVVENIb3VycygpKSk7XG5cdGxldCBtaW51dGVTdHJpbmcgPSBfcGFkWmVyb2VzKDIsIFN0cmluZyhkLmdldFVUQ01pbnV0ZXMoKSkpO1xuXHRsZXQgc2Vjb25kU3RyaW5nID0gX3BhZFplcm9lcygyLCBTdHJpbmcoZC5nZXRVVENTZWNvbmRzKCkpKTtcblx0bGV0IG1pbGxpc2Vjb25kU3RyaW5nID0gX3BhZFplcm9lcygzLCBTdHJpbmcoZC5nZXRVVENNaWxsaXNlY29uZHMoKSkpO1xuXHRyZXR1cm4gaG91clN0cmluZyArICc6JyArIG1pbnV0ZVN0cmluZyArICc6JyArIHNlY29uZFN0cmluZyArICcuJyArIG1pbGxpc2Vjb25kU3RyaW5nICsgJyBVVEMnO1xufVxuXG5mdW5jdGlvbiBfcGFkWmVyb2VzKG1pbkRlc2lyZWRMZW5ndGg6IG51bWJlciwgbnVtYmVyVG9QYWQ6IHN0cmluZyk6IHN0cmluZyB7XG5cdGlmIChudW1iZXJUb1BhZC5sZW5ndGggPj0gbWluRGVzaXJlZExlbmd0aCkge1xuXHRcdHJldHVybiBudW1iZXJUb1BhZDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gU3RyaW5nKCcwJy5yZXBlYXQobWluRGVzaXJlZExlbmd0aCkgKyBudW1iZXJUb1BhZCkuc2xpY2UoLW1pbkRlc2lyZWRMZW5ndGgpO1xuXHR9XG59XG4iXX0=

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/logger.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/logger.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trimLastNewline = exports.LogOutputEvent = exports.logger = exports.Logger = exports.LogLevel = void 0;
const internalLogger_1 = __webpack_require__(/*! ./internalLogger */ "./node_modules/@vscode/debugadapter/lib/internalLogger.js");
const debugSession_1 = __webpack_require__(/*! ./debugSession */ "./node_modules/@vscode/debugadapter/lib/debugSession.js");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    LogLevel[LogLevel["Log"] = 1] = "Log";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Stop"] = 4] = "Stop";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class Logger {
    constructor() {
        this._pendingLogQ = [];
    }
    log(msg, level = LogLevel.Log) {
        msg = msg + '\n';
        this._write(msg, level);
    }
    verbose(msg) {
        this.log(msg, LogLevel.Verbose);
    }
    warn(msg) {
        this.log(msg, LogLevel.Warn);
    }
    error(msg) {
        this.log(msg, LogLevel.Error);
    }
    dispose() {
        if (this._currentLogger) {
            const disposeP = this._currentLogger.dispose();
            this._currentLogger = null;
            return disposeP;
        }
        else {
            return Promise.resolve();
        }
    }
    /**
     * `log` adds a newline, `write` doesn't
     */
    _write(msg, level = LogLevel.Log) {
        // [null, undefined] => string
        msg = msg + '';
        if (this._pendingLogQ) {
            this._pendingLogQ.push({ msg, level });
        }
        else if (this._currentLogger) {
            this._currentLogger.log(msg, level);
        }
    }
    /**
     * Set the logger's minimum level to log in the console, and whether to log to the file. Log messages are queued before this is
     * called the first time, because minLogLevel defaults to Warn.
     */
    setup(consoleMinLogLevel, _logFilePath, prependTimestamp = true) {
        const logFilePath = typeof _logFilePath === 'string' ?
            _logFilePath :
            (_logFilePath && this._logFilePathFromInit);
        if (this._currentLogger) {
            const options = {
                consoleMinLogLevel,
                logFilePath,
                prependTimestamp
            };
            this._currentLogger.setup(options).then(() => {
                // Now that we have a minimum logLevel, we can clear out the queue of pending messages
                if (this._pendingLogQ) {
                    const logQ = this._pendingLogQ;
                    this._pendingLogQ = null;
                    logQ.forEach(item => this._write(item.msg, item.level));
                }
            });
        }
    }
    init(logCallback, logFilePath, logToConsole) {
        // Re-init, create new global Logger
        this._pendingLogQ = this._pendingLogQ || [];
        this._currentLogger = new internalLogger_1.InternalLogger(logCallback, logToConsole);
        this._logFilePathFromInit = logFilePath;
    }
}
exports.Logger = Logger;
exports.logger = new Logger();
class LogOutputEvent extends debugSession_1.OutputEvent {
    constructor(msg, level) {
        const category = level === LogLevel.Error ? 'stderr' :
            level === LogLevel.Warn ? 'console' :
                'stdout';
        super(msg, category);
    }
}
exports.LogOutputEvent = LogOutputEvent;
function trimLastNewline(str) {
    return str.replace(/(\n|\r\n)$/, '');
}
exports.trimLastNewline = trimLastNewline;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2xvZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OzREQUU0RDs7O0FBRTVELHFEQUFrRDtBQUNsRCxpREFBNkM7QUFFN0MsSUFBWSxRQU1YO0FBTkQsV0FBWSxRQUFRO0lBQ25CLDZDQUFXLENBQUE7SUFDWCxxQ0FBTyxDQUFBO0lBQ1AsdUNBQVEsQ0FBQTtJQUNSLHlDQUFTLENBQUE7SUFDVCx1Q0FBUSxDQUFBO0FBQ1QsQ0FBQyxFQU5XLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBTW5CO0FBNEJELE1BQWEsTUFBTTtJQUFuQjtRQUlTLGlCQUFZLEdBQWUsRUFBRSxDQUFDO0lBMkV2QyxDQUFDO0lBekVBLEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFHO1FBQ3BDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxPQUFPLENBQUMsR0FBVztRQUNsQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVELElBQUksQ0FBQyxHQUFXO1FBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxLQUFLLENBQUMsR0FBVztRQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELE9BQU87UUFDTixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDeEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMvQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztZQUMzQixPQUFPLFFBQVEsQ0FBQztTQUNoQjthQUFNO1lBQ04sT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDekI7SUFDRixDQUFDO0lBRUQ7O09BRUc7SUFDSyxNQUFNLENBQUMsR0FBVyxFQUFFLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRztRQUMvQyw4QkFBOEI7UUFDOUIsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUN2QzthQUFNLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUMvQixJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDcEM7SUFDRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGtCQUE0QixFQUFFLFlBQTZCLEVBQUUsbUJBQTRCLElBQUk7UUFDbEcsTUFBTSxXQUFXLEdBQUcsT0FBTyxZQUFZLEtBQUssUUFBUSxDQUFDLENBQUM7WUFDckQsWUFBWSxDQUFDLENBQUM7WUFDZCxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUU3QyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDeEIsTUFBTSxPQUFPLEdBQUc7Z0JBQ2Ysa0JBQWtCO2dCQUNsQixXQUFXO2dCQUNYLGdCQUFnQjthQUNoQixDQUFDO1lBQ0YsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDNUMsc0ZBQXNGO2dCQUN0RixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7b0JBQ3RCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7b0JBQy9CLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO29CQUN6QixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUN4RDtZQUNGLENBQUMsQ0FBQyxDQUFDO1NBRUg7SUFDRixDQUFDO0lBRUQsSUFBSSxDQUFDLFdBQXlCLEVBQUUsV0FBb0IsRUFBRSxZQUFzQjtRQUMzRSxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQztRQUM1QyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLG9CQUFvQixHQUFHLFdBQVcsQ0FBQztJQUN6QyxDQUFDO0NBQ0Q7QUEvRUQsd0JBK0VDO0FBRVksUUFBQSxNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQztBQUVuQyxNQUFhLGNBQWUsU0FBUSwwQkFBVztJQUM5QyxZQUFZLEdBQVcsRUFBRSxLQUFlO1FBQ3ZDLE1BQU0sUUFBUSxHQUNiLEtBQUssS0FBSyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNyQyxLQUFLLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3JDLFFBQVEsQ0FBQztRQUNWLEtBQUssQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEIsQ0FBQztDQUNEO0FBUkQsd0NBUUM7QUFFRCxTQUFnQixlQUFlLENBQUMsR0FBVztJQUMxQyxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFGRCwwQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKEMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBJbnRlcm5hbExvZ2dlciB9IGZyb20gJy4vaW50ZXJuYWxMb2dnZXInO1xuaW1wb3J0IHsgT3V0cHV0RXZlbnQgfSBmcm9tICcuL2RlYnVnU2Vzc2lvbic7XG5cbmV4cG9ydCBlbnVtIExvZ0xldmVsIHtcblx0VmVyYm9zZSA9IDAsXG5cdExvZyA9IDEsXG5cdFdhcm4gPSAyLFxuXHRFcnJvciA9IDMsXG5cdFN0b3AgPSA0XG59XG5cbmV4cG9ydCB0eXBlIElMb2dDYWxsYmFjayA9IChvdXRwdXRFdmVudDogT3V0cHV0RXZlbnQpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBJTG9nSXRlbSB7XG5cdG1zZzogc3RyaW5nO1xuXHRsZXZlbDogTG9nTGV2ZWw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUxvZ2dlciB7XG5cdGxvZyhtc2c6IHN0cmluZywgbGV2ZWw/OiBMb2dMZXZlbCk6IHZvaWQ7XG5cdHZlcmJvc2UobXNnOiBzdHJpbmcpOiB2b2lkO1xuXHR3YXJuKG1zZzogc3RyaW5nKTogdm9pZDtcblx0ZXJyb3IobXNnOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcm5hbExvZ2dlciB7XG5cdGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPjtcblx0bG9nKG1zZzogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwsIHByZXBlbmRUaW1lc3RhbXA/OiBib29sZWFuKSA6IHZvaWQ7XG5cdHNldHVwKG9wdGlvbnM6IElJbnRlcm5hbExvZ2dlck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcm5hbExvZ2dlck9wdGlvbnMge1xuXHRjb25zb2xlTWluTG9nTGV2ZWw6IExvZ0xldmVsO1xuXHRsb2dGaWxlUGF0aD86IHN0cmluZztcblx0cHJlcGVuZFRpbWVzdGFtcD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuXHRwcml2YXRlIF9sb2dGaWxlUGF0aEZyb21Jbml0OiBzdHJpbmc7XG5cblx0cHJpdmF0ZSBfY3VycmVudExvZ2dlcjogSUludGVybmFsTG9nZ2VyO1xuXHRwcml2YXRlIF9wZW5kaW5nTG9nUTogSUxvZ0l0ZW1bXSA9IFtdO1xuXG5cdGxvZyhtc2c6IHN0cmluZywgbGV2ZWwgPSBMb2dMZXZlbC5Mb2cpOiB2b2lkIHtcblx0XHRtc2cgPSBtc2cgKyAnXFxuJztcblx0XHR0aGlzLl93cml0ZShtc2csIGxldmVsKTtcblx0fVxuXG5cdHZlcmJvc2UobXNnOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmxvZyhtc2csIExvZ0xldmVsLlZlcmJvc2UpO1xuXHR9XG5cblx0d2Fybihtc2c6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubG9nKG1zZywgTG9nTGV2ZWwuV2Fybik7XG5cdH1cblxuXHRlcnJvcihtc2c6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubG9nKG1zZywgTG9nTGV2ZWwuRXJyb3IpO1xuXHR9XG5cblx0ZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAodGhpcy5fY3VycmVudExvZ2dlcikge1xuXHRcdFx0Y29uc3QgZGlzcG9zZVAgPSB0aGlzLl9jdXJyZW50TG9nZ2VyLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRMb2dnZXIgPSBudWxsO1xuXHRcdFx0cmV0dXJuIGRpc3Bvc2VQO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIGBsb2dgIGFkZHMgYSBuZXdsaW5lLCBgd3JpdGVgIGRvZXNuJ3Rcblx0ICovXG5cdHByaXZhdGUgX3dyaXRlKG1zZzogc3RyaW5nLCBsZXZlbCA9IExvZ0xldmVsLkxvZyk6IHZvaWQge1xuXHRcdC8vIFtudWxsLCB1bmRlZmluZWRdID0+IHN0cmluZ1xuXHRcdG1zZyA9IG1zZyArICcnO1xuXHRcdGlmICh0aGlzLl9wZW5kaW5nTG9nUSkge1xuXHRcdFx0dGhpcy5fcGVuZGluZ0xvZ1EucHVzaCh7IG1zZywgbGV2ZWwgfSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9jdXJyZW50TG9nZ2VyKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50TG9nZ2VyLmxvZyhtc2csIGxldmVsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBsb2dnZXIncyBtaW5pbXVtIGxldmVsIHRvIGxvZyBpbiB0aGUgY29uc29sZSwgYW5kIHdoZXRoZXIgdG8gbG9nIHRvIHRoZSBmaWxlLiBMb2cgbWVzc2FnZXMgYXJlIHF1ZXVlZCBiZWZvcmUgdGhpcyBpc1xuXHQgKiBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIGJlY2F1c2UgbWluTG9nTGV2ZWwgZGVmYXVsdHMgdG8gV2Fybi5cblx0ICovXG5cdHNldHVwKGNvbnNvbGVNaW5Mb2dMZXZlbDogTG9nTGV2ZWwsIF9sb2dGaWxlUGF0aD86IHN0cmluZ3xib29sZWFuLCBwcmVwZW5kVGltZXN0YW1wOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuXHRcdGNvbnN0IGxvZ0ZpbGVQYXRoID0gdHlwZW9mIF9sb2dGaWxlUGF0aCA9PT0gJ3N0cmluZycgP1xuXHRcdFx0X2xvZ0ZpbGVQYXRoIDpcblx0XHRcdChfbG9nRmlsZVBhdGggJiYgdGhpcy5fbG9nRmlsZVBhdGhGcm9tSW5pdCk7XG5cblx0XHRpZiAodGhpcy5fY3VycmVudExvZ2dlcikge1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IHtcblx0XHRcdFx0Y29uc29sZU1pbkxvZ0xldmVsLFxuXHRcdFx0XHRsb2dGaWxlUGF0aCxcblx0XHRcdFx0cHJlcGVuZFRpbWVzdGFtcFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuX2N1cnJlbnRMb2dnZXIuc2V0dXAob3B0aW9ucykudGhlbigoKSA9PiB7XG5cdFx0XHRcdC8vIE5vdyB0aGF0IHdlIGhhdmUgYSBtaW5pbXVtIGxvZ0xldmVsLCB3ZSBjYW4gY2xlYXIgb3V0IHRoZSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzXG5cdFx0XHRcdGlmICh0aGlzLl9wZW5kaW5nTG9nUSkge1xuXHRcdFx0XHRcdGNvbnN0IGxvZ1EgPSB0aGlzLl9wZW5kaW5nTG9nUTtcblx0XHRcdFx0XHR0aGlzLl9wZW5kaW5nTG9nUSA9IG51bGw7XG5cdFx0XHRcdFx0bG9nUS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5fd3JpdGUoaXRlbS5tc2csIGl0ZW0ubGV2ZWwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9XG5cdH1cblxuXHRpbml0KGxvZ0NhbGxiYWNrOiBJTG9nQ2FsbGJhY2ssIGxvZ0ZpbGVQYXRoPzogc3RyaW5nLCBsb2dUb0NvbnNvbGU/OiBib29sZWFuKTogdm9pZCB7XG5cdFx0Ly8gUmUtaW5pdCwgY3JlYXRlIG5ldyBnbG9iYWwgTG9nZ2VyXG5cdFx0dGhpcy5fcGVuZGluZ0xvZ1EgPSB0aGlzLl9wZW5kaW5nTG9nUSB8fCBbXTtcblx0XHR0aGlzLl9jdXJyZW50TG9nZ2VyID0gbmV3IEludGVybmFsTG9nZ2VyKGxvZ0NhbGxiYWNrLCBsb2dUb0NvbnNvbGUpO1xuXHRcdHRoaXMuX2xvZ0ZpbGVQYXRoRnJvbUluaXQgPSBsb2dGaWxlUGF0aDtcblx0fVxufVxuXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5leHBvcnQgY2xhc3MgTG9nT3V0cHV0RXZlbnQgZXh0ZW5kcyBPdXRwdXRFdmVudCB7XG5cdGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwpIHtcblx0XHRjb25zdCBjYXRlZ29yeSA9XG5cdFx0XHRsZXZlbCA9PT0gTG9nTGV2ZWwuRXJyb3IgPyAnc3RkZXJyJyA6XG5cdFx0XHRsZXZlbCA9PT0gTG9nTGV2ZWwuV2FybiA/ICdjb25zb2xlJyA6XG5cdFx0XHQnc3Rkb3V0Jztcblx0XHRzdXBlcihtc2csIGNhdGVnb3J5KTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxhc3ROZXdsaW5lKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oXFxufFxcclxcbikkLywgJycpO1xufVxuXG5cbiJdfQ==

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/loggingDebugSession.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/loggingDebugSession.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggingDebugSession = void 0;
const Logger = __webpack_require__(/*! ./logger */ "./node_modules/@vscode/debugadapter/lib/logger.js");
const logger = Logger.logger;
const debugSession_1 = __webpack_require__(/*! ./debugSession */ "./node_modules/@vscode/debugadapter/lib/debugSession.js");
class LoggingDebugSession extends debugSession_1.DebugSession {
    constructor(obsolete_logFilePath, obsolete_debuggerLinesAndColumnsStartAt1, obsolete_isServer) {
        super(obsolete_debuggerLinesAndColumnsStartAt1, obsolete_isServer);
        this.obsolete_logFilePath = obsolete_logFilePath;
        this.on('error', (event) => {
            logger.error(event.body);
        });
    }
    start(inStream, outStream) {
        super.start(inStream, outStream);
        logger.init(e => this.sendEvent(e), this.obsolete_logFilePath, this._isServer);
    }
    /**
     * Overload sendEvent to log
     */
    sendEvent(event) {
        if (!(event instanceof Logger.LogOutputEvent)) {
            // Don't create an infinite loop...
            let objectToLog = event;
            if (event instanceof debugSession_1.OutputEvent && event.body && event.body.data && event.body.data.doNotLogOutput) {
                delete event.body.data.doNotLogOutput;
                objectToLog = { ...event };
                objectToLog.body = { ...event.body, output: '<output not logged>' };
            }
            logger.verbose(`To client: ${JSON.stringify(objectToLog)}`);
        }
        super.sendEvent(event);
    }
    /**
     * Overload sendRequest to log
     */
    sendRequest(command, args, timeout, cb) {
        logger.verbose(`To client: ${JSON.stringify(command)}(${JSON.stringify(args)}), timeout: ${timeout}`);
        super.sendRequest(command, args, timeout, cb);
    }
    /**
     * Overload sendResponse to log
     */
    sendResponse(response) {
        logger.verbose(`To client: ${JSON.stringify(response)}`);
        super.sendResponse(response);
    }
    dispatchRequest(request) {
        logger.verbose(`From client: ${request.command}(${JSON.stringify(request.arguments)})`);
        super.dispatchRequest(request);
    }
}
exports.LoggingDebugSession = LoggingDebugSession;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2luZ0RlYnVnU2Vzc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9sb2dnaW5nRGVidWdTZXNzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O2dHQUdnRzs7O0FBSWhHLG1DQUFtQztBQUNuQyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQzdCLGlEQUF5RDtBQUV6RCxNQUFhLG1CQUFvQixTQUFRLDJCQUFZO0lBQ3BELFlBQTJCLG9CQUE2QixFQUFFLHdDQUFrRCxFQUFFLGlCQUEyQjtRQUN4SSxLQUFLLENBQUMsd0NBQXdDLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUR6Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQVM7UUFHdkQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUEwQixFQUFFLEVBQUU7WUFDL0MsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQStCLEVBQUUsU0FBZ0M7UUFDN0UsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDakMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQ7O09BRUc7SUFDSSxTQUFTLENBQUMsS0FBMEI7UUFDMUMsSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLE1BQU0sQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM5QyxtQ0FBbUM7WUFFbkMsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUksS0FBSyxZQUFZLDBCQUFXLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3BHLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO2dCQUN0QyxXQUFXLEdBQUcsRUFBRSxHQUFHLEtBQUssRUFBRSxDQUFDO2dCQUMzQixXQUFXLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxxQkFBcUIsRUFBRSxDQUFBO2FBQ25FO1lBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQzVEO1FBRUQsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXLENBQUMsT0FBZSxFQUFFLElBQVMsRUFBRSxPQUFlLEVBQUUsRUFBOEM7UUFDN0csTUFBTSxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3RHLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksWUFBWSxDQUFDLFFBQWdDO1FBQ25ELE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RCxLQUFLLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFUyxlQUFlLENBQUMsT0FBOEI7UUFDdkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsT0FBTyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUUsR0FBRyxDQUFDLENBQUM7UUFDekYsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoQyxDQUFDO0NBQ0Q7QUF0REQsa0RBc0RDIiwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmltcG9ydCB7RGVidWdQcm90b2NvbH0gZnJvbSAnQHZzY29kZS9kZWJ1Z3Byb3RvY29sJztcblxuaW1wb3J0ICogYXMgTG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IExvZ2dlci5sb2dnZXI7XG5pbXBvcnQge0RlYnVnU2Vzc2lvbiwgT3V0cHV0RXZlbnR9IGZyb20gJy4vZGVidWdTZXNzaW9uJztcblxuZXhwb3J0IGNsYXNzIExvZ2dpbmdEZWJ1Z1Nlc3Npb24gZXh0ZW5kcyBEZWJ1Z1Nlc3Npb24ge1xuXHRwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBvYnNvbGV0ZV9sb2dGaWxlUGF0aD86IHN0cmluZywgb2Jzb2xldGVfZGVidWdnZXJMaW5lc0FuZENvbHVtbnNTdGFydEF0MT86IGJvb2xlYW4sIG9ic29sZXRlX2lzU2VydmVyPzogYm9vbGVhbikge1xuXHRcdHN1cGVyKG9ic29sZXRlX2RlYnVnZ2VyTGluZXNBbmRDb2x1bW5zU3RhcnRBdDEsIG9ic29sZXRlX2lzU2VydmVyKTtcblxuXHRcdHRoaXMub24oJ2Vycm9yJywgKGV2ZW50OiBEZWJ1Z1Byb3RvY29sLkV2ZW50KSA9PiB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoZXZlbnQuYm9keSk7XG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhcnQoaW5TdHJlYW06IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSwgb3V0U3RyZWFtOiBOb2RlSlMuV3JpdGFibGVTdHJlYW0pOiB2b2lkIHtcblx0XHRzdXBlci5zdGFydChpblN0cmVhbSwgb3V0U3RyZWFtKTtcblx0XHRsb2dnZXIuaW5pdChlID0+IHRoaXMuc2VuZEV2ZW50KGUpLCB0aGlzLm9ic29sZXRlX2xvZ0ZpbGVQYXRoLCB0aGlzLl9pc1NlcnZlcik7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcmxvYWQgc2VuZEV2ZW50IHRvIGxvZ1xuXHQgKi9cblx0cHVibGljIHNlbmRFdmVudChldmVudDogRGVidWdQcm90b2NvbC5FdmVudCk6IHZvaWQge1xuXHRcdGlmICghKGV2ZW50IGluc3RhbmNlb2YgTG9nZ2VyLkxvZ091dHB1dEV2ZW50KSkge1xuXHRcdFx0Ly8gRG9uJ3QgY3JlYXRlIGFuIGluZmluaXRlIGxvb3AuLi5cblxuXHRcdFx0bGV0IG9iamVjdFRvTG9nID0gZXZlbnQ7XG5cdFx0XHRpZiAoZXZlbnQgaW5zdGFuY2VvZiBPdXRwdXRFdmVudCAmJiBldmVudC5ib2R5ICYmIGV2ZW50LmJvZHkuZGF0YSAmJiBldmVudC5ib2R5LmRhdGEuZG9Ob3RMb2dPdXRwdXQpIHtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50LmJvZHkuZGF0YS5kb05vdExvZ091dHB1dDtcblx0XHRcdFx0b2JqZWN0VG9Mb2cgPSB7IC4uLmV2ZW50IH07XG5cdFx0XHRcdG9iamVjdFRvTG9nLmJvZHkgPSB7IC4uLmV2ZW50LmJvZHksIG91dHB1dDogJzxvdXRwdXQgbm90IGxvZ2dlZD4nIH1cblx0XHRcdH1cblxuXHRcdFx0bG9nZ2VyLnZlcmJvc2UoYFRvIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeShvYmplY3RUb0xvZyl9YCk7XG5cdFx0fVxuXG5cdFx0c3VwZXIuc2VuZEV2ZW50KGV2ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCBzZW5kUmVxdWVzdCB0byBsb2dcblx0ICovXG5cdHB1YmxpYyBzZW5kUmVxdWVzdChjb21tYW5kOiBzdHJpbmcsIGFyZ3M6IGFueSwgdGltZW91dDogbnVtYmVyLCBjYjogKHJlc3BvbnNlOiBEZWJ1Z1Byb3RvY29sLlJlc3BvbnNlKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0bG9nZ2VyLnZlcmJvc2UoYFRvIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeShjb21tYW5kKX0oJHtKU09OLnN0cmluZ2lmeShhcmdzKX0pLCB0aW1lb3V0OiAke3RpbWVvdXR9YCk7XG5cdFx0c3VwZXIuc2VuZFJlcXVlc3QoY29tbWFuZCwgYXJncywgdGltZW91dCwgY2IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHNlbmRSZXNwb25zZSB0byBsb2dcblx0ICovXG5cdHB1YmxpYyBzZW5kUmVzcG9uc2UocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVzcG9uc2UpOiB2b2lkIHtcblx0XHRsb2dnZXIudmVyYm9zZShgVG8gY2xpZW50OiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gKTtcblx0XHRzdXBlci5zZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGRpc3BhdGNoUmVxdWVzdChyZXF1ZXN0OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0XHRsb2dnZXIudmVyYm9zZShgRnJvbSBjbGllbnQ6ICR7cmVxdWVzdC5jb21tYW5kfSgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QuYXJndW1lbnRzKSB9KWApO1xuXHRcdHN1cGVyLmRpc3BhdGNoUmVxdWVzdChyZXF1ZXN0KTtcblx0fVxufVxuIl19

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/main.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/main.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Handles = exports.Response = exports.Event = exports.ErrorDestination = exports.CompletionItem = exports.Module = exports.Source = exports.Breakpoint = exports.Variable = exports.Scope = exports.StackFrame = exports.Thread = exports.MemoryEvent = exports.InvalidatedEvent = exports.ProgressEndEvent = exports.ProgressUpdateEvent = exports.ProgressStartEvent = exports.CapabilitiesEvent = exports.LoadedSourceEvent = exports.ModuleEvent = exports.BreakpointEvent = exports.ThreadEvent = exports.OutputEvent = exports.ContinuedEvent = exports.StoppedEvent = exports.ExitedEvent = exports.TerminatedEvent = exports.InitializedEvent = exports.logger = exports.Logger = exports.LoggingDebugSession = exports.DebugSession = void 0;
const debugSession_1 = __webpack_require__(/*! ./debugSession */ "./node_modules/@vscode/debugadapter/lib/debugSession.js");
Object.defineProperty(exports, "DebugSession", ({ enumerable: true, get: function () { return debugSession_1.DebugSession; } }));
Object.defineProperty(exports, "InitializedEvent", ({ enumerable: true, get: function () { return debugSession_1.InitializedEvent; } }));
Object.defineProperty(exports, "TerminatedEvent", ({ enumerable: true, get: function () { return debugSession_1.TerminatedEvent; } }));
Object.defineProperty(exports, "ExitedEvent", ({ enumerable: true, get: function () { return debugSession_1.ExitedEvent; } }));
Object.defineProperty(exports, "StoppedEvent", ({ enumerable: true, get: function () { return debugSession_1.StoppedEvent; } }));
Object.defineProperty(exports, "ContinuedEvent", ({ enumerable: true, get: function () { return debugSession_1.ContinuedEvent; } }));
Object.defineProperty(exports, "OutputEvent", ({ enumerable: true, get: function () { return debugSession_1.OutputEvent; } }));
Object.defineProperty(exports, "ThreadEvent", ({ enumerable: true, get: function () { return debugSession_1.ThreadEvent; } }));
Object.defineProperty(exports, "BreakpointEvent", ({ enumerable: true, get: function () { return debugSession_1.BreakpointEvent; } }));
Object.defineProperty(exports, "ModuleEvent", ({ enumerable: true, get: function () { return debugSession_1.ModuleEvent; } }));
Object.defineProperty(exports, "LoadedSourceEvent", ({ enumerable: true, get: function () { return debugSession_1.LoadedSourceEvent; } }));
Object.defineProperty(exports, "CapabilitiesEvent", ({ enumerable: true, get: function () { return debugSession_1.CapabilitiesEvent; } }));
Object.defineProperty(exports, "ProgressStartEvent", ({ enumerable: true, get: function () { return debugSession_1.ProgressStartEvent; } }));
Object.defineProperty(exports, "ProgressUpdateEvent", ({ enumerable: true, get: function () { return debugSession_1.ProgressUpdateEvent; } }));
Object.defineProperty(exports, "ProgressEndEvent", ({ enumerable: true, get: function () { return debugSession_1.ProgressEndEvent; } }));
Object.defineProperty(exports, "InvalidatedEvent", ({ enumerable: true, get: function () { return debugSession_1.InvalidatedEvent; } }));
Object.defineProperty(exports, "MemoryEvent", ({ enumerable: true, get: function () { return debugSession_1.MemoryEvent; } }));
Object.defineProperty(exports, "Thread", ({ enumerable: true, get: function () { return debugSession_1.Thread; } }));
Object.defineProperty(exports, "StackFrame", ({ enumerable: true, get: function () { return debugSession_1.StackFrame; } }));
Object.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return debugSession_1.Scope; } }));
Object.defineProperty(exports, "Variable", ({ enumerable: true, get: function () { return debugSession_1.Variable; } }));
Object.defineProperty(exports, "Breakpoint", ({ enumerable: true, get: function () { return debugSession_1.Breakpoint; } }));
Object.defineProperty(exports, "Source", ({ enumerable: true, get: function () { return debugSession_1.Source; } }));
Object.defineProperty(exports, "Module", ({ enumerable: true, get: function () { return debugSession_1.Module; } }));
Object.defineProperty(exports, "CompletionItem", ({ enumerable: true, get: function () { return debugSession_1.CompletionItem; } }));
Object.defineProperty(exports, "ErrorDestination", ({ enumerable: true, get: function () { return debugSession_1.ErrorDestination; } }));
const loggingDebugSession_1 = __webpack_require__(/*! ./loggingDebugSession */ "./node_modules/@vscode/debugadapter/lib/loggingDebugSession.js");
Object.defineProperty(exports, "LoggingDebugSession", ({ enumerable: true, get: function () { return loggingDebugSession_1.LoggingDebugSession; } }));
const Logger = __webpack_require__(/*! ./logger */ "./node_modules/@vscode/debugadapter/lib/logger.js");
exports.Logger = Logger;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@vscode/debugadapter/lib/messages.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return messages_1.Event; } }));
Object.defineProperty(exports, "Response", ({ enumerable: true, get: function () { return messages_1.Response; } }));
const handles_1 = __webpack_require__(/*! ./handles */ "./node_modules/@vscode/debugadapter/lib/handles.js");
Object.defineProperty(exports, "Handles", ({ enumerable: true, get: function () { return handles_1.Handles; } }));
const logger = Logger.logger;
exports.logger = logger;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Z0dBR2dHO0FBQ2hHLFlBQVksQ0FBQzs7O0FBRWIsaURBT3dCO0FBU3ZCLDZGQWZBLDJCQUFZLE9BZUE7QUFJWixpR0FsQkEsK0JBQWdCLE9Ba0JBO0FBQUUsZ0dBbEJBLDhCQUFlLE9Ba0JBO0FBQUUsNEZBbEJBLDBCQUFXLE9Ba0JBO0FBQUUsNkZBbEJBLDJCQUFZLE9Ba0JBO0FBQUUsK0ZBbEJBLDZCQUFjLE9Ba0JBO0FBQUUsNEZBbEJBLDBCQUFXLE9Ba0JBO0FBQUUsNEZBbEJBLDBCQUFXLE9Ba0JBO0FBQUUsZ0dBbEJBLDhCQUFlLE9Ba0JBO0FBQUUsNEZBbEJBLDBCQUFXLE9Ba0JBO0FBQ25JLGtHQWxCQSxnQ0FBaUIsT0FrQkE7QUFBRSxrR0FsQkEsZ0NBQWlCLE9Ba0JBO0FBQUUsbUdBbEJBLGlDQUFrQixPQWtCQTtBQUFFLG9HQWxCQSxrQ0FBbUIsT0FrQkE7QUFBRSxpR0FsQkEsK0JBQWdCLE9Ba0JBO0FBQUUsaUdBbEJBLCtCQUFnQixPQWtCQTtBQUFFLDRGQWxCQSwwQkFBVyxPQWtCQTtBQUMvSCx1RkFsQkEscUJBQU0sT0FrQkE7QUFBRSwyRkFsQkEseUJBQVUsT0FrQkE7QUFBRSxzRkFsQkEsb0JBQUssT0FrQkE7QUFBRSx5RkFsQkEsdUJBQVEsT0FrQkE7QUFDbkMsMkZBbEJBLHlCQUFVLE9Ba0JBO0FBQUUsdUZBbEJBLHFCQUFNLE9Ba0JBO0FBQUUsdUZBbEJBLHFCQUFNLE9Ba0JBO0FBQUUsK0ZBbEJBLDZCQUFjLE9Ba0JBO0FBQzFDLGlHQWxCQSwrQkFBZ0IsT0FrQkE7QUFoQmpCLCtEQUEwRDtBQVN6RCxvR0FUTyx5Q0FBbUIsT0FTUDtBQVJwQixtQ0FBbUM7QUFTbEMsd0JBQU07QUFSUCx5Q0FBNkM7QUFlNUMsc0ZBZlEsZ0JBQUssT0FlUjtBQUFFLHlGQWZRLG1CQUFRLE9BZVI7QUFkaEIsdUNBQW9DO0FBZW5DLHdGQWZRLGlCQUFPLE9BZVI7QUFiUixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBTTVCLHdCQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHREZWJ1Z1Nlc3Npb24sXG5cdEluaXRpYWxpemVkRXZlbnQsIFRlcm1pbmF0ZWRFdmVudCwgRXhpdGVkRXZlbnQsIFN0b3BwZWRFdmVudCwgQ29udGludWVkRXZlbnQsIE91dHB1dEV2ZW50LCBUaHJlYWRFdmVudCwgQnJlYWtwb2ludEV2ZW50LCBNb2R1bGVFdmVudCxcblx0XHRMb2FkZWRTb3VyY2VFdmVudCwgQ2FwYWJpbGl0aWVzRXZlbnQsIFByb2dyZXNzU3RhcnRFdmVudCwgUHJvZ3Jlc3NVcGRhdGVFdmVudCwgUHJvZ3Jlc3NFbmRFdmVudCwgSW52YWxpZGF0ZWRFdmVudCwgTWVtb3J5RXZlbnQsXG5cdFRocmVhZCwgU3RhY2tGcmFtZSwgU2NvcGUsIFZhcmlhYmxlLFxuXHRCcmVha3BvaW50LCBTb3VyY2UsIE1vZHVsZSwgQ29tcGxldGlvbkl0ZW0sXG5cdEVycm9yRGVzdGluYXRpb25cbn0gZnJvbSAnLi9kZWJ1Z1Nlc3Npb24nO1xuaW1wb3J0IHtMb2dnaW5nRGVidWdTZXNzaW9ufSBmcm9tICcuL2xvZ2dpbmdEZWJ1Z1Nlc3Npb24nO1xuaW1wb3J0ICogYXMgTG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IEV2ZW50LCBSZXNwb25zZSB9IGZyb20gJy4vbWVzc2FnZXMnO1xuaW1wb3J0IHsgSGFuZGxlcyB9IGZyb20gJy4vaGFuZGxlcyc7XG5cbmNvbnN0IGxvZ2dlciA9IExvZ2dlci5sb2dnZXI7XG5cbmV4cG9ydCB7XG5cdERlYnVnU2Vzc2lvbixcblx0TG9nZ2luZ0RlYnVnU2Vzc2lvbixcblx0TG9nZ2VyLFxuXHRsb2dnZXIsXG5cdEluaXRpYWxpemVkRXZlbnQsIFRlcm1pbmF0ZWRFdmVudCwgRXhpdGVkRXZlbnQsIFN0b3BwZWRFdmVudCwgQ29udGludWVkRXZlbnQsIE91dHB1dEV2ZW50LCBUaHJlYWRFdmVudCwgQnJlYWtwb2ludEV2ZW50LCBNb2R1bGVFdmVudCxcblx0XHRMb2FkZWRTb3VyY2VFdmVudCwgQ2FwYWJpbGl0aWVzRXZlbnQsIFByb2dyZXNzU3RhcnRFdmVudCwgUHJvZ3Jlc3NVcGRhdGVFdmVudCwgUHJvZ3Jlc3NFbmRFdmVudCwgSW52YWxpZGF0ZWRFdmVudCwgTWVtb3J5RXZlbnQsXG5cdFRocmVhZCwgU3RhY2tGcmFtZSwgU2NvcGUsIFZhcmlhYmxlLFxuXHRCcmVha3BvaW50LCBTb3VyY2UsIE1vZHVsZSwgQ29tcGxldGlvbkl0ZW0sXG5cdEVycm9yRGVzdGluYXRpb24sXG5cdEV2ZW50LCBSZXNwb25zZSxcblx0SGFuZGxlc1xufVxuIl19

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/messages.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/messages.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = exports.Response = exports.Message = void 0;
class Message {
    constructor(type) {
        this.seq = 0;
        this.type = type;
    }
}
exports.Message = Message;
class Response extends Message {
    constructor(request, message) {
        super('response');
        this.request_seq = request.seq;
        this.command = request.command;
        if (message) {
            this.success = false;
            this.message = message;
        }
        else {
            this.success = true;
        }
    }
}
exports.Response = Response;
class Event extends Message {
    constructor(event, body) {
        super('event');
        this.event = event;
        if (body) {
            this.body = body;
        }
    }
}
exports.Event = Event;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWVzc2FnZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Z0dBR2dHOzs7QUFLaEcsTUFBYSxPQUFPO0lBSW5CLFlBQW1CLElBQVk7UUFDOUIsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDYixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNsQixDQUFDO0NBQ0Q7QUFSRCwwQkFRQztBQUVELE1BQWEsUUFBUyxTQUFRLE9BQU87SUFLcEMsWUFBbUIsT0FBOEIsRUFBRSxPQUFnQjtRQUNsRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQy9CLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLE9BQU8sRUFBRTtZQUNaLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ2YsSUFBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7U0FDOUI7YUFBTTtZQUNOLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3BCO0lBQ0YsQ0FBQztDQUNEO0FBaEJELDRCQWdCQztBQUVELE1BQWEsS0FBTSxTQUFRLE9BQU87SUFHakMsWUFBbUIsS0FBYSxFQUFFLElBQVU7UUFDM0MsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxJQUFJLEVBQUU7WUFDSCxJQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUN4QjtJQUNGLENBQUM7Q0FDRDtBQVZELHNCQVVDIiwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmltcG9ydCB7IERlYnVnUHJvdG9jb2wgfSBmcm9tICdAdnNjb2RlL2RlYnVncHJvdG9jb2wnO1xuXG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlIGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5Qcm90b2NvbE1lc3NhZ2Uge1xuXHRzZXE6IG51bWJlcjtcblx0dHlwZTogc3RyaW5nO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcpIHtcblx0XHR0aGlzLnNlcSA9IDA7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIGltcGxlbWVudHMgRGVidWdQcm90b2NvbC5SZXNwb25zZSB7XG5cdHJlcXVlc3Rfc2VxOiBudW1iZXI7XG5cdHN1Y2Nlc3M6IGJvb2xlYW47XG5cdGNvbW1hbmQ6IHN0cmluZztcblxuXHRwdWJsaWMgY29uc3RydWN0b3IocmVxdWVzdDogRGVidWdQcm90b2NvbC5SZXF1ZXN0LCBtZXNzYWdlPzogc3RyaW5nKSB7XG5cdFx0c3VwZXIoJ3Jlc3BvbnNlJyk7XG5cdFx0dGhpcy5yZXF1ZXN0X3NlcSA9IHJlcXVlc3Quc2VxO1xuXHRcdHRoaXMuY29tbWFuZCA9IHJlcXVlc3QuY29tbWFuZDtcblx0XHRpZiAobWVzc2FnZSkge1xuXHRcdFx0dGhpcy5zdWNjZXNzID0gZmFsc2U7XG5cdFx0XHQoPGFueT50aGlzKS5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zdWNjZXNzID0gdHJ1ZTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50IGV4dGVuZHMgTWVzc2FnZSBpbXBsZW1lbnRzIERlYnVnUHJvdG9jb2wuRXZlbnQge1xuXHRldmVudDogc3RyaW5nO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihldmVudDogc3RyaW5nLCBib2R5PzogYW55KSB7XG5cdFx0c3VwZXIoJ2V2ZW50Jyk7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdGlmIChib2R5KSB7XG5cdFx0XHQoPGFueT50aGlzKS5ib2R5ID0gYm9keTtcblx0XHR9XG5cdH1cbn1cbiJdfQ==

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/protocol.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/protocol.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolServer = void 0;
const ee = __webpack_require__(/*! events */ "events");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@vscode/debugadapter/lib/messages.js");
class Disposable0 {
    dispose() {
    }
}
class Emitter {
    get event() {
        if (!this._event) {
            this._event = (listener, thisArg) => {
                this._listener = listener;
                this._this = thisArg;
                let result;
                result = {
                    dispose: () => {
                        this._listener = undefined;
                        this._this = undefined;
                    }
                };
                return result;
            };
        }
        return this._event;
    }
    fire(event) {
        if (this._listener) {
            try {
                this._listener.call(this._this, event);
            }
            catch (e) {
            }
        }
    }
    hasListener() {
        return !!this._listener;
    }
    dispose() {
        this._listener = undefined;
        this._this = undefined;
    }
}
class ProtocolServer extends ee.EventEmitter {
    constructor() {
        super();
        this._sendMessage = new Emitter();
        this._sequence = 1;
        this._pendingRequests = new Map();
        this.onDidSendMessage = this._sendMessage.event;
    }
    // ---- implements vscode.Debugadapter interface ---------------------------
    dispose() {
    }
    handleMessage(msg) {
        if (msg.type === 'request') {
            this.dispatchRequest(msg);
        }
        else if (msg.type === 'response') {
            const response = msg;
            const clb = this._pendingRequests.get(response.request_seq);
            if (clb) {
                this._pendingRequests.delete(response.request_seq);
                clb(response);
            }
        }
    }
    _isRunningInline() {
        return this._sendMessage && this._sendMessage.hasListener();
    }
    //--------------------------------------------------------------------------
    start(inStream, outStream) {
        this._writableStream = outStream;
        this._rawData = Buffer.alloc(0);
        inStream.on('data', (data) => this._handleData(data));
        inStream.on('close', () => {
            this._emitEvent(new messages_1.Event('close'));
        });
        inStream.on('error', (error) => {
            this._emitEvent(new messages_1.Event('error', 'inStream error: ' + (error && error.message)));
        });
        outStream.on('error', (error) => {
            this._emitEvent(new messages_1.Event('error', 'outStream error: ' + (error && error.message)));
        });
        inStream.resume();
    }
    stop() {
        if (this._writableStream) {
            this._writableStream.end();
        }
    }
    sendEvent(event) {
        this._send('event', event);
    }
    sendResponse(response) {
        if (response.seq > 0) {
            console.error(`attempt to send more than one response for command ${response.command}`);
        }
        else {
            this._send('response', response);
        }
    }
    sendRequest(command, args, timeout, cb) {
        const request = {
            command: command
        };
        if (args && Object.keys(args).length > 0) {
            request.arguments = args;
        }
        this._send('request', request);
        if (cb) {
            this._pendingRequests.set(request.seq, cb);
            const timer = setTimeout(() => {
                clearTimeout(timer);
                const clb = this._pendingRequests.get(request.seq);
                if (clb) {
                    this._pendingRequests.delete(request.seq);
                    clb(new messages_1.Response(request, 'timeout'));
                }
            }, timeout);
        }
    }
    // ---- protected ----------------------------------------------------------
    dispatchRequest(request) {
    }
    // ---- private ------------------------------------------------------------
    _emitEvent(event) {
        this.emit(event.event, event);
    }
    _send(typ, message) {
        message.type = typ;
        message.seq = this._sequence++;
        if (this._writableStream) {
            const json = JSON.stringify(message);
            this._writableStream.write(`Content-Length: ${Buffer.byteLength(json, 'utf8')}\r\n\r\n${json}`, 'utf8');
        }
        this._sendMessage.fire(message);
    }
    _handleData(data) {
        this._rawData = Buffer.concat([this._rawData, data]);
        while (true) {
            if (this._contentLength >= 0) {
                if (this._rawData.length >= this._contentLength) {
                    const message = this._rawData.toString('utf8', 0, this._contentLength);
                    this._rawData = this._rawData.slice(this._contentLength);
                    this._contentLength = -1;
                    if (message.length > 0) {
                        try {
                            let msg = JSON.parse(message);
                            this.handleMessage(msg);
                        }
                        catch (e) {
                            this._emitEvent(new messages_1.Event('error', 'Error handling data: ' + (e && e.message)));
                        }
                    }
                    continue; // there may be more complete messages to process
                }
            }
            else {
                const idx = this._rawData.indexOf(ProtocolServer.TWO_CRLF);
                if (idx !== -1) {
                    const header = this._rawData.toString('utf8', 0, idx);
                    const lines = header.split('\r\n');
                    for (let i = 0; i < lines.length; i++) {
                        const pair = lines[i].split(/: +/);
                        if (pair[0] == 'Content-Length') {
                            this._contentLength = +pair[1];
                        }
                    }
                    this._rawData = this._rawData.slice(idx + ProtocolServer.TWO_CRLF.length);
                    continue;
                }
            }
            break;
        }
    }
}
exports.ProtocolServer = ProtocolServer;
ProtocolServer.TWO_CRLF = '\r\n\r\n';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdG9jb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcHJvdG9jb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Z0dBR2dHOzs7QUFFaEcsNkJBQTZCO0FBRTdCLHlDQUE2QztBQVM3QyxNQUFNLFdBQVc7SUFDaEIsT0FBTztJQUNQLENBQUM7Q0FDRDtBQU1ELE1BQU0sT0FBTztJQU1aLElBQUksS0FBSztRQUNSLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxRQUF1QixFQUFFLE9BQWEsRUFBRSxFQUFFO2dCQUV4RCxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztnQkFDMUIsSUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUM7Z0JBRXJCLElBQUksTUFBbUIsQ0FBQztnQkFDeEIsTUFBTSxHQUFHO29CQUNSLE9BQU8sRUFBRSxHQUFHLEVBQUU7d0JBQ2IsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7d0JBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO29CQUN4QixDQUFDO2lCQUNELENBQUM7Z0JBQ0YsT0FBTyxNQUFNLENBQUM7WUFDZixDQUFDLENBQUM7U0FDRjtRQUNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQVE7UUFDWixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsSUFBSTtnQkFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3ZDO1lBQUMsT0FBTyxDQUFDLEVBQUU7YUFDWDtTQUNEO0lBQ0YsQ0FBQztJQUVELFdBQVc7UUFDVixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxPQUFPO1FBQ04sSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDeEIsQ0FBQztDQUNEO0FBWUQsTUFBYSxjQUFlLFNBQVEsRUFBRSxDQUFDLFlBQVk7SUFZbEQ7UUFDQyxLQUFLLEVBQUUsQ0FBQztRQVRELGlCQUFZLEdBQUcsSUFBSSxPQUFPLEVBQXdCLENBQUM7UUFJbkQsY0FBUyxHQUFXLENBQUMsQ0FBQztRQUV0QixxQkFBZ0IsR0FBRyxJQUFJLEdBQUcsRUFBc0QsQ0FBQztRQVdsRixxQkFBZ0IsR0FBaUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7SUFQaEYsQ0FBQztJQUVELDRFQUE0RTtJQUVyRSxPQUFPO0lBQ2QsQ0FBQztJQUlNLGFBQWEsQ0FBQyxHQUFrQztRQUN0RCxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQzNCLElBQUksQ0FBQyxlQUFlLENBQXdCLEdBQUcsQ0FBQyxDQUFDO1NBQ2pEO2FBQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUNuQyxNQUFNLFFBQVEsR0FBMkIsR0FBRyxDQUFDO1lBQzdDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzVELElBQUksR0FBRyxFQUFFO2dCQUNSLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNuRCxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDZDtTQUNEO0lBQ0YsQ0FBQztJQUVTLGdCQUFnQjtRQUN6QixPQUFPLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3RCxDQUFDO0lBRUQsNEVBQTRFO0lBRXJFLEtBQUssQ0FBQyxRQUErQixFQUFFLFNBQWdDO1FBQzdFLElBQUksQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVoQyxRQUFRLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRTlELFFBQVEsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtZQUN6QixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksZ0JBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBQ0gsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM5QixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksZ0JBQUssQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLEdBQUcsQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRixDQUFDLENBQUMsQ0FBQztRQUVILFNBQVMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLGdCQUFLLENBQUMsT0FBTyxFQUFFLG1CQUFtQixHQUFHLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckYsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVNLElBQUk7UUFDVixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDekIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUMzQjtJQUNGLENBQUM7SUFFTSxTQUFTLENBQUMsS0FBMEI7UUFDMUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVNLFlBQVksQ0FBQyxRQUFnQztRQUNuRCxJQUFJLFFBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sQ0FBQyxLQUFLLENBQUMsc0RBQXNELFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQ3hGO2FBQU07WUFDTixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNqQztJQUNGLENBQUM7SUFFTSxXQUFXLENBQUMsT0FBZSxFQUFFLElBQVMsRUFBRSxPQUFlLEVBQUUsRUFBOEM7UUFFN0csTUFBTSxPQUFPLEdBQVE7WUFDcEIsT0FBTyxFQUFFLE9BQU87U0FDaEIsQ0FBQztRQUNGLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN6QyxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN6QjtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRS9CLElBQUksRUFBRSxFQUFFO1lBQ1AsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRTNDLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQzdCLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDcEIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ25ELElBQUksR0FBRyxFQUFFO29CQUNSLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUMxQyxHQUFHLENBQUMsSUFBSSxtQkFBUSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO2lCQUN0QztZQUNGLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0YsQ0FBQztJQUVELDRFQUE0RTtJQUVsRSxlQUFlLENBQUMsT0FBOEI7SUFDeEQsQ0FBQztJQUVELDRFQUE0RTtJQUVwRSxVQUFVLENBQUMsS0FBMEI7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFTyxLQUFLLENBQUMsR0FBcUMsRUFBRSxPQUFzQztRQUUxRixPQUFPLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUNuQixPQUFPLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUUvQixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDekIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLFdBQVcsSUFBSSxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDeEc7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRU8sV0FBVyxDQUFDLElBQVk7UUFFL0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXJELE9BQU8sSUFBSSxFQUFFO1lBQ1osSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUNoRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDdkUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQ3pELElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3pCLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQ3ZCLElBQUk7NEJBQ0gsSUFBSSxHQUFHLEdBQWtDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7NEJBQzdELElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7eUJBQ3hCO3dCQUNELE9BQU8sQ0FBQyxFQUFFOzRCQUNULElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxnQkFBSyxDQUFDLE9BQU8sRUFBRSx1QkFBdUIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO3lCQUNoRjtxQkFDRDtvQkFDRCxTQUFTLENBQUMsaURBQWlEO2lCQUMzRDthQUNEO2lCQUFNO2dCQUNOLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDM0QsSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQ2YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDdEQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDbkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7d0JBQ3RDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ25DLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixFQUFFOzRCQUNoQyxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3lCQUMvQjtxQkFDRDtvQkFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUMxRSxTQUFTO2lCQUNUO2FBQ0Q7WUFDRCxNQUFNO1NBQ047SUFDRixDQUFDOztBQXRLRix3Q0F1S0M7QUFyS2UsdUJBQVEsR0FBRyxVQUFVLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuaW1wb3J0ICogYXMgZWUgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IERlYnVnUHJvdG9jb2wgfSBmcm9tICdAdnNjb2RlL2RlYnVncHJvdG9jb2wnO1xuaW1wb3J0IHsgUmVzcG9uc2UsIEV2ZW50IH0gZnJvbSAnLi9tZXNzYWdlcyc7XG5cbmludGVyZmFjZSBEZWJ1Z1Byb3RvY29sTWVzc2FnZSB7XG59XG5cbmludGVyZmFjZSBJRGlzcG9zYWJsZSB7XG5cdGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuY2xhc3MgRGlzcG9zYWJsZTAgaW1wbGVtZW50cyBJRGlzcG9zYWJsZSB7XG5cdGRpc3Bvc2UoKTogYW55IHtcblx0fVxufVxuXG5pbnRlcmZhY2UgRXZlbnQwPFQ+IHtcblx0KGxpc3RlbmVyOiAoZTogVCkgPT4gYW55LCB0aGlzQXJnPzogYW55KTogRGlzcG9zYWJsZTA7XG59XG5cbmNsYXNzIEVtaXR0ZXI8VD4ge1xuXG5cdHByaXZhdGUgX2V2ZW50PzogRXZlbnQwPFQ+O1xuXHRwcml2YXRlIF9saXN0ZW5lcj86IChlOiBUKSA9PiB2b2lkO1xuXHRwcml2YXRlIF90aGlzPzogYW55O1xuXG5cdGdldCBldmVudCgpOiBFdmVudDA8VD4ge1xuXHRcdGlmICghdGhpcy5fZXZlbnQpIHtcblx0XHRcdHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyOiAoZTogVCkgPT4gYW55LCB0aGlzQXJnPzogYW55KSA9PiB7XG5cblx0XHRcdFx0dGhpcy5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcblx0XHRcdFx0dGhpcy5fdGhpcyA9IHRoaXNBcmc7XG5cblx0XHRcdFx0bGV0IHJlc3VsdDogSURpc3Bvc2FibGU7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHRkaXNwb3NlOiAoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHRoaXMuX3RoaXMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2V2ZW50O1xuXHR9XG5cblx0ZmlyZShldmVudDogVCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLl9saXN0ZW5lcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXIuY2FsbCh0aGlzLl90aGlzLCBldmVudCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aGFzTGlzdGVuZXIoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiAhIXRoaXMuX2xpc3RlbmVyO1xuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLl9saXN0ZW5lciA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLl90aGlzID0gdW5kZWZpbmVkO1xuXHR9XG59XG5cbi8qKlxuICogQSBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCBjb3B5IG9mIHZzY29kZS5EZWJ1Z0FkYXB0ZXJcbiAqL1xuaW50ZXJmYWNlIFZTQ29kZURlYnVnQWRhcHRlciBleHRlbmRzIERpc3Bvc2FibGUwIHtcblxuXHRyZWFkb25seSBvbkRpZFNlbmRNZXNzYWdlOiBFdmVudDA8RGVidWdQcm90b2NvbE1lc3NhZ2U+O1xuXG5cdGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogRGVidWdQcm90b2NvbC5Qcm90b2NvbE1lc3NhZ2UpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgUHJvdG9jb2xTZXJ2ZXIgZXh0ZW5kcyBlZS5FdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBWU0NvZGVEZWJ1Z0FkYXB0ZXIge1xuXG5cdHByaXZhdGUgc3RhdGljIFRXT19DUkxGID0gJ1xcclxcblxcclxcbic7XG5cblx0cHJpdmF0ZSBfc2VuZE1lc3NhZ2UgPSBuZXcgRW1pdHRlcjxEZWJ1Z1Byb3RvY29sTWVzc2FnZT4oKTtcblxuXHRwcml2YXRlIF9yYXdEYXRhOiBCdWZmZXI7XG5cdHByaXZhdGUgX2NvbnRlbnRMZW5ndGg6IG51bWJlcjtcblx0cHJpdmF0ZSBfc2VxdWVuY2U6IG51bWJlciA9IDE7XG5cdHByaXZhdGUgX3dyaXRhYmxlU3RyZWFtOiBOb2RlSlMuV3JpdGFibGVTdHJlYW07XG5cdHByaXZhdGUgX3BlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXA8bnVtYmVyLCAocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVzcG9uc2UpID0+IHZvaWQ+KCk7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8vIC0tLS0gaW1wbGVtZW50cyB2c2NvZGUuRGVidWdhZGFwdGVyIGludGVyZmFjZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRwdWJsaWMgZGlzcG9zZSgpOiBhbnkge1xuXHR9XG5cblx0cHVibGljIG9uRGlkU2VuZE1lc3NhZ2U6IEV2ZW50MDxEZWJ1Z1Byb3RvY29sTWVzc2FnZT4gPSB0aGlzLl9zZW5kTWVzc2FnZS5ldmVudDtcblxuXHRwdWJsaWMgaGFuZGxlTWVzc2FnZShtc2c6IERlYnVnUHJvdG9jb2wuUHJvdG9jb2xNZXNzYWdlKTogdm9pZCB7XG5cdFx0aWYgKG1zZy50eXBlID09PSAncmVxdWVzdCcpIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hSZXF1ZXN0KDxEZWJ1Z1Byb3RvY29sLlJlcXVlc3Q+bXNnKTtcblx0XHR9IGVsc2UgaWYgKG1zZy50eXBlID09PSAncmVzcG9uc2UnKSB7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IDxEZWJ1Z1Byb3RvY29sLlJlc3BvbnNlPm1zZztcblx0XHRcdGNvbnN0IGNsYiA9IHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5nZXQocmVzcG9uc2UucmVxdWVzdF9zZXEpO1xuXHRcdFx0aWYgKGNsYikge1xuXHRcdFx0XHR0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKHJlc3BvbnNlLnJlcXVlc3Rfc2VxKTtcblx0XHRcdFx0Y2xiKHJlc3BvbnNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgX2lzUnVubmluZ0lubGluZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VuZE1lc3NhZ2UgJiYgdGhpcy5fc2VuZE1lc3NhZ2UuaGFzTGlzdGVuZXIoKTtcblx0fVxuXG5cdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRwdWJsaWMgc3RhcnQoaW5TdHJlYW06IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSwgb3V0U3RyZWFtOiBOb2RlSlMuV3JpdGFibGVTdHJlYW0pOiB2b2lkIHtcblx0XHR0aGlzLl93cml0YWJsZVN0cmVhbSA9IG91dFN0cmVhbTtcblx0XHR0aGlzLl9yYXdEYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuXG5cdFx0aW5TdHJlYW0ub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB0aGlzLl9oYW5kbGVEYXRhKGRhdGEpKTtcblxuXHRcdGluU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcblx0XHRcdHRoaXMuX2VtaXRFdmVudChuZXcgRXZlbnQoJ2Nsb3NlJykpO1xuXHRcdH0pO1xuXHRcdGluU3RyZWFtLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuXHRcdFx0dGhpcy5fZW1pdEV2ZW50KG5ldyBFdmVudCgnZXJyb3InLCAnaW5TdHJlYW0gZXJyb3I6ICcgKyAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSkpKTtcblx0XHR9KTtcblxuXHRcdG91dFN0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcblx0XHRcdHRoaXMuX2VtaXRFdmVudChuZXcgRXZlbnQoJ2Vycm9yJywgJ291dFN0cmVhbSBlcnJvcjogJyArIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKSkpO1xuXHRcdH0pO1xuXG5cdFx0aW5TdHJlYW0ucmVzdW1lKCk7XG5cdH1cblxuXHRwdWJsaWMgc3RvcCgpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5fd3JpdGFibGVTdHJlYW0pIHtcblx0XHRcdHRoaXMuX3dyaXRhYmxlU3RyZWFtLmVuZCgpO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBzZW5kRXZlbnQoZXZlbnQ6IERlYnVnUHJvdG9jb2wuRXZlbnQpOiB2b2lkIHtcblx0XHR0aGlzLl9zZW5kKCdldmVudCcsIGV2ZW50KTtcblx0fVxuXG5cdHB1YmxpYyBzZW5kUmVzcG9uc2UocmVzcG9uc2U6IERlYnVnUHJvdG9jb2wuUmVzcG9uc2UpOiB2b2lkIHtcblx0XHRpZiAocmVzcG9uc2Uuc2VxID4gMCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgYXR0ZW1wdCB0byBzZW5kIG1vcmUgdGhhbiBvbmUgcmVzcG9uc2UgZm9yIGNvbW1hbmQgJHtyZXNwb25zZS5jb21tYW5kfWApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kKCdyZXNwb25zZScsIHJlc3BvbnNlKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgc2VuZFJlcXVlc3QoY29tbWFuZDogc3RyaW5nLCBhcmdzOiBhbnksIHRpbWVvdXQ6IG51bWJlciwgY2I6IChyZXNwb25zZTogRGVidWdQcm90b2NvbC5SZXNwb25zZSkgPT4gdm9pZCkgOiB2b2lkIHtcblxuXHRcdGNvbnN0IHJlcXVlc3Q6IGFueSA9IHtcblx0XHRcdGNvbW1hbmQ6IGNvbW1hbmRcblx0XHR9O1xuXHRcdGlmIChhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA+IDApIHtcblx0XHRcdHJlcXVlc3QuYXJndW1lbnRzID0gYXJncztcblx0XHR9XG5cblx0XHR0aGlzLl9zZW5kKCdyZXF1ZXN0JywgcmVxdWVzdCk7XG5cblx0XHRpZiAoY2IpIHtcblx0XHRcdHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zZXQocmVxdWVzdC5zZXEsIGNiKTtcblxuXHRcdFx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0Y29uc3QgY2xiID0gdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmdldChyZXF1ZXN0LnNlcSk7XG5cdFx0XHRcdGlmIChjbGIpIHtcblx0XHRcdFx0XHR0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3Quc2VxKTtcblx0XHRcdFx0XHRjbGIobmV3IFJlc3BvbnNlKHJlcXVlc3QsICd0aW1lb3V0JykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aW1lb3V0KTtcblx0XHR9XG5cdH1cblxuXHQvLyAtLS0tIHByb3RlY3RlZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0cHJvdGVjdGVkIGRpc3BhdGNoUmVxdWVzdChyZXF1ZXN0OiBEZWJ1Z1Byb3RvY29sLlJlcXVlc3QpOiB2b2lkIHtcblx0fVxuXG5cdC8vIC0tLS0gcHJpdmF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRwcml2YXRlIF9lbWl0RXZlbnQoZXZlbnQ6IERlYnVnUHJvdG9jb2wuRXZlbnQpIHtcblx0XHR0aGlzLmVtaXQoZXZlbnQuZXZlbnQsIGV2ZW50KTtcblx0fVxuXG5cdHByaXZhdGUgX3NlbmQodHlwOiAncmVxdWVzdCcgfCAncmVzcG9uc2UnIHwgJ2V2ZW50JywgbWVzc2FnZTogRGVidWdQcm90b2NvbC5Qcm90b2NvbE1lc3NhZ2UpOiB2b2lkIHtcblxuXHRcdG1lc3NhZ2UudHlwZSA9IHR5cDtcblx0XHRtZXNzYWdlLnNlcSA9IHRoaXMuX3NlcXVlbmNlKys7XG5cblx0XHRpZiAodGhpcy5fd3JpdGFibGVTdHJlYW0pIHtcblx0XHRcdGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHRcdHRoaXMuX3dyaXRhYmxlU3RyZWFtLndyaXRlKGBDb250ZW50LUxlbmd0aDogJHtCdWZmZXIuYnl0ZUxlbmd0aChqc29uLCAndXRmOCcpfVxcclxcblxcclxcbiR7anNvbn1gLCAndXRmOCcpO1xuXHRcdH1cblx0XHR0aGlzLl9zZW5kTWVzc2FnZS5maXJlKG1lc3NhZ2UpO1xuXHR9XG5cblx0cHJpdmF0ZSBfaGFuZGxlRGF0YShkYXRhOiBCdWZmZXIpOiB2b2lkIHtcblxuXHRcdHRoaXMuX3Jhd0RhdGEgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9yYXdEYXRhLCBkYXRhXSk7XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKHRoaXMuX2NvbnRlbnRMZW5ndGggPj0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fcmF3RGF0YS5sZW5ndGggPj0gdGhpcy5fY29udGVudExlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9yYXdEYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgdGhpcy5fY29udGVudExlbmd0aCk7XG5cdFx0XHRcdFx0dGhpcy5fcmF3RGF0YSA9IHRoaXMuX3Jhd0RhdGEuc2xpY2UodGhpcy5fY29udGVudExlbmd0aCk7XG5cdFx0XHRcdFx0dGhpcy5fY29udGVudExlbmd0aCA9IC0xO1xuXHRcdFx0XHRcdGlmIChtZXNzYWdlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGxldCBtc2c6IERlYnVnUHJvdG9jb2wuUHJvdG9jb2xNZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5oYW5kbGVNZXNzYWdlKG1zZyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9lbWl0RXZlbnQobmV3IEV2ZW50KCdlcnJvcicsICdFcnJvciBoYW5kbGluZyBkYXRhOiAnICsgKGUgJiYgZS5tZXNzYWdlKSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250aW51ZTtcdC8vIHRoZXJlIG1heSBiZSBtb3JlIGNvbXBsZXRlIG1lc3NhZ2VzIHRvIHByb2Nlc3Ncblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgaWR4ID0gdGhpcy5fcmF3RGF0YS5pbmRleE9mKFByb3RvY29sU2VydmVyLlRXT19DUkxGKTtcblx0XHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb25zdCBoZWFkZXIgPSB0aGlzLl9yYXdEYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgaWR4KTtcblx0XHRcdFx0XHRjb25zdCBsaW5lcyA9IGhlYWRlci5zcGxpdCgnXFxyXFxuJyk7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgcGFpciA9IGxpbmVzW2ldLnNwbGl0KC86ICsvKTtcblx0XHRcdFx0XHRcdGlmIChwYWlyWzBdID09ICdDb250ZW50LUxlbmd0aCcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY29udGVudExlbmd0aCA9ICtwYWlyWzFdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdEYXRhID0gdGhpcy5fcmF3RGF0YS5zbGljZShpZHggKyBQcm90b2NvbFNlcnZlci5UV09fQ1JMRi5sZW5ndGgpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn1cbiJdfQ==

/***/ }),

/***/ "./node_modules/@vscode/debugadapter/lib/runDebugAdapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vscode/debugadapter/lib/runDebugAdapter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runDebugAdapter = void 0;
const Net = __webpack_require__(/*! net */ "net");
function runDebugAdapter(debugSession) {
    // parse arguments
    let port = 0;
    const args = process.argv.slice(2);
    args.forEach(function (val, index, array) {
        const portMatch = /^--server=(\d{4,5})$/.exec(val);
        if (portMatch) {
            port = parseInt(portMatch[1], 10);
        }
    });
    if (port > 0) {
        // start as a server
        console.error(`waiting for debug protocol on port ${port}`);
        Net.createServer((socket) => {
            console.error('>> accepted connection from client');
            socket.on('end', () => {
                console.error('>> client connection closed\n');
            });
            const session = new debugSession(false, true);
            session.setRunAsServer(true);
            session.start(socket, socket);
        }).listen(port);
    }
    else {
        // start a session
        //console.error('waiting for debug protocol on stdin/stdout');
        const session = new debugSession(false);
        process.on('SIGTERM', () => {
            session.shutdown();
        });
        session.start(process.stdin, process.stdout);
    }
}
exports.runDebugAdapter = runDebugAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVuRGVidWdBZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3J1bkRlYnVnQWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztnR0FHZ0c7OztBQUVoRywyQkFBMkI7QUFJM0IsU0FBZ0IsZUFBZSxDQUFDLFlBQWlDO0lBRWhFLGtCQUFrQjtJQUNsQixJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFDYixNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLO1FBQ3ZDLE1BQU0sU0FBUyxHQUFHLHNCQUFzQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuRCxJQUFJLFNBQVMsRUFBRTtZQUNkLElBQUksR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ2xDO0lBQ0YsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7UUFDYixvQkFBb0I7UUFDcEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxzQ0FBc0MsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUM1RCxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDM0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtnQkFDckIsT0FBTyxDQUFDLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1lBQ2hELENBQUMsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzlDLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDN0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2hCO1NBQU07UUFFTixrQkFBa0I7UUFDbEIsOERBQThEO1FBQzlELE1BQU0sT0FBTyxHQUFHLElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRTtZQUMxQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDcEIsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzdDO0FBQ0YsQ0FBQztBQWxDRCwwQ0FrQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuaW1wb3J0ICogYXMgTmV0IGZyb20gJ25ldCc7XG5cbmltcG9ydCB7IERlYnVnU2Vzc2lvbiB9IGZyb20gJy4vZGVidWdTZXNzaW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkRlYnVnQWRhcHRlcihkZWJ1Z1Nlc3Npb246IHR5cGVvZiBEZWJ1Z1Nlc3Npb24pIHtcblxuXHQvLyBwYXJzZSBhcmd1bWVudHNcblx0bGV0IHBvcnQgPSAwO1xuXHRjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuXHRhcmdzLmZvckVhY2goZnVuY3Rpb24gKHZhbCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0Y29uc3QgcG9ydE1hdGNoID0gL14tLXNlcnZlcj0oXFxkezQsNX0pJC8uZXhlYyh2YWwpO1xuXHRcdGlmIChwb3J0TWF0Y2gpIHtcblx0XHRcdHBvcnQgPSBwYXJzZUludChwb3J0TWF0Y2hbMV0sIDEwKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChwb3J0ID4gMCkge1xuXHRcdC8vIHN0YXJ0IGFzIGEgc2VydmVyXG5cdFx0Y29uc29sZS5lcnJvcihgd2FpdGluZyBmb3IgZGVidWcgcHJvdG9jb2wgb24gcG9ydCAke3BvcnR9YCk7XG5cdFx0TmV0LmNyZWF0ZVNlcnZlcigoc29ja2V0KSA9PiB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCc+PiBhY2NlcHRlZCBjb25uZWN0aW9uIGZyb20gY2xpZW50Jyk7XG5cdFx0XHRzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignPj4gY2xpZW50IGNvbm5lY3Rpb24gY2xvc2VkXFxuJyk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHNlc3Npb24gPSBuZXcgZGVidWdTZXNzaW9uKGZhbHNlLCB0cnVlKTtcblx0XHRcdHNlc3Npb24uc2V0UnVuQXNTZXJ2ZXIodHJ1ZSk7XG5cdFx0XHRzZXNzaW9uLnN0YXJ0KHNvY2tldCwgc29ja2V0KTtcblx0XHR9KS5saXN0ZW4ocG9ydCk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBzdGFydCBhIHNlc3Npb25cblx0XHQvL2NvbnNvbGUuZXJyb3IoJ3dhaXRpbmcgZm9yIGRlYnVnIHByb3RvY29sIG9uIHN0ZGluL3N0ZG91dCcpO1xuXHRcdGNvbnN0IHNlc3Npb24gPSBuZXcgZGVidWdTZXNzaW9uKGZhbHNlKTtcblx0XHRwcm9jZXNzLm9uKCdTSUdURVJNJywgKCkgPT4ge1xuXHRcdFx0c2Vzc2lvbi5zaHV0ZG93bigpO1xuXHRcdH0pO1xuXHRcdHNlc3Npb24uc3RhcnQocHJvY2Vzcy5zdGRpbiwgcHJvY2Vzcy5zdGRvdXQpO1xuXHR9XG59XG4iXX0=

/***/ }),

/***/ "./node_modules/accepts/index.js":
/*!***************************************!*\
  !*** ./node_modules/accepts/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(/*! negotiator */ "./node_modules/negotiator/index.js")
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/color-convert/index.js");
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ "./node_modules/anymatch/index.js":
/*!****************************************!*\
  !*** ./node_modules/anymatch/index.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const picomatch = __webpack_require__(/*! picomatch */ "./node_modules/picomatch/index.js");
const normalizePath = __webpack_require__(/*! normalize-path */ "./node_modules/normalize-path/index.js");

/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */
const BANG = '!';
const DEFAULT_OPTIONS = {returnIndex: false};
const arrify = (item) => Array.isArray(item) ? item : [item];

/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */
const createPattern = (matcher, options) => {
  if (typeof matcher === 'function') {
    return matcher;
  }
  if (typeof matcher === 'string') {
    const glob = picomatch(matcher, options);
    return (string) => matcher === string || glob(string);
  }
  if (matcher instanceof RegExp) {
    return (string) => matcher.test(string);
  }
  return (string) => false;
};

/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */
const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(_path))
  }
  const path = normalizePath(_path, false);

  for (let index = 0; index < negPatterns.length; index++) {
    const nglob = negPatterns[index];
    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  const applied = isList && [path].concat(args.slice(1));
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (isList ? pattern(...applied) : pattern(path)) {
      return returnIndex ? index : true;
    }
  }

  return returnIndex ? -1 : false;
};

/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */
const anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;
  const returnIndex = opts.returnIndex || false;

  // Early cache for matchers.
  const mtchers = arrify(matchers);
  const negatedGlobs = mtchers
    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)
    .map(item => item.slice(1))
    .map(item => picomatch(item, opts));
  const patterns = mtchers
    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))
    .map(matcher => createPattern(matcher, opts));

  if (testString == null) {
    return (testString, ri = false) => {
      const returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    }
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch.default = anymatch;
module.exports = anymatch;


/***/ }),

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Expose `arrayFlatten`.
 */
module.exports = arrayFlatten

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth (array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenForever(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten (array, depth) {
  if (depth == null) {
    return flattenForever(array, [])
  }

  return flattenWithDepth(array, [], depth)
}


/***/ }),

/***/ "./node_modules/binary-extensions/index.js":
/*!*************************************************!*\
  !*** ./node_modules/binary-extensions/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./binary-extensions.json */ "./node_modules/binary-extensions/binary-extensions.json");


/***/ }),

/***/ "./node_modules/body-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/body-parser/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('body-parser')

/**
 * Cache of loaded parsers.
 * @private
 */

var parsers = Object.create(null)

/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = deprecate.function(bodyParser,
  'bodyParser: use individual json/urlencoded middlewares')

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, "json", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('json')
}))

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, "raw", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('raw')
}))

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, "text", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('text')
}))

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, "urlencoded", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('urlencoded')
}))

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser (options) {
  // use default type for parsers
  var opts = Object.create(options || null, {
    type: {
      configurable: true,
      enumerable: true,
      value: undefined,
      writable: true
    }
  })

  var _urlencoded = exports.urlencoded(opts)
  var _json = exports.json(opts)

  return function bodyParser (req, res, next) {
    _json(req, res, function (err) {
      if (err) return next(err)
      _urlencoded(req, res, next)
    })
  }
}

/**
 * Create a getter for loading a parser.
 * @private
 */

function createParserGetter (name) {
  return function get () {
    return loadParser(name)
  }
}

/**
 * Load a parser module.
 * @private
 */

function loadParser (parserName) {
  var parser = parsers[parserName]

  if (parser !== undefined) {
    return parser
  }

  // this uses a switch for static require analysis
  switch (parserName) {
    case 'json':
      parser = __webpack_require__(/*! ./lib/types/json */ "./node_modules/body-parser/lib/types/json.js")
      break
    case 'raw':
      parser = __webpack_require__(/*! ./lib/types/raw */ "./node_modules/body-parser/lib/types/raw.js")
      break
    case 'text':
      parser = __webpack_require__(/*! ./lib/types/text */ "./node_modules/body-parser/lib/types/text.js")
      break
    case 'urlencoded':
      parser = __webpack_require__(/*! ./lib/types/urlencoded */ "./node_modules/body-parser/lib/types/urlencoded.js")
      break
  }

  // store to prevent invoking require()
  return (parsers[parserName] = parser)
}


/***/ }),

/***/ "./node_modules/body-parser/lib/read.js":
/*!**********************************************!*\
  !*** ./node_modules/body-parser/lib/read.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var destroy = __webpack_require__(/*! destroy */ "./node_modules/destroy/index.js")
var getBody = __webpack_require__(/*! raw-body */ "./node_modules/raw-body/index.js")
var iconv = __webpack_require__(/*! iconv-lite */ "./node_modules/iconv-lite/lib/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var unpipe = __webpack_require__(/*! unpipe */ "./node_modules/unpipe/index.js")
var zlib = __webpack_require__(/*! zlib */ "zlib")

/**
 * Module exports.
 */

module.exports = read

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read (req, res, next, parse, debug, options) {
  var length
  var opts = options
  var stream

  // flag as parsed
  req._body = true

  // read options
  var encoding = opts.encoding !== null
    ? opts.encoding
    : null
  var verify = opts.verify

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate)
    length = stream.length
    stream.length = undefined
  } catch (err) {
    return next(err)
  }

  // set raw-body options
  opts.length = length
  opts.encoding = verify
    ? null
    : encoding

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }))
  }

  // read body
  debug('read body')
  getBody(stream, opts, function (error, body) {
    if (error) {
      var _error

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        })
      } else {
        // set status code on error
        _error = createError(400, error)
      }

      // unpipe from stream and destroy
      if (stream !== req) {
        unpipe(req)
        destroy(stream, true)
      }

      // read off entire request
      dump(req, function onfinished () {
        next(createError(400, _error))
      })
      return
    }

    // verify
    if (verify) {
      try {
        debug('verify body')
        verify(req, res, body, encoding)
      } catch (err) {
        next(createError(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }))
        return
      }
    }

    // parse
    var str = body
    try {
      debug('parse body')
      str = typeof body !== 'string' && encoding !== null
        ? iconv.decode(body, encoding)
        : body
      req.body = parse(str)
    } catch (err) {
      next(createError(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }))
      return
    }

    next()
  })
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream (req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
  var length = req.headers['content-length']
  var stream

  debug('content-encoding "%s"', encoding)

  if (inflate === false && encoding !== 'identity') {
    throw createError(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }

  switch (encoding) {
    case 'deflate':
      stream = zlib.createInflate()
      debug('inflate body')
      req.pipe(stream)
      break
    case 'gzip':
      stream = zlib.createGunzip()
      debug('gunzip body')
      req.pipe(stream)
      break
    case 'identity':
      stream = req
      stream.length = length
      break
    default:
      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      })
  }

  return stream
}

/**
 * Dump the contents of a request.
 *
 * @param {object} req
 * @param {function} callback
 * @api private
 */

function dump (req, callback) {
  if (onFinished.isFinished(req)) {
    callback(null)
  } else {
    onFinished(req, callback)
    req.resume()
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/json.js":
/*!****************************************************!*\
  !*** ./node_modules/body-parser/lib/types/json.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:json')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/ // eslint-disable-line no-control-regex

var JSON_SYNTAX_CHAR = '#'
var JSON_SYNTAX_REGEXP = /#+/g

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json (options) {
  var opts = options || {}

  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var inflate = opts.inflate !== false
  var reviver = opts.reviver
  var strict = opts.strict !== false
  var type = opts.type || 'application/json'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {}
    }

    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        throw createStrictSyntaxError(body, first)
      }
    }

    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  return function jsonParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8'
    if (charset.slice(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = ''

  if (index !== -1) {
    partial = str.substring(0, index) + JSON_SYNTAX_CHAR

    for (var i = index + 1; i < str.length; i++) {
      partial += JSON_SYNTAX_CHAR
    }
  }

  try {
    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {
        return str.substring(index, index + placeholder.length)
      }),
      stack: e.stack
    })
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar (str) {
  var match = FIRST_CHAR_REGEXP.exec(str)

  return match
    ? match[1]
    : undefined
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError (error, obj) {
  var keys = Object.getOwnPropertyNames(error)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    if (key !== 'stack' && key !== 'message') {
      delete error[key]
    }
  }

  // replace stack before message for Node.js 0.10 and below
  error.stack = obj.stack.replace(error.message, obj.message)
  error.message = obj.message

  return error
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/raw.js":
/*!***************************************************!*\
  !*** ./node_modules/body-parser/lib/types/raw.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:raw')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = raw

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw (options) {
  var opts = options || {}

  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/octet-stream'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function rawParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: null,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/text.js":
/*!****************************************************!*\
  !*** ./node_modules/body-parser/lib/types/text.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:text')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = text

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text (options) {
  var opts = options || {}

  var defaultCharset = opts.defaultCharset || 'utf-8'
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'text/plain'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function textParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // get charset
    var charset = getCharset(req) || defaultCharset

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/urlencoded.js":
/*!**********************************************************!*\
  !*** ./node_modules/body-parser/lib/types/urlencoded.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:urlencoded')
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('body-parser')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = urlencoded

/**
 * Cache of parser modules.
 */

var parsers = Object.create(null)

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded (options) {
  var opts = options || {}

  // notice because option default will flip in next major
  if (opts.extended === undefined) {
    deprecate('undefined extended: provide extended option')
  }

  var extended = opts.extended !== false
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/x-www-form-urlencoded'
  var verify = opts.verify || false
  var depth = typeof opts.depth !== 'number'
    ? Number(opts.depth || 32)
    : opts.depth

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate query parser
  var queryparse = extended
    ? extendedparser(opts)
    : simpleparser(opts)

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    return body.length
      ? queryparse(body)
      : {}
  }

  return function urlencodedParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset
    var charset = getCharset(req) || 'utf-8'
    if (charset !== 'utf-8') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      debug: debug,
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify,
      depth: depth
    })
  }
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function extendedparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000

  var depth = typeof options.depth !== 'number'
    ? Number(options.depth || 32)
    : options.depth
  var parse = parser('qs')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isNaN(depth) || depth < 0) {
    throw new TypeError('option depth must be a zero or a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    var arrayLimit = Math.max(100, paramCount)

    debug('parse extended urlencoding')
    try {
      return parse(body, {
        allowPrototypes: true,
        arrayLimit: arrayLimit,
        depth: depth,
        strictDepth: true,
        parameterLimit: parameterLimit
      })
    } catch (err) {
      if (err instanceof RangeError) {
        throw createError(400, 'The input exceeded the depth', {
          type: 'querystring.parse.rangeError'
        })
      } else {
        throw err
      }
    }
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var count = 0
  var index = 0

  while ((index = body.indexOf('&', index)) !== -1) {
    count++
    index++

    if (count === limit) {
      return undefined
    }
  }

  return count
}

/**
 * Get parser for module name dynamically.
 *
 * @param {string} name
 * @return {function}
 * @api private
 */

function parser (name) {
  var mod = parsers[name]

  if (mod !== undefined) {
    return mod.parse
  }

  // this uses a switch for static require analysis
  switch (name) {
    case 'qs':
      mod = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js")
      break
    case 'querystring':
      mod = __webpack_require__(/*! querystring */ "querystring")
      break
  }

  // store to prevent invoking require()
  parsers[name] = mod

  return mod.parse
}

/**
 * Get the simple query parser.
 *
 * @param {object} options
 */

function simpleparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('querystring')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    debug('parse urlencoding')
    return parse(body, undefined, undefined, { maxKeys: parameterLimit })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/browser.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/body-parser/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/debug.js":
/*!******************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/debug.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/body-parser/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/body-parser/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/body-parser/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/node.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/body-parser/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/body-parser/node_modules/ms/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/body-parser/node_modules/ms/index.js ***!
  \***********************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/braces/index.js":
/*!**************************************!*\
  !*** ./node_modules/braces/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(/*! ./lib/stringify */ "./node_modules/braces/lib/stringify.js");
const compile = __webpack_require__(/*! ./lib/compile */ "./node_modules/braces/lib/compile.js");
const expand = __webpack_require__(/*! ./lib/expand */ "./node_modules/braces/lib/expand.js");
const parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/braces/lib/parse.js");

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (const pattern of input) {
      const result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

  return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ "./node_modules/braces/lib/compile.js":
/*!********************************************!*\
  !*** ./node_modules/braces/lib/compile.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(/*! fill-range */ "./node_modules/fill-range/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

const compile = (ast, options = {}) => {
  const walk = (node, parent = {}) => {
    const invalidBlock = utils.isInvalidBrace(parent);
    const invalidNode = node.invalid === true && options.escapeInvalid === true;
    const invalid = invalidBlock === true || invalidNode === true;
    const prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }

    if (node.isClose === true) {
      console.log('node.isClose', prefix, node.value);
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? prefix + node.value : '(';
    }

    if (node.type === 'close') {
      return invalid ? prefix + node.value : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      const args = utils.reduce(node.nodes);
      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (const child of node.nodes) {
        output += walk(child, node);
      }
    }

    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ "./node_modules/braces/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 10000,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ "./node_modules/braces/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/braces/lib/expand.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(/*! fill-range */ "./node_modules/fill-range/index.js");
const stringify = __webpack_require__(/*! ./stringify */ "./node_modules/braces/lib/stringify.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

const append = (queue = '', stash = '', enclose = false) => {
  const result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (const item of queue) {
    if (Array.isArray(item)) {
      for (const value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;

  const walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      const args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    const enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      const child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ "./node_modules/braces/lib/parse.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/parse.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(/*! ./stringify */ "./node_modules/braces/lib/stringify.js");

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(/*! ./constants */ "./node_modules/braces/lib/constants.js");

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  const opts = options || {};
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  const ast = { type: 'root', input, nodes: [] };
  const stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  const length = input.length;
  let index = 0;
  let depth = 0;
  let value;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      const open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      const brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      const type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        const open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      const siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        const before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      const parent = stack[stack.length - 1];
      const index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ "./node_modules/braces/lib/stringify.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/stringify.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

module.exports = (ast, options = {}) => {
  const stringify = (node, parent = {}) => {
    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    const invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (const child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ "./node_modules/braces/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  const node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];

  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      const ele = arr[i];

      if (Array.isArray(ele)) {
        flat(ele);
        continue;
      }

      if (ele !== undefined) {
        result.push(ele);
      }
    }
    return result;
  };

  flat(args);
  return result;
};


/***/ }),

/***/ "./node_modules/bytes/index.js":
/*!*************************************!*\
  !*** ./node_modules/bytes/index.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5),
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.split('.').map(function (s, i) {
      return i === 0
        ? s.replace(formatThousandsRegExp, thousandsSeparator)
        : s
    }).join('.');
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  if (isNaN(floatValue)) {
    return null;
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/chokidar/index.js":
/*!****************************************!*\
  !*** ./node_modules/chokidar/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const { EventEmitter } = __webpack_require__(/*! events */ "events");
const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const { promisify } = __webpack_require__(/*! util */ "util");
const readdirp = __webpack_require__(/*! readdirp */ "./node_modules/readdirp/index.js");
const anymatch = (__webpack_require__(/*! anymatch */ "./node_modules/anymatch/index.js")["default"]);
const globParent = __webpack_require__(/*! glob-parent */ "./node_modules/glob-parent/index.js");
const isGlob = __webpack_require__(/*! is-glob */ "./node_modules/is-glob/index.js");
const braces = __webpack_require__(/*! braces */ "./node_modules/braces/index.js");
const normalizePath = __webpack_require__(/*! normalize-path */ "./node_modules/normalize-path/index.js");

const NodeFsHandler = __webpack_require__(/*! ./lib/nodefs-handler */ "./node_modules/chokidar/lib/nodefs-handler.js");
const FsEventsHandler = __webpack_require__(/*! ./lib/fsevents-handler */ "./node_modules/chokidar/lib/fsevents-handler.js");
const {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,

  STR_CLOSE,
  STR_END,

  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,

  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,

  isWindows,
  isMacos,
  isIBMi
} = __webpack_require__(/*! ./lib/constants */ "./node_modules/chokidar/lib/constants.js");

const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);

/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

const arrify = (value = []) => Array.isArray(value) ? value : [value];
const flatten = (list, result = []) => {
  list.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

const unifyPaths = (paths_) => {
  /**
   * @type {Array<String>}
   */
  const paths = flatten(arrify(paths_));
  if (!paths.every(p => typeof p === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};

// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string) => {
  let str = string.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str = SLASH + str;
  }
  return str;
};

// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));

const normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
  if (typeof path !== STRING_TYPE) return path;
  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
};

const getAbsolutePath = (path, cwd) => {
  if (sysPath.isAbsolute(path)) {
    return path;
  }
  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }
  return sysPath.join(cwd, path);
};

const undef = (opts, key) => opts[key] === undefined;

/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */
class DirEntry {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */
    this.items = new Set();
  }

  add(item) {
    const {items} = this;
    if (!items) return;
    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
  }

  async remove(item) {
    const {items} = this;
    if (!items) return;
    items.delete(item);
    if (items.size > 0) return;

    const dir = this.path;
    try {
      await readdir(dir);
    } catch (err) {
      if (this._removeWatcher) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }

  has(item) {
    const {items} = this;
    if (!items) return;
    return items.has(item);
  }

  /**
   * @returns {Array<String>}
   */
  getChildren() {
    const {items} = this;
    if (!items) return;
    return [...items.values()];
  }

  dispose() {
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
  }
}

const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
  constructor(path, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */
    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  checkGlobSymlink(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === EMPTY_STR
    if (this.globSymlink === undefined) {
      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?
        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};
    }

    if (this.globSymlink) {
      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }

    return entry.fullPath;
  }

  entryPath(entry) {
    return sysPath.join(this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
    );
  }

  filterPath(entry) {
    const {stats} = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?
      this.globFilter(resolvedPath) : true;
    return matchesGlob &&
      this.fsw._isntIgnored(resolvedPath, stats) &&
      this.fsw._hasReadPermissions(stats);
  }

  getDirParts(path) {
    if (!this.hasGlob) return [];
    const parts = [];
    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
    expandedPath.forEach((path) => {
      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
    });
    return parts;
  }

  filterDir(entry) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i) => {
          if (part === GLOBSTAR) globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
  }
}

/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter {
// Not indenting methods for history sake; for now.
constructor(_opts) {
  super();

  const opts = {};
  if (_opts) Object.assign(opts, _opts); // for frozen objects

  /** @type {Map<String, DirEntry>} */
  this._watched = new Map();
  /** @type {Map<String, Array>} */
  this._closers = new Map();
  /** @type {Set<String>} */
  this._ignoredPaths = new Set();

  /** @type {Map<ThrottleType, Map>} */
  this._throttled = new Map();

  /** @type {Map<Path, String|Boolean>} */
  this._symlinkPaths = new Map();

  this._streams = new Set();
  this.closed = false;

  // Set up default options.
  if (undef(opts, 'persistent')) opts.persistent = true;
  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef(opts, 'interval')) opts.interval = 100;
  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  const canUseFsEvents = FsEventsHandler.canUse();
  if (!canUseFsEvents) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs_watch.
  if (undef(opts, 'usePolling') && !opts.useFsEvents) {
    opts.usePolling = isMacos;
  }

  // Always default to polling on IBM i because fs.watch() is not available on IBM i.
  if(isIBMi) {
    opts.usePolling = true;
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  const envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    const envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower;
    }
  }
  const envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = Number.parseInt(envInterval, 10);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = new Map();

  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  const awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;
    this._pendingWrites = new Map();
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  let readyCalls = 0;
  this._emitReady = () => {
    readyCalls++;
    if (readyCalls >= this._readyCount) {
      this._emitReady = EMPTY_FN;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(() => this.emit(EV_READY));
    }
  };
  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
  this._readyEmitted = false;
  this.options = opts;

  // Initialize with proper watcher.
  if (opts.useFsEvents) {
    this._fsEventsHandler = new FsEventsHandler(this);
  } else {
    this._nodeFsHandler = new NodeFsHandler(this);
  }

  // Youre frozen when your hearts not open.
  Object.freeze(opts);
}

// Public methods

/**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param {Path|Array<Path>} paths_
 * @param {String=} _origAdd private; for handling non-existent paths to be watched
 * @param {Boolean=} _internal private; indicates a non-user add
 * @returns {FSWatcher} for chaining
 */
add(paths_, _origAdd, _internal) {
  const {cwd, disableGlobbing} = this.options;
  this.closed = false;
  let paths = unifyPaths(paths_);
  if (cwd) {
    paths = paths.map((path) => {
      const absPath = getAbsolutePath(path, cwd);

      // Check `path` instead of `absPath` because the cwd portion can't be a glob
      if (disableGlobbing || !isGlob(path)) {
        return absPath;
      }
      return normalizePath(absPath);
    });
  }

  // set aside negated glob strings
  paths = paths.filter((path) => {
    if (path.startsWith(BANG)) {
      this._ignoredPaths.add(path.slice(1));
      return false;
    }

    // if a path is being added that was previously ignored, stop ignoring it
    this._ignoredPaths.delete(path);
    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;

    return true;
  });

  if (this.options.useFsEvents && this._fsEventsHandler) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount += paths.length;
    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    Promise.all(
      paths.map(async path => {
        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
        if (res) this._emitReady();
        return res;
      })
    ).then(results => {
      if (this.closed) return;
      results.filter(item => item).forEach(item => {
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      });
    });
  }

  return this;
}

/**
 * Close watchers or start ignoring events from specified paths.
 * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
 * @returns {FSWatcher} for chaining
*/
unwatch(paths_) {
  if (this.closed) return this;
  const paths = unifyPaths(paths_);
  const {cwd} = this.options;

  paths.forEach((path) => {
    // convert to absolute path unless relative path already matches
    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
      if (cwd) path = sysPath.join(cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths.add(path);
    if (this._watched.has(path)) {
      this._ignoredPaths.add(path + SLASH_GLOBSTAR);
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;
  });

  return this;
}

/**
 * Close watchers and remove all listeners from watched paths.
 * @returns {Promise<void>}.
*/
close() {
  if (this.closed) return this._closePromise;
  this.closed = true;

  // Memory management.
  this.removeAllListeners();
  const closers = [];
  this._closers.forEach(closerList => closerList.forEach(closer => {
    const promise = closer();
    if (promise instanceof Promise) closers.push(promise);
  }));
  this._streams.forEach(stream => stream.destroy());
  this._userIgnored = undefined;
  this._readyCount = 0;
  this._readyEmitted = false;
  this._watched.forEach(dirent => dirent.dispose());
  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {
    this[`_${key}`].clear();
  });

  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
  return this._closePromise;
}

/**
 * Expose list of watched paths
 * @returns {Object} for chaining
*/
getWatched() {
  const watchList = {};
  this._watched.forEach((entry, dir) => {
    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || ONE_DOT] = entry.getChildren().sort();
  });
  return watchList;
}

emitWithAll(event, args) {
  this.emit(...args);
  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
}

// Common helpers
// --------------

/**
 * Normalize and emit events.
 * Calling _emit DOES NOT MEAN emit() would be called!
 * @param {EventName} event Type of event
 * @param {Path} path File or directory path
 * @param {*=} val1 arguments to be passed with event
 * @param {*=} val2
 * @param {*=} val3
 * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
async _emit(event, path, val1, val2, val3) {
  if (this.closed) return;

  const opts = this.options;
  if (isWindows) path = sysPath.normalize(path);
  if (opts.cwd) path = sysPath.relative(opts.cwd, path);
  /** @type Array<any> */
  const args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  const awf = opts.awaitWriteFinish;
  let pw;
  if (awf && (pw = this._pendingWrites.get(path))) {
    pw.lastChange = new Date();
    return this;
  }

  if (opts.atomic) {
    if (event === EV_UNLINK) {
      this._pendingUnlinks.set(path, args);
      setTimeout(() => {
        this._pendingUnlinks.forEach((entry, path) => {
          this.emit(...entry);
          this.emit(EV_ALL, ...entry);
          this._pendingUnlinks.delete(path);
        });
      }, typeof opts.atomic === 'number' ? opts.atomic : 100);
      return this;
    }
    if (event === EV_ADD && this._pendingUnlinks.has(path)) {
      event = args[0] = EV_CHANGE;
      this._pendingUnlinks.delete(path);
    }
  }

  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
    const awfEmit = (err, stats) => {
      if (err) {
        event = args[0] = EV_ERROR;
        args[1] = err;
        this.emitWithAll(event, args);
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        this.emitWithAll(event, args);
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === EV_CHANGE) {
    const isThrottled = !this._throttle(EV_CHANGE, path, 50);
    if (isThrottled) return this;
  }

  if (opts.alwaysStat && val1 === undefined &&
    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)
  ) {
    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
    let stats;
    try {
      stats = await stat(fullPath);
    } catch (err) {}
    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
    if (!stats || this.closed) return;
    args.push(stats);
  }
  this.emitWithAll(event, args);

  return this;
}

/**
 * Common handler for errors
 * @param {Error} error
 * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
_handleError(error) {
  const code = error && error.code;
  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
  ) {
    this.emit(EV_ERROR, error);
  }
  return error || this.closed;
}

/**
 * Helper utility for throttling
 * @param {ThrottleType} actionType type being throttled
 * @param {Path} path being acted upon
 * @param {Number} timeout duration of time to suppress duplicate actions
 * @returns {Object|false} tracking object or false if action should be suppressed
 */
_throttle(actionType, path, timeout) {
  if (!this._throttled.has(actionType)) {
    this._throttled.set(actionType, new Map());
  }

  /** @type {Map<Path, Object>} */
  const action = this._throttled.get(actionType);
  /** @type {Object} */
  const actionPath = action.get(path);

  if (actionPath) {
    actionPath.count++;
    return false;
  }

  let timeoutObject;
  const clear = () => {
    const item = action.get(path);
    const count = item ? item.count : 0;
    action.delete(path);
    clearTimeout(timeoutObject);
    if (item) clearTimeout(item.timeoutObject);
    return count;
  };
  timeoutObject = setTimeout(clear, timeout);
  const thr = {timeoutObject, clear, count: 0};
  action.set(path, thr);
  return thr;
}

_incrReadyCount() {
  return this._readyCount++;
}

/**
 * Awaits write operation to finish.
 * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
 * @param {Path} path being acted upon
 * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
 * @param {EventName} event
 * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
 */
_awaitWriteFinish(path, threshold, event, awfEmit) {
  let timeoutHandler;

  let fullPath = path;
  if (this.options.cwd && !sysPath.isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  const now = new Date();

  const awaitWriteFinish = (prevStat) => {
    fs.stat(fullPath, (err, curStat) => {
      if (err || !this._pendingWrites.has(path)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      const now = Number(new Date());

      if (prevStat && curStat.size !== prevStat.size) {
        this._pendingWrites.get(path).lastChange = now;
      }
      const pw = this._pendingWrites.get(path);
      const df = now - pw.lastChange;

      if (df >= threshold) {
        this._pendingWrites.delete(path);
        awfEmit(undefined, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish,
          this.options.awaitWriteFinish.pollInterval,
          curStat
        );
      }
    });
  };

  if (!this._pendingWrites.has(path)) {
    this._pendingWrites.set(path, {
      lastChange: now,
      cancelWait: () => {
        this._pendingWrites.delete(path);
        clearTimeout(timeoutHandler);
        return event;
      }
    });
    timeoutHandler = setTimeout(
      awaitWriteFinish,
      this.options.awaitWriteFinish.pollInterval
    );
  }
}

_getGlobIgnored() {
  return [...this._ignoredPaths.values()];
}

/**
 * Determines whether user has asked to ignore this path.
 * @param {Path} path filepath or dir
 * @param {fs.Stats=} stats result of fs.stat
 * @returns {Boolean}
 */
_isIgnored(path, stats) {
  if (this.options.atomic && DOT_RE.test(path)) return true;
  if (!this._userIgnored) {
    const {cwd} = this.options;
    const ign = this.options.ignored;

    const ignored = ign && ign.map(normalizeIgnored(cwd));
    const paths = arrify(ignored)
      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))
      .map((path) => path + SLASH_GLOBSTAR);
    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
  }

  return this._userIgnored([path, stats]);
}

_isntIgnored(path, stat) {
  return !this._isIgnored(path, stat);
}

/**
 * Provides a set of common helpers and properties relating to symlink and glob handling.
 * @param {Path} path file, directory, or glob pattern being watched
 * @param {Number=} depth at any depth > 0, this isn't a glob
 * @returns {WatchHelper} object containing helpers for this path
 */
_getWatchHelpers(path, depth) {
  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  const follow = this.options.followSymlinks;

  return new WatchHelper(path, watchPath, follow, this);
}

// Directory helpers
// -----------------

/**
 * Provides directory tracking objects
 * @param {String} directory path of the directory
 * @returns {DirEntry} the directory's tracking object
 */
_getWatchedDir(directory) {
  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
  const dir = sysPath.resolve(directory);
  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
  return this._watched.get(dir);
}

// File helpers
// ------------

/**
 * Check for read permissions.
 * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
 * @param {fs.Stats} stats - object, result of fs_stat
 * @returns {Boolean} indicates whether the file can be read
*/
_hasReadPermissions(stats) {
  if (this.options.ignorePermissionErrors) return true;

  // stats.mode may be bigint
  const md = stats && Number.parseInt(stats.mode, 10);
  const st = md & 0o777;
  const it = Number.parseInt(st.toString(8)[0], 10);
  return Boolean(4 & it);
}

/**
 * Handles emitting unlink events for
 * files and directories, and via recursion, for
 * files and directories within directories that are unlinked
 * @param {String} directory within which the following item is located
 * @param {String} item      base path of item/directory
 * @returns {void}
*/
_remove(directory, item, isDirectory) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  const path = sysPath.join(directory, item);
  const fullPath = sysPath.resolve(path);
  isDirectory = isDirectory != null
    ? isDirectory
    : this._watched.has(path) || this._watched.has(fullPath);

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  const wp = this._getWatchedDir(path);
  const nestedDirectoryChildren = wp.getChildren();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

  // Check if item was on the watched list and remove it
  const parent = this._getWatchedDir(directory);
  const wasTracked = parent.has(item);
  parent.remove(item);

  // Fixes issue #1042 -> Relative paths were detected and added as symlinks
  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
  // but never removed from the map in case the path was deleted.
  // This leads to an incorrect state if the path was recreated:
  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
  if (this._symlinkPaths.has(fullPath)) {
    this._symlinkPaths.delete(fullPath);
  }

  // If we wait for this file to be fully written, cancel the wait.
  let relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
    const event = this._pendingWrites.get(relPath).cancelWait();
    if (event === EV_ADD) return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  this._watched.delete(path);
  this._watched.delete(fullPath);
  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
}

/**
 * Closes all watchers for a path
 * @param {Path} path
 */
_closePath(path) {
  this._closeFile(path)
  const dir = sysPath.dirname(path);
  this._getWatchedDir(dir).remove(sysPath.basename(path));
}

/**
 * Closes only file-specific watchers
 * @param {Path} path
 */
_closeFile(path) {
  const closers = this._closers.get(path);
  if (!closers) return;
  closers.forEach(closer => closer());
  this._closers.delete(path);
}

/**
 *
 * @param {Path} path
 * @param {Function} closer
 */
_addPathCloser(path, closer) {
  if (!closer) return;
  let list = this._closers.get(path);
  if (!list) {
    list = [];
    this._closers.set(path, list);
  }
  list.push(closer);
}

_readdirp(root, opts) {
  if (this.closed) return;
  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};
  let stream = readdirp(root, options);
  this._streams.add(stream);
  stream.once(STR_CLOSE, () => {
    stream = undefined;
  });
  stream.once(STR_END, () => {
    if (stream) {
      this._streams.delete(stream);
      stream = undefined;
    }
  });
  return stream;
}

}

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */
const watch = (paths, options) => {
  const watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

exports.watch = watch;


/***/ }),

/***/ "./node_modules/chokidar/lib/constants.js":
/*!************************************************!*\
  !*** ./node_modules/chokidar/lib/constants.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const {sep} = __webpack_require__(/*! path */ "path");
const {platform} = process;
const os = __webpack_require__(/*! os */ "os");

exports.EV_ALL = 'all';
exports.EV_READY = 'ready';
exports.EV_ADD = 'add';
exports.EV_CHANGE = 'change';
exports.EV_ADD_DIR = 'addDir';
exports.EV_UNLINK = 'unlink';
exports.EV_UNLINK_DIR = 'unlinkDir';
exports.EV_RAW = 'raw';
exports.EV_ERROR = 'error';

exports.STR_DATA = 'data';
exports.STR_END = 'end';
exports.STR_CLOSE = 'close';

exports.FSEVENT_CREATED = 'created';
exports.FSEVENT_MODIFIED = 'modified';
exports.FSEVENT_DELETED = 'deleted';
exports.FSEVENT_MOVED = 'moved';
exports.FSEVENT_CLONED = 'cloned';
exports.FSEVENT_UNKNOWN = 'unknown';
exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
exports.FSEVENT_TYPE_FILE = 'file';
exports.FSEVENT_TYPE_DIRECTORY = 'directory';
exports.FSEVENT_TYPE_SYMLINK = 'symlink';

exports.KEY_LISTENERS = 'listeners';
exports.KEY_ERR = 'errHandlers';
exports.KEY_RAW = 'rawEmitters';
exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];

exports.DOT_SLASH = `.${sep}`;

exports.BACK_SLASH_RE = /\\/g;
exports.DOUBLE_SLASH_RE = /\/\//;
exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
exports.REPLACER_RE = /^\.[/\\]/;

exports.SLASH = '/';
exports.SLASH_SLASH = '//';
exports.BRACE_START = '{';
exports.BANG = '!';
exports.ONE_DOT = '.';
exports.TWO_DOTS = '..';
exports.STAR = '*';
exports.GLOBSTAR = '**';
exports.ROOT_GLOBSTAR = '/**/*';
exports.SLASH_GLOBSTAR = '/**';
exports.DIR_SUFFIX = 'Dir';
exports.ANYMATCH_OPTS = {dot: true};
exports.STRING_TYPE = 'string';
exports.FUNCTION_TYPE = 'function';
exports.EMPTY_STR = '';
exports.EMPTY_FN = () => {};
exports.IDENTITY_FN = val => val;

exports.isWindows = platform === 'win32';
exports.isMacos = platform === 'darwin';
exports.isLinux = platform === 'linux';
exports.isIBMi = os.type() === 'OS400';


/***/ }),

/***/ "./node_modules/chokidar/lib/fsevents-handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/chokidar/lib/fsevents-handler.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const { promisify } = __webpack_require__(/*! util */ "util");

let fsevents;
try {
  fsevents = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fsevents'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj = Number.parseInt(mtch[1], 10);
    const min = Number.parseInt(mtch[2], 10);
    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

const {
  EV_ADD,
  EV_CHANGE,
  EV_ADD_DIR,
  EV_UNLINK,
  EV_ERROR,
  STR_DATA,
  STR_END,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,

  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE,
  EMPTY_FN,
  IDENTITY_FN
} = __webpack_require__(/*! ./constants */ "./node_modules/chokidar/lib/constants.js");

const Depth = (value) => isNaN(value) ? {} : {depth: value};

const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

const statMethods = { stat, lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
const FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;

const wrongEventFlags = new Set([
  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
const createFSEventsInstance = (path, callback) => {
  const stop = fsevents.watch(path, callback);
  return {stop};
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;

  const parentPath = sysPath.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  const resolvedPath = sysPath.resolve(path);
  const hasSymlink = resolvedPath !== realPath;

  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(list => {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return () => {
    const lst = cont.listeners;

    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
const canUse = () => fsevents && FSEventsWatchers.size < 128;

// determines subdirectory traversal levels from root to path
const calcDepth = (path, root) => {
  let i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
};

// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
const sameTypes = (info, stats) => (
  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||
  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||
  info.type === FSEVENT_TYPE_FILE && stats.isFile()
)

/**
 * @mixin
 */
class FsEventsHandler {

/**
 * @param {import('../index').FSWatcher} fsw
 */
constructor(fsw) {
  this.fsw = fsw;
}
checkIgnored(path, stats) {
  const ipaths = this.fsw._ignoredPaths;
  if (this.fsw._isIgnored(path, stats)) {
    ipaths.add(path);
    if (stats && stats.isDirectory()) {
      ipaths.add(path + ROOT_GLOBSTAR);
    }
    return true;
  }

  ipaths.delete(path);
  ipaths.delete(path + ROOT_GLOBSTAR);
}

addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
}

async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  try {
    const stats = await stat(path)
    if (this.fsw.closed) return;
    if (sameTypes(info, stats)) {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  } catch (error) {
    if (error.code === 'EACCES') {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }
}

handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  if (this.fsw.closed || this.checkIgnored(path)) return;

  if (event === EV_UNLINK) {
    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY
    // suppress unlink events on never before seen files
    if (isDirectory || watchedDir.has(item)) {
      this.fsw._remove(parent, item, isDirectory);
    }
  } else {
    if (event === EV_ADD) {
      // track new directories
      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
        // push symlinks back to the top of the stack to get handled
        const curDepth = opts.depth === undefined ?
          undefined : calcDepth(fullPath, realPath) + 1;
        return this._addToFsEvents(path, false, true, curDepth);
      }

      // track new paths
      // (other than symlinks being followed, which will be tracked soon)
      this.fsw._getWatchedDir(parent).add(item);
    }
    /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */
    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
    this.fsw._emit(eventName, path);
    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
  }
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/
_watchWithFsEvents(watchPath, realPath, transform, globFilter) {
  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
  const opts = this.fsw.options;
  const watchCallback = async (fullPath, flags, info) => {
    if (this.fsw.closed) return;
    if (
      opts.depth !== undefined &&
      calcDepth(fullPath, realPath) > opts.depth
    ) return;
    const path = transform(sysPath.join(
      watchPath, sysPath.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    const parent = sysPath.dirname(path);
    const item = sysPath.basename(path);
    const watchedDir = this.fsw._getWatchedDir(
      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
    );

    // correct for wrong events emitted
    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
      if (typeof opts.ignored === FUNCTION_TYPE) {
        let stats;
        try {
          stats = await stat(path);
        } catch (error) {}
        if (this.fsw.closed) return;
        if (this.checkIgnored(path, stats)) return;
        if (sameTypes(info, stats)) {
          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } else {
      switch (info.event) {
      case FSEVENT_CREATED:
      case FSEVENT_MODIFIED:
        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      case FSEVENT_DELETED:
      case FSEVENT_MOVED:
        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  };

  const closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.fsw._emitRaw
  );

  this.fsw._emitReady();
  return closer;
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {Promise<void>}
 */
async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
  // don't follow the same symlink more than once
  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;

  this.fsw._symlinkPaths.set(fullPath, true);
  this.fsw._incrReadyCount();

  try {
    const linkTarget = await realpath(linkPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(linkTarget)) {
      return this.fsw._emitReady();
    }

    this.fsw._incrReadyCount();

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, (path) => {
      let aliasedPath = linkPath;
      if (linkTarget && linkTarget !== DOT_SLASH) {
        aliasedPath = path.replace(linkTarget, linkPath);
      } else if (path !== DOT_SLASH) {
        aliasedPath = sysPath.join(linkPath, path);
      }
      return transform(aliasedPath);
    }, false, curDepth);
  } catch(error) {
    if (this.fsw._handleError(error)) {
      return this.fsw._emitReady();
    }
  }
}

/**
 *
 * @param {Path} newPath
 * @param {fs.Stats} stats
 */
emitAdd(newPath, stats, processPath, opts, forceAdd) {
  const pp = processPath(newPath);
  const isDir = stats.isDirectory();
  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
  const base = sysPath.basename(pp);

  // ensure empty dirs get tracked
  if (isDir) this.fsw._getWatchedDir(pp);
  if (dirObj.has(base)) return;
  dirObj.add(base);

  if (!opts.ignoreInitial || forceAdd === true) {
    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
  }
}

initWatch(realPath, path, wh, processPath) {
  if (this.fsw.closed) return;
  const closer = this._watchWithFsEvents(
    wh.watchPath,
    sysPath.resolve(realPath || wh.watchPath),
    processPath,
    wh.globFilter
  );
  this.fsw._addPathCloser(path, closer);
}

/**
 * Handle added path with fsevents
 * @param {String} path file/dir path or glob pattern
 * @param {Function|Boolean=} transform converts working path to what the user expects
 * @param {Boolean=} forceAdd ensure add is emitted
 * @param {Number=} priorDepth Level of subdirectories already traversed.
 * @returns {Promise<void>}
 */
async _addToFsEvents(path, transform, forceAdd, priorDepth) {
  if (this.fsw.closed) {
    return;
  }
  const opts = this.fsw.options;
  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;

  const wh = this.fsw._getWatchHelpers(path);

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      throw null;
    }
    if (stats.isDirectory()) {
      // emit addDir unless this is a glob parent
      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);

      // don't recurse further if it would exceed depth setting
      if (priorDepth && priorDepth > opts.depth) return;

      // scan the contents of the dir
      this.fsw._readdirp(wh.watchPath, {
        fileFilter: entry => wh.filterPath(entry),
        directoryFilter: entry => wh.filterDir(entry),
        ...Depth(opts.depth - (priorDepth || 0))
      }).on(STR_DATA, (entry) => {
        // need to check filterPath on dirs b/c filterDir is less restrictive
        if (this.fsw.closed) {
          return;
        }
        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;

        const joinedPath = sysPath.join(wh.watchPath, entry.path);
        const {fullPath} = entry;

        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
          // preserve the current depth here since it can't be derived from
          // real paths past the symlink
          const curDepth = opts.depth === undefined ?
            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
        } else {
          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
        }
      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
        this.fsw._emitReady();
      });
    } else {
      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
      this.fsw._emitReady();
    }
  } catch (error) {
    if (!error || this.fsw._handleError(error)) {
      // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
      this.fsw._emitReady();
      this.fsw._emitReady();
    }
  }

  if (opts.persistent && forceAdd !== true) {
    if (typeof transform === FUNCTION_TYPE) {
      // realpath has already been resolved
      this.initWatch(undefined, path, wh, processPath);
    } else {
      let realPath;
      try {
        realPath = await realpath(wh.watchPath);
      } catch (e) {}
      this.initWatch(realPath, path, wh, processPath);
    }
  }
}

}

module.exports = FsEventsHandler;
module.exports.canUse = canUse;


/***/ }),

/***/ "./node_modules/chokidar/lib/nodefs-handler.js":
/*!*****************************************************!*\
  !*** ./node_modules/chokidar/lib/nodefs-handler.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const { promisify } = __webpack_require__(/*! util */ "util");
const isBinaryPath = __webpack_require__(/*! is-binary-path */ "./node_modules/is-binary-path/index.js");
const {
  isWindows,
  isLinux,
  EMPTY_FN,
  EMPTY_STR,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE,
  EV_ADD,
  EV_ADD_DIR,
  EV_ERROR,
  STR_DATA,
  STR_END,
  BRACE_START,
  STAR
} = __webpack_require__(/*! ./constants */ "./node_modules/chokidar/lib/constants.js");

const THROTTLE_MODE_WATCH = 'watch';

const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const fsrealpath = promisify(fs.realpath);

const statMethods = { lstat, stat };

// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};

const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], (listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const {listener, errHandler, rawEmitter} = handlers;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher) return;
    watcher.on(EV_ERROR, async (error) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows && error.code === 'EPERM') {
        try {
          const fd = await open(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const {listener, rawEmitter} = handlers;
  let cont = FsWatchFileInstances.get(fullPath);

  /* eslint-disable no-unused-vars, prefer-destructuring */
  let listeners = new Set();
  let rawEmitters = new Set();

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */
class NodeFsHandler {

/**
 * @param {import("../index").FSWatcher} fsW
 */
constructor(fsW) {
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath.dirname(path);
  const basename = sysPath.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = EMPTY_FN;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath.dirname(file);
  const basename = sysPath.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  const listener = async (path, newStats) => {
    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
    if (!newStats || newStats.mtimeMs === 0) {
      try {
        const newStats = await stat(file);
        if (this.fsw.closed) return;
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE, file, newStats);
        }
        if (isLinux && prevStats.ino !== newStats.ino) {
          this.fsw._closeFile(path)
          prevStats = newStats;
          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
        } else {
          prevStats = newStats;
        }
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
      // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit(EV_CHANGE, file, newStats);
      }
      prevStats = newStats;
    }
  }
  // kick off the watcher
  const closer = this._watchWithNodeFs(file, listener);

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle(EV_ADD, file, 0)) return;
    this.fsw._emit(EV_ADD, file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */
async _handleSymlink(entry, directory, path, item) {
  if (this.fsw.closed) {
    return;
  }
  const full = entry.fullPath;
  const dir = this.fsw._getWatchedDir(directory);

  if (!this.fsw.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this.fsw._incrReadyCount();

    let linkPath;
    try {
      linkPath = await fsrealpath(path);
    } catch (e) {
      this.fsw._emitReady();
      return true;
    }

    if (this.fsw.closed) return;
    if (dir.has(item)) {
      if (this.fsw._symlinkPaths.get(full) !== linkPath) {
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_CHANGE, path, entry.stats);
      }
    } else {
      dir.add(item);
      this.fsw._symlinkPaths.set(full, linkPath);
      this.fsw._emit(EV_ADD, path, entry.stats);
    }
    this.fsw._emitReady();
    return true;
  }

  // don't follow the same symlink more than once
  if (this.fsw._symlinkPaths.has(full)) {
    return true;
  }

  this.fsw._symlinkPaths.set(full, true);
}

_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
  // Normalize the directory name on Windows
  directory = sysPath.join(directory, EMPTY_STR);

  if (!wh.hasGlob) {
    throttler = this.fsw._throttle('readdir', directory, 1000);
    if (!throttler) return;
  }

  const previous = this.fsw._getWatchedDir(wh.path);
  const current = new Set();

  let stream = this.fsw._readdirp(directory, {
    fileFilter: entry => wh.filterPath(entry),
    directoryFilter: entry => wh.filterDir(entry),
    depth: 0
  }).on(STR_DATA, async (entry) => {
    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    const item = entry.path;
    let path = sysPath.join(directory, item);
    current.add(item);

    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
      return;
    }

    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    // Files that present in current directory snapshot
    // but absent in previous are added to watch list and
    // emit `add` event.
    if (item === target || !target && !previous.has(item)) {
      this.fsw._incrReadyCount();

      // ensure relativeness of path is preserved in case of watcher reuse
      path = sysPath.join(dir, sysPath.relative(dir, path));

      this._addToNodeFs(path, initialAdd, wh, depth + 1);
    }
  }).on(EV_ERROR, this._boundHandleError);

  return new Promise(resolve =>
    stream.once(STR_END, () => {
      if (this.fsw.closed) {
        stream = undefined;
        return;
      }
      const wasThrottled = throttler ? throttler.clear() : false;

      resolve();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.getChildren().filter((item) => {
        return item !== directory &&
          !current.has(item) &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach((item) => {
        this.fsw._remove(directory, item);
      });

      stream = undefined;

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
    })
  );
}

/**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targeted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */
async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
  const tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this.fsw._getWatchedDir(dir);
  let throttler;
  let closer;

  const oDepth = this.fsw.options.depth;
  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
    if (!target) {
      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
      if (this.fsw.closed) return;
    }

    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
      // if current directory is removed, do nothing
      if (stats && stats.mtimeMs === 0) return;

      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
    });
  }
  return closer;
}

/**
 * Handle added file, directory, or glob pattern.
 * Delegates call to _handleFile / _handleDir after checks.
 * @param {String} path to file or ir
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @param {Object} priorWh depth relative to user-supplied path
 * @param {Number} depth Child path actually targeted for watch
 * @param {String=} target Child path actually targeted for watch
 * @returns {Promise}
 */
async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
  const ready = this.fsw._emitReady;
  if (this.fsw._isIgnored(path) || this.fsw.closed) {
    ready();
    return false;
  }

  const wh = this.fsw._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = entry => priorWh.filterPath(entry);
    wh.filterDir = entry => priorWh.filterDir(entry);
  }

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      ready();
      return false;
    }

    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
    let closer;
    if (stats.isDirectory()) {
      const absPath = sysPath.resolve(path);
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
      if (this.fsw.closed) return;
      // preserve this symlink's target path
      if (absPath !== targetPath && targetPath !== undefined) {
        this.fsw._symlinkPaths.set(absPath, targetPath);
      }
    } else if (stats.isSymbolicLink()) {
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      const parent = sysPath.dirname(wh.watchPath);
      this.fsw._getWatchedDir(parent).add(wh.watchPath);
      this.fsw._emit(EV_ADD, wh.watchPath, stats);
      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
      if (this.fsw.closed) return;

      // preserve this symlink's target path
      if (targetPath !== undefined) {
        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
      }
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd);
    }
    ready();

    this.fsw._addPathCloser(path, closer);
    return false;

  } catch (error) {
    if (this.fsw._handleError(error)) {
      ready();
      return path;
    }
  }
}

}

module.exports = NodeFsHandler;


/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");
const route = __webpack_require__(/*! ./route */ "./node_modules/color-convert/route.js");

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/content-disposition/index.js":
/*!***************************************************!*\
  !*** ./node_modules/content-disposition/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = (__webpack_require__(/*! path */ "path").basename)
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.substr(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 5987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
      value = Buffer.from(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */

function pencode (char) {
  return '%' + String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),

/***/ "./node_modules/content-type/index.js":
/*!********************************************!*\
  !*** ./node_modules/content-type/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * Module exports.
 * @public
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var type = obj.type

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  var string = type

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object'
    ? getcontenttype(string)
    : string

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = header.indexOf(';')
  var type = index !== -1
    ? header.slice(0, index).trim()
    : header.trim()

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type')
  }

  var obj = new ContentType(type.toLowerCase())

  // parse parameters
  if (index !== -1) {
    var key
    var match
    var value

    PARAM_REGEXP.lastIndex = index

    while ((match = PARAM_REGEXP.exec(header))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format')
      }

      index += match[0].length
      key = match[1].toLowerCase()
      value = match[2]

      if (value.charCodeAt(0) === 0x22 /* " */) {
        // remove quotes
        value = value.slice(1, -1)

        // remove escapes
        if (value.indexOf('\\') !== -1) {
          value = value.replace(QESC_REGEXP, '$1')
        }
      }

      obj.parameters[key] = value
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format')
    }
  }

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype (obj) {
  var header

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type')
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type']
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object')
  }

  return header
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType (type) {
  this.parameters = Object.create(null)
  this.type = type
}


/***/ }),

/***/ "./node_modules/cookie-parser/index.js":
/*!*********************************************!*\
  !*** ./node_modules/cookie-parser/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * cookie-parser
 * Copyright(c) 2014 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var cookie = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js")
var signature = __webpack_require__(/*! cookie-signature */ "./node_modules/cookie-signature/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = cookieParser
module.exports.JSONCookie = JSONCookie
module.exports.JSONCookies = JSONCookies
module.exports.signedCookie = signedCookie
module.exports.signedCookies = signedCookies

/**
 * Parse Cookie header and populate `req.cookies`
 * with an object keyed by the cookie names.
 *
 * @param {string|array} [secret] A string (or array of strings) representing cookie signing secret(s).
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function cookieParser (secret, options) {
  var secrets = !secret || Array.isArray(secret)
    ? (secret || [])
    : [secret]

  return function cookieParser (req, res, next) {
    if (req.cookies) {
      return next()
    }

    var cookies = req.headers.cookie

    req.secret = secrets[0]
    req.cookies = Object.create(null)
    req.signedCookies = Object.create(null)

    // no cookies
    if (!cookies) {
      return next()
    }

    req.cookies = cookie.parse(cookies, options)

    // parse signed cookies
    if (secrets.length !== 0) {
      req.signedCookies = signedCookies(req.cookies, secrets)
      req.signedCookies = JSONCookies(req.signedCookies)
    }

    // parse JSON cookies
    req.cookies = JSONCookies(req.cookies)

    next()
  }
}

/**
 * Parse JSON cookie string.
 *
 * @param {String} str
 * @return {Object} Parsed object or undefined if not json cookie
 * @public
 */

function JSONCookie (str) {
  if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') {
    return undefined
  }

  try {
    return JSON.parse(str.slice(2))
  } catch (err) {
    return undefined
  }
}

/**
 * Parse JSON cookies.
 *
 * @param {Object} obj
 * @return {Object}
 * @public
 */

function JSONCookies (obj) {
  var cookies = Object.keys(obj)
  var key
  var val

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i]
    val = JSONCookie(obj[key])

    if (val) {
      obj[key] = val
    }
  }

  return obj
}

/**
 * Parse a signed cookie string, return the decoded value.
 *
 * @param {String} str signed cookie string
 * @param {string|array} secret
 * @return {String} decoded value
 * @public
 */

function signedCookie (str, secret) {
  if (typeof str !== 'string') {
    return undefined
  }

  if (str.substr(0, 2) !== 's:') {
    return str
  }

  var secrets = !secret || Array.isArray(secret)
    ? (secret || [])
    : [secret]

  for (var i = 0; i < secrets.length; i++) {
    var val = signature.unsign(str.slice(2), secrets[i])

    if (val !== false) {
      return val
    }
  }

  return false
}

/**
 * Parse signed cookies, returning an object containing the decoded key/value
 * pairs, while removing the signed key from obj.
 *
 * @param {Object} obj
 * @param {string|array} secret
 * @return {Object}
 * @public
 */

function signedCookies (obj, secret) {
  var cookies = Object.keys(obj)
  var dec
  var key
  var ret = Object.create(null)
  var val

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i]
    val = obj[key]
    dec = signedCookie(val, secret)

    if (val !== dec) {
      ret[key] = dec
      delete obj[key]
    }
  }

  return ret
}


/***/ }),

/***/ "./node_modules/cookie-signature/index.js":
/*!************************************************!*\
  !*** ./node_modules/cookie-signature/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(/*! crypto */ "crypto");

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}


/***/ }),

/***/ "./node_modules/cookie/index.js":
/*!**************************************!*\
  !*** ./node_modules/cookie/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString
var __hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */

var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode;
  var index = 0;
  var eqIdx = 0;
  var endIdx = 0;

  do {
    eqIdx = str.indexOf('=', index);
    if (eqIdx === -1) break; // No more cookie pairs.

    endIdx = str.indexOf(';', index);

    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1;
      continue;
    }

    var keyStartIdx = startIndex(str, index, eqIdx);
    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    var key = str.slice(keyStartIdx, keyEndIdx);

    // only assign once
    if (!__hasOwnProperty.call(obj, key)) {
      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str, endIdx, valStartIdx);

      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
        valStartIdx++;
        valEndIdx--;
      }

      var val = str.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode(val, dec);
    }

    index = endIdx + 1
  } while (index < len);

  return obj;
}

function startIndex(str, index, max) {
  do {
    var code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}

function endIndex(str, index, min) {
  while (index > min) {
    var code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);

    if (!isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + maxAge;
  }

  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    var expires = opt.expires

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString()
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned'
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode (str) {
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/depd/index.js":
/*!************************************!*\
  !*** ./node_modules/depd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var relative = (__webpack_require__(/*! path */ "path").relative)

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/)
  var ns = String(namespace).toLowerCase()

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter () { return value }

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + stack[i].toString()
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if event emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function eehaslisteners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eehaslisteners(process, 'deprecation')

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var depSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    callSite.name = depSite.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    depSite = callSiteLocation(stack[i])
    callSite = depSite
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  var msg = message
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var output = format.call(this, msg, caller, stack.slice(i))
  process.stderr.write(output + '\n', 'utf8')
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + stack[i].toString()
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

  // eslint-disable-next-line no-new-func
  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
    '"use strict"\n' +
    'return function (' + args + ') {' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '}')(fn, log, this, message, site)

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val
    }
  })

  return error
}


/***/ }),

/***/ "./node_modules/destroy/index.js":
/*!***************************************!*\
  !*** ./node_modules/destroy/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter)
var ReadStream = (__webpack_require__(/*! fs */ "fs").ReadStream)
var Stream = __webpack_require__(/*! stream */ "stream")
var Zlib = __webpack_require__(/*! zlib */ "zlib")

/**
 * Module exports.
 * @public
 */

module.exports = destroy

/**
 * Destroy the given stream, and optionally suppress any future `error` events.
 *
 * @param {object} stream
 * @param {boolean} suppress
 * @public
 */

function destroy (stream, suppress) {
  if (isFsReadStream(stream)) {
    destroyReadStream(stream)
  } else if (isZlibStream(stream)) {
    destroyZlibStream(stream)
  } else if (hasDestroy(stream)) {
    stream.destroy()
  }

  if (isEventEmitter(stream) && suppress) {
    stream.removeAllListeners('error')
    stream.addListener('error', noop)
  }

  return stream
}

/**
 * Destroy a ReadStream.
 *
 * @param {object} stream
 * @private
 */

function destroyReadStream (stream) {
  stream.destroy()

  if (typeof stream.close === 'function') {
    // node.js core bug work-around
    stream.on('open', onOpenClose)
  }
}

/**
 * Close a Zlib stream.
 *
 * Zlib streams below Node.js 4.5.5 have a buggy implementation
 * of .close() when zlib encountered an error.
 *
 * @param {object} stream
 * @private
 */

function closeZlibStream (stream) {
  if (stream._hadError === true) {
    var prop = stream._binding === null
      ? '_binding'
      : '_handle'

    stream[prop] = {
      close: function () { this[prop] = null }
    }
  }

  stream.close()
}

/**
 * Destroy a Zlib stream.
 *
 * Zlib streams don't have a destroy function in Node.js 6. On top of that
 * simply calling destroy on a zlib stream in Node.js 8+ will result in a
 * memory leak. So until that is fixed, we need to call both close AND destroy.
 *
 * PR to fix memory leak: https://github.com/nodejs/node/pull/23734
 *
 * In Node.js 6+8, it's important that destroy is called before close as the
 * stream would otherwise emit the error 'zlib binding closed'.
 *
 * @param {object} stream
 * @private
 */

function destroyZlibStream (stream) {
  if (typeof stream.destroy === 'function') {
    // node.js core bug work-around
    // istanbul ignore if: node.js 0.8
    if (stream._binding) {
      // node.js < 0.10.0
      stream.destroy()
      if (stream._processing) {
        stream._needDrain = true
        stream.once('drain', onDrainClearBinding)
      } else {
        stream._binding.clear()
      }
    } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
      // node.js >= 12, ^11.1.0, ^10.15.1
      stream.destroy()
    } else if (stream._destroy && typeof stream.close === 'function') {
      // node.js 7, 8
      stream.destroyed = true
      stream.close()
    } else {
      // fallback
      // istanbul ignore next
      stream.destroy()
    }
  } else if (typeof stream.close === 'function') {
    // node.js < 8 fallback
    closeZlibStream(stream)
  }
}

/**
 * Determine if stream has destroy.
 * @private
 */

function hasDestroy (stream) {
  return stream instanceof Stream &&
    typeof stream.destroy === 'function'
}

/**
 * Determine if val is EventEmitter.
 * @private
 */

function isEventEmitter (val) {
  return val instanceof EventEmitter
}

/**
 * Determine if stream is fs.ReadStream stream.
 * @private
 */

function isFsReadStream (stream) {
  return stream instanceof ReadStream
}

/**
 * Determine if stream is Zlib stream.
 * @private
 */

function isZlibStream (stream) {
  return stream instanceof Zlib.Gzip ||
    stream instanceof Zlib.Gunzip ||
    stream instanceof Zlib.Deflate ||
    stream instanceof Zlib.DeflateRaw ||
    stream instanceof Zlib.Inflate ||
    stream instanceof Zlib.InflateRaw ||
    stream instanceof Zlib.Unzip
}

/**
 * No-op function.
 * @private
 */

function noop () {}

/**
 * On drain handler to clear binding.
 * @private
 */

// istanbul ignore next: node.js 0.8
function onDrainClearBinding () {
  this._binding.clear()
}

/**
 * On open handler to close stream.
 * @private
 */

function onOpenClose () {
  if (typeof this.fd === 'number') {
    // actually close down the fd
    this.close()
  }
}


/***/ }),

/***/ "./node_modules/ee-first/index.js":
/*!****************************************!*\
  !*** ./node_modules/ee-first/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}


/***/ }),

/***/ "./node_modules/emoji-regex/index.js":
/*!*******************************************!*\
  !*** ./node_modules/emoji-regex/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};


/***/ }),

/***/ "./node_modules/encodeurl/index.js":
/*!*****************************************!*\
  !*** ./node_modules/encodeurl/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/escalade/sync/index.js":
/*!*********************************************!*\
  !*** ./node_modules/escalade/sync/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { dirname, resolve } = __webpack_require__(/*! path */ "path");
const { readdirSync, statSync } = __webpack_require__(/*! fs */ "fs");

module.exports = function (start, callback) {
	let dir = resolve('.', start);
	let tmp, stats = statSync(dir);

	if (!stats.isDirectory()) {
		dir = dirname(dir);
	}

	while (true) {
		tmp = callback(dir, readdirSync(dir));
		if (tmp) return resolve(dir, tmp);
		dir = dirname(tmp = dir);
		if (tmp === dir) break;
	}
}


/***/ }),

/***/ "./node_modules/escape-html/index.js":
/*!*******************************************!*\
  !*** ./node_modules/escape-html/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),

/***/ "./node_modules/etag/index.js":
/*!************************************!*\
  !*** ./node_modules/etag/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = etag

/**
 * Module dependencies.
 * @private
 */

var crypto = __webpack_require__(/*! crypto */ "crypto")
var Stats = (__webpack_require__(/*! fs */ "fs").Stats)

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27)

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
}


/***/ }),

/***/ "./node_modules/express-session/index.js":
/*!***********************************************!*\
  !*** ./node_modules/express-session/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
var cookie = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js");
var crypto = __webpack_require__(/*! crypto */ "crypto")
var debug = __webpack_require__(/*! debug */ "./node_modules/express-session/node_modules/debug/src/index.js")('express-session');
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express-session');
var onHeaders = __webpack_require__(/*! on-headers */ "./node_modules/on-headers/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var signature = __webpack_require__(/*! cookie-signature */ "./node_modules/express-session/node_modules/cookie-signature/index.js")
var uid = (__webpack_require__(/*! uid-safe */ "./node_modules/uid-safe/index.js").sync)

var Cookie = __webpack_require__(/*! ./session/cookie */ "./node_modules/express-session/session/cookie.js")
var MemoryStore = __webpack_require__(/*! ./session/memory */ "./node_modules/express-session/session/memory.js")
var Session = __webpack_require__(/*! ./session/session */ "./node_modules/express-session/session/session.js")
var Store = __webpack_require__(/*! ./session/store */ "./node_modules/express-session/session/store.js")

// environment

var env = "development";

/**
 * Expose the middleware.
 */

exports = module.exports = session;

/**
 * Expose constructors.
 */

exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;

/**
 * Warning message for `MemoryStore` usage in production.
 * @private
 */

var warning = 'Warning: connect.session() MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and will not scale past a single process.';

/**
 * Node.js 0.8+ async implementation.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Setup session store with the given `options`.
 *
 * @param {Object} [options]
 * @param {Object} [options.cookie] Options for cookie
 * @param {Function} [options.genid]
 * @param {String} [options.name=connect.sid] Session ID cookie name
 * @param {Boolean} [options.proxy]
 * @param {Boolean} [options.resave] Resave unmodified sessions back to the store
 * @param {Boolean} [options.rolling] Enable/disable rolling session expiration
 * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store
 * @param {String|Array} [options.secret] Secret for signing session ID
 * @param {Object} [options.store=MemoryStore] Session store
 * @param {String} [options.unset]
 * @return {Function} middleware
 * @public
 */

function session(options) {
  var opts = options || {}

  // get the cookie options
  var cookieOptions = opts.cookie || {}

  // get the session id generate function
  var generateId = opts.genid || generateSessionId

  // get the session cookie name
  var name = opts.name || opts.key || 'connect.sid'

  // get the session store
  var store = opts.store || new MemoryStore()

  // get the trust proxy setting
  var trustProxy = opts.proxy

  // get the resave session option
  var resaveSession = opts.resave;

  // get the rolling session option
  var rollingSessions = Boolean(opts.rolling)

  // get the save uninitialized session option
  var saveUninitializedSession = opts.saveUninitialized

  // get the cookie signing secret
  var secret = opts.secret

  if (typeof generateId !== 'function') {
    throw new TypeError('genid option must be a function');
  }

  if (resaveSession === undefined) {
    deprecate('undefined resave option; provide resave option');
    resaveSession = true;
  }

  if (saveUninitializedSession === undefined) {
    deprecate('undefined saveUninitialized option; provide saveUninitialized option');
    saveUninitializedSession = true;
  }

  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {
    throw new TypeError('unset option must be "destroy" or "keep"');
  }

  // TODO: switch to "destroy" on next major
  var unsetDestroy = opts.unset === 'destroy'

  if (Array.isArray(secret) && secret.length === 0) {
    throw new TypeError('secret option array must contain one or more strings');
  }

  if (secret && !Array.isArray(secret)) {
    secret = [secret];
  }

  if (!secret) {
    deprecate('req.secret; provide secret option');
  }

  // notify user that this store is not
  // meant for a production environment
  /* istanbul ignore next: not tested */
  if (env === 'production' && store instanceof MemoryStore) {
    console.warn(warning);
  }

  // generates the new session
  store.generate = function(req){
    req.sessionID = generateId(req);
    req.session = new Session(req);
    req.session.cookie = new Cookie(cookieOptions);

    if (cookieOptions.secure === 'auto') {
      req.session.cookie.secure = issecure(req, trustProxy);
    }
  };

  var storeImplementsTouch = typeof store.touch === 'function';

  // register event listeners for the store to track readiness
  var storeReady = true
  store.on('disconnect', function ondisconnect() {
    storeReady = false
  })
  store.on('connect', function onconnect() {
    storeReady = true
  })

  return function session(req, res, next) {
    // self-awareness
    if (req.session) {
      next()
      return
    }

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    if (!storeReady) {
      debug('store is disconnected')
      next()
      return
    }

    // pathname mismatch
    var originalPath = parseUrl.original(req).pathname || '/'
    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) {
      debug('pathname mismatch')
      next()
      return
    }

    // ensure a secret is available or bail
    if (!secret && !req.secret) {
      next(new Error('secret option required for sessions'));
      return;
    }

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    var secrets = secret || [req.secret];

    var originalHash;
    var originalId;
    var savedHash;
    var touched = false

    // expose store
    req.sessionStore = store;

    // get the session ID from the cookie
    var cookieId = req.sessionID = getcookie(req, name, secrets);

    // set-cookie
    onHeaders(res, function(){
      if (!req.session) {
        debug('no session');
        return;
      }

      if (!shouldSetCookie(req)) {
        return;
      }

      // only send secure cookies via https
      if (req.session.cookie.secure && !issecure(req, trustProxy)) {
        debug('not secured');
        return;
      }

      if (!touched) {
        // touch session
        req.session.touch()
        touched = true
      }

      // set cookie
      try {
        setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data)
      } catch (err) {
        defer(next, err)
      }
    });

    // proxy end() to commit the session
    var _end = res.end;
    var _write = res.write;
    var ended = false;
    res.end = function end(chunk, encoding) {
      if (ended) {
        return false;
      }

      ended = true;

      var ret;
      var sync = true;

      function writeend() {
        if (sync) {
          ret = _end.call(res, chunk, encoding);
          sync = false;
          return;
        }

        _end.call(res);
      }

      function writetop() {
        if (!sync) {
          return ret;
        }

        if (!res._header) {
          res._implicitHeader()
        }

        if (chunk == null) {
          ret = true;
          return ret;
        }

        var contentLength = Number(res.getHeader('Content-Length'));

        if (!isNaN(contentLength) && contentLength > 0) {
          // measure chunk
          chunk = !Buffer.isBuffer(chunk)
            ? Buffer.from(chunk, encoding)
            : chunk;
          encoding = undefined;

          if (chunk.length !== 0) {
            debug('split response');
            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
            chunk = chunk.slice(chunk.length - 1, chunk.length);
            return ret;
          }
        }

        ret = _write.call(res, chunk, encoding);
        sync = false;

        return ret;
      }

      if (shouldDestroy(req)) {
        // destroy session
        debug('destroying');
        store.destroy(req.sessionID, function ondestroy(err) {
          if (err) {
            defer(next, err);
          }

          debug('destroyed');
          writeend();
        });

        return writetop();
      }

      // no session to save
      if (!req.session) {
        debug('no session');
        return _end.call(res, chunk, encoding);
      }

      if (!touched) {
        // touch session
        req.session.touch()
        touched = true
      }

      if (shouldSave(req)) {
        req.session.save(function onsave(err) {
          if (err) {
            defer(next, err);
          }

          writeend();
        });

        return writetop();
      } else if (storeImplementsTouch && shouldTouch(req)) {
        // store implements touch method
        debug('touching');
        store.touch(req.sessionID, req.session, function ontouch(err) {
          if (err) {
            defer(next, err);
          }

          debug('touched');
          writeend();
        });

        return writetop();
      }

      return _end.call(res, chunk, encoding);
    };

    // generate the session
    function generate() {
      store.generate(req);
      originalId = req.sessionID;
      originalHash = hash(req.session);
      wrapmethods(req.session);
    }

    // inflate the session
    function inflate (req, sess) {
      store.createSession(req, sess)
      originalId = req.sessionID
      originalHash = hash(sess)

      if (!resaveSession) {
        savedHash = originalHash
      }

      wrapmethods(req.session)
    }

    function rewrapmethods (sess, callback) {
      return function () {
        if (req.session !== sess) {
          wrapmethods(req.session)
        }

        callback.apply(this, arguments)
      }
    }

    // wrap session methods
    function wrapmethods(sess) {
      var _reload = sess.reload
      var _save = sess.save;

      function reload(callback) {
        debug('reloading %s', this.id)
        _reload.call(this, rewrapmethods(this, callback))
      }

      function save() {
        debug('saving %s', this.id);
        savedHash = hash(this);
        _save.apply(this, arguments);
      }

      Object.defineProperty(sess, 'reload', {
        configurable: true,
        enumerable: false,
        value: reload,
        writable: true
      })

      Object.defineProperty(sess, 'save', {
        configurable: true,
        enumerable: false,
        value: save,
        writable: true
      });
    }

    // check if session has been modified
    function isModified(sess) {
      return originalId !== sess.id || originalHash !== hash(sess);
    }

    // check if session has been saved
    function isSaved(sess) {
      return originalId === sess.id && savedHash === hash(sess);
    }

    // determine if session should be destroyed
    function shouldDestroy(req) {
      return req.sessionID && unsetDestroy && req.session == null;
    }

    // determine if session should be saved to store
    function shouldSave(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }

      return !saveUninitializedSession && !savedHash && cookieId !== req.sessionID
        ? isModified(req.session)
        : !isSaved(req.session)
    }

    // determine if session should be touched
    function shouldTouch(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }

      return cookieId === req.sessionID && !shouldSave(req);
    }

    // determine if cookie should be set on response
    function shouldSetCookie(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        return false;
      }

      return cookieId !== req.sessionID
        ? saveUninitializedSession || isModified(req.session)
        : rollingSessions || req.session.cookie.expires != null && isModified(req.session);
    }

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next();
      return;
    }

    // generate the session object
    debug('fetching %s', req.sessionID);
    store.get(req.sessionID, function(err, sess){
      // error handling
      if (err && err.code !== 'ENOENT') {
        debug('error %j', err);
        next(err)
        return
      }

      try {
        if (err || !sess) {
          debug('no session found')
          generate()
        } else {
          debug('session found')
          inflate(req, sess)
        }
      } catch (e) {
        next(e)
        return
      }

      next()
    });
  };
};

/**
 * Generate a session ID for a new session.
 *
 * @return {String}
 * @private
 */

function generateSessionId(sess) {
  return uid(24);
}

/**
 * Get the session ID cookie from request.
 *
 * @return {string}
 * @private
 */

function getcookie(req, name, secrets) {
  var header = req.headers.cookie;
  var raw;
  var val;

  // read from cookie header
  if (header) {
    var cookies = cookie.parse(header);

    raw = cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);

        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }

  // back-compat read from cookieParser() signedCookies data
  if (!val && req.signedCookies) {
    val = req.signedCookies[name];

    if (val) {
      deprecate('cookie should be available in req.headers.cookie');
    }
  }

  // back-compat read from cookieParser() cookies data
  if (!val && req.cookies) {
    raw = req.cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);

        if (val) {
          deprecate('cookie should be available in req.headers.cookie');
        }

        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }

  return val;
}

/**
 * Hash the given `sess` object omitting changes to `.cookie`.
 *
 * @param {Object} sess
 * @return {String}
 * @private
 */

function hash(sess) {
  // serialize
  var str = JSON.stringify(sess, function (key, val) {
    // ignore sess.cookie property
    if (this === sess && key === 'cookie') {
      return
    }

    return val
  })

  // hash
  return crypto
    .createHash('sha1')
    .update(str, 'utf8')
    .digest('hex')
}

/**
 * Determine if request is secure.
 *
 * @param {Object} req
 * @param {Boolean} [trustProxy]
 * @return {Boolean}
 * @private
 */

function issecure(req, trustProxy) {
  // socket is https server
  if (req.connection && req.connection.encrypted) {
    return true;
  }

  // do not trust proxy
  if (trustProxy === false) {
    return false;
  }

  // no explicit trust; try req.secure from express
  if (trustProxy !== true) {
    return req.secure === true
  }

  // read the proto from x-forwarded-proto header
  var header = req.headers['x-forwarded-proto'] || '';
  var index = header.indexOf(',');
  var proto = index !== -1
    ? header.substr(0, index).toLowerCase().trim()
    : header.toLowerCase().trim()

  return proto === 'https';
}

/**
 * Set cookie on response.
 *
 * @private
 */

function setcookie(res, name, val, secret, options) {
  var signed = 's:' + signature.sign(val, secret);
  var data = cookie.serialize(name, signed, options);

  debug('set-cookie %s', data);

  var prev = res.getHeader('Set-Cookie') || []
  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];

  res.setHeader('Set-Cookie', header)
}

/**
 * Verify and decode the given `val` with `secrets`.
 *
 * @param {String} val
 * @param {Array} secrets
 * @returns {String|Boolean}
 * @private
 */
function unsigncookie(val, secrets) {
  for (var i = 0; i < secrets.length; i++) {
    var result = signature.unsign(val, secrets[i]);

    if (result !== false) {
      return result;
    }
  }

  return false;
}


/***/ }),

/***/ "./node_modules/express-session/node_modules/cookie-signature/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/express-session/node_modules/cookie-signature/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(/*! crypto */ "crypto");

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' !== typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if (null == secret) throw new TypeError("Secret key must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' !== typeof val) throw new TypeError("Signed cookie string must be provided.");
  if (null == secret) throw new TypeError("Secret key must be provided.");
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}


/***/ }),

/***/ "./node_modules/express-session/node_modules/debug/src/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/express-session/node_modules/debug/src/browser.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express-session/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/express-session/node_modules/debug/src/debug.js":
/*!**********************************************************************!*\
  !*** ./node_modules/express-session/node_modules/debug/src/debug.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/express-session/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/express-session/node_modules/debug/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/express-session/node_modules/debug/src/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/express-session/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/express-session/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/express-session/node_modules/debug/src/node.js":
/*!*********************************************************************!*\
  !*** ./node_modules/express-session/node_modules/debug/src/node.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express-session/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/express-session/node_modules/ms/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/express-session/node_modules/ms/index.js ***!
  \***************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/express-session/session/cookie.js":
/*!********************************************************!*\
  !*** ./node_modules/express-session/session/cookie.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Connect - session - Cookie
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var cookie = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js")
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express-session')

/**
 * Initialize a new `Cookie` with the given `options`.
 *
 * @param {IncomingMessage} req
 * @param {Object} options
 * @api private
 */

var Cookie = module.exports = function Cookie(options) {
  this.path = '/';
  this.maxAge = null;
  this.httpOnly = true;

  if (options) {
    if (typeof options !== 'object') {
      throw new TypeError('argument options must be a object')
    }

    for (var key in options) {
      if (key !== 'data') {
        this[key] = options[key]
      }
    }
  }

  if (this.originalMaxAge === undefined || this.originalMaxAge === null) {
    this.originalMaxAge = this.maxAge
  }
};

/*!
 * Prototype.
 */

Cookie.prototype = {

  /**
   * Set expires `date`.
   *
   * @param {Date} date
   * @api public
   */

  set expires(date) {
    this._expires = date;
    this.originalMaxAge = this.maxAge;
  },

  /**
   * Get expires `date`.
   *
   * @return {Date}
   * @api public
   */

  get expires() {
    return this._expires;
  },

  /**
   * Set expires via max-age in `ms`.
   *
   * @param {Number} ms
   * @api public
   */

  set maxAge(ms) {
    if (ms && typeof ms !== 'number' && !(ms instanceof Date)) {
      throw new TypeError('maxAge must be a number or Date')
    }

    if (ms instanceof Date) {
      deprecate('maxAge as Date; pass number of milliseconds instead')
    }

    this.expires = typeof ms === 'number'
      ? new Date(Date.now() + ms)
      : ms;
  },

  /**
   * Get expires max-age in `ms`.
   *
   * @return {Number}
   * @api public
   */

  get maxAge() {
    return this.expires instanceof Date
      ? this.expires.valueOf() - Date.now()
      : this.expires;
  },

  /**
   * Return cookie data object.
   *
   * @return {Object}
   * @api private
   */

  get data() {
    return {
      originalMaxAge: this.originalMaxAge,
      partitioned: this.partitioned,
      priority: this.priority
      , expires: this._expires
      , secure: this.secure
      , httpOnly: this.httpOnly
      , domain: this.domain
      , path: this.path
      , sameSite: this.sameSite
    }
  },

  /**
   * Return a serialized cookie string.
   *
   * @return {String}
   * @api public
   */

  serialize: function(name, val){
    return cookie.serialize(name, val, this.data);
  },

  /**
   * Return JSON representation of this cookie.
   *
   * @return {Object}
   * @api private
   */

  toJSON: function(){
    return this.data;
  }
};


/***/ }),

/***/ "./node_modules/express-session/session/memory.js":
/*!********************************************************!*\
  !*** ./node_modules/express-session/session/memory.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Store = __webpack_require__(/*! ./store */ "./node_modules/express-session/session/store.js")
var util = __webpack_require__(/*! util */ "util")

/**
 * Shim setImmediate for node.js < 0.10
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Module exports.
 */

module.exports = MemoryStore

/**
 * A session store in memory.
 * @public
 */

function MemoryStore() {
  Store.call(this)
  this.sessions = Object.create(null)
}

/**
 * Inherit from Store.
 */

util.inherits(MemoryStore, Store)

/**
 * Get all active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.all = function all(callback) {
  var sessionIds = Object.keys(this.sessions)
  var sessions = Object.create(null)

  for (var i = 0; i < sessionIds.length; i++) {
    var sessionId = sessionIds[i]
    var session = getSession.call(this, sessionId)

    if (session) {
      sessions[sessionId] = session;
    }
  }

  callback && defer(callback, null, sessions)
}

/**
 * Clear all sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.clear = function clear(callback) {
  this.sessions = Object.create(null)
  callback && defer(callback)
}

/**
 * Destroy the session associated with the given session ID.
 *
 * @param {string} sessionId
 * @public
 */

MemoryStore.prototype.destroy = function destroy(sessionId, callback) {
  delete this.sessions[sessionId]
  callback && defer(callback)
}

/**
 * Fetch session by the given session ID.
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.get = function get(sessionId, callback) {
  defer(callback, null, getSession.call(this, sessionId))
}

/**
 * Commit the given session associated with the given sessionId to the store.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.set = function set(sessionId, session, callback) {
  this.sessions[sessionId] = JSON.stringify(session)
  callback && defer(callback)
}

/**
 * Get number of active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.length = function length(callback) {
  this.all(function (err, sessions) {
    if (err) return callback(err)
    callback(null, Object.keys(sessions).length)
  })
}

/**
 * Touch the given session object associated with the given session ID.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.touch = function touch(sessionId, session, callback) {
  var currentSession = getSession.call(this, sessionId)

  if (currentSession) {
    // update expiration
    currentSession.cookie = session.cookie
    this.sessions[sessionId] = JSON.stringify(currentSession)
  }

  callback && defer(callback)
}

/**
 * Get session from the store.
 * @private
 */

function getSession(sessionId) {
  var sess = this.sessions[sessionId]

  if (!sess) {
    return
  }

  // parse
  sess = JSON.parse(sess)

  if (sess.cookie) {
    var expires = typeof sess.cookie.expires === 'string'
      ? new Date(sess.cookie.expires)
      : sess.cookie.expires

    // destroy expired session
    if (expires && expires <= Date.now()) {
      delete this.sessions[sessionId]
      return
    }
  }

  return sess
}


/***/ }),

/***/ "./node_modules/express-session/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/express-session/session/session.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
/*!
 * Connect - session - Session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */



/**
 * Expose Session.
 */

module.exports = Session;

/**
 * Create a new `Session` with the given request and `data`.
 *
 * @param {IncomingRequest} req
 * @param {Object} data
 * @api private
 */

function Session(req, data) {
  Object.defineProperty(this, 'req', { value: req });
  Object.defineProperty(this, 'id', { value: req.sessionID });

  if (typeof data === 'object' && data !== null) {
    // merge data into this, ignoring prototype properties
    for (var prop in data) {
      if (!(prop in this)) {
        this[prop] = data[prop]
      }
    }
  }
}

/**
 * Update reset `.cookie.maxAge` to prevent
 * the cookie from expiring when the
 * session is still active.
 *
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'touch', function touch() {
  return this.resetMaxAge();
});

/**
 * Reset `.maxAge` to `.originalMaxAge`.
 *
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'resetMaxAge', function resetMaxAge() {
  this.cookie.maxAge = this.cookie.originalMaxAge;
  return this;
});

/**
 * Save the session data with optional callback `fn(err)`.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'save', function save(fn) {
  this.req.sessionStore.set(this.id, this, fn || function(){});
  return this;
});

/**
 * Re-loads the session data _without_ altering
 * the maxAge properties. Invokes the callback `fn(err)`,
 * after which time if no exception has occurred the
 * `req.session` property will be a new `Session` object,
 * although representing the same session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'reload', function reload(fn) {
  var req = this.req
  var store = this.req.sessionStore

  store.get(this.id, function(err, sess){
    if (err) return fn(err);
    if (!sess) return fn(new Error('failed to load session'));
    store.createSession(req, sess);
    fn();
  });
  return this;
});

/**
 * Destroy `this` session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'destroy', function destroy(fn) {
  delete this.req.session;
  this.req.sessionStore.destroy(this.id, fn);
  return this;
});

/**
 * Regenerate this request's session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'regenerate', function regenerate(fn) {
  this.req.sessionStore.regenerate(this.req, fn);
  return this;
});

/**
 * Helper function for creating a method on a prototype.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} fn
 * @private
 */
function defineMethod(obj, name, fn) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: false,
    value: fn,
    writable: true
  });
};


/***/ }),

/***/ "./node_modules/express-session/session/store.js":
/*!*******************************************************!*\
  !*** ./node_modules/express-session/session/store.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Connect - session - Store
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Cookie = __webpack_require__(/*! ./cookie */ "./node_modules/express-session/session/cookie.js")
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter)
var Session = __webpack_require__(/*! ./session */ "./node_modules/express-session/session/session.js")
var util = __webpack_require__(/*! util */ "util")

/**
 * Module exports.
 * @public
 */

module.exports = Store

/**
 * Abstract base class for session stores.
 * @public
 */

function Store () {
  EventEmitter.call(this)
}

/**
 * Inherit from EventEmitter.
 */

util.inherits(Store, EventEmitter)

/**
 * Re-generate the given requests's session.
 *
 * @param {IncomingRequest} req
 * @return {Function} fn
 * @api public
 */

Store.prototype.regenerate = function(req, fn){
  var self = this;
  this.destroy(req.sessionID, function(err){
    self.generate(req);
    fn(err);
  });
};

/**
 * Load a `Session` instance via the given `sid`
 * and invoke the callback `fn(err, sess)`.
 *
 * @param {String} sid
 * @param {Function} fn
 * @api public
 */

Store.prototype.load = function(sid, fn){
  var self = this;
  this.get(sid, function(err, sess){
    if (err) return fn(err);
    if (!sess) return fn();
    var req = { sessionID: sid, sessionStore: self };
    fn(null, self.createSession(req, sess))
  });
};

/**
 * Create session from JSON `sess` data.
 *
 * @param {IncomingRequest} req
 * @param {Object} sess
 * @return {Session}
 * @api private
 */

Store.prototype.createSession = function(req, sess){
  var expires = sess.cookie.expires
  var originalMaxAge = sess.cookie.originalMaxAge

  sess.cookie = new Cookie(sess.cookie);

  if (typeof expires === 'string') {
    // convert expires to a Date object
    sess.cookie.expires = new Date(expires)
  }

  // keep originalMaxAge intact
  sess.cookie.originalMaxAge = originalMaxAge

  req.session = new Session(req, sess);
  return req.session;
};


/***/ }),

/***/ "./node_modules/express/index.js":
/*!***************************************!*\
  !*** ./node_modules/express/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



module.exports = __webpack_require__(/*! ./lib/express */ "./node_modules/express/lib/express.js");


/***/ }),

/***/ "./node_modules/express/lib/application.js":
/*!*************************************************!*\
  !*** ./node_modules/express/lib/application.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var finalhandler = __webpack_require__(/*! finalhandler */ "./node_modules/finalhandler/index.js");
var Router = __webpack_require__(/*! ./router */ "./node_modules/express/lib/router/index.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");
var middleware = __webpack_require__(/*! ./middleware/init */ "./node_modules/express/lib/middleware/init.js");
var query = __webpack_require__(/*! ./middleware/query */ "./node_modules/express/lib/middleware/query.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:application');
var View = __webpack_require__(/*! ./view */ "./node_modules/express/lib/view.js");
var http = __webpack_require__(/*! http */ "http");
var compileETag = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileETag);
var compileQueryParser = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileQueryParser);
var compileTrust = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileTrust);
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var resolve = (__webpack_require__(/*! path */ "path").resolve);
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty
var slice = Array.prototype.slice;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = "development" || 0;

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'extended');
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    setPrototypeOf(this.request, parent.request)
    setPrototypeOf(this.response, parent.response)
    setPrototypeOf(this.engines, parent.engines)
    setPrototypeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', View);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }

  Object.defineProperty(this, 'router', {
    get: function() {
      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
    }
  });
};

/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @private
 */
app.lazyrouter = function lazyrouter() {
  if (!this._router) {
    this._router = new Router({
      caseSensitive: this.enabled('case sensitive routing'),
      strict: this.enabled('strict routing')
    });

    this._router.use(query(this.get('query parser fn')));
    this._router.use(middleware.init(this));
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  var router = this._router;

  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router) {
    debug('no routes defined on app');
    done();
    return;
  }

  router.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // setup router
  this.lazyrouter();
  var router = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setPrototypeOf(req, orig.request)
        setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path) {
  this.lazyrouter();
  return this._router.route(path);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you don't need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.'
    ? '.' + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    var settings = this.settings

    while (settings && settings !== Object.prototype) {
      if (hasOwnProperty.call(settings, setting)) {
        return settings[setting]
      }

      settings = Object.getPrototypeOf(settings)
    }

    return undefined
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function(method){
  app[method] = function(path){
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path);
    }

    this.lazyrouter();

    var route = this._router.route(path);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path) {
  this.lazyrouter();

  var route = this._router.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

// del -> delete alias

app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge app.locals
  merge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    merge(renderOptions, opts._locals);
  }

  // merge options
  merge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get('view');

    view = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) && view.root.length > 1
        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
        : 'directory "' + view.root + '"'
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view, options, callback) {
  try {
    view.render(options, callback);
  } catch (err) {
    callback(err);
  }
}


/***/ }),

/***/ "./node_modules/express/lib/express.js":
/*!*********************************************!*\
  !*** ./node_modules/express/lib/express.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bodyParser = __webpack_require__(/*! body-parser */ "./node_modules/body-parser/index.js")
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var mixin = __webpack_require__(/*! merge-descriptors */ "./node_modules/merge-descriptors/index.js");
var proto = __webpack_require__(/*! ./application */ "./node_modules/express/lib/application.js");
var Route = __webpack_require__(/*! ./router/route */ "./node_modules/express/lib/router/route.js");
var Router = __webpack_require__(/*! ./router */ "./node_modules/express/lib/router/index.js");
var req = __webpack_require__(/*! ./request */ "./node_modules/express/lib/request.js");
var res = __webpack_require__(/*! ./response */ "./node_modules/express/lib/response.js");

/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.query = __webpack_require__(/*! ./middleware/query */ "./node_modules/express/lib/middleware/query.js");
exports.raw = bodyParser.raw
exports["static"] = __webpack_require__(/*! serve-static */ "./node_modules/serve-static/index.js");
exports.text = bodyParser.text
exports.urlencoded = bodyParser.urlencoded

/**
 * Replace removed middleware with an appropriate error message.
 */

var removedMiddlewares = [
  'bodyParser',
  'compress',
  'cookieSession',
  'session',
  'logger',
  'cookieParser',
  'favicon',
  'responseTime',
  'errorHandler',
  'timeout',
  'methodOverride',
  'vhost',
  'csrf',
  'directory',
  'limit',
  'multipart',
  'staticCache'
]

removedMiddlewares.forEach(function (name) {
  Object.defineProperty(exports, name, {
    get: function () {
      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
    },
    configurable: true
  });
});


/***/ }),

/***/ "./node_modules/express/lib/middleware/init.js":
/*!*****************************************************!*\
  !*** ./node_modules/express/lib/middleware/init.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")

/**
 * Initialization middleware, exposing the
 * request and response to each other, as well
 * as defaulting the X-Powered-By header field.
 *
 * @param {Function} app
 * @return {Function}
 * @api private
 */

exports.init = function(app){
  return function expressInit(req, res, next){
    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
    req.res = res;
    res.req = req;
    req.next = next;

    setPrototypeOf(req, app.request)
    setPrototypeOf(res, app.response)

    res.locals = res.locals || Object.create(null);

    next();
  };
};



/***/ }),

/***/ "./node_modules/express/lib/middleware/query.js":
/*!******************************************************!*\
  !*** ./node_modules/express/lib/middleware/query.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var qs = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");

/**
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function query(options) {
  var opts = merge({}, options)
  var queryparse = qs.parse;

  if (typeof options === 'function') {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined && opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
};


/***/ }),

/***/ "./node_modules/express/lib/request.js":
/*!*********************************************!*\
  !*** ./node_modules/express/lib/request.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var isIP = (__webpack_require__(/*! net */ "net").isIP);
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js");
var http = __webpack_require__(/*! http */ "http");
var fresh = __webpack_require__(/*! fresh */ "./node_modules/fresh/index.js");
var parseRange = __webpack_require__(/*! range-parser */ "./node_modules/range-parser/index.js");
var parse = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var proxyaddr = __webpack_require__(/*! proxy-addr */ "./node_modules/proxy-addr/index.js");

/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = req

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get =
req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function(){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function(){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
  'req.acceptsEncoding: Use acceptsEncodings instead');

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function(){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

req.acceptsCharset = deprecate.function(req.acceptsCharsets,
  'req.acceptsCharset: Use acceptsCharsets instead');

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function(){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
  'req.acceptsLanguage: Use acceptsLanguages instead');

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
};

/**
 * Return the value of param `name` when present or `defaultValue`.
 *
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 *
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `bodyParser()` middleware.
 *
 * @param {String} name
 * @param {Mixed} [defaultValue]
 * @return {String}
 * @public
 */

req.param = function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1
    ? 'name'
    : 'name, default';
  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the given mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path() {
  return parse(this).pathname;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  } else if (host.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    host = host.substring(0, host.indexOf(',')).trimRight()
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
});

// TODO: change req.host to return host in next major

defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'));

/**
 * Check if the request is fresh, aka
 * Last-Modified and/or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale(){
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}


/***/ }),

/***/ "./node_modules/express/lib/response.js":
/*!**********************************************!*\
  !*** ./node_modules/express/lib/response.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
var contentDisposition = __webpack_require__(/*! content-disposition */ "./node_modules/content-disposition/index.js");
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js");
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js");
var http = __webpack_require__(/*! http */ "http");
var isAbsolute = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").isAbsolute);
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js");
var path = __webpack_require__(/*! path */ "path");
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var sign = (__webpack_require__(/*! cookie-signature */ "./node_modules/cookie-signature/index.js").sign);
var normalizeType = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").normalizeType);
var normalizeTypes = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").normalizeTypes);
var setCharset = (__webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").setCharset);
var cookie = __webpack_require__(/*! cookie */ "./node_modules/express/node_modules/cookie/index.js");
var send = __webpack_require__(/*! send */ "./node_modules/send/index.js");
var extname = path.extname;
var mime = send.mime;
var resolve = path.resolve;
var vary = __webpack_require__(/*! vary */ "./node_modules/vary/index.js");

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  if ((typeof code === 'string' || Math.floor(code) !== code) && code > 99 && code < 1000) {
    deprecate('res.status(' + JSON.stringify(code) + '): use res.status(' + Math.floor(code) + ') instead')
  }
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links){
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function(rel){
    return '<' + links[rel] + '>; rel="' + rel + '"';
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === 'number' && arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get('Content-Type')) {
      this.type('txt');
    }

    deprecate('res.send(status): Use res.sendStatus(status) instead');
    this.statusCode = chunk;
    chunk = statuses.message[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn')
  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  // alter headers for 205
  if (this.statusCode === 205) {
    this.set('Content-Length', '0')
    this.removeHeader('Transfer-Encoding')
    chunk = ''
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.jsonp(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    if (body === undefined) {
      // empty argument
      body = ''
    } else if (typeof body === 'string') {
      // replace chars not allowed in JavaScript that are in JSON
      body = body
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029')
    }

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string to res.sendFile')
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !isAbsolute(path)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send(req, path, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

res.sendfile = deprecate.function(res.sendfile,
  'res.sendfile: Use res.sendFile instead');

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * occurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === 'function') {
    done = options
    opts = null
  }

  // support optional filename, where options may be in it's place
  if (typeof filename === 'object' &&
    (typeof options === 'function' || options === undefined)) {
    name = null
    opts = filename
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = !opts.root
    ? resolve(path)
    : path

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1
    ? mime.lookup(type)
    : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'application/json': function () {
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var keys = Object.keys(obj)
    .filter(function (v) { return v !== 'default' })

  var key = keys.length > 0
    ? req.accepts(keys)
    : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType(key).value);
    obj[key](req, this, next);
  } else if (obj.default) {
    obj.default(req, this, next)
  } else {
    next(createError(406, {
      types: normalizeTypes(keys).map(function (o) { return o.value })
    }))
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set('Content-Disposition', contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
        : [prev, val]
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime.charsets.lookup(value.split(';')[0]);
        if (charset) value += '; charset=' + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  if (options) {
    if (options.maxAge) {
      deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
    if (options.expires) {
      deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
  }
  var opts = merge({ expires: new Date(1), path: '/' }, options);

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object'
    ? 'j:' + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = 's:' + sign(val, secret);
  }

  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0

    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge)
      opts.maxAge = Math.floor(maxAge / 1000)
    }
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  var loc;

  // "back" is an alias for the referrer
  if (url === 'back') {
    deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
    loc = this.req.get('Referrer') || '/';
  } else {
    loc = String(url);
  }

  return this.set('Location', encodeUrl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === 'number') {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses.message[status] + '. Redirecting to ' + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>'
    },

    default: function(){
      body = '';
    }
  });

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  // checks for back-compat
  if (!field || (Array.isArray(field) && !field.length)) {
    deprecate('res.vary(): Provide a field name');
    return this;
  }

  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replacer
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape && typeof json === 'string') {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c'
        case 0x3e:
          return '\\u003e'
        case 0x26:
          return '\\u0026'
        /* istanbul ignore next: unreachable default */
        default:
          return c
      }
    })
  }

  return json
}


/***/ }),

/***/ "./node_modules/express/lib/router/index.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Route = __webpack_require__(/*! ./route */ "./node_modules/express/lib/router/route.js");
var Layer = __webpack_require__(/*! ./layer */ "./node_modules/express/lib/router/layer.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");
var mixin = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router');
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")

/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is a callable function
 * @public
 */

var proto = module.exports = function(options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead')
    name = name.slice(1)
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || ''
  var removed = '';
  var slashAdded = false;
  var sync = 0
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route'
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.slice(1)
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.slice(protohost.length)
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true && idx < stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        next(layerError || err)
      } else if (route) {
        layer.handle_request(req, res, next)
      } else {
        trim_prefix(layer, layerError, layerPath, path)
      }

      sync = 0
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path is a prefix match
      if (layerPath !== path.slice(0, layerPath.length)) {
        next(layerError)
        return
      }

      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c && c !== '/' && c !== '.') return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.slice(protohost.length + removed.length)

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed);
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

    if (layerError) {
      layer.handle_error(layerError, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal
      || (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
};

// create Router#VERB functions
methods.concat('all').forEach(function(method){
  proto[method] = function(path){
    var route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of methods
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}

// get pathname of request
function getPathname(req) {
  try {
    return parseUrl(req).pathname;
  } catch (err) {
    return undefined;
  }
}

// Get get protocol + host for a URL
function getProtohost(url) {
  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
    return undefined
  }

  var searchIndex = url.indexOf('?')
  var pathLength = searchIndex !== -1
    ? searchIndex
    : url.length
  var fqdnIndex = url.slice(0, pathLength).indexOf('://')

  return fqdnIndex !== -1
    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined
}

// get type for error message
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }

  // inspect [[Class]] for objects
  return toString.call(obj)
    .replace(objectRegExp, '$1');
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer(layer, path) {
  try {
    return layer.match(path);
  } catch (err) {
    return err;
  }
}

// merge params with parent params
function mergeParams(params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params;
  }

  // make copy of parent for base
  var obj = mixin({}, parent);

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return mixin(obj, params);
  }

  var i = 0;
  var o = 0;

  // determine numeric gaps
  while (i in params) {
    i++;
  }

  while (o in parent) {
    o++;
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i];
    }
  }

  return mixin(obj, params);
}

// restore obj props after function
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);

  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }

  return function () {
    // restore vals
    for (var i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i];
    }

    return fn.apply(this, arguments);
  };
}

// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
  try {
    var body = options.join(',');
    res.set('Allow', body);
    res.send(body);
  } catch (err) {
    next(err);
  }
}

// wrap a function
function wrap(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);

    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }

    fn.apply(this, args);
  };
}


/***/ }),

/***/ "./node_modules/express/lib/router/layer.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/layer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var pathRegexp = __webpack_require__(/*! path-to-regexp */ "./node_modules/path-to-regexp/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

module.exports = Layer;

function Layer(path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathRegexp(path, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    match = this.regexp.exec(path)
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0]

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}


/***/ }),

/***/ "./node_modules/express/lib/router/route.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/route.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router:route');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var Layer = __webpack_require__(/*! ./layer */ "./node_modules/express/lib/router/layer.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");

/**
 * Module variables.
 * @private
 */

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Module exports.
 * @public
 */

module.exports = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @public
 */

function Route(path) {
  this.path = path;
  this.stack = [];

  debug('new %o', path)

  // route handlers for various http methods
  this.methods = {};
}

/**
 * Determine if the route handles a given method.
 * @private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  // normalize name
  var name = typeof method === 'string'
    ? method.toLowerCase()
    : method

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

/**
 * @return {Array} supported HTTP methods
 * @private
 */

Route.prototype._options = function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (var i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
};

/**
 * dispatch req, res into this route
 * @private
 */

Route.prototype.dispatch = function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  var sync = 0

  if (stack.length === 0) {
    return done();
  }
  var method = typeof req.method === 'string'
    ? req.method.toLowerCase()
    : req.method

  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err && err === 'route') {
      return done();
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err)
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    var layer = stack[idx++]

    // end of layers
    if (!layer) {
      return done(err)
    }

    if (layer.method && layer.method !== method) {
      next(err)
    } else if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }

    sync = 0
  }
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all() {
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== 'function') {
      var type = toString.call(handle);
      var msg = 'Route.all() requires a callback function but got a ' + type
      throw new TypeError(msg);
    }

    var layer = Layer('/', {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
};

methods.forEach(function(method){
  Route.prototype[method] = function(){
    var handles = flatten(slice.call(arguments));

    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];

      if (typeof handle !== 'function') {
        var type = toString.call(handle);
        var msg = 'Route.' + method + '() requires a callback function but got a ' + type
        throw new Error(msg);
      }

      debug('%s %o', method, this.path)

      var layer = Layer('/', {}, handle);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }

    return this;
  };
});


/***/ }),

/***/ "./node_modules/express/lib/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/express/lib/utils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @api private
 */

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
var contentDisposition = __webpack_require__(/*! content-disposition */ "./node_modules/content-disposition/index.js");
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js");
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var mime = (__webpack_require__(/*! send */ "./node_modules/send/index.js").mime);
var etag = __webpack_require__(/*! etag */ "./node_modules/etag/index.js");
var proxyaddr = __webpack_require__(/*! proxy-addr */ "./node_modules/proxy-addr/index.js");
var qs = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
var querystring = __webpack_require__(/*! querystring */ "querystring");

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false })

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true })

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams (str) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {} }

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'weak':
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
}

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'simple':
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
}

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(',')
      .map(function (v) { return v.trim() })
  }

  return proxyaddr.compile(val || []);
}

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator (options) {
  return function generateETag (body, encoding) {
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  }
}

/**
 * Parse an extended query string with qs.
 *
 * @param {String} str
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}

/**
 * Return new empty object.
 *
 * @return {Object}
 * @api private
 */

function newObject() {
  return {};
}


/***/ }),

/***/ "./node_modules/express/lib/view.js":
/*!******************************************!*\
  !*** ./node_modules/express/lib/view.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:view');
var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");

/**
 * Module variables.
 * @private
 */

var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;

/**
 * Module exports.
 * @public
 */

module.exports = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.'
      ? '.' + this.defaultEngine
      : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.slice(1)
    debug('require "%s"', mod)

    // default engine export
    var fn = __webpack_require__("./node_modules/express/lib sync recursive")(mod).__express

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.')
    }

    opts.engines[this.ext] = fn
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path;
  var roots = [].concat(this.root);

  debug('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path = this.resolve(dir, file);
  }

  return path;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  debug('render "%s"', this.path);
  this.engine(this.path, options, callback);
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path = join(dir, file);
  var stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }

  // <path>/index.<ext>
  path = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}


/***/ }),

/***/ "./node_modules/express/lib sync recursive":
/*!****************************************!*\
  !*** ./node_modules/express/lib/ sync ***!
  \****************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/express/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/express/node_modules/cookie/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/express/node_modules/cookie/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */

var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode;
  var index = 0;
  var eqIdx = 0;
  var endIdx = 0;

  do {
    eqIdx = str.indexOf('=', index);
    if (eqIdx === -1) break; // No more cookie pairs.

    endIdx = str.indexOf(';', index);

    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1;
      continue;
    }

    var keyStartIdx = startIndex(str, index, eqIdx);
    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    var key = str.slice(keyStartIdx, keyEndIdx);

    // only assign once
    if (!obj.hasOwnProperty(key)) {
      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str, endIdx, valStartIdx);

      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
        valStartIdx++;
        valEndIdx--;
      }

      var val = str.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode(val, dec);
    }

    index = endIdx + 1
  } while (index < len);

  return obj;
}

function startIndex(str, index, max) {
  do {
    var code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}

function endIndex(str, index, min) {
  while (index > min) {
    var code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);

    if (!isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + maxAge;
  }

  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    var expires = opt.expires

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString()
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned'
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode (str) {
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/browser.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/debug.js":
/*!**************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/debug.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/express/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/express/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/express/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/node.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/express/node_modules/ms/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/express/node_modules/ms/index.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/fill-range/index.js":
/*!******************************************!*\
  !*** ./node_modules/fill-range/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(/*! util */ "util");
const toRegexRange = __webpack_require__(/*! to-regex-range */ "./node_modules/to-regex-range/index.js");

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options, maxLen) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options, maxLen)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }

  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ "./node_modules/finalhandler/index.js":
/*!********************************************!*\
  !*** ./node_modules/finalhandler/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/finalhandler/node_modules/debug/src/index.js")('finalhandler')
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var unpipe = __webpack_require__(/*! unpipe */ "./node_modules/unpipe/index.js")

/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g
var NEWLINE_REGEXP = /\n/g

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
var isFinished = onFinished.isFinished

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>')
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || "development" || 0

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug('cannot %d after headers sent', status)
      if (req.socket) {
        req.socket.destroy()
      }
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null)
  var keys = Object.keys(err.headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    headers[key] = err.headers[key]
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }

  return msg || statuses.message[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500
  }

  return status
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message)

    // response status
    res.statusCode = status

    if (req.httpVersionMajor < 2) {
      res.statusMessage = statuses.message[status]
    }

    // remove any content headers
    res.removeHeader('Content-Encoding')
    res.removeHeader('Content-Language')
    res.removeHeader('Content-Range')

    // response headers
    setHeaders(res, headers)

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

  if (isFinished(req)) {
    write()
    return
  }

  // unpipe everything from the request
  unpipe(req)

  // flush the request
  onFinished(req, write)
  req.resume()
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  if (!headers) {
    return
  }

  var keys = Object.keys(headers)
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/browser.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/finalhandler/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/debug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/debug.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/finalhandler/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/finalhandler/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/finalhandler/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/node.js":
/*!******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/node.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/finalhandler/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/ms/index.js":
/*!************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/ms/index.js ***!
  \************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/forwarded/index.js":
/*!*****************************************!*\
  !*** ./node_modules/forwarded/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = forwarded

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded (req) {
  if (!req) {
    throw new TypeError('argument req is required')
  }

  // simple header parsing
  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')
  var socketAddr = getSocketAddr(req)
  var addrs = [socketAddr].concat(proxyAddrs)

  // return all addresses
  return addrs
}

/**
 * Get the socket address for a request.
 *
 * @param {object} req
 * @return {string}
 * @private
 */

function getSocketAddr (req) {
  return req.socket
    ? req.socket.remoteAddress
    : req.connection.remoteAddress
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse (header) {
  var end = header.length
  var list = []
  var start = header.length

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(header.substring(start, end))
        }
        start = end = i
        break
      default:
        start = i
        break
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end))
  }

  return list
}


/***/ }),

/***/ "./node_modules/fresh/index.js":
/*!*************************************!*\
  !*** ./node_modules/fresh/index.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

/**
 * Module exports.
 * @public
 */

module.exports = fresh

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag']

    if (!etag) {
      return false
    }

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false
        break
      }
    }

    if (etagStale) {
      return false
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-caller-file/index.js":
/*!***********************************************!*\
  !*** ./node_modules/get-caller-file/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";

// Call this function in a another function to find out the file from
// which that function was called from. (Inspects the v8 stack trace)
//
// Inspired by http://stackoverflow.com/questions/13227489
module.exports = function getCallerFile(position) {
    if (position === void 0) { position = 2; }
    if (position >= Error.stackTraceLimit) {
        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');
    }
    var oldPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = new Error().stack;
    Error.prepareStackTrace = oldPrepareStackTrace;
    if (stack !== null && typeof stack === 'object') {
        // stack[0] holds this file
        // stack[1] holds where this function was called
        // stack[2] holds the file we're interested in
        return stack[position] ? stack[position].getFileName() : undefined;
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/glob-parent/index.js":
/*!*******************************************!*\
  !*** ./node_modules/glob-parent/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isGlob = __webpack_require__(/*! is-glob */ "./node_modules/is-glob/index.js");
var pathPosixDirname = (__webpack_require__(/*! path */ "path").posix).dirname;
var isWin32 = (__webpack_require__(/*! os */ "os").platform)() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/hpagent/index.js":
/*!***************************************!*\
  !*** ./node_modules/hpagent/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const https = __webpack_require__(/*! https */ "https")
const http = __webpack_require__(/*! http */ "http")
const { URL } = __webpack_require__(/*! url */ "url")

class HttpProxyAgent extends http.Agent {
  constructor (options) {
    const { proxy, proxyRequestOptions, ...opts } = options
    super(opts)
    this.proxy = typeof proxy === 'string'
      ? new URL(proxy)
      : proxy
    this.proxyRequestOptions = proxyRequestOptions || {}
  }

  createConnection (options, callback) {
    const requestOptions = {
      ...this.proxyRequestOptions,
      method: 'CONNECT',
      host: this.proxy.hostname,
      port: this.proxy.port,
      path: `${options.host}:${options.port}`,
      setHost: false,
      headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },
      agent: false,
      timeout: options.timeout || 0
    }

    if (this.proxy.username || this.proxy.password) {
      const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || '')}:${decodeURIComponent(this.proxy.password || '')}`).toString('base64')
      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`
    }

    if (this.proxy.protocol === 'https:') {
      requestOptions.servername = this.proxy.hostname
    }

    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)
    request.once('connect', (response, socket, head) => {
      request.removeAllListeners()
      socket.removeAllListeners()
      if (response.statusCode === 200) {
        callback(null, socket)
      } else {
        socket.destroy()
        callback(new Error(`Bad response: ${response.statusCode}`), null)
      }
    })

    request.once('timeout', () => {
      request.destroy(new Error('Proxy timeout'))
    })

    request.once('error', err => {
      request.removeAllListeners()
      callback(err, null)
    })

    request.end()
  }
}

class HttpsProxyAgent extends https.Agent {
  constructor (options) {
    const { proxy, proxyRequestOptions, ...opts } = options
    super(opts)
    this.proxy = typeof proxy === 'string'
      ? new URL(proxy)
      : proxy
    this.proxyRequestOptions = proxyRequestOptions || {}
  }

  createConnection (options, callback) {
    const requestOptions = {
      ...this.proxyRequestOptions,
      method: 'CONNECT',
      host: this.proxy.hostname,
      port: this.proxy.port,
      path: `${options.host}:${options.port}`,
      setHost: false,
      headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },
      agent: false,
      timeout: options.timeout || 0
    }

    if (this.proxy.username || this.proxy.password) {
      const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || '')}:${decodeURIComponent(this.proxy.password || '')}`).toString('base64')
      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`
    }

    // Necessary for the TLS check with the proxy to succeed.
    if (this.proxy.protocol === 'https:') {
      requestOptions.servername = this.proxy.hostname
    }

    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)
    request.once('connect', (response, socket, head) => {
      request.removeAllListeners()
      socket.removeAllListeners()
      if (response.statusCode === 200) {
        const secureSocket = super.createConnection({ ...options, socket })
        callback(null, secureSocket)
      } else {
        socket.destroy()
        callback(new Error(`Bad response: ${response.statusCode}`), null)
      }
    })

    request.once('timeout', () => {
      request.destroy(new Error('Proxy timeout'))
    })

    request.once('error', err => {
      request.removeAllListeners()
      callback(err, null)
    })

    request.end()
  }
}

module.exports = {
  HttpProxyAgent,
  HttpsProxyAgent
}


/***/ }),

/***/ "./node_modules/http-errors/index.js":
/*!*******************************************!*\
  !*** ./node_modules/http-errors/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('http-errors')
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js")
var toIdentifier = __webpack_require__(/*! toidentifier */ "./node_modules/toidentifier/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = createError
module.exports.HttpError = createHttpErrorConstructor()
module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError)

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass (status) {
  return Number(String(status).charAt(0) + '00')
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError () {
  // so much arity going on ~_~
  var err
  var msg
  var status = 500
  var props = {}
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i]
    var type = typeof arg
    if (type === 'object' && arg instanceof Error) {
      err = arg
      status = err.status || err.statusCode || status
    } else if (type === 'number' && i === 0) {
      status = arg
    } else if (type === 'string') {
      msg = arg
    } else if (type === 'object') {
      props = arg
    } else {
      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes')
  }

  if (typeof status !== 'number' ||
    (!statuses.message[status] && (status < 400 || status >= 600))) {
    status = 500
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)]

  if (!err) {
    // create error
    err = HttpError
      ? new HttpError(msg)
      : new Error(msg || statuses.message[status])
    Error.captureStackTrace(err, createError)
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500
    err.status = err.statusCode = status
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key]
    }
  }

  return err
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor () {
  function HttpError () {
    throw new TypeError('cannot construct abstract class')
  }

  inherits(HttpError, Error)

  return HttpError
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ClientError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ClientError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ClientError, HttpError)
  nameFunc(ClientError, className)

  ClientError.prototype.status = code
  ClientError.prototype.statusCode = code
  ClientError.prototype.expose = true

  return ClientError
}

/**
 * Create function to test is a value is a HttpError.
 * @private
 */

function createIsHttpErrorFunction (HttpError) {
  return function isHttpError (val) {
    if (!val || typeof val !== 'object') {
      return false
    }

    if (val instanceof HttpError) {
      return true
    }

    return val instanceof Error &&
      typeof val.expose === 'boolean' &&
      typeof val.statusCode === 'number' && val.status === val.statusCode
  }
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ServerError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ServerError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ServerError, HttpError)
  nameFunc(ServerError, className)

  ServerError.prototype.status = code
  ServerError.prototype.statusCode = code
  ServerError.prototype.expose = false

  return ServerError
}

/**
 * Set the name of a function, if possible.
 * @private
 */

function nameFunc (func, name) {
  var desc = Object.getOwnPropertyDescriptor(func, 'name')

  if (desc && desc.configurable) {
    desc.value = name
    Object.defineProperty(func, 'name', desc)
  }
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports (exports, codes, HttpError) {
  codes.forEach(function forEachCode (code) {
    var CodeError
    var name = toIdentifier(statuses.message[code])

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code)
        break
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code)
        break
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError
      exports[name] = CodeError
    }
  })
}

/**
 * Get a class name from a name identifier.
 * @private
 */

function toClassName (name) {
  return name.substr(-5) !== 'Error'
    ? name + 'Error'
    : name
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/dbcs-codec.js":
/*!*********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/dbcs-codec.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),

/***/ "./node_modules/iconv-lite/encodings/dbcs-data.js":
/*!********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/dbcs-data.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/shiftjis.json */ "./node_modules/iconv-lite/encodings/tables/shiftjis.json") },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/eucjp.json */ "./node_modules/iconv-lite/encodings/tables/eucjp.json") },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json") },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json").concat)(__webpack_require__(/*! ./tables/gbk-added.json */ "./node_modules/iconv-lite/encodings/tables/gbk-added.json")) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json").concat)(__webpack_require__(/*! ./tables/gbk-added.json */ "./node_modules/iconv-lite/encodings/tables/gbk-added.json")) },
        gb18030: function() { return __webpack_require__(/*! ./tables/gb18030-ranges.json */ "./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json") },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp949.json */ "./node_modules/iconv-lite/encodings/tables/cp949.json") },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp950.json */ "./node_modules/iconv-lite/encodings/tables/cp950.json") },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(/*! ./tables/cp950.json */ "./node_modules/iconv-lite/encodings/tables/cp950.json").concat)(__webpack_require__(/*! ./tables/big5-added.json */ "./node_modules/iconv-lite/encodings/tables/big5-added.json")) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/index.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __webpack_require__(/*! ./internal */ "./node_modules/iconv-lite/encodings/internal.js"),
    __webpack_require__(/*! ./utf16 */ "./node_modules/iconv-lite/encodings/utf16.js"),
    __webpack_require__(/*! ./utf7 */ "./node_modules/iconv-lite/encodings/utf7.js"),
    __webpack_require__(/*! ./sbcs-codec */ "./node_modules/iconv-lite/encodings/sbcs-codec.js"),
    __webpack_require__(/*! ./sbcs-data */ "./node_modules/iconv-lite/encodings/sbcs-data.js"),
    __webpack_require__(/*! ./sbcs-data-generated */ "./node_modules/iconv-lite/encodings/sbcs-data-generated.js"),
    __webpack_require__(/*! ./dbcs-codec */ "./node_modules/iconv-lite/encodings/dbcs-codec.js"),
    __webpack_require__(/*! ./dbcs-data */ "./node_modules/iconv-lite/encodings/dbcs-data.js"),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/internal.js":
/*!*******************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/internal.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder);

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-codec.js":
/*!*********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-codec.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-data-generated.js":
/*!******************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-data-generated.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-data.js":
/*!********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-data.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    "mik": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),

/***/ "./node_modules/iconv-lite/encodings/utf16.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/utf16.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),

/***/ "./node_modules/iconv-lite/encodings/utf7.js":
/*!***************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/utf7.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),

/***/ "./node_modules/iconv-lite/lib/bom-handling.js":
/*!*****************************************************!*\
  !*** ./node_modules/iconv-lite/lib/bom-handling.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),

/***/ "./node_modules/iconv-lite/lib/extend-node.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/lib/extend-node.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

// == Extend Node primitives to use iconv-lite =================================

module.exports = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
        };

        Buffer.isNativeEncoding = function(enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        }

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = (__webpack_require__(/*! buffer */ "buffer").SlowBuffer);

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        }

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer.isEncoding;
        Buffer.isEncoding = function(encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }

        original.BufferByteLength = Buffer.byteLength;
        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        }

        original.BufferToString = Buffer.prototype.toString;
        Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.BufferWrite = Buffer.prototype.write;
        Buffer.prototype.write = function(string, offset, length, encoding) {
            var _offset = offset, _length = length, _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        }


        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = (__webpack_require__(/*! stream */ "stream").Readable);

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            }

            Readable.prototype.collect = iconv._collect;
        }
    }

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
            return;
        if (!original)
            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

        delete Buffer.isNativeEncoding;

        var SlowBuffer = (__webpack_require__(/*! buffer */ "buffer").SlowBuffer);

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer.isEncoding = original.BufferIsEncoding;
        Buffer.byteLength = original.BufferByteLength;
        Buffer.prototype.toString = original.BufferToString;
        Buffer.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = (__webpack_require__(/*! stream */ "stream").Readable);

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    }
}


/***/ }),

/***/ "./node_modules/iconv-lite/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/iconv-lite/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = (__webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer);

var bomHandling = __webpack_require__(/*! ./bom-handling */ "./node_modules/iconv-lite/lib/bom-handling.js"),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __webpack_require__(/*! ../encodings */ "./node_modules/iconv-lite/encodings/index.js"); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __webpack_require__(/*! ./streams */ "./node_modules/iconv-lite/lib/streams.js")(iconv);
    }

    // Load Node primitive extensions.
    __webpack_require__(/*! ./extend-node */ "./node_modules/iconv-lite/lib/extend-node.js")(iconv);
}

if (false) {}


/***/ }),

/***/ "./node_modules/iconv-lite/lib/streams.js":
/*!************************************************!*\
  !*** ./node_modules/iconv-lite/lib/streams.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer),
    Transform = (__webpack_require__(/*! stream */ "stream").Transform);


// == Exports ==================================================================
module.exports = function(iconv) {
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) { chunks.push(chunk); });
    this.on('end', function() {
        cb(null, Buffer.concat(chunks));
    });
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) { res += chunk; });
    this.on('end', function() {
        cb(null, res);
    });
    return this;
}



/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(/*! util */ "util");
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "./node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/ipaddr.js/lib/ipaddr.js":
/*!**********************************************!*\
  !*** ./node_modules/ipaddr.js/lib/ipaddr.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if (( true && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function() {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function() {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;
      while ((match = regex.exec(string))) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }
      if (bestMatchLength < 0) {
        return string;
      }
      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = (function() {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function(string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function(string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);


/***/ }),

/***/ "./node_modules/is-binary-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-binary-path/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const binaryExtensions = __webpack_require__(/*! binary-extensions */ "./node_modules/binary-extensions/index.js");

const extensions = new Set(binaryExtensions);

module.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());


/***/ }),

/***/ "./node_modules/is-extglob/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),

/***/ "./node_modules/is-fullwidth-code-point/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/is-fullwidth-code-point/index.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
/* eslint-disable yoda */


const isFullwidthCodePoint = codePoint => {
	if (Number.isNaN(codePoint)) {
		return false;
	}

	// Code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (
		codePoint >= 0x1100 && (
			codePoint <= 0x115F || // Hangul Jamo
			codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
			codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
			(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
			(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
			// CJK Unified Ideographs .. Yi Radicals
			(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
			// Hangul Jamo Extended-A
			(0xA960 <= codePoint && codePoint <= 0xA97C) ||
			// Hangul Syllables
			(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
			// CJK Compatibility Ideographs
			(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
			// Vertical Forms
			(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
			// CJK Compatibility Forms .. Small Form Variants
			(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
			// Halfwidth and Fullwidth Forms
			(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
			(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
			// Kana Supplement
			(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
			// Enclosed Ideographic Supplement
			(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
			(0x20000 <= codePoint && codePoint <= 0x3FFFD)
		)
	) {
		return true;
	}

	return false;
};

module.exports = isFullwidthCodePoint;
module.exports["default"] = isFullwidthCodePoint;


/***/ }),

/***/ "./node_modules/is-glob/index.js":
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __webpack_require__(/*! is-extglob */ "./node_modules/is-extglob/index.js");
var chars = { '{': '}', '(': ')', '[': ']'};
var strictCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var relaxedCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck;

  // optionally relax check
  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};


/***/ }),

/***/ "./node_modules/is-number/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-number/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ "./node_modules/isexe/index.js":
/*!*************************************!*\
  !*** ./node_modules/isexe/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(/*! ./windows.js */ "./node_modules/isexe/windows.js")
} else {
  core = __webpack_require__(/*! ./mode.js */ "./node_modules/isexe/mode.js")
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),

/***/ "./node_modules/isexe/mode.js":
/*!************************************!*\
  !*** ./node_modules/isexe/mode.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(/*! fs */ "fs")

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),

/***/ "./node_modules/isexe/windows.js":
/*!***************************************!*\
  !*** ./node_modules/isexe/windows.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(/*! fs */ "fs")

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),

/***/ "./node_modules/media-typer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/media-typer/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegExp = /([\\"])/g;

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var subtype = obj.subtype
  var suffix = obj.suffix
  var type = obj.type

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffix
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix')
    }

    string += '+' + suffix
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype(string)
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = string.indexOf(';')
  var type = index !== -1
    ? string.substr(0, index)
    : string

  var key
  var match
  var obj = splitType(type)
  var params = {}
  var value

  paramRegExp.lastIndex = index

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(qescRegExp, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  obj.parameters = params

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type')
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type']
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring(val) {
  var str = String(val)

  // no need to quote tokens
  if (tokenRegExp.test(str)) {
    return str
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
}

/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffix

  // suffix after last +
  var index = subtype.lastIndexOf('+')
  if (index !== -1) {
    suffix = subtype.substr(index + 1)
    subtype = subtype.substr(0, index)
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  }

  return obj
}


/***/ }),

/***/ "./node_modules/merge-descriptors/index.js":
/*!*************************************************!*\
  !*** ./node_modules/merge-descriptors/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = merge

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge (dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required')
  }

  if (!src) {
    throw new TypeError('argument src is required')
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName (name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip descriptor
      return
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name)
    Object.defineProperty(dest, name, descriptor)
  })

  return dest
}


/***/ }),

/***/ "./node_modules/methods/index.js":
/*!***************************************!*\
  !*** ./node_modules/methods/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var http = __webpack_require__(/*! http */ "http");

/**
 * Module exports.
 * @public
 */

module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return [
    'get',
    'post',
    'put',
    'head',
    'delete',
    'options',
    'trace',
    'copy',
    'lock',
    'mkcol',
    'move',
    'purge',
    'propfind',
    'proppatch',
    'unlock',
    'report',
    'mkactivity',
    'checkout',
    'merge',
    'm-search',
    'notify',
    'subscribe',
    'unsubscribe',
    'patch',
    'search',
    'connect'
  ];
}


/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/mime/mime.js":
/*!***********************************!*\
  !*** ./node_modules/mime/mime.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts[i]] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(__webpack_require__(/*! ./types.json */ "./node_modules/mime/types.json"));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/negotiator/index.js":
/*!******************************************!*\
  !*** ./node_modules/negotiator/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



var preferredCharsets = __webpack_require__(/*! ./lib/charset */ "./node_modules/negotiator/lib/charset.js")
var preferredEncodings = __webpack_require__(/*! ./lib/encoding */ "./node_modules/negotiator/lib/encoding.js")
var preferredLanguages = __webpack_require__(/*! ./lib/language */ "./node_modules/negotiator/lib/language.js")
var preferredMediaTypes = __webpack_require__(/*! ./lib/mediaType */ "./node_modules/negotiator/lib/mediaType.js")

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;


/***/ }),

/***/ "./node_modules/negotiator/lib/charset.js":
/*!************************************************!*\
  !*** ./node_modules/negotiator/lib/charset.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/encoding.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/encoding.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/language.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/language.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1]
  var suffix = match[2]
  var full = prefix

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/mediaType.js":
/*!**************************************************!*\
  !*** ./node_modules/negotiator/lib/mediaType.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),

/***/ "./node_modules/node-domexception/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-domexception/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */

if (!globalThis.DOMException) {
  try {
    const { MessageChannel } = __webpack_require__(/*! worker_threads */ "worker_threads"),
    port = new MessageChannel().port1,
    ab = new ArrayBuffer()
    port.postMessage(ab, [ab, ab])
  } catch (err) {
    err.constructor.name === 'DOMException' && (
      globalThis.DOMException = err.constructor
    )
  }
}

module.exports = globalThis.DOMException


/***/ }),

/***/ "./node_modules/normalize-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/normalize-path/index.js ***!
  \**********************************************/
/***/ ((module) => {

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};


/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "./node_modules/object-inspect/util.inspect.js");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof global !== 'undefined' && obj === global)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/object-inspect/util.inspect.js":
/*!*****************************************************!*\
  !*** ./node_modules/object-inspect/util.inspect.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! util */ "util").inspect;


/***/ }),

/***/ "./node_modules/on-finished/index.js":
/*!*******************************************!*\
  !*** ./node_modules/on-finished/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var first = __webpack_require__(/*! ee-first */ "./node_modules/ee-first/index.js")

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished (msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, wrap(listener))

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished (msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener (msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish (error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket (socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // istanbul ignore next: node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener (msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener (msg) {
  function listener (err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

// istanbul ignore next: node.js 0.8 patch
function patchAssignSocket (res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket (socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __webpack_require__(/*! async_hooks */ "async_hooks")
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),

/***/ "./node_modules/on-headers/index.js":
/*!******************************************!*\
  !*** ./node_modules/on-headers/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
/*!
 * on-headers
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onHeaders

/**
 * Create a replacement writeHead method.
 *
 * @param {function} prevWriteHead
 * @param {function} listener
 * @private
 */

function createWriteHead (prevWriteHead, listener) {
  var fired = false

  // return function with core name and argument list
  return function writeHead (statusCode) {
    // set headers from arguments
    var args = setWriteHeadHeaders.apply(this, arguments)

    // fire listener
    if (!fired) {
      fired = true
      listener.call(this)

      // pass-along an updated status code
      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {
        args[0] = this.statusCode
        args.length = 1
      }
    }

    return prevWriteHead.apply(this, args)
  }
}

/**
 * Execute a listener when a response is about to write headers.
 *
 * @param {object} res
 * @return {function} listener
 * @public
 */

function onHeaders (res, listener) {
  if (!res) {
    throw new TypeError('argument res is required')
  }

  if (typeof listener !== 'function') {
    throw new TypeError('argument listener must be a function')
  }

  res.writeHead = createWriteHead(res.writeHead, listener)
}

/**
 * Set headers contained in array on the response object.
 *
 * @param {object} res
 * @param {array} headers
 * @private
 */

function setHeadersFromArray (res, headers) {
  for (var i = 0; i < headers.length; i++) {
    res.setHeader(headers[i][0], headers[i][1])
  }
}

/**
 * Set headers contained in object on the response object.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeadersFromObject (res, headers) {
  var keys = Object.keys(headers)
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i]
    if (k) res.setHeader(k, headers[k])
  }
}

/**
 * Set headers and other properties on the response object.
 *
 * @param {number} statusCode
 * @private
 */

function setWriteHeadHeaders (statusCode) {
  var length = arguments.length
  var headerIndex = length > 1 && typeof arguments[1] === 'string'
    ? 2
    : 1

  var headers = length >= headerIndex + 1
    ? arguments[headerIndex]
    : undefined

  this.statusCode = statusCode

  if (Array.isArray(headers)) {
    // handle array case
    setHeadersFromArray(this, headers)
  } else if (headers) {
    // handle object case
    setHeadersFromObject(this, headers)
  }

  // copy leading arguments
  var args = new Array(Math.min(length, headerIndex))
  for (var i = 0; i < args.length; i++) {
    args[i] = arguments[i]
  }

  return args
}


/***/ }),

/***/ "./node_modules/parseurl/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseurl/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var url = __webpack_require__(/*! url */ "url")
var parse = url.parse
var Url = url.Url

/**
 * Module exports.
 * @public
 */

module.exports = parseurl
module.exports.original = originalurl

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedUrl = parsed)
};

/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedOriginalUrl = parsed)
};

/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str
  var query = null
  var search = null

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i)
          query = str.substring(i + 1)
          search = str.substring(i)
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {}

  url.path = str
  url.href = str
  url.pathname = pathname

  if (search !== null) {
    url.query = query
    url.search = search
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}


/***/ }),

/***/ "./node_modules/path-to-regexp/index.js":
/*!**********************************************!*\
  !*** ./node_modules/path-to-regexp/index.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Expose `pathToRegexp`.
 */

module.exports = pathToRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathToRegexp(path, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var lookahead = options.lookahead !== false;
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var pos = 0;
  var backtrack = '';
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
      if (m[0][0] === '\\') continue;

      keys.push({
        name: m[1] || name++,
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathToRegexp(value, keys, options).source;
    });

    return new RegExp(path.join('|'), flags);
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string, array of strings, or regular expression');
  }

  path = path.replace(
    /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
    function (match, slash, format, key, capture, star, optional, offset) {
      if (match[0] === '\\') {
        backtrack += match;
        pos += 2;
        return match;
      }

      if (match === '.') {
        backtrack += '\\.';
        extraOffset += 1;
        pos += 1;
        return '\\.';
      }

      if (slash || format) {
        backtrack = '';
      } else {
        backtrack += path.slice(pos, offset);
      }

      pos = offset + match.length;

      if (match === '*') {
        extraOffset += 3;
        return '(.*)';
      }

      if (match === '/(') {
        backtrack += '/';
        extraOffset += 2;
        return '/(?:';
      }

      slash = slash || '';
      format = format ? '\\.' : '';
      optional = optional || '';
      capture = capture ?
        capture.replace(/\\.|\*/, function (m) { return m === '*' ? '(.*)' : m; }) :
        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = '(?:'
        + format + slash + capture
        + (star ? '((?:[/' + format + '].+?)?)' : '')
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
    if (m[0][0] === '\\') continue;

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';

  // If the path is non-ending, match until the end or a slash.
  if (end) {
    path += '$';
  } else if (path[path.length - 1] !== '/') {
    path += lookahead ? '(?=/|$)' : '(?:/|$)';
  }

  return new RegExp('^' + path, flags);
};


/***/ }),

/***/ "./node_modules/picomatch/index.js":
/*!*****************************************!*\
  !*** ./node_modules/picomatch/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./lib/picomatch */ "./node_modules/picomatch/lib/picomatch.js");


/***/ }),

/***/ "./node_modules/picomatch/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/constants.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ "./node_modules/picomatch/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/parse.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ "./node_modules/picomatch/lib/picomatch.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/picomatch.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const scan = __webpack_require__(/*! ./scan */ "./node_modules/picomatch/lib/scan.js");
const parse = __webpack_require__(/*! ./parse */ "./node_modules/picomatch/lib/parse.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ "./node_modules/picomatch/lib/scan.js":
/*!********************************************!*\
  !*** ./node_modules/picomatch/lib/scan.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ "./node_modules/picomatch/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),

/***/ "./node_modules/proxy-addr/index.js":
/*!******************************************!*\
  !*** ./node_modules/proxy-addr/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile

/**
 * Module dependencies.
 * @private
 */

var forwarded = __webpack_require__(/*! forwarded */ "./node_modules/forwarded/index.js")
var ipaddr = __webpack_require__(/*! ipaddr.js */ "./node_modules/ipaddr.js/lib/ipaddr.js")

/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
  return len === 0
    ? trustNone
    : len === 1
      ? trustSingle(rangeSubnets[0])
      : trustMulti(rangeSubnets)
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
  }

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone () {
  return false
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
}


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/random-bytes/index.js":
/*!********************************************!*\
  !*** ./node_modules/random-bytes/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * random-bytes
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var crypto = __webpack_require__(/*! crypto */ "crypto")

/**
 * Module variables.
 * @private
 */

var generateAttempts = crypto.randomBytes === crypto.pseudoRandomBytes ? 1 : 3

/**
 * Module exports.
 * @public
 */

module.exports = randomBytes
module.exports.sync = randomBytesSync

/**
 * Generates strong pseudo-random bytes.
 *
 * @param {number} size
 * @param {function} [callback]
 * @return {Promise}
 * @public
 */

function randomBytes(size, callback) {
  // validate callback is a function, if provided
  if (callback !== undefined && typeof callback !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!callback && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  if (callback) {
    // classic callback style
    return generateRandomBytes(size, generateAttempts, callback)
  }

  return new Promise(function executor(resolve, reject) {
    generateRandomBytes(size, generateAttempts, function onRandomBytes(err, str) {
      if (err) return reject(err)
      resolve(str)
    })
  })
}

/**
 * Generates strong pseudo-random bytes sync.
 *
 * @param {number} size
 * @return {Buffer}
 * @public
 */

function randomBytesSync(size) {
  var err = null

  for (var i = 0; i < generateAttempts; i++) {
    try {
      return crypto.randomBytes(size)
    } catch (e) {
      err = e
    }
  }

  throw err
}

/**
 * Generates strong pseudo-random bytes.
 *
 * @param {number} size
 * @param {number} attempts
 * @param {function} callback
 * @private
 */

function generateRandomBytes(size, attempts, callback) {
  crypto.randomBytes(size, function onRandomBytes(err, buf) {
    if (!err) return callback(null, buf)
    if (!--attempts) return callback(err)
    setTimeout(generateRandomBytes.bind(null, size, attempts, callback), 10)
  })
}


/***/ }),

/***/ "./node_modules/range-parser/index.js":
/*!********************************************!*\
  !*** ./node_modules/range-parser/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string')
  }

  var index = str.indexOf('=')

  if (index === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  }
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) {
  return a.index - b.index
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}


/***/ }),

/***/ "./node_modules/raw-body/index.js":
/*!****************************************!*\
  !*** ./node_modules/raw-body/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var iconv = __webpack_require__(/*! iconv-lite */ "./node_modules/iconv-lite/lib/index.js")
var unpipe = __webpack_require__(/*! unpipe */ "./node_modules/unpipe/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  // light validation
  if (stream === undefined) {
    throw new TypeError('argument stream is required')
  } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
    throw new TypeError('argument stream must be a stream')
  }

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, wrap(done))
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt (stream) {
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
  }

  if (typeof stream.readable !== 'undefined' && !stream.readable) {
    return done(createError(500, 'stream is not readable', {
      type: 'stream.not.readable'
    }))
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
    return done(err)
  }

  var buffer = decoder
    ? ''
    : []

  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
      done(null, string)
    }
  }

  function cleanup () {
    buffer = null

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __webpack_require__(/*! async_hooks */ "async_hooks")
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),

/***/ "./node_modules/readdirp/index.js":
/*!****************************************!*\
  !*** ./node_modules/readdirp/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const { Readable } = __webpack_require__(/*! stream */ "stream");
const sysPath = __webpack_require__(/*! path */ "path");
const { promisify } = __webpack_require__(/*! util */ "util");
const picomatch = __webpack_require__(/*! picomatch */ "./node_modules/picomatch/index.js");

const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

const BANG = '!';
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
const FILE_TYPE = 'files';
const DIR_TYPE = 'directories';
const FILE_DIR_TYPE = 'files_directories';
const EVERYTHING_TYPE = 'all';
const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

const isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);
const [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));
const wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));

const normalizeFilter = filter => {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    const glob = picomatch(filter.trim());
    return entry => glob(entry.basename);
  }

  if (Array.isArray(filter)) {
    const positive = [];
    const negative = [];
    for (const item of filter) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG) {
        negative.push(picomatch(trimmed.slice(1)));
      } else {
        positive.push(picomatch(trimmed));
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return entry =>
          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));
      }
      return entry => !negative.some(f => f(entry.basename));
    }
    return entry => positive.some(f => f(entry.basename));
  }
};

class ReaddirpStream extends Readable {
  static get defaultOptions() {
    return {
      root: '.',
      /* eslint-disable no-unused-vars */
      fileFilter: (path) => true,
      directoryFilter: (path) => true,
      /* eslint-enable no-unused-vars */
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    };
  }

  constructor(options = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    });
    const opts = { ...ReaddirpStream.defaultOptions, ...options };
    const { root, type } = opts;

    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);

    const statMethod = opts.lstat ? lstat : stat;
    // Use bigint stats if it's windows and stat() supports options (node 10+).
    if (wantBigintFsStats) {
      this._stat = path => statMethod(path, { bigint: true });
    } else {
      this._stat = statMethod;
    }

    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath.resolve(root);
    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;
    this._statsProp = this._isDirent ? 'dirent' : 'stats';
    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };

    // Launch stream with one parent, the root dir.
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = undefined;
  }

  async _read(batch) {
    if (this.reading) return;
    this.reading = true;

    try {
      while (!this.destroyed && batch > 0) {
        const { path, depth, files = [] } = this.parent || {};

        if (files.length > 0) {
          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));
          for (const entry of await Promise.all(slice)) {
            if (this.destroyed) return;

            const entryType = await this._getEntryType(entry);
            if (entryType === 'directory' && this._directoryFilter(entry)) {
              if (depth <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
              }

              if (this._wantsDir) {
                this.push(entry);
                batch--;
              }
            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {
              if (this._wantsFile) {
                this.push(entry);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed) return;
        }
      }
    } catch (error) {
      this.destroy(error);
    } finally {
      this.reading = false;
    }
  }

  async _exploreDir(path, depth) {
    let files;
    try {
      files = await readdir(path, this._rdOptions);
    } catch (error) {
      this._onError(error);
    }
    return { files, depth, path };
  }

  async _formatEntry(dirent, path) {
    let entry;
    try {
      const basename = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath.resolve(sysPath.join(path, basename));
      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err) {
      this._onError(err);
    }
    return entry;
  }

  _onError(err) {
    if (isNormalFlowError(err) && !this.destroyed) {
      this.emit('warn', err);
    } else {
      this.destroy(err);
    }
  }

  async _getEntryType(entry) {
    // entry may be undefined, because a warning or an error were emitted
    // and the statsProp is undefined
    const stats = entry && entry[this._statsProp];
    if (!stats) {
      return;
    }
    if (stats.isFile()) {
      return 'file';
    }
    if (stats.isDirectory()) {
      return 'directory';
    }
    if (stats && stats.isSymbolicLink()) {
      const full = entry.fullPath;
      try {
        const entryRealPath = await realpath(full);
        const entryRealPathStats = await lstat(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return 'file';
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
            const recursiveError = new Error(
              `Circular symlink detected: "${full}" points to "${entryRealPath}"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return 'directory';
        }
      } catch (error) {
        this._onError(error);
      }
    }
  }

  _includeAsFile(entry) {
    const stats = entry && entry[this._statsProp];

    return stats && this._wantsEverything && !stats.isDirectory();
  }
}

/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */
const readdirp = (root, options = {}) => {
  let type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
  }

  options.root = root;
  return new ReaddirpStream(options);
};

const readdirpPromise = (root, options = {}) => {
  return new Promise((resolve, reject) => {
    const files = [];
    readdirp(root, options)
      .on('data', entry => files.push(entry))
      .on('end', () => resolve(files))
      .on('error', error => reject(error));
  });
};

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp.default = readdirp;

module.exports = readdirp;


/***/ }),

/***/ "./node_modules/require-directory/index.js":
/*!*************************************************!*\
  !*** ./node_modules/require-directory/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs"),
  join = (__webpack_require__(/*! path */ "path").join),
  resolve = (__webpack_require__(/*! path */ "path").resolve),
  dirname = (__webpack_require__(/*! path */ "path").dirname),
  defaultOptions = {
    extensions: ['js', 'json', 'coffee'],
    recurse: true,
    rename: function (name) {
      return name;
    },
    visit: function (obj) {
      return obj;
    }
  };

function checkFileInclusion(path, filename, options) {
  return (
    // verify file has valid extension
    (new RegExp('\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&

    // if options.include is a RegExp, evaluate it and make sure the path passes
    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&

    // if options.include is a function, evaluate it and make sure the path passes
    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&

    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&

    // if options.exclude is a function, evaluate it and make sure the path doesn't pass
    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))
  );
}

function requireDirectory(m, path, options) {
  var retval = {};

  // path is optional
  if (path && !options && typeof path !== 'string') {
    options = path;
    path = null;
  }

  // default options
  options = options || {};
  for (var prop in defaultOptions) {
    if (typeof options[prop] === 'undefined') {
      options[prop] = defaultOptions[prop];
    }
  }

  // if no path was passed in, assume the equivelant of __dirname from caller
  // otherwise, resolve path relative to the equivalent of __dirname
  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);

  // get the path of each file in specified directory, append to current tree node, recurse
  fs.readdirSync(path).forEach(function (filename) {
    var joined = join(path, filename),
      files,
      key,
      obj;

    if (fs.statSync(joined).isDirectory() && options.recurse) {
      // this node is a directory; recurse
      files = requireDirectory(m, joined, options);
      // exclude empty directories
      if (Object.keys(files).length) {
        retval[options.rename(filename, joined, filename)] = files;
      }
    } else {
      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
        // hash node key shouldn't include file extension
        key = filename.substring(0, filename.lastIndexOf('.'));
        obj = m.require(joined);
        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
      }
    }
  });

  return retval;
}

module.exports = requireDirectory;
module.exports.defaults = defaultOptions;


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/safer-buffer/safer.js":
/*!********************************************!*\
  !*** ./node_modules/safer-buffer/safer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // disallow unquoted attribute values if not otherwise configured
    // and strict mode is true
    if (parser.opt.unquotedAttributeValues === undefined) {
      parser.opt.unquotedAttributeValues = !strict;
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = (__webpack_require__(/*! stream */ "stream").Stream)
  } catch (ex) {
    Stream = function () {}
  }
  if (!Stream) Stream = function () {}

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder)
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
            continue;
          }

          if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
            parser.state = S.DOCTYPE_DTD
            parser.doctype += '<!' + parser.sgmlDecl + c
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          if (c === ']') {
            parser.doctype += c
            parser.state = S.DOCTYPE
          } else if (c === '<') {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else if (isQuote(c)) {
            parser.doctype += c
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          } else {
            parser.doctype += c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else if (parser.doctype && parser.doctype !== true) {
            parser.state = S.DOCTYPE_DTD
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            if (!parser.opt.unquotedAttributeValues) {
              error(parser, 'Unquoted attribute value')
            }
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            var parsedEntity = parseEntity(parser)
            if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
              parser.entity = ''
              parser.state = returnState
              parser.write(parsedEntity)
            } else {
              parser[buffer] += parsedEntity
              parser.entity = ''
              parser.state = returnState
            }
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default: /* istanbul ignore next */ {
          throw new Error(parser, 'Unknown state: ' + parser.state)
        }
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ }),

/***/ "./node_modules/send/index.js":
/*!************************************!*\
  !*** ./node_modules/send/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/send/node_modules/debug/src/index.js")('send')
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('send')
var destroy = __webpack_require__(/*! destroy */ "./node_modules/destroy/index.js")
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/send/node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var etag = __webpack_require__(/*! etag */ "./node_modules/etag/index.js")
var fresh = __webpack_require__(/*! fresh */ "./node_modules/fresh/index.js")
var fs = __webpack_require__(/*! fs */ "fs")
var mime = __webpack_require__(/*! mime */ "./node_modules/mime/mime.js")
var ms = __webpack_require__(/*! ms */ "./node_modules/ms/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var parseRange = __webpack_require__(/*! range-parser */ "./node_modules/range-parser/index.js")
var path = __webpack_require__(/*! path */ "path")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var Stream = __webpack_require__(/*! stream */ "stream")
var util = __webpack_require__(/*! util */ "util")

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send
module.exports.mime = mime

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : 'ignore'

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
  }

  this._hidden = Boolean(opts.hidden)

  if (opts.hidden !== undefined) {
    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, 'extensions option')
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, 'index option')
    : ['index.html']

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === 'string'
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null

  if (!this._root && opts.from) {
    this.from(opts.from)
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate.function(function etag (val) {
  this._etag = Boolean(val)
  debug('etag %s', this._etag)
  return this
}, 'send.etag: pass etag as option')

/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate.function(function hidden (val) {
  this._hidden = Boolean(val)
  this._dotfiles = undefined
  debug('hidden %s', this._hidden)
  return this
}, 'send.hidden: use dotfiles option')

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate.function(function index (paths) {
  var index = !paths ? [] : normalizeList(paths, 'paths argument')
  debug('index %o', paths)
  this._index = index
  return this
}, 'send.index: pass index as option')

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root (path) {
  this._root = resolve(String(path))
  debug('root %s', this._root)
  return this
}

SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
  'send.from: pass root as option')

SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
  'send.root: pass root as option')

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
  this._maxage = typeof maxAge === 'string'
    ? ms(maxAge)
    : Number(maxAge)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0
  debug('max-age %d', this._maxage)
  return this
}, 'send.maxage: pass maxAge as option')

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', createHttpError(status, err))
  }

  var res = this.res
  var msg = statuses.message[status] || String(status)
  var doc = createHtmlDocument('Error', escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err && err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(doc)
}

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === '/'
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers['if-match'] ||
    this.req.headers['if-unmodified-since'] ||
    this.req.headers['if-none-match'] ||
    this.req.headers['if-modified-since']
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers['if-match']
  if (match) {
    var etag = res.getHeader('ETag')
    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))
    return isNaN(lastModified) || lastModified > unmodifiedSince
  }

  return false
}

/**
 * Strip various content header fields for a change in entity.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res

  res.removeHeader('Content-Encoding')
  res.removeHeader('Content-Language')
  res.removeHeader('Content-Length')
  res.removeHeader('Content-Range')
  res.removeHeader('Content-Type')
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug('not modified')
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error('Can\'t set headers after they are sent.')
  debug('headers already sent')
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode >= 200 && statusCode < 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    etag: this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers['if-range']

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag')
    return Boolean(etag && ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified')
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))
  var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

  // redirect
  res.statusCode = 301
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('Location', loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf('\0')) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize('.' + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === '.'
        ? (this._hidden ? 'allow' : 'ignore')
        : 'allow'
    }

    debug('%s dotfile "%s"', access, path)
    switch (access) {
      case 'allow':
        break
      case 'deny':
        this.error(403)
        return res
      case 'ignore':
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (headersSent(res)) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug('pipe "%s"', path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len > bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug('range stale')
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug('range unsatisfiable')

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { 'Content-Range': res.getHeader('Content-Range') }
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug('range %j', ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader('Content-Length', len)

  // HEAD support
  if (req.method === 'HEAD') {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug('stat "%s"', path)
  fs.stat(path, function onstat (err, stat) {
    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    self.emit('file', path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length <= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + '.' + self._extensions[i++]

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit('stream', stream)
  stream.pipe(res)

  // cleanup
  function cleanup () {
    destroy(stream, true)
  }

  // response finished, cleanup
  onFinished(res, cleanup)

  // error handling
  stream.on('error', function onerror (err) {
    // clean up stream early
    cleanup()

    // error
    self.onStatError(err)
  })

  // end
  stream.on('end', function onend () {
    self.emit('end')
  })
}

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader('Content-Type')) return

  var type = mime.lookup(path)

  if (!type) {
    debug('no content-type')
    return
  }

  var charset = mime.charsets.lookup(type)

  debug('content-type %s', type)
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit('headers', res, path, stat)

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug('accept ranges')
    res.setHeader('Accept-Ranges', 'bytes')
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += ', immutable'
    }

    debug('cache-control %s', cacheControl)
    res.setHeader('Cache-Control', cacheControl)
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString()
    debug('modified %s', modified)
    res.setHeader('Last-Modified', modified)
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag(stat)
    debug('etag %s', val)
    res.setHeader('ETag', val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    res.removeHeader(headers[i])
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i]
    if (part.length > 1 && part[0] === '.') {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a HttpError object from simple arguments.
 *
 * @param {number} status
 * @param {Error|object} err
 * @private
 */

function createHttpError (status, err) {
  if (!err) {
    return createError(status)
  }

  return err instanceof Error
    ? createError(status, err, { expose: false })
    : createError(status, err)
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames (res) {
  return typeof res.getHeaderNames !== 'function'
    ? Object.keys(res._headers || {})
    : res.getHeaderNames()
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false')
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(str.substring(start, end))
        }
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  if (start !== end) {
    list.push(str.substring(start, end))
  }

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/node_modules/ms/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/send/node_modules/debug/node_modules/ms/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/browser.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/send/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/debug.js":
/*!***********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/debug.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/send/node_modules/debug/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/send/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/send/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/node.js":
/*!**********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/node.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/send/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/send/node_modules/encodeurl/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/send/node_modules/encodeurl/index.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),

/***/ "./node_modules/serve-static/index.js":
/*!********************************************!*\
  !*** ./node_modules/serve-static/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js")
var resolve = (__webpack_require__(/*! path */ "path").resolve)
var send = __webpack_require__(/*! send */ "./node_modules/send/index.js")
var url = __webpack_require__(/*! url */ "url")

/**
 * Module exports.
 * @public
 */

module.exports = serveStatic
module.exports.mime = send.mime

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic (root, options) {
  if (!root) {
    throw new TypeError('root path required')
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string')
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function')
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader('Allow', 'GET, HEAD')
      res.setHeader('Content-Length', '0')
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path = ''
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on('directory', onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on('error', function error (err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener () {
  return function notFound () {
    this.error(404)
  }
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener () {
  return function redirect (res) {
    if (this.hasTrailingSlash()) {
      this.error(404)
      return
    }

    // get original URL
    var originalUrl = parseUrl.original(this.req)

    // append trailing slash
    originalUrl.path = null
    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

    // reformat the URL
    var loc = encodeUrl(url.format(originalUrl))
    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

    // send redirect response
    res.statusCode = 301
    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
    res.setHeader('Content-Length', Buffer.byteLength(doc))
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')
    res.setHeader('Location', loc)
    res.end(doc)
  }
}


/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/setprototypeof/index.js":
/*!**********************************************!*\
  !*** ./node_modules/setprototypeof/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

/* eslint no-proto: 0 */
module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)

function setProtoOf (obj, proto) {
  obj.__proto__ = proto
  return obj
}

function mixinProperties (obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop]
    }
  }
  return obj
}


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/statuses/index.js":
/*!****************************************!*\
  !*** ./node_modules/statuses/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __webpack_require__(/*! ./codes.json */ "./node_modules/statuses/codes.json")

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.message = codes

// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes)

// array of status codes
status.codes = createStatusCodeList(codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Create a map of message to status code.
 * @private
 */

function createMessageToStatusCodeMap (codes) {
  var map = {}

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // populate map
    map[message.toLowerCase()] = status
  })

  return map
}

/**
 * Create a list of all status codes.
 * @private
 */

function createStatusCodeList (codes) {
  return Object.keys(codes).map(function mapCode (code) {
    return Number(code)
  })
}

/**
 * Get the status code for given message.
 * @private
 */

function getStatusCode (message) {
  var msg = message.toLowerCase()

  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"')
  }

  return status.code[msg]
}

/**
 * Get the status message for given code.
 * @private
 */

function getStatusMessage (code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error('invalid status code: ' + code)
  }

  return status.message[code]
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    return getStatusMessage(code)
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    return getStatusMessage(n)
  }

  return getStatusCode(code)
}


/***/ }),

/***/ "./node_modules/string-width/index.js":
/*!********************************************!*\
  !*** ./node_modules/string-width/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js");
const isFullwidthCodePoint = __webpack_require__(/*! is-fullwidth-code-point */ "./node_modules/is-fullwidth-code-point/index.js");
const emojiRegex = __webpack_require__(/*! emoji-regex */ "./node_modules/emoji-regex/index.js");

const stringWidth = string => {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	string = stripAnsi(string);

	if (string.length === 0) {
		return 0;
	}

	string = string.replace(emojiRegex(), '  ');

	let width = 0;

	for (let i = 0; i < string.length; i++) {
		const code = string.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};

module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports["default"] = stringWidth;


/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js");

module.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;


/***/ }),

/***/ "./node_modules/to-regex-range/index.js":
/*!**********************************************!*\
  !*** ./node_modules/to-regex-range/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(/*! is-number */ "./node_modules/is-number/index.js");

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ "./node_modules/toidentifier/index.js":
/*!********************************************!*\
  !*** ./node_modules/toidentifier/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = toIdentifier

/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */

function toIdentifier (str) {
  return str
    .split(' ')
    .map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1)
    })
    .join('')
    .replace(/[^ _0-9a-z]/gi, '')
}


/***/ }),

/***/ "./src/ClientConnection.ts":
/*!*********************************!*\
  !*** ./src/ClientConnection.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright 2024 The MathWorks, Inc.
const node_1 = __webpack_require__(/*! vscode-languageserver/node */ "./node_modules/vscode-languageserver/node.js");
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class ClientConnection {
    /**
     * Retrieves the connection to the client. If no connection currently exists,
     * a new connection is created.
     *
     * @returns The connection to the client
     */
    static getConnection() {
        if (ClientConnection.connection == null) {
            ClientConnection.connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
        }
        return ClientConnection.connection;
    }
    /**
     * Sets the ClientConnection to a given object.
     * This API is primarily meant for testing purposes.
     *
     * @param connection The connection object to set
     */
    static _setConnection(connection) {
        ClientConnection.connection = connection;
    }
    /**
     * Clears the current connection.
     * This API is primarily meant for testing purposes.
     */
    static _clearConnection() {
        ClientConnection.connection = undefined;
    }
}
exports["default"] = ClientConnection;


/***/ }),

/***/ "./src/debug/DebugServices.ts":
/*!************************************!*\
  !*** ./src/debug/DebugServices.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugServices = exports.GlobalBreakpointInfo = exports.GlobalBreakpointType = exports.BreakpointInfo = void 0;
const events_1 = __importDefault(__webpack_require__(/*! events */ "events"));
class BreakpointInfo {
    constructor(filePath, lineNumber, condition, anonymousFunctionIndex) {
        this.filePath = filePath;
        this.lineNumber = lineNumber;
        this.condition = condition === '' ? undefined : condition;
        this.anonymousFunctionIndex = 0;
        this.enabled = condition === undefined || !(condition === 'false' || /$false && \(.*\)^/.test(condition));
    }
    equals(other, ignoreCondition) {
        const result = other.filePath === this.filePath && other.lineNumber === this.lineNumber && other.anonymousFunctionIndex === this.anonymousFunctionIndex;
        if (!result || ignoreCondition) {
            return result;
        }
        else {
            return this.condition === other.condition;
        }
    }
}
exports.BreakpointInfo = BreakpointInfo;
var GlobalBreakpointType;
(function (GlobalBreakpointType) {
    GlobalBreakpointType["ERROR"] = "ERROR";
    GlobalBreakpointType["CAUGHT_ERROR"] = "CAUGHT_ERROR";
    GlobalBreakpointType["WARNING"] = "WARNING";
    GlobalBreakpointType["NAN_INF"] = "NAN_INF";
})(GlobalBreakpointType = exports.GlobalBreakpointType || (exports.GlobalBreakpointType = {}));
class GlobalBreakpointInfo {
    constructor(type, identifiers) {
        this.type = type;
        this.identifiers = identifiers;
    }
}
exports.GlobalBreakpointInfo = GlobalBreakpointInfo;
GlobalBreakpointInfo.TypeMap = {
    0: GlobalBreakpointType.ERROR,
    1: GlobalBreakpointType.CAUGHT_ERROR,
    2: GlobalBreakpointType.WARNING,
    3: GlobalBreakpointType.NAN_INF,
    error: GlobalBreakpointType.ERROR,
    'caught error': GlobalBreakpointType.CAUGHT_ERROR,
    warning: GlobalBreakpointType.WARNING,
    naninf: GlobalBreakpointType.NAN_INF,
    [GlobalBreakpointType.ERROR]: GlobalBreakpointType.ERROR,
    [GlobalBreakpointType.CAUGHT_ERROR]: GlobalBreakpointType.CAUGHT_ERROR,
    [GlobalBreakpointType.WARNING]: GlobalBreakpointType.WARNING,
    [GlobalBreakpointType.NAN_INF]: GlobalBreakpointType.NAN_INF
};
var Events;
(function (Events) {
    Events["DBEnter"] = "DBEnter";
    Events["DBStop"] = "DBStop";
    Events["DBExit"] = "DBExit";
    Events["DBCont"] = "DBCont";
    Events["DBWorkspaceChanged"] = "DBWorkspaceChanged";
    Events["BreakpointAdded"] = "BreakpointAdded";
    Events["BreakpointRemoved"] = "BreakpointRemoved";
    Events["BreakpointsCleared"] = "BreakpointsCleared";
    Events["GlobalBreakpointAdded"] = "GlobalBreakpointAdded";
    Events["GlobalBreakpointRemoved"] = "GlobalBreakpointRemoved";
})(Events || (Events = {}));
class DebugServices extends events_1.default {
    constructor(mvm) {
        super();
        this._mvm = mvm;
        this._setupListeners();
    }
    _setupListeners() {
        this._mvm.on('EnterDebuggerEvent', this._handleEnterEvent.bind(this));
        this._mvm.on('EnterDebuggerWithWarningEvent', this._handleEnterEvent.bind(this));
        this._mvm.on('ExitDebuggerEvent', this._handleExitEvent.bind(this));
        this._mvm.on('ContinueExecutionEvent', (data) => {
            this.emit(DebugServices.Events.DBCont);
        });
        this._mvm.on('ChangeCurrentWorkspace', (data) => {
            this.emit(DebugServices.Events.DBWorkspaceChanged);
        });
        this._mvm.on('AddLineNumberBreakpointEvent', (data) => {
            this.emit(DebugServices.Events.BreakpointAdded, new BreakpointInfo(data.Filespec, data.LineNumber, data.Condition, data.whichAnonymousFunctionOnCurrentLine));
        });
        this._mvm.on('DeleteLineNumberBreakpointEvent', (data) => {
            this.emit(DebugServices.Events.BreakpointRemoved, new BreakpointInfo(data.Filespec, data.LineNumber, data.Condition, data.whichAnonymousFunctionOnCurrentLine));
        });
        this._mvm.on('DeleteAllBreakpointsEvent', () => {
            this.emit(DebugServices.Events.BreakpointsCleared);
        });
        this._mvm.on('AddProgramWideBreakpointEvent', (data) => {
            this.emit(DebugServices.Events.GlobalBreakpointAdded, new GlobalBreakpointInfo(GlobalBreakpointInfo.TypeMap[data.programWideTag], data.messageIdentifier === 'all' ? [] : [data.messageIdentifier]));
        });
        this._mvm.on('DeleteProgramWideBreakpointEvent', (data) => {
            this.emit(DebugServices.Events.GlobalBreakpointRemoved, new GlobalBreakpointInfo(GlobalBreakpointInfo.TypeMap[data.programWideTag], data.messageIdentifier === 'all' ? [] : [data.messageIdentifier]));
        });
    }
    _isSessionLevelEvent(eventData) {
        if (this._mvm.getMatlabRelease() === 'R2021b') {
            return eventData.DebugNestLevel >= 3;
        }
        else {
            return eventData.DebugNestLevel === 2;
        }
    }
    _handleEnterEvent(data) {
        var _a;
        if (this._isSessionLevelEvent(data)) {
            this.emit(DebugServices.Events.DBEnter);
        }
        else {
            const filepath = data.Filespec;
            const lineNumber = data.IsAtEndOfFunction ? -data.LineNumber : data.LineNumber;
            this.emit(DebugServices.Events.DBStop, filepath, lineNumber, (_a = data.Stack) !== null && _a !== void 0 ? _a : []);
        }
    }
    _handleExitEvent(data) {
        if (this._isSessionLevelEvent(data)) {
            this.emit(DebugServices.Events.DBExit, data.IsDebuggerActive);
        }
    }
}
exports.DebugServices = DebugServices;
DebugServices.Events = Events;


/***/ }),

/***/ "./src/debug/MatlabDebugAdaptor.ts":
/*!*****************************************!*\
  !*** ./src/debug/MatlabDebugAdaptor.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug = __importStar(__webpack_require__(/*! @vscode/debugadapter */ "./node_modules/@vscode/debugadapter/lib/main.js"));
const DebugServices_1 = __webpack_require__(/*! ./DebugServices */ "./src/debug/DebugServices.ts");
const PromiseUtils_1 = __webpack_require__(/*! ../utils/PromiseUtils */ "./src/utils/PromiseUtils.ts");
const MVM_1 = __webpack_require__(/*! ../mvm/impl/MVM */ "./src/mvm/impl/MVM.js");
var BreakpointChangeType;
(function (BreakpointChangeType) {
    BreakpointChangeType[BreakpointChangeType["ADD"] = 0] = "ADD";
    BreakpointChangeType[BreakpointChangeType["REMOVE"] = 1] = "REMOVE";
})(BreakpointChangeType || (BreakpointChangeType = {}));
const mdaLength = function (obj) {
    if (obj instanceof Array) {
        return obj.length;
    }
    else if (obj.mwsize !== undefined) {
        return obj.mwsize[0];
    }
    else {
        return 1;
    }
};
const mdaUnwrap = function (obj, property, index) {
    const handleIndex = (intermediate, index) => {
        if (intermediate instanceof Array) {
            return intermediate[index !== null && index !== void 0 ? index : 0];
        }
        else if (index !== undefined) {
            if (index === 0 && intermediate[index] === undefined) {
                return intermediate;
            }
            else {
                return intermediate[index];
            }
        }
        else {
            return intermediate;
        }
    };
    if (obj.mwdata !== undefined) {
        if (property !== undefined) {
            return handleIndex(obj.mwdata[property], index);
        }
        else {
            return handleIndex(obj.mwdata, index);
        }
    }
    else {
        if (property !== undefined) {
            return handleIndex(obj[property], index);
        }
        else {
            return handleIndex(obj, index);
        }
    }
};
const isError = function (value) {
    return typeof (value) === 'object' && (value != null) && 'error' in value;
};
class MatlabDebugAdaptor {
    constructor(mvm, debugServices) {
        this._numberOfStackFrames = -1;
        this._breakpointChangeListeners = [];
        this._matlabBreakpoints = [];
        this._canonicalizedPathCache = new Map();
        this._isCurrentlyStopped = false;
        this._isCurrentlyDebugging = false;
        this._hasShownReplWarning = 0;
        this._mvm = mvm;
        this._debugServices = debugServices;
        this._pendingSetBreakpointPromise = undefined;
        this._pendingVariablesPromise = undefined;
        this._mvm.on(MVM_1.IMVM.Events.stateChange, (state) => {
            if (state === MVM_1.MatlabState.DISCONNECTED) {
                this._handleDisconnect();
                this._matlabBreakpoints = [];
            }
        });
        this._setupListeners();
    }
    handleRequest(request, response) {
        try {
            if (request.command === 'initialize') {
                void this.initializeRequest(response, request.arguments);
            }
            else if (request.command === 'terminate') {
                void this.terminateRequest(response, request.arguments, request);
            }
            else if (request.command === 'setBreakpoints') {
                void this.setBreakPointsRequest(response, request.arguments, request);
            }
            else if (request.command === 'continue') {
                void this.continueRequest(response, request.arguments, request);
            }
            else if (request.command === 'next') {
                void this.nextRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepIn') {
                void this.stepInRequest(response, request.arguments, request);
            }
            else if (request.command === 'stepOut') {
                void this.stepOutRequest(response, request.arguments, request);
            }
            else if (request.command === 'pause') {
                void this.pauseRequest(response, request.arguments, request);
            }
            else if (request.command === 'stackTrace') {
                void this.stackTraceRequest(response, request.arguments, request);
            }
            else if (request.command === 'scopes') {
                void this.scopesRequest(response, request.arguments, request);
            }
            else if (request.command === 'variables') {
                void this.variablesRequest(response, request.arguments, request);
            }
            else if (request.command === 'source') {
                void this.sourceRequest(response, request.arguments, request);
            }
            else if (request.command === 'threads') {
                void this.threadsRequest(response, request);
            }
            else if (request.command === 'evaluate') {
                void this.evaluateRequest(response, request.arguments, request);
            }
            else if (request.command === 'launch') {
                this.sendResponse(response);
            }
            else if (request.command === 'attach') {
                this.sendResponse(response);
            }
            else if (request.command === 'disconnect') {
                this.sendResponse(response);
            }
            else if (request.command === 'restart') {
                this.sendResponse(response);
            }
            else if (request.command === 'setFunctionBreakpoints') {
                this.sendResponse(response);
            }
            else if (request.command === 'setExceptionBreakpoints') {
                this.sendResponse(response);
            }
            else if (request.command === 'configurationDone') {
                this.sendResponse(response);
            }
            else if (request.command === 'stepBack') {
                this.sendResponse(response);
            }
            else if (request.command === 'reverseContinue') {
                this.sendResponse(response);
            }
            else if (request.command === 'restartFrame') {
                this.sendResponse(response);
            }
            else if (request.command === 'goto') {
                this.sendResponse(response);
            }
            else if (request.command === 'setVariable') {
                this.sendResponse(response);
            }
            else if (request.command === 'setExpression') {
                this.sendResponse(response);
            }
            else if (request.command === 'terminateThreads') {
                this.sendResponse(response);
            }
            else if (request.command === 'stepInTargets') {
                this.sendResponse(response);
            }
            else if (request.command === 'gotoTargets') {
                this.sendResponse(response);
            }
            else if (request.command === 'completions') {
                this.sendResponse(response);
            }
            else if (request.command === 'exceptionInfo') {
                this.sendResponse(response);
            }
            else if (request.command === 'loadedSources') {
                this.sendResponse(response);
            }
            else if (request.command === 'dataBreakpointInfo') {
                this.sendResponse(response);
            }
            else if (request.command === 'setDataBreakpoints') {
                this.sendResponse(response);
            }
            else if (request.command === 'readMemory') {
                this.sendResponse(response);
            }
            else if (request.command === 'writeMemory') {
                this.sendResponse(response);
            }
            else if (request.command === 'disassemble') {
                this.sendResponse(response);
            }
            else if (request.command === 'cancel') {
                this.sendResponse(response);
            }
            else if (request.command === 'breakpointLocations') {
                this.sendResponse(response);
            }
            else if (request.command === 'setInstructionBreakpoints') {
                this.sendResponse(response);
            }
            else {
                this.customRequest(request.command, response, request.arguments, request);
            }
        }
        catch (e) {
            console.log('Error with debug request', e);
        }
    }
    sendResponse(response) {
        throw new Error('Unimplemented method: sendResponse');
    }
    sendEvent(event) {
        throw new Error('Unimplemented method: sendResponse');
    }
    _waitForPendingBreakpointsRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._pendingSetBreakpointPromise !== undefined) {
                yield this._pendingSetBreakpointPromise;
            }
            this._pendingSetBreakpointPromise = (0, PromiseUtils_1.createResolvablePromise)();
        });
    }
    _waitForPendingVariablesRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._pendingVariablesPromise !== undefined) {
                yield this._pendingVariablesPromise;
            }
            this._pendingVariablesPromise = (0, PromiseUtils_1.createResolvablePromise)();
        });
    }
    _clearPendingBreakpointsRequest() {
        const oldPromise = this._pendingSetBreakpointPromise;
        this._pendingSetBreakpointPromise = undefined;
        oldPromise === null || oldPromise === void 0 ? void 0 : oldPromise.resolve();
    }
    _clearPendingVariablesRequest() {
        const oldPromise = this._pendingVariablesPromise;
        this._pendingVariablesPromise = undefined;
        oldPromise === null || oldPromise === void 0 ? void 0 : oldPromise.resolve();
    }
    _setupListeners() {
        this._debugServices.on(DebugServices_1.DebugServices.Events.BreakpointAdded, (breakpoint) => __awaiter(this, void 0, void 0, function* () {
            this._matlabBreakpoints.push(breakpoint);
            this._breakpointChangeListeners.forEach((listener) => {
                listener(BreakpointChangeType.ADD, breakpoint);
            });
        }));
        this._debugServices.on(DebugServices_1.DebugServices.Events.BreakpointRemoved, (breakpoint) => __awaiter(this, void 0, void 0, function* () {
            this._matlabBreakpoints = this._matlabBreakpoints.filter((existingBreakpoint) => {
                return !existingBreakpoint.equals(breakpoint, true);
            });
            this._breakpointChangeListeners.forEach((listener) => {
                listener(BreakpointChangeType.REMOVE, breakpoint);
            });
        }));
        this._debugServices.on(DebugServices_1.DebugServices.Events.DBEnter, () => __awaiter(this, void 0, void 0, function* () {
            const oldValue = this._isCurrentlyDebugging;
            this._isCurrentlyDebugging = true;
            if (oldValue !== this._isCurrentlyDebugging) {
                this._handleDebuggingStateChange();
            }
        }));
        this._debugServices.on(DebugServices_1.DebugServices.Events.DBExit, (isDebuggerStillActive) => __awaiter(this, void 0, void 0, function* () {
            const oldValue = this._isCurrentlyDebugging;
            this._isCurrentlyDebugging = isDebuggerStillActive;
            if (oldValue !== this._isCurrentlyDebugging) {
                this._handleDebuggingStateChange();
            }
            if (isDebuggerStillActive) {
                this.sendEvent(new debug.StoppedEvent('breakpoint', 0));
                return;
            }
            this.sendEvent(new debug.ExitedEvent(0));
            this.sendEvent(new debug.TerminatedEvent(false));
        }));
        this._debugServices.on(DebugServices_1.DebugServices.Events.DBCont, () => __awaiter(this, void 0, void 0, function* () {
            this._isCurrentlyStopped = false;
            this.sendEvent(new debug.ContinuedEvent(0, true));
        }));
        this._debugServices.on(DebugServices_1.DebugServices.Events.DBStop, (filename, lineNumber, stack) => __awaiter(this, void 0, void 0, function* () {
            this._isCurrentlyStopped = true;
            const oldValue = this._isCurrentlyDebugging;
            this._isCurrentlyDebugging = true;
            if (oldValue !== this._isCurrentlyDebugging) {
                this._handleDebuggingStateChange();
            }
            this.sendEvent(new debug.StoppedEvent('breakpoint', 0));
        }));
    }
    _handleDebuggingStateChange() {
        // Intentionally unimplemented
    }
    _registerBreakpointChangeListener(listener) {
        this._breakpointChangeListeners.push(listener);
        return {
            remove: () => {
                const index = this._breakpointChangeListeners.indexOf(listener);
                if (index !== -1) {
                    this._breakpointChangeListeners.splice(index, 1);
                }
            }
        };
    }
    initializeRequest(response, args) {
        response.body = {
            // Supported Features
            supportsConfigurationDoneRequest: true,
            supportsConditionalBreakpoints: true,
            supportsEvaluateForHovers: true,
            supportsExceptionOptions: true,
            supportsExceptionInfoRequest: true,
            supportTerminateDebuggee: true,
            supportsTerminateRequest: true,
            supportsCancelRequest: true,
            supportsSingleThreadExecutionRequests: true,
            supportsSteppingGranularity: true,
            // Unsupported Features
            supportsHitConditionalBreakpoints: false,
            supportsFunctionBreakpoints: false,
            supportsStepBack: false,
            supportsSetVariable: false,
            supportsRestartFrame: false,
            supportsGotoTargetsRequest: false,
            supportsStepInTargetsRequest: false,
            supportsCompletionsRequest: false,
            supportsModulesRequest: false,
            supportsRestartRequest: true,
            supportsValueFormattingOptions: false,
            supportSuspendDebuggee: false,
            supportsDelayedStackTraceLoading: false,
            supportsLoadedSourcesRequest: false,
            supportsLogPoints: false,
            supportsTerminateThreadsRequest: false,
            supportsSetExpression: false,
            supportsDataBreakpoints: false,
            supportsReadMemoryRequest: false,
            supportsWriteMemoryRequest: false,
            supportsDisassembleRequest: false,
            supportsBreakpointLocationsRequest: false,
            supportsClipboardContext: false,
            supportsInstructionBreakpoints: false,
            supportsExceptionFilterOptions: false
        };
        this.sendResponse(response);
        this.sendEvent(new debug.InitializedEvent());
        if (this._isCurrentlyStopped) {
            this.sendEvent(new debug.StoppedEvent('breakpoint', 0));
        }
    }
    disconnectRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            void this._handleClientDisconnectRequest(response);
        });
    }
    terminateRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            void this._handleClientDisconnectRequest(response);
        });
    }
    _handleClientDisconnectRequest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isCurrentlyStopped) {
                this._mvm.interrupt();
            }
            try {
                yield this._mvm.eval("if system_dependent('IsDebugMode')==1, dbquit all; end");
            }
            catch (e) { }
            this.sendResponse(response);
            this._cleanup();
            this.sendEvent(new debug.ExitedEvent(0));
            this.sendEvent(new debug.TerminatedEvent(false));
        });
    }
    setBreakPointsRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            const source = args.source;
            if (source.path === undefined) {
                this.sendResponse(response);
                return;
            }
            try {
                yield this._waitForPendingBreakpointsRequest();
            }
            catch (e) {
                return;
            }
            const canonicalizedPath = yield this._getCanonicalPath(source.path);
            const newBreakpoints = (args.breakpoints != null)
                ? args.breakpoints.map((breakpoint) => {
                    return new DebugServices_1.BreakpointInfo(canonicalizedPath, breakpoint.line, breakpoint.condition, 0);
                })
                : [];
            const matlabBreakpointsForFile = this._matlabBreakpoints.filter((breakpoint) => {
                return breakpoint.filePath === canonicalizedPath;
            });
            const breakpointsToAdd = newBreakpoints.map((newBreakpoint) => {
                if (matlabBreakpointsForFile.some((matlabBreakpoint) => {
                    return newBreakpoint.equals(matlabBreakpoint, false);
                })) {
                    return {
                        preexisting: true,
                        info: newBreakpoint
                    };
                }
                else {
                    return {
                        preexisting: false,
                        info: newBreakpoint
                    };
                }
            });
            const breakpointsToRemove = matlabBreakpointsForFile.filter((matlabBreakpoint) => {
                return !newBreakpoints.some((newBreakpoint) => {
                    return newBreakpoint.equals(matlabBreakpoint, true);
                });
            });
            // Remove all breakpoints that are now gone.
            const breakpointsRemovalPromises = [];
            breakpointsToRemove.forEach((breakpoint) => {
                breakpointsRemovalPromises.push(this._mvm.clearBreakpoint(breakpoint.filePath, breakpoint.lineNumber));
            });
            yield Promise.all(breakpointsRemovalPromises);
            response.body = {
                breakpoints: []
            };
            for (const newBreakpoint of breakpointsToAdd) {
                // Pre-existing breakpoints are not sent to the server.
                if (newBreakpoint.preexisting) {
                    const breakpoint = new debug.Breakpoint(true, newBreakpoint.info.lineNumber, undefined, source);
                    response.body.breakpoints.push(breakpoint);
                    continue;
                }
                let matlabBreakpointInfos = [];
                const listener = this._registerBreakpointChangeListener((changeType, bpInfo) => {
                    if (changeType === BreakpointChangeType.ADD && bpInfo.filePath === canonicalizedPath) {
                        matlabBreakpointInfos.push(bpInfo);
                    }
                });
                yield this._mvm.setBreakpoint(canonicalizedPath, newBreakpoint.info.lineNumber, newBreakpoint.info.condition);
                listener.remove();
                if (matlabBreakpointInfos.length === 0) {
                    matlabBreakpointInfos.push(new DebugServices_1.BreakpointInfo(canonicalizedPath, newBreakpoint.info.lineNumber, undefined, 0));
                }
                else if (matlabBreakpointInfos.length > 1) {
                    matlabBreakpointInfos = [matlabBreakpointInfos[0]];
                }
                const matlabBP = matlabBreakpointInfos[0];
                const breakpoint = new debug.Breakpoint(true, matlabBP.lineNumber, undefined, source);
                response.body.breakpoints.push(breakpoint);
            }
            this.sendResponse(response);
            this._clearPendingBreakpointsRequest();
        });
    }
    continueRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._mvm.eval("if system_dependent('IsDebugMode')==1, dbcont; end");
            }
            catch (e) { }
            this.sendResponse(response);
        });
    }
    nextRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._mvm.eval("if system_dependent('IsDebugMode')==1, dbstep; end");
            }
            catch (e) { }
            this.sendResponse(response);
        });
    }
    stepInRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._mvm.eval("if system_dependent('IsDebugMode')==1, dbstep in; end");
            }
            catch (e) { }
            this.sendResponse(response);
        });
    }
    stepOutRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._mvm.eval("if system_dependent('IsDebugMode')==1, dbstep out; end");
            }
            catch (e) { }
            this.sendResponse(response);
        });
    }
    sourceRequest(response, args, request) {
        this.sendResponse(response);
    }
    threadsRequest(response, request) {
        response.body = {
            threads: [
                new debug.Thread(0, 'MATLAB')
            ]
        };
        this.sendResponse(response);
    }
    stackTraceRequest(response, args, request) {
        return __awaiter(this, void 0, void 0, function* () {
            response.body = { stackFrames: [], totalFrames: 0 };
            this._numberOfStackFrames = 0;
            let stackResponse;
            try {
                stackResponse = yield this._mvm.feval('dbstack', 1, ['-completenames']);
            }
            catch (e) {
                return;
            }
            const transformStack = (stack) => {
                var _a;
                if (((_a = stack[0]) === null || _a === void 0 ? void 0 : _a.mwtype) !== undefined) {
                    stack = stack[0];
                    const size = stack.mwsize[0];
                    const newStack = [];
                    for (let i = 0; i < size; i++) {
                        newStack.push(new debug.StackFrame(size - i + 1, stack.mwdata.name[i], new debug.Source(stack.mwdata.name[i], stack.mwdata.file[i]), Math.abs(stack.mwdata.line[i]), 1));
                    }
                    return newStack;
                }
                else {
                    const numberOfStackFrames = stack.length;
                    return stack.map((stackFrame, i) => new debug.StackFrame(numberOfStackFrames - i + 1, stackFrame.name, new debug.Source(stackFrame.name, stackFrame.file), Math.abs(stackFrame.line), 1));
                }
            };
            const stack = transformStack(stackResponse.result);
            const baseFrame = new debug.StackFrame(1, 'Base');
            baseFrame.presentationHint = 'label';
            stack.push(baseFrame);
            response.body = { stackFrames: stack, totalFrames: stack.length };
            this._numberOfStackFrames = stack.length;
            this.sendResponse(response);
        });
    }
    scopesRequest(response, args, request) {
        const scope = {
            name: 'Locals',
            variablesReference: args.frameId,
            expensive: false,
            presentationHint: 'locals'
        };
        response.body = {
            scopes: [
                scope
            ]
        };
        this.sendResponse(response);
    }
    variablesRequest(response, args, request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            response.body = { variables: [] };
            let stackChanger;
            try {
                stackChanger = yield this._moveToFrame(args.variablesReference);
            }
            catch (e) {
                this.sendResponse(response);
                return;
            }
            const maybeVariableResult = yield this._mvm.feval('matlab.internal.datatoolsservices.getWorkspaceDisplay', 1, ['caller']);
            if (stackChanger != null) {
                try {
                    void stackChanger.revert();
                }
                catch (e) {
                    this.sendResponse(response);
                    return;
                }
            }
            if (isError(maybeVariableResult)) {
                this.sendResponse(response);
                return;
            }
            const variableResult = maybeVariableResult.result[0];
            const numberOfVariables = mdaLength(variableResult);
            const unwrap = (struct, field, index) => mdaUnwrap(mdaUnwrap(struct, field, index));
            for (let i = 0; i < numberOfVariables; i++) {
                const name = unwrap(variableResult, 'Name', i);
                const type = unwrap(variableResult, 'Class', i);
                const size = unwrap(variableResult, 'Size', i);
                const value = unwrap(variableResult, 'Value', i);
                // eslint-disable-next-line  @typescript-eslint/no-unused-vars
                const isSummary = unwrap(variableResult, 'IsSummary', i);
                const combinedType = type === 'double' ? `${size}` : `${size} ${type}`;
                const variable = {
                    name,
                    value,
                    type: combinedType,
                    presentationHint: {
                        kind: 'data',
                        attributes: [],
                        visibility: 'public',
                        lazy: false
                    },
                    evaluateName: undefined,
                    variablesReference: 0
                };
                (_b = (_a = variable === null || variable === void 0 ? void 0 : variable.presentationHint) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.push('readOnly');
                response.body.variables.push(variable);
            }
            this.sendResponse(response);
        });
    }
    evaluateRequest(response, args, request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let stackChanger;
            try {
                stackChanger = yield this._moveToFrame(args.frameId);
            }
            catch (e) {
                this.sendResponse(response);
                return;
            }
            let maybeResult;
            const oldHotlinks = yield this._mvm.feval('feature', 1, ['HotLinks']);
            if (args.context === 'repl') {
                maybeResult = yield this._mvm.feval('evalc', 1, ['try, feature(\'HotLinks\', 0); ' + args.expression + ', catch exceptionObj; try; showReport(exceptionObj), end; clear exceptionObj; end']);
                if (this._hasShownReplWarning < 3) {
                    this.sendEvent(new debug.OutputEvent('For best results, evaluate expressions in the MATLAB Terminal.', 'console'));
                    this._hasShownReplWarning++;
                }
            }
            else if (args.context === 'watch') {
                maybeResult = yield this._mvm.feval('evalc', 1, ['try, disp(' + args.expression + "), catch, disp('Error evaluating expression'); end"]);
            }
            else {
                maybeResult = yield this._mvm.feval('evalc', 1, ["try, datatipinfo('" + args.expression + "'), catch, disp('Error evaluating expression'); end"]);
            }
            yield this._mvm.feval('feature', 0, ['HotLinks', ((_b = (_a = oldHotlinks === null || oldHotlinks === void 0 ? void 0 : oldHotlinks.result) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : true)]);
            if (stackChanger !== null) {
                try {
                    void stackChanger.revert();
                }
                catch (e) {
                    this.sendResponse(response);
                    return;
                }
            }
            if (isError(maybeResult)) {
                this.sendResponse(response);
                return;
            }
            let result = maybeResult.result[0];
            // eslint-disable-next-line no-control-regex
            result = result.replace(/(\[|\]|\{|\})\x08/g, '');
            result = result.trim();
            if (result === '') {
                this.sendResponse(response);
                return;
            }
            response.body = {
                result: result,
                variablesReference: 0
            };
            response.body.type = 'string';
            response.body.presentationHint = {
                kind: 'data',
                attributes: ['rawString']
            };
            this.sendResponse(response);
        });
    }
    pauseRequest(response, args, request) {
        this.sendResponse(response);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    customRequest(command, response, args, request) {
        if (command === 'cacheFilePath') {
            this._getCanonicalPath(args.fileName).then(() => { }, () => { });
        }
        this.sendResponse(response);
    }
    _cleanup() {
        this._numberOfStackFrames = -1;
        if (this._pendingSetBreakpointPromise != null) {
            this._pendingSetBreakpointPromise.reject();
            this._pendingSetBreakpointPromise = undefined;
        }
        if (this._pendingVariablesPromise != null) {
            this._pendingVariablesPromise.reject();
            this._pendingVariablesPromise = undefined;
        }
        this._breakpointChangeListeners = [];
    }
    _handleDisconnect() {
        this._cleanup();
        this.sendEvent(new debug.ExitedEvent(0));
        this.sendEvent(new debug.TerminatedEvent(false));
    }
    _moveToFrame(frameId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (frameId === undefined) {
                return null;
            }
            try {
                yield this._waitForPendingVariablesRequest();
            }
            catch (e) {
                return null;
            }
            const dbAmount = this._numberOfStackFrames - frameId;
            if (dbAmount !== 0) {
                try {
                    if (dbAmount > 0) {
                        yield this._mvm.feval('dbup', 0, [dbAmount]);
                    }
                    else {
                        yield this._mvm.feval('dbdown', 0, [-dbAmount]);
                    }
                }
                catch (e) {
                    this._clearPendingVariablesRequest();
                    throw e;
                }
            }
            return {
                revert: () => __awaiter(this, void 0, void 0, function* () {
                    const dbAmount = this._numberOfStackFrames - frameId;
                    if (dbAmount !== 0) {
                        try {
                            if (dbAmount > 0) {
                                yield this._mvm.feval('dbdown', 0, [dbAmount]);
                            }
                            else {
                                yield this._mvm.feval('dbup', 0, [-dbAmount]);
                            }
                        }
                        catch (e) {
                            this._clearPendingVariablesRequest();
                            return;
                        }
                    }
                    this._clearPendingVariablesRequest();
                })
            };
        });
    }
    _getCanonicalPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            let cachePromise = this._canonicalizedPathCache.get(path);
            if (cachePromise === undefined) {
                cachePromise = (0, PromiseUtils_1.createResolvablePromise)();
                this._canonicalizedPathCache.set(path, cachePromise);
                let canonicalizeResult;
                try {
                    canonicalizeResult = yield this._mvm.feval('builtin', 1, ['_canonicalizepath', path]);
                }
                catch (e) {
                    cachePromise.reject();
                    this._canonicalizedPathCache.delete(path);
                    return yield cachePromise;
                }
                if (isError(canonicalizeResult)) {
                    cachePromise.reject();
                    this._canonicalizedPathCache.delete(path);
                    return yield cachePromise;
                }
                const resultPath = canonicalizeResult.result[0];
                cachePromise.resolve(resultPath);
                return resultPath;
            }
            else {
                return yield cachePromise;
            }
        });
    }
}
exports["default"] = MatlabDebugAdaptor;
MatlabDebugAdaptor._nextId = 1;


/***/ }),

/***/ "./src/debug/MatlabDebugAdaptorServer.ts":
/*!***********************************************!*\
  !*** ./src/debug/MatlabDebugAdaptorServer.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const MatlabDebugAdaptor_1 = __importDefault(__webpack_require__(/*! ./MatlabDebugAdaptor */ "./src/debug/MatlabDebugAdaptor.ts"));
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
class MatlabDebugAdaptorServer extends MatlabDebugAdaptor_1.default {
    constructor(mvm, debugServices) {
        super(mvm, debugServices);
        this._notifier = NotificationService_1.default;
        this._notifier.registerNotificationListener(NotificationService_1.Notification.DebugAdaptorRequest, this._handleServerRequest.bind(this));
    }
    _handleDebuggingStateChange() {
        this._notifier.sendNotification(NotificationService_1.Notification.DebuggingStateChange, this._isCurrentlyDebugging);
    }
    _handleServerRequest(packagedRequest) {
        const request = packagedRequest.debugRequest;
        const response = {
            seq: 0,
            type: 'response',
            success: true,
            command: request.command,
            request_seq: request.seq,
            tag: packagedRequest.tag
        };
        this.handleRequest(request, response);
    }
    sendResponse(response) {
        const tag = response.tag;
        delete response.tag;
        const packagedResponse = {
            debugResponse: response,
            tag
        };
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.DebugAdaptorResponse, packagedResponse);
    }
    sendEvent(event) {
        const packagedEvent = {
            debugEvent: event
        };
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.DebugAdaptorEvent, packagedEvent);
    }
}
exports["default"] = MatlabDebugAdaptorServer;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Start up the LSP server
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ./ClientConnection */ "./src/ClientConnection.ts"));
const server = __importStar(__webpack_require__(/*! ./server */ "./src/server.ts"));
// Start up the language server
void server.startServer();
// Listen on the client connection
ClientConnection_1.default.getConnection().listen();


/***/ }),

/***/ "./src/indexing/DocumentIndexer.ts":
/*!*****************************************!*\
  !*** ./src/indexing/DocumentIndexer.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const FileInfoIndex_1 = __importDefault(__webpack_require__(/*! ./FileInfoIndex */ "./src/indexing/FileInfoIndex.ts"));
const INDEXING_DELAY = 500; // Delay (in ms) after keystroke before attempting to re-index the document
/**
 * Handles indexing a currently open document to gather data about classes,
 * functions, and variables.
 */
class DocumentIndexer {
    constructor(indexer) {
        this.indexer = indexer;
        this.pendingFilesToIndex = new Map();
    }
    /**
     * Queues a document to be indexed. This handles debouncing so that
     * indexing is not performed on every keystroke.
     *
     * @param textDocument The document to be indexed
     */
    queueIndexingForDocument(textDocument) {
        const uri = textDocument.uri;
        this.clearTimerForDocumentUri(uri);
        this.pendingFilesToIndex.set(uri, setTimeout(() => {
            this.indexDocument(textDocument);
        }, INDEXING_DELAY) // Specify timeout for debouncing, to avoid re-indexing every keystroke while a user types
        );
    }
    /**
     * Indexes the document and caches the data.
     *
     * @param textDocument The document being indexed
     */
    indexDocument(textDocument) {
        void this.indexer.indexDocument(textDocument);
    }
    /**
     * Clears any active indexing timers for the provided document URI.
     *
     * @param uri The document URI
     */
    clearTimerForDocumentUri(uri) {
        const timerId = this.pendingFilesToIndex.get(uri);
        if (timerId != null) {
            clearTimeout(timerId);
            this.pendingFilesToIndex.delete(uri);
        }
    }
    /**
     * Ensure that @param textDocument is fully indexed and up to date by flushing any pending indexing tasks
     * and then forcing an index. This is intended to service requests like documentSymbols where returning
     * stale info could be confusing.
     *
     * @param textDocument The document to index
     */
    ensureDocumentIndexIsUpdated(textDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = textDocument.uri;
            if (this.pendingFilesToIndex.has(uri)) {
                this.clearTimerForDocumentUri(uri);
                yield this.indexer.indexDocument(textDocument);
            }
            if (!FileInfoIndex_1.default.codeDataCache.has(uri)) {
                yield this.indexer.indexDocument(textDocument);
            }
        });
    }
}
exports["default"] = DocumentIndexer;


/***/ }),

/***/ "./src/indexing/FileInfoIndex.ts":
/*!***************************************!*\
  !*** ./src/indexing/FileInfoIndex.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatlabCodeData = exports.MatlabFunctionInfo = exports.MatlabClassMemberInfo = exports.MatlabClassInfo = exports.FunctionVisibility = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const PositionUtils_1 = __webpack_require__(/*! ../utils/PositionUtils */ "./src/utils/PositionUtils.ts");
var FunctionVisibility;
(function (FunctionVisibility) {
    FunctionVisibility[FunctionVisibility["Public"] = 0] = "Public";
    FunctionVisibility[FunctionVisibility["Private"] = 1] = "Private";
})(FunctionVisibility = exports.FunctionVisibility || (exports.FunctionVisibility = {}));
/**
 * Serves as an cache of data extracted from files
 */
class FileInfoIndex {
    constructor() {
        /**
         * Maps document URI to the code data
         */
        this.codeDataCache = new Map();
        /**
         * Maps class name to class info
         */
        this.classInfoCache = new Map();
    }
    static getInstance() {
        if (FileInfoIndex.instance == null) {
            FileInfoIndex.instance = new FileInfoIndex();
        }
        return FileInfoIndex.instance;
    }
    /**
     * Parses the raw data into a more usable form. Caches the resulting data
     * in the code data index.
     *
     * @param uri The uri of the document from which the data was extracted
     * @param rawCodeData The raw data
     * @returns An object containing the parsed data
     */
    parseAndStoreCodeData(uri, rawCodeData) {
        let parsedCodeData;
        if (rawCodeData.classInfo.hasClassInfo) {
            let classInfo = this.classInfoCache.get(rawCodeData.classInfo.name);
            if (classInfo == null) {
                // Class not discovered yet - need to create info object
                classInfo = new MatlabClassInfo(rawCodeData.classInfo, uri);
                this.classInfoCache.set(classInfo.name, classInfo);
            }
            else {
                // Class already known - update data
                classInfo.appendClassData(rawCodeData.classInfo, uri);
            }
            parsedCodeData = new MatlabCodeData(uri, rawCodeData, classInfo);
        }
        else {
            parsedCodeData = new MatlabCodeData(uri, rawCodeData);
        }
        // Store in cache
        this.codeDataCache.set(uri, parsedCodeData);
        return parsedCodeData;
    }
}
/**
 * Class to contain info about a class
 */
class MatlabClassInfo {
    constructor(rawClassInfo, uri) {
        this.uri = uri;
        this.methods = new Map();
        this.properties = new Map();
        this.enumerations = new Map();
        this.name = rawClassInfo.name;
        this.baseClasses = rawClassInfo.baseClasses;
        this.classDefFolder = rawClassInfo.classDefFolder;
        if (rawClassInfo.isClassDef) {
            this.range = convertRange(rawClassInfo.range);
            this.declaration = convertRange(rawClassInfo.declaration);
        }
        this.parsePropertiesAndEnums(rawClassInfo);
    }
    /**
     * Appends the new data to the existing class data.
     *
     * Specifically, when the new data represents the classdef file, information about
     * the URI, base classes, and range/declaration are added to the existing data.
     *
     * @param rawClassInfo The raw class data being appended
     * @param uri The document URI corresponding to the class data
     */
    appendClassData(rawClassInfo, uri) {
        if (rawClassInfo.isClassDef) {
            // Data contains class definition
            this.uri = uri;
            this.baseClasses = rawClassInfo.baseClasses;
            this.range = convertRange(rawClassInfo.range);
            this.declaration = convertRange(rawClassInfo.declaration);
            // Since this is the classdef, we'll update all members. Clear them out here.
            this.enumerations.clear();
            this.properties.clear();
            this.methods.clear();
            this.parsePropertiesAndEnums(rawClassInfo);
        }
        else {
            // Data contains supplementary class info - nothing to do in this situation
        }
    }
    /**
     * Appends info about a method to the class's info.
     *
     * This will not replace info about a method's implementation with info about a method prototype.
     *
     * @param functionInfo The method's information
     */
    addMethod(functionInfo) {
        var _a, _b;
        // Only store the method if a non-prototype version of it is not
        // already stored, as that will contain better information.
        const name = functionInfo.name;
        const shouldStoreMethod = !functionInfo.isPrototype || ((_b = (_a = this.methods.get(name)) === null || _a === void 0 ? void 0 : _a.isPrototype) !== null && _b !== void 0 ? _b : true);
        if (shouldStoreMethod) {
            this.methods.set(name, functionInfo);
        }
    }
    /**
     * Parses information about the class's properties and enums from the raw data.
     *
     * @param rawClassInfo The raw class info
     */
    parsePropertiesAndEnums(rawClassInfo) {
        rawClassInfo.properties.forEach(propertyInfo => {
            const name = propertyInfo.name;
            this.properties.set(name, new MatlabClassMemberInfo(propertyInfo));
        });
        rawClassInfo.enumerations.forEach(enumerationInfo => {
            const name = enumerationInfo.name;
            this.enumerations.set(name, new MatlabClassMemberInfo(enumerationInfo));
        });
    }
}
exports.MatlabClassInfo = MatlabClassInfo;
/**
 * Class to contain info about members of a class (e.g. Properties or Enumerations)
 */
class MatlabClassMemberInfo {
    constructor(rawPropertyInfo) {
        this.name = rawPropertyInfo.name;
        this.range = convertRange(rawPropertyInfo.range);
        this.parentClass = rawPropertyInfo.parentClass;
    }
}
exports.MatlabClassMemberInfo = MatlabClassMemberInfo;
/**
 * Class to contain info about functions
 */
class MatlabFunctionInfo {
    constructor(rawFunctionInfo, uri) {
        this.uri = uri;
        this.name = rawFunctionInfo.name;
        this.range = convertRange(rawFunctionInfo.range);
        this.declaration = rawFunctionInfo.declaration != null ? convertRange(rawFunctionInfo.declaration) : null;
        this.isPrototype = rawFunctionInfo.isPrototype;
        this.parentClass = rawFunctionInfo.parentClass;
        this.isClassMethod = this.parentClass !== '';
        this.visibility = rawFunctionInfo.isPublic ? FunctionVisibility.Public : FunctionVisibility.Private;
        this.variableInfo = new Map();
        this.parseVariableInfo(rawFunctionInfo);
    }
    /**
     * Parses information about variables within the function from the raw data.
     *
     * @param rawFunctionInfo The raw function info
     */
    parseVariableInfo(rawFunctionInfo) {
        const variableInfo = rawFunctionInfo.variableInfo;
        const globals = rawFunctionInfo.globals;
        variableInfo.definitions.forEach(varDefinition => {
            const name = varDefinition[0];
            const range = convertRange(varDefinition[1]);
            const varInfo = this.getOrCreateVariableInfo(name, globals);
            varInfo.addDefinition(range);
        });
        variableInfo.references.forEach(varReference => {
            const name = varReference[0];
            const range = convertRange(varReference[1]);
            const varInfo = this.getOrCreateVariableInfo(name, globals);
            varInfo.addReference(range);
        });
    }
    /**
     * Attempts to retrieve an existing MatlabVariableInfo object for the requested variable.
     * Creates a new instance if one does not already exist.
     *
     * @param name The variable's name
     * @param globals The list of global variables
     * @returns The MatlabVariableInfo object for the variable
     */
    getOrCreateVariableInfo(name, globals) {
        let variableInfo = this.variableInfo.get(name);
        if (variableInfo == null) {
            const isGlobal = globals.includes(name);
            variableInfo = new MatlabVariableInfo(name, isGlobal);
            this.variableInfo.set(name, variableInfo);
        }
        return variableInfo;
    }
}
exports.MatlabFunctionInfo = MatlabFunctionInfo;
/**
 * Class to contain info about variables
 */
class MatlabVariableInfo {
    constructor(name, isGlobal) {
        this.name = name;
        this.isGlobal = isGlobal;
        this.definitions = [];
        this.references = [];
    }
    /**
     * Add a definition for the variable
     *
     * @param range The range of the definition
     */
    addDefinition(range) {
        this.definitions.push(range);
    }
    /**
     * Add a reference for the variable
     *
     * @param range The range of the reference
     */
    addReference(range) {
        this.references.push(range);
    }
}
/**
 * Class to contain info about an entire file
 */
class MatlabCodeData {
    constructor(uri, rawCodeData, classInfo) {
        this.uri = uri;
        this.classInfo = classInfo;
        this.functions = new Map();
        this.references = new Map();
        this.sections = new Map();
        this.packageName = rawCodeData.packageName;
        this.errorMessage = undefined;
        this.parseFunctions(rawCodeData.functionInfo);
        this.parseReferences(rawCodeData.references);
        this.parseSectionInfo(rawCodeData.sections);
        this.parseErrorInfo(rawCodeData.errorInfo);
    }
    parseErrorInfo(errorInfo) {
        if (errorInfo == undefined) {
            this.errorMessage = undefined;
            return;
        }
        this.errorMessage = errorInfo.message;
    }
    /**
     * Whether or not the code data represents a class definition
     */
    get isClassDef() {
        return this.classInfo != null;
    }
    /**
     * Whether or not the code data represents a main classdef file.
     * For @aclass/aclass.m this returns true
     * For @aclass/amethod.m this returns false.
     */
    get isMainClassDefDocument() {
        var _a;
        return this.isClassDef && this.uri === ((_a = this.classInfo) === null || _a === void 0 ? void 0 : _a.uri);
    }
    /**
     * Finds the info for the function containing the given position.
     *
     * @param position A position in the document
     * @returns The info for the function containing the position, or null if no function contains that position.
     */
    findContainingFunction(position) {
        let containingFunction = null;
        for (const functionInfo of this.functions.values()) {
            const start = functionInfo.range.start;
            const end = functionInfo.range.end;
            // Check if position is within range
            if ((0, PositionUtils_1.isPositionLessThanOrEqualTo)(start, position) && (0, PositionUtils_1.isPositionGreaterThan)(end, position)) {
                if (containingFunction == null) {
                    containingFunction = functionInfo;
                }
                else {
                    // Prefer a narrower function if we already have a match (e.g. nested functions)
                    if ((0, PositionUtils_1.isPositionGreaterThan)(start, containingFunction.range.start)) {
                        containingFunction = functionInfo;
                    }
                }
            }
        }
        return containingFunction;
    }
    /**
     * Parses information about the file's functions.
     *
     * @param functionInfos The raw information about the functions in the file
     */
    parseFunctions(functionInfos) {
        functionInfos.forEach(functionInfo => {
            var _a;
            const fcnInfo = new MatlabFunctionInfo(functionInfo, this.uri);
            this.functions.set(fcnInfo.name, fcnInfo);
            if (fcnInfo.isClassMethod) {
                // Store the function info with the class as well
                (_a = this.classInfo) === null || _a === void 0 ? void 0 : _a.addMethod(fcnInfo);
            }
        });
    }
    /**
     * Parses information about the file's variable and function references.
     *
     * @param references The raw information about the references in the file
     */
    parseReferences(references) {
        references.forEach(reference => {
            var _a;
            const funcName = reference[0];
            const range = convertRange(reference[1]);
            if (!this.references.has(funcName)) {
                // First time seeing this reference
                this.references.set(funcName, [range]);
            }
            else {
                (_a = this.references.get(funcName)) === null || _a === void 0 ? void 0 : _a.push(range);
            }
        });
    }
    /**
     * Parse raw section info to the section and set to this.sections
     * @param sectionsInfo Array of the section information of the file retrieved from MATLAB
     */
    parseSectionInfo(sectionsInfo) {
        sectionsInfo.forEach((sectionInfo) => {
            var _a;
            const { title, range: rangeSectionInfo } = sectionInfo;
            const range = convertRange(rangeSectionInfo);
            if (!this.sections.has(title)) {
                this.sections.set(title, [range]);
            }
            else {
                (_a = this.sections.get(title)) === null || _a === void 0 ? void 0 : _a.push(range);
            }
        });
    }
}
exports.MatlabCodeData = MatlabCodeData;
/**
 * Converts from a CodeDataRange to a Range as expected by the language server APIs.
 *
 * @param codeDataRange The CodeDataRange
 * @returns A Range corresponding to the inputted range
 */
function convertRange(codeDataRange) {
    // When converting, need to change value from 1-based to 0-based
    return vscode_languageserver_1.Range.create(codeDataRange.lineStart - 1, codeDataRange.charStart - 1, codeDataRange.lineEnd - 1, codeDataRange.charEnd - 1);
}
exports["default"] = FileInfoIndex.getInstance();


/***/ }),

/***/ "./src/indexing/Indexer.ts":
/*!*********************************!*\
  !*** ./src/indexing/Indexer.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
const FileInfoIndex_1 = __importDefault(__webpack_require__(/*! ./FileInfoIndex */ "./src/indexing/FileInfoIndex.ts"));
const fs = __importStar(__webpack_require__(/*! fs/promises */ "fs/promises"));
const ConfigurationManager_1 = __importDefault(__webpack_require__(/*! ../lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
class Indexer {
    constructor(matlabLifecycleManager, pathResolver) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.pathResolver = pathResolver;
        this.INDEX_DOCUMENT_REQUEST_CHANNEL = '/matlabls/indexDocument/request';
        this.INDEX_DOCUMENT_RESPONSE_CHANNEL = '/matlabls/indexDocument/response';
        this.INDEX_FOLDERS_REQUEST_CHANNEL = '/matlabls/indexFolders/request';
        this.INDEX_FOLDERS_RESPONSE_CHANNEL = '/matlabls/indexFolders/response';
    }
    /**
     * Indexes the given TextDocument and caches the data.
     *
     * @param textDocument The document being indexed
     */
    indexDocument(textDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            if (matlabConnection == null) {
                return;
            }
            const rawCodeData = yield this.getCodeData(textDocument.getText(), textDocument.uri, matlabConnection);
            const parsedCodeData = FileInfoIndex_1.default.parseAndStoreCodeData(textDocument.uri, rawCodeData);
            void this.indexAdditionalClassData(parsedCodeData, matlabConnection, textDocument.uri);
        });
    }
    /**
     * Indexes all M files within the given list of folders.
     *
     * @param folders A list of folder URIs to be indexed
     */
    indexFolders(folders) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            if (matlabConnection == null) {
                return;
            }
            const channelId = matlabConnection.getChannelId();
            const channel = `${this.INDEX_FOLDERS_RESPONSE_CHANNEL}/${channelId}`;
            const responseSub = matlabConnection.subscribe(channel, message => {
                const fileResults = message;
                if (fileResults.isDone) {
                    // No more files being indexed - safe to unsubscribe
                    matlabConnection.unsubscribe(responseSub);
                }
                // Convert file path to URI, which is used as an index when storing the code data
                const fileUri = vscode_uri_1.URI.file(fileResults.filePath).toString();
                FileInfoIndex_1.default.parseAndStoreCodeData(fileUri, fileResults.codeData);
            });
            const analysisLimit = (yield ConfigurationManager_1.default.getConfiguration()).maxFileSizeForAnalysis;
            matlabConnection.publish(this.INDEX_FOLDERS_REQUEST_CHANNEL, {
                folders,
                channelId,
                analysisLimit
            });
        });
    }
    /**
     * Indexes the file for the given URI and caches the data.
     *
     * @param uri The URI for the file being indexed
     */
    indexFile(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            if (matlabConnection == null) {
                return;
            }
            const fileContentBuffer = yield fs.readFile(vscode_uri_1.URI.parse(uri).fsPath);
            const code = fileContentBuffer.toString();
            const rawCodeData = yield this.getCodeData(code, uri, matlabConnection);
            FileInfoIndex_1.default.parseAndStoreCodeData(uri, rawCodeData);
        });
    }
    /**
     * Retrieves data about classes, functions, and variables from the given document.
     *
     * @param code The code being parsed
     * @param uri The URI associated with the code
     * @param matlabConnection The connection to MATLAB
     *
     * @returns The raw data extracted from the document
     */
    getCodeData(code, uri, matlabConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = vscode_uri_1.URI.parse(uri).fsPath;
            return yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.INDEX_DOCUMENT_RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    resolve(message);
                });
                const analysisLimit = (yield ConfigurationManager_1.default.getConfiguration()).maxFileSizeForAnalysis;
                matlabConnection.publish(this.INDEX_DOCUMENT_REQUEST_CHANNEL, {
                    code,
                    filePath,
                    channelId,
                    analysisLimit
                });
            }));
        });
    }
    /**
     * Indexes any supplemental files if the parsed code data represents a class.
     * This will index any other files in a @ directory, as well as any direct base classes.
     *
     * @param parsedCodeData The parsed code data
     * @param matlabConnection The connection to MATLAB
     * @param uri The document's URI
     */
    indexAdditionalClassData(parsedCodeData, matlabConnection, uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (parsedCodeData.classInfo == null) {
                return;
            }
            // Queue indexing for other files in @ class directory
            const classDefFolder = parsedCodeData.classInfo.classDefFolder;
            if (classDefFolder !== '') {
                void this.indexFolders([classDefFolder]);
            }
            // Find and queue indexing for parent classes
            const baseClasses = parsedCodeData.classInfo.baseClasses;
            const resolvedBaseClasses = yield this.pathResolver.resolvePaths(baseClasses, uri, matlabConnection);
            resolvedBaseClasses.forEach(resolvedBaseClass => {
                const uri = resolvedBaseClass.uri;
                if (uri !== '') {
                    void this.indexFile(uri);
                }
            });
        });
    }
}
exports["default"] = Indexer;


/***/ }),

/***/ "./src/indexing/SymbolSearchService.ts":
/*!*********************************************!*\
  !*** ./src/indexing/SymbolSearchService.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportTelemetry = exports.RequestType = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const FileInfoIndex_1 = __importStar(__webpack_require__(/*! ./FileInfoIndex */ "./src/indexing/FileInfoIndex.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const TextDocumentUtils_1 = __webpack_require__(/*! ../utils/TextDocumentUtils */ "./src/utils/TextDocumentUtils.ts");
const fs = __importStar(__webpack_require__(/*! fs/promises */ "fs/promises"));
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
var RequestType;
(function (RequestType) {
    RequestType[RequestType["Definition"] = 0] = "Definition";
    RequestType[RequestType["References"] = 1] = "References";
    RequestType[RequestType["DocumentSymbol"] = 2] = "DocumentSymbol";
    RequestType[RequestType["RenameSymbol"] = 3] = "RenameSymbol";
})(RequestType = exports.RequestType || (exports.RequestType = {}));
function reportTelemetry(type, errorCondition = '') {
    let action;
    switch (type) {
        case RequestType.Definition:
            action = TelemetryUtils_1.Actions.GoToDefinition;
            break;
        case RequestType.References:
            action = TelemetryUtils_1.Actions.GoToReference;
            break;
        case RequestType.DocumentSymbol:
            action = TelemetryUtils_1.Actions.DocumentSymbol;
            break;
        case RequestType.RenameSymbol:
            action = TelemetryUtils_1.Actions.RenameSymbol;
            break;
    }
    (0, TelemetryUtils_1.reportTelemetryAction)(action, errorCondition);
}
exports.reportTelemetry = reportTelemetry;
class SymbolSearchService {
    constructor() {
        this.DOTTED_IDENTIFIER_REGEX = /[\w.]+/;
    }
    static getInstance() {
        if (SymbolSearchService.instance == null) {
            SymbolSearchService.instance = new SymbolSearchService();
        }
        return SymbolSearchService.instance;
    }
    /**
     * Finds references of an expression.
     *
     * @param uri The URI of the document containing the expression
     * @param position The position of the expression
     * @param expression The expression for which we are looking for references
     * @param documentManager The text document manager
     * @param requestType The type of request (definition, references, or rename)
     * @returns The references' locations
     */
    findReferences(uri, position, expression, documentManager, requestType) {
        // Get code data for current file
        const codeData = FileInfoIndex_1.default.codeDataCache.get(uri);
        if (codeData == null) {
            // File not indexed - unable to look for references
            reportTelemetry(requestType, 'File not indexed');
            return [];
        }
        const textDocument = documentManager.get(uri);
        if (textDocument == null) {
            reportTelemetry(requestType, 'No document');
            return [];
        }
        const line = (0, TextDocumentUtils_1.getTextOnLine)(textDocument, position.line);
        const commentStart = line.indexOf('%');
        if (commentStart > -1 && commentStart < position.character) {
            // Current expression is in a comment - no references should be returned
            return [];
        }
        const referencesInCodeData = this.findReferencesInCodeData(uri, position, expression, codeData);
        reportTelemetry(requestType);
        if (referencesInCodeData != null) {
            return referencesInCodeData;
        }
        return [];
    }
    /**
     * Searches for references, starting within the given code data. If the expression does not correspond to a local variable,
     *  the search is broadened to other indexed files in the user's workspace.
     *
     * @param uri The URI corresponding to the provided code data
     * @param position The position of the expression
     * @param expression The expression for which we are looking for references
     * @param codeData The code data which is being searched
     * @returns The references' locations, or null if no reference was found
     */
    findReferencesInCodeData(uri, position, expression, codeData) {
        var _a, _b, _c;
        // If first part of expression is targeted - look for a local variable
        if (expression.selectedComponent === 0) {
            const containingFunction = codeData.findContainingFunction(position);
            if (containingFunction != null) {
                const varRefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.References);
                if (varRefs != null) {
                    return varRefs;
                }
            }
        }
        // Check for functions in file
        const functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression);
        if (functionDeclaration != null && functionDeclaration.visibility === FileInfoIndex_1.FunctionVisibility.Private) {
            // Found a local function. Look through this file's references
            return (_b = (_a = codeData.references.get(functionDeclaration.name)) === null || _a === void 0 ? void 0 : _a.map(range => vscode_languageserver_1.Location.create(uri, range))) !== null && _b !== void 0 ? _b : [];
        }
        // Check other files
        const refs = [];
        for (const [, fileCodeData] of FileInfoIndex_1.default.codeDataCache) {
            if (((_c = fileCodeData.functions.get(expression.fullExpression)) === null || _c === void 0 ? void 0 : _c.visibility) === FileInfoIndex_1.FunctionVisibility.Private) {
                // Skip files with other local functions
                continue;
            }
            const varRefs = fileCodeData.references.get(expression.fullExpression);
            if (varRefs != null) {
                varRefs.forEach(range => refs.push(vscode_languageserver_1.Location.create(fileCodeData.uri, range)));
            }
        }
        return refs;
    }
    /**
     * Gets the definition/references of a variable within a function.
     *
     * @param containingFunction Info about a function
     * @param variableName The variable name for which we are looking for definitions or references
     * @param uri The URI of the file
     * @param requestType The type of request (definition or references)
     * @returns The locations of the definition(s) or references of the given variable name within the given function info, or null if none can be found
     */
    getVariableDefsOrRefs(containingFunction, variableName, uri, requestType) {
        const variableInfo = containingFunction.variableInfo.get(variableName);
        if (variableInfo == null) {
            return null;
        }
        const varInfoRanges = requestType === RequestType.Definition ? variableInfo.definitions : variableInfo.references;
        return varInfoRanges.map(range => {
            return vscode_languageserver_1.Location.create(uri, range);
        });
    }
    /**
     * Searches for info about a function within the given code data.
     *
     * @param codeData The code data being searched
     * @param functionName The name of the function being searched for
     * @returns The info about the desired function, or null if it cannot be found
     */
    getFunctionDeclaration(codeData, functionName) {
        var _a, _b;
        let functionDecl = codeData.functions.get(functionName);
        if (codeData.isClassDef && (functionDecl == null || functionDecl.isPrototype)) {
            // For classes, look in the methods list to better handle @folders
            functionDecl = (_b = (_a = codeData.classInfo) === null || _a === void 0 ? void 0 : _a.methods.get(functionName)) !== null && _b !== void 0 ? _b : functionDecl;
        }
        return functionDecl !== null && functionDecl !== void 0 ? functionDecl : null;
    }
    /**
     * Searches for info about a property within the given code data.
     *
     * @param codeData The code data being searched
     * @param propertyName The name of the property being searched for
     * @returns The info about the desired property, or null if it cannot be found
     */
    getPropertyDeclaration(codeData, propertyName) {
        var _a;
        if (codeData.classInfo == null) {
            return null;
        }
        return (_a = codeData.classInfo.properties.get(propertyName)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Finds the definition(s) of an expression.
     *
     * @param uri The URI of the document containing the expression
     * @param position The position of the expression
     * @param expression The expression for which we are looking for the definition
     * @param matlabConnection The connection to MATLAB
     * @param pathResolver The path resolver
     * @param indexer The workspace indexer
     * @returns The definition location(s)
     */
    findDefinition(uri, position, expression, matlabConnection, pathResolver, indexer) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get code data for current file
            const codeData = FileInfoIndex_1.default.codeDataCache.get(uri);
            if (codeData == null) {
                // File not indexed - unable to look for definition
                reportTelemetry(RequestType.Definition, 'File not indexed');
                return [];
            }
            // First check within the current file's code data
            const definitionInCodeData = this.findDefinitionInCodeData(uri, position, expression, codeData);
            if (definitionInCodeData != null) {
                reportTelemetry(RequestType.Definition);
                return definitionInCodeData;
            }
            // Check the MATLAB path
            const definitionOnPath = yield this.findDefinitionOnPath(uri, position, expression, matlabConnection, pathResolver, indexer);
            if (definitionOnPath != null) {
                reportTelemetry(RequestType.Definition);
                return definitionOnPath;
            }
            // If not on path, may be in user's workspace
            reportTelemetry(RequestType.Definition);
            return this.findDefinitionInWorkspace(uri, expression);
        });
    }
    /**
     * Searches the given code data for the definition(s) of the given expression
     *
     * @param uri The URI corresponding to the provided code data
     * @param position The position of the expression
     * @param expression The expression for which we are looking for the definition
     * @param codeData The code data which is being searched
     * @returns The definition location(s), or null if no definition was found
     */
    findDefinitionInCodeData(uri, position, expression, codeData) {
        // If first part of expression targeted - look for a local variable
        if (expression.selectedComponent === 0) {
            const containingFunction = codeData.findContainingFunction(position);
            if (containingFunction != null) {
                const varDefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.Definition);
                if (varDefs != null) {
                    return varDefs;
                }
            }
        }
        // Check for functions in file
        let functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression);
        if (functionDeclaration != null) {
            return [this.getLocationForFunctionDeclaration(functionDeclaration)];
        }
        // Check for definitions within classes
        if (codeData.isClassDef && codeData.classInfo != null) {
            // Look for methods/properties within class definitions (e.g. obj.foo)
            functionDeclaration = this.getFunctionDeclaration(codeData, expression.last);
            if (functionDeclaration != null) {
                return [this.getLocationForFunctionDeclaration(functionDeclaration)];
            }
            // Look for possible properties
            if (expression.selectedComponent === 1) {
                const propertyDeclaration = this.getPropertyDeclaration(codeData, expression.last);
                if (propertyDeclaration != null) {
                    const propertyRange = vscode_languageserver_1.Range.create(propertyDeclaration.range.start, propertyDeclaration.range.end);
                    const uri = codeData.classInfo.uri;
                    if (uri != null) {
                        return [vscode_languageserver_1.Location.create(uri, propertyRange)];
                    }
                }
            }
        }
        return null;
    }
    /**
     * Gets the location of the given function's declaration. If the function does not have
     * a definite declaration, provides a location at the beginning of the file. For example,
     * this may be the case for built-in functions like 'plot'.
     *
     * @param functionInfo Info about the function
     * @returns The location of the function declaration
     */
    getLocationForFunctionDeclaration(functionInfo) {
        var _a;
        const range = (_a = functionInfo.declaration) !== null && _a !== void 0 ? _a : vscode_languageserver_1.Range.create(0, 0, 0, 0);
        return vscode_languageserver_1.Location.create(functionInfo.uri, range);
    }
    /**
     * Searches the MATLAB path for the definition of the given expression
     *
     * @param uri The URI of the file containing the expression
     * @param position The position of the expression
     * @param expression The expression for which we are looking for the definition
     * @param matlabConnection The connection to MATLAB
     * @param pathResolver The path resolver
     * @param indexer The workspace indexer
     * @returns The definition location(s), or null if no definition was found
     */
    findDefinitionOnPath(uri, position, expression, matlabConnection, pathResolver, indexer) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedPath = yield pathResolver.resolvePaths([expression.targetExpression], uri, matlabConnection);
            const resolvedUri = resolvedPath[0].uri;
            if (resolvedUri === '') {
                // Not found
                return null;
            }
            // Ensure URI is not a directory. This can occur with some packages.
            const fileStats = yield fs.stat(vscode_uri_1.URI.parse(resolvedUri).fsPath);
            if (fileStats.isDirectory()) {
                return null;
            }
            if (!FileInfoIndex_1.default.codeDataCache.has(resolvedUri)) {
                // Index target file, if necessary
                yield indexer.indexFile(resolvedUri);
            }
            const codeData = FileInfoIndex_1.default.codeDataCache.get(resolvedUri);
            // Find definition location within determined file
            if (codeData != null) {
                const definition = this.findDefinitionInCodeData(resolvedUri, position, expression, codeData);
                if (definition != null) {
                    return definition;
                }
            }
            // If a definition location cannot be identified, default to the beginning of the file.
            // This could be the case for builtin functions which don't actually have a definition in a .m file (e.g. plot).
            return [vscode_languageserver_1.Location.create(resolvedUri, vscode_languageserver_1.Range.create(0, 0, 0, 0))];
        });
    }
    /**
     * Searches the (indexed) workspace for the definition of the given expression. These files may not be on the MATLAB path.
     *
     * @param uri The URI of the file containing the expression
     * @param expression The expression for which we are looking for the definition
     * @returns The definition location(s). Returns an empty array if no definitions found.
     */
    findDefinitionInWorkspace(uri, expression) {
        var _a, _b;
        const expressionToMatch = expression.fullExpression;
        for (const [fileUri, fileCodeData] of FileInfoIndex_1.default.codeDataCache) {
            if (uri === fileUri)
                continue; // Already looked in the current file
            let match = fileCodeData.packageName === '' ? '' : fileCodeData.packageName + '.';
            if (fileCodeData.classInfo != null) {
                const classUri = fileCodeData.classInfo.uri;
                if (classUri == null)
                    continue;
                // Check class name
                match += fileCodeData.classInfo.name;
                if (expressionToMatch === match) {
                    const range = (_a = fileCodeData.classInfo.declaration) !== null && _a !== void 0 ? _a : vscode_languageserver_1.Range.create(0, 0, 0, 0);
                    return [vscode_languageserver_1.Location.create(classUri, range)];
                }
                // Check properties
                const matchedProperty = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.properties);
                if (matchedProperty != null) {
                    return matchedProperty;
                }
                // Check enums
                const matchedEnum = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.enumerations);
                if (matchedEnum != null) {
                    return matchedEnum;
                }
            }
            // Check functions
            for (const [funcName, funcData] of fileCodeData.functions) {
                const funcMatch = (match === '') ? funcName : match + '.' + funcName;
                // Need to ensure that a function with a matching name should also be visible from the current file.
                if (expressionToMatch === funcMatch && this.isFunctionVisibleFromUri(uri, funcData)) {
                    const range = (_b = funcData.declaration) !== null && _b !== void 0 ? _b : vscode_languageserver_1.Range.create(0, 0, 0, 0);
                    return [vscode_languageserver_1.Location.create(funcData.uri, range)];
                }
            }
        }
        return [];
    }
    /**
     * Finds the class member (property or enumeration) in the given map which matches to given expression.
     *
     * @param expressionToMatch The expression being compared against
     * @param matchPrefix The prefix which should be attached to the class members before comparison
     * @param classUri The URI for the current class
     * @param classMemberMap The map of class members
     * @returns An array containing the location of the matched class member, or null if one was not found
     */
    findMatchingClassMember(expressionToMatch, matchPrefix, classUri, classMemberMap) {
        for (const [memberName, memberData] of classMemberMap) {
            const match = matchPrefix + '.' + memberName;
            if (expressionToMatch === match) {
                return [vscode_languageserver_1.Location.create(classUri, memberData.range)];
            }
        }
        return null;
    }
    /**
     * Determines whether the given function should be visible from the given file URI.
     * The function is visible if it is contained within the same file, or is public.
     *
     * @param uri The file's URI
     * @param funcData The function data
     * @returns true if the function should be visible from the given URI; false otherwise
     */
    isFunctionVisibleFromUri(uri, funcData) {
        return uri === funcData.uri || funcData.visibility === FileInfoIndex_1.FunctionVisibility.Public;
    }
}
exports["default"] = SymbolSearchService.getInstance();


/***/ }),

/***/ "./src/indexing/WorkspaceIndexer.ts":
/*!******************************************!*\
  !*** ./src/indexing/WorkspaceIndexer.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ConfigurationManager_1 = __importDefault(__webpack_require__(/*! ../lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ../ClientConnection */ "./src/ClientConnection.ts"));
/**
 * Handles indexing files in the user's workspace to gather data about classes,
 * functions, and variables.
 */
class WorkspaceIndexer {
    constructor(indexer) {
        this.indexer = indexer;
        this.isWorkspaceIndexingSupported = false;
    }
    /**
     * Sets up workspace change listeners, if supported.
     *
     * @param capabilities The client capabilities, which contains information about
     * whether the client supports workspaces.
     */
    setupCallbacks(capabilities) {
        var _a, _b;
        this.isWorkspaceIndexingSupported = (_b = (_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) !== null && _b !== void 0 ? _b : false;
        if (!this.isWorkspaceIndexingSupported) {
            // Workspace indexing not supported
            return;
        }
        ClientConnection_1.default.getConnection().workspace.onDidChangeWorkspaceFolders((params) => {
            void this.handleWorkspaceFoldersAdded(params.added);
        });
    }
    /**
     * Attempts to index the files in the user's workspace.
     */
    indexWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.shouldIndexWorkspace())) {
                return;
            }
            const folders = yield ClientConnection_1.default.getConnection().workspace.getWorkspaceFolders();
            if (folders == null) {
                return;
            }
            void this.indexer.indexFolders(folders.map(folder => folder.uri));
        });
    }
    /**
     * Handles when new folders are added to the user's workspace by indexing them.
     *
     * @param folders The list of folders added to the workspace
     */
    handleWorkspaceFoldersAdded(folders) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.shouldIndexWorkspace())) {
                return;
            }
            void this.indexer.indexFolders(folders.map(folder => folder.uri));
        });
    }
    /**
     * Determines whether or not the workspace should be indexed.
     * The workspace should be indexed if the client supports workspaces, and if the
     * workspace indexing setting is true.
     *
     * @returns True if workspace indexing should occurr, false otherwise.
     */
    shouldIndexWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldIndexWorkspace = (yield ConfigurationManager_1.default.getConfiguration()).indexWorkspace;
            return this.isWorkspaceIndexingSupported && shouldIndexWorkspace;
        });
    }
}
exports["default"] = WorkspaceIndexer;


/***/ }),

/***/ "./src/licensing/config.ts":
/*!*********************************!*\
  !*** ./src/licensing/config.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMatlabVersion = exports.setMatlabVersion = exports.setInstallPath = exports.staticFolderPath = exports.MWI_LICENSING_SESSION_COOKIE_NAME = exports.MWI_ENABLE_TOKEN_AUTH = exports.MWI_AUTH_TOKEN_LENGTH = exports.MWI_AUTH_TOKEN_NAME_FOR_HTTP = void 0;
const fs_1 = __webpack_require__(/*! fs */ "fs");
const FsUtils_1 = __webpack_require__(/*! ../utils/FsUtils */ "./src/utils/FsUtils.ts");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const xml2js = __importStar(__webpack_require__(/*! xml2js */ "./node_modules/xml2js/lib/xml2js.js"));
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const VERSION_INFO_FILENAME = 'VersionInfo.xml';
exports.MWI_AUTH_TOKEN_NAME_FOR_HTTP = 'mwi-auth-token';
exports.MWI_AUTH_TOKEN_LENGTH = 32;
exports.MWI_ENABLE_TOKEN_AUTH = true;
exports.MWI_LICENSING_SESSION_COOKIE_NAME = 'matlab-licensing-session';
let installPath = null;
let matlabVersion = null;
exports.staticFolderPath = path.join(__dirname, 'licensing', 'static');
/**
 * Sets the MATLAB install path. Is called when:
 * 1) The LSP is initialzed
 * &
 * 2) The installPath setting changes by its config change handler
 * @param path - The MATLAB install path
 */
function setInstallPath(path) {
    installPath = path;
    // When installPath changes, update MATLAB version
    getMatlabVersionFromInstallPath(installPath).then((version) => {
        matlabVersion = version;
    });
}
exports.setInstallPath = setInstallPath;
/**
 * Sets the MATLAB version. This function is called to update the current
 * MATLAB version in the application state.
 *
 * @param version - The MATLAB version to be set
 */
function setMatlabVersion(version) {
    matlabVersion = version;
}
exports.setMatlabVersion = setMatlabVersion;
/**
 * Gets the MATLAB version
 * @returns {Promise<string | null>} The MATLAB version or null if it cannot be determined
 */
function getMatlabVersion() {
    return __awaiter(this, void 0, void 0, function* () {
        // If MATLAB version was already determined (either by this function or the setInstallPath function), return it directly.
        if (matlabVersion) {
            return matlabVersion;
        }
        else {
            const matlabExecutableOnPath = yield (0, FsUtils_1.findExecutableOnPath)('matlab');
            // If there's no matlab executable on system PATH return null
            if (!matlabExecutableOnPath) {
                return null;
            }
            const absoluteMatlabPath = yield (0, FsUtils_1.resolveSymlink)(matlabExecutableOnPath);
            const matlabRoot = path.resolve(absoluteMatlabPath, '..', '..');
            // Update matlabVersion variable before returning to avoid recomputation.
            matlabVersion = yield getMatlabVersionFromInstallPath(matlabRoot);
            return matlabVersion;
        }
    });
}
exports.getMatlabVersion = getMatlabVersion;
/**
 * Retrieves the MATLAB version from the installation path.
 *
 * @param pathToMatlabRoot - The path to the MATLAB ROOT.
 * @returns {Promise<string|null>} A promise that resolves to the MATLAB version as a string, or null if an error occurs.
 */
function getMatlabVersionFromInstallPath(pathToMatlabRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const versionInfoPath = path.join(pathToMatlabRoot, VERSION_INFO_FILENAME);
        try {
            const fileContent = yield fs_1.promises.readFile(versionInfoPath, { encoding: 'utf-8' });
            const xmlData = (yield xml2js.parseStringPromise(fileContent));
            const versionInfo = xmlData.MathWorks_version_info.release[0];
            return versionInfo;
        }
        catch (error) {
            Logger_1.default.error(`Failed to read version info file at path:${versionInfoPath} with error:${error}`);
            return null;
        }
    });
}


/***/ }),

/***/ "./src/licensing/errors.ts":
/*!*********************************!*\
  !*** ./src/licensing/errors.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidTokenError = exports.EntitlementError = exports.OnlineLicensingError = exports.LicensingError = exports.AppError = void 0;
class AppError extends Error {
    /**
     * A Generic Parent class which inherits the Error class.
     * This class will be inherited by other classes representing specific exceptions.
     *
     * @param message - Error message.
     * @param logs - Logs associated with the error.
     * @param stacktrace - Stacktrace associated with the error.
     */
    constructor(message, logs = null, stacktrace = null) {
        super(message);
        this.logs = logs;
        this.stacktrace = stacktrace;
        this.name = this.constructor.name;
    }
}
exports.AppError = AppError;
/**
 * A Class which inherits the AppError class.
 * This class represents any Licensing Errors (MHLM and NLM Licensing)
 */
class LicensingError extends AppError {
}
exports.LicensingError = LicensingError;
/**
 * A Class which inherits the Licensing class.
 * This class represents any errors specific to MHLM Licensing.
 */
class OnlineLicensingError extends LicensingError {
}
exports.OnlineLicensingError = OnlineLicensingError;
/**
 * A Class which inherits the LicensingError class.
 * This class represents errors with Entitlements in MHLM Licensing.
 */
class EntitlementError extends LicensingError {
}
exports.EntitlementError = EntitlementError;
/**
 * A Class which inherits the AppError class.
 * This class represents token authentication errors.
 */
class InvalidTokenError extends AppError {
}
exports.InvalidTokenError = InvalidTokenError;


/***/ }),

/***/ "./src/licensing/index.ts":
/*!********************************!*\
  !*** ./src/licensing/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const config_1 = __webpack_require__(/*! ./config */ "./src/licensing/config.ts");
const mw_1 = __webpack_require__(/*! ./mw */ "./src/licensing/mw.ts");
const FsUtils_1 = __webpack_require__(/*! ../utils/FsUtils */ "./src/utils/FsUtils.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/licensing/errors.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/licensing/types.ts");
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const config = __importStar(__webpack_require__(/*! ./config */ "./src/licensing/config.ts"));
/**
 * The `Licensing` class is responsible for managing the licensing information for the application.
 * It handles the initialization of licensing, fetching and persisting licensing data, and setting up environment variables for MATLAB.
 * The class is designed as a singleton, ensuring there is only one instance of `Licensing` in the application.
 */
class Licensing {
    /**
     * Creates an instance of the `Licensing` class.
     * If an instance already exists, it returns the existing instance.
     */
    constructor() {
        this.data = null;
        this.error = null;
        if (Licensing.instance) {
            return Licensing.instance;
        }
        this.data = null;
        this.error = null;
        // Create the folder for storing proxy_app_config.json file
        this.createCachedConfigDirectory().then(() => { });
        // Initialize licensing
        this.initializeLicensing().then(() => { });
        // Update static variable to make this object a singleton instance
        Licensing.instance = this;
    }
    /**
     * Initializes the licensing information.
     * It checks for the presence of an NLM connection string in the environment variables or a cached licensing configuration file.
     * Based on the available information, it sets the appropriate licensing data.
     * @private
     */
    initializeLicensing() {
        return __awaiter(this, void 0, void 0, function* () {
            this.data = null;
            const nlmConnectionStringInEnv = process.env.MLM_LICENSE_FILE;
            const mwiConfigFileExists = fs.existsSync(Licensing.mwiConfigFilePath);
            if (nlmConnectionStringInEnv) {
                Logger_1.default.log(`Found MLM_LICENSE_FILE environment variable set to: ${nlmConnectionStringInEnv}. Using it for licensing MATLAB`);
                this.data = {
                    type: 'nlm',
                    conn_str: nlmConnectionStringInEnv
                };
                yield this.deleteCachedConfigFile();
            }
            else if (mwiConfigFileExists) {
                try {
                    const data = JSON.parse(fs.readFileSync(Licensing.mwiConfigFilePath, 'utf8'));
                    Logger_1.default.log('Found cached licensing information...');
                    const cachedLicensingData = data.licensing;
                    if (cachedLicensingData.type === types_1.NLMLicenseType) {
                        this.data = {
                            type: types_1.NLMLicenseType,
                            conn_str: cachedLicensingData.conn_str
                        };
                    }
                    else if (cachedLicensingData.type === types_1.MHLMLicenseType) {
                        this.data = {
                            type: types_1.MHLMLicenseType,
                            identity_token: cachedLicensingData.identity_token,
                            source_id: cachedLicensingData.source_id,
                            expiry: cachedLicensingData.expiry,
                            email_addr: cachedLicensingData.email_addr,
                            first_name: cachedLicensingData.first_name,
                            last_name: cachedLicensingData.last_name,
                            display_name: cachedLicensingData.display_name,
                            user_id: cachedLicensingData.user_id,
                            profile_id: cachedLicensingData.profile_id,
                            entitlements: [],
                            entitlement_id: cachedLicensingData.entitlement_id
                        };
                        // If 'matlab' field exists in the data, then update it in the config.
                        if ('matlab' in data) {
                            config.setMatlabVersion(data.matlab.version);
                        }
                        const expiry = new Date(this.data.expiry);
                        const expiryWindow = new Date(expiry.getTime() - 3600000); // subtract 1 hour
                        if (expiryWindow.getTime() > (new Date()).getTime()) {
                            const successfulUpdate = yield this.updateAndPersistLicensing();
                            if (successfulUpdate) {
                                console.debug('Using cached Online Licensing to launch MATLAB.');
                            }
                            else {
                                this.resetAndDeleteCachedConfig();
                                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingError, 'Failed to fetch entitlements. Resetting cached licensing information.');
                            }
                        }
                    }
                    else if (cachedLicensingData.type === types_1.ExistingLicenseType) {
                        this.data = cachedLicensingData;
                    }
                    else {
                        this.resetAndDeleteCachedConfig();
                        NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingError, 'Failed to determine licensing type. Resetting cached licensing information.');
                    }
                }
                catch (e) {
                    NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingError, 'Something went wrong when reading cached licensing info. Resetting cached licensing information.');
                    this.resetAndDeleteCachedConfig();
                }
            }
            else {
                Logger_1.default.log('Cached licensing not found...');
            }
        });
    }
    /**
     * Checks if the application is licensed.
     * @returns {boolean} `true` if the application is licensed, `false` otherwise.
     */
    isLicensed() {
        return this.isMHLMLicensing() || this.isNLMLicensing() || this.isExistingLicensing();
    }
    /**
     * Gets the email address associated with the MHLM licensing.
     * @returns {string | null} The email address if MHLM licensing is configured, `null` otherwise.
     */
    getMHLMEmailAddress() {
        if (this.isMHLMLicensing()) {
            return this.data.email_addr;
        }
        return null;
    }
    /**
     * Checks if the licensing type is MHLM (Online License Manager).
     * @private
     * @returns {boolean} `true` if the licensing type is MHLM, `false` otherwise.
     */
    isMHLMLicensing() {
        return (0, types_1.isMHLMLicensingDataType)(this.data);
    }
    /**
     * Checks if the licensing type is NLM (Network License Manager).
     * @private
     * @returns {boolean} `true` if the licensing type is NLM, `false` otherwise.
     */
    isNLMLicensing() {
        return (0, types_1.isNLMLicensingDataType)(this.data);
    }
    /**
     * Checks if the licensing type is an existing license.
     * @private
     * @returns {boolean} `true` if the licensing type is an existing license, `false` otherwise.
     */
    isExistingLicensing() {
        return (0, types_1.isExistingLicensingDataType)(this.data);
    }
    /**
     * Checks if there is no licensing configured.
     * @private
     * @returns {boolean} `true` if there is no licensing configured, `false` otherwise.
     */
    isNoLicensing() {
        return (0, types_1.isNoLicensingDataType)(this.data);
    }
    /**
     * Gets the minimal licensing information as a string.
     * @returns {string} The minimal licensing information.
     */
    getMinimalLicensingInfo() {
        if (this.isMHLMLicensing()) {
            return `${Licensing.type.MHLM_LICENSE} ${this.getMHLMEmailAddress()}`;
        }
        else if (this.isNLMLicensing()) {
            return `${Licensing.type.NLM_LICENSE} ${this.data.conn_str}`;
        }
        else if (this.isExistingLicensing()) {
            return Licensing.type.EXISTING_LICENSE;
        }
        return '';
    }
    /**
     * Unsets the licensing information and deletes the cached configuration file.
     */
    unsetLicensing() {
        return __awaiter(this, void 0, void 0, function* () {
            this.data = null;
            if (this.error && this.error instanceof errors_1.LicensingError) {
                this.error = null;
            }
            yield this.deleteCachedConfigFile();
            console.log("Successfully unset licensing");
        });
    }
    /**
     * Sets the licensing information based on the provided data.
     * @param licenseData - The licensing data to be set.
     */
    setLicensingInfo(licenseData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!licenseData.hasOwnProperty('type') || ![types_1.MHLMLicenseType, types_1.NLMLicenseType, types_1.ExistingLicenseType].includes(licenseData.type)) {
                throw new Error("Incorrect values supplied. Licensing type must be 'NLM', 'MHLM' or 'ExistingLicense'");
            }
            const type = licenseData.type;
            if (type === types_1.MHLMLicenseType) {
                yield this.setLicensingToMHLM(licenseData);
            }
            else if (type === types_1.NLMLicenseType) {
                this.setLicensingToNLM(licenseData);
            }
            else {
                this.setLicensingToExistingLicense();
            }
        });
    }
    /**
     * Sets up the environment variables required for MATLAB based on the licensing information.
     * @returns {NodeJS.ProcessEnv} The environment variables.
     */
    setupEnvironmentVariables() {
        return __awaiter(this, void 0, void 0, function* () {
            const environmentVariables = {};
            // Is not licensed or existing license return early.
            if (!this.isLicensed()) {
                return environmentVariables;
            }
            if (this.isMHLMLicensing()) {
                const mhlmData = this.data;
                const accessTokenData = yield (0, mw_1.fetchAccessToken)(Licensing.mwaApiEndpoint, mhlmData.identity_token, mhlmData.source_id);
                if (accessTokenData) {
                    environmentVariables.MLM_WEB_LICENSE = 'true';
                    environmentVariables.MLM_WEB_USER_CRED = accessTokenData.token;
                    environmentVariables.MLM_WEB_ID = mhlmData.entitlement_id;
                }
            }
            else if (this.isNLMLicensing()) {
                const nlmData = this.data;
                environmentVariables.MLM_LICENSE_FILE = nlmData.conn_str;
            }
            Logger_1.default.log('Successfully marshaled environment variables for MATLAB');
            return environmentVariables;
        });
    }
    /**
     * Sets the licensing information to MHLM (Online License Manager).
     * @param licenseData - The MHLM licensing data.
     * @private
     */
    setLicensingToMHLM(licenseData) {
        return __awaiter(this, void 0, void 0, function* () {
            const { token: identityToken, sourceId, emailAddress } = licenseData;
            try {
                const expandTokenData = yield (0, mw_1.fetchExpandToken)(Licensing.mwaApiEndpoint, identityToken, sourceId);
                this.data = {
                    type: 'mhlm',
                    identity_token: identityToken,
                    source_id: sourceId,
                    expiry: expandTokenData.expiry,
                    email_addr: emailAddress,
                    first_name: expandTokenData.first_name,
                    last_name: expandTokenData.last_name,
                    display_name: expandTokenData.display_name,
                    user_id: expandTokenData.user_id,
                    profile_id: expandTokenData.profile_id,
                    entitlements: [],
                    entitlement_id: null
                };
                const successfulUpdate = yield this.updateAndPersistLicensing();
                if (successfulUpdate) {
                    Logger_1.default.log('MHLM login successful, persisting login info.');
                    // Set the error back to null if MHLM login was successful.
                    this.error = null;
                }
            }
            catch (error) {
                if (error instanceof errors_1.OnlineLicensingError || error instanceof errors_1.EntitlementError) {
                    this.error = error;
                    this.data = {
                        type: types_1.MHLMLicenseType,
                        email_addr: emailAddress
                    };
                }
                else {
                    this.error = error;
                    this.data = null;
                }
                Logger_1.default.error(error.message);
                console.log(error);
            }
        });
    }
    /**
     * Sets the licensing information to NLM (Network License Manager).
     * @param connectionStr - The NLM connection string.
     * @private
     */
    setLicensingToNLM(data) {
        const { connectionString } = data;
        this.data = {
            type: types_1.NLMLicenseType,
            conn_str: connectionString
        };
        Logger_1.default.log('Persisting NLM info.');
        this.persistConfigData();
    }
    /**
     * Sets the licensing information to an existing license.
     * @private
     */
    setLicensingToExistingLicense() {
        this.data = {
            type: types_1.ExistingLicenseType
        };
        this.persistConfigData();
    }
    /**
     * Updates the user-selected entitlement information for MHLM licensing.
     * @param entitlementId - The entitlement ID.
     */
    updateUserSelectedEntitlementInfo(entitlementId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMHLMLicensing()) {
                const licensingData = this.data;
                licensingData.entitlement_id = entitlementId;
                this.data = licensingData;
                yield this.persistConfigData();
            }
        });
    }
    /**
     * Updates the entitlements for MHLM licensing.
     * @returns {Promise<boolean>} `true` if the entitlements were updated successfully, `false` otherwise.
     */
    updateEntitlements() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.data) === null || _a === void 0 ? void 0 : _a.type) !== types_1.MHLMLicenseType) {
                const err = new errors_1.LicensingError('MHLM licensing must be configured to update entitlements!');
                Logger_1.default.warn(err.message);
                this.error = err;
                return false;
            }
            const matlabVersion = yield (0, config_1.getMatlabVersion)();
            if (!matlabVersion) {
                const err = new errors_1.EntitlementError('MATLAB version is required for fetching entitlements');
                this.error = err;
                Logger_1.default.warn(err.message);
                return false;
            }
            const mhlmData = this.data;
            try {
                const accessTokenData = yield (0, mw_1.fetchAccessToken)(Licensing.mwaApiEndpoint, mhlmData.identity_token, mhlmData.source_id);
                // Fetch entitlements
                const entitlements = yield (0, mw_1.fetchEntitlements)(Licensing.mhlmApiEndpoint, accessTokenData.token, matlabVersion);
                mhlmData.entitlements = entitlements;
                // Auto-select the entitlement if only one entitlement is returned from MHLM
                if (entitlements.length === 1) {
                    mhlmData.entitlement_id = entitlements[0].id;
                }
                // Update the data variable
                this.data = mhlmData;
                Logger_1.default.log('Successfully fetched entitlements');
                return true;
            }
            catch (e) {
                if (e instanceof errors_1.EntitlementError) {
                    this.error = e;
                    const failedMhlmData = this.data;
                    failedMhlmData.identity_token = null;
                    failedMhlmData.source_id = null;
                    failedMhlmData.expiry = null;
                    failedMhlmData.first_name = null;
                    failedMhlmData.last_name = null;
                    failedMhlmData.display_name = null;
                    failedMhlmData.user_id = null;
                    failedMhlmData.profile_id = null;
                    failedMhlmData.entitlements = [];
                    failedMhlmData.entitlement_id = null;
                    this.data = failedMhlmData;
                    Logger_1.default.error(e.message);
                    return false;
                }
                else if (e instanceof errors_1.OnlineLicensingError) {
                    this.error = e;
                    Logger_1.default.error(e.message);
                    return false;
                }
                else {
                    this.error = e;
                    Logger_1.default.error(e.message);
                    return false;
                }
            }
        });
    }
    /**
     * Updates and persists the licensing information.
     * @private
     * @returns {Promise<boolean>} `true` if the licensing information was updated and persisted successfully, `false` otherwise.
     */
    updateAndPersistLicensing() {
        return __awaiter(this, void 0, void 0, function* () {
            const successfulUpdate = yield this.updateEntitlements();
            if (successfulUpdate) {
                this.persistConfigData();
            }
            else {
                yield this.resetAndDeleteCachedConfig();
            }
            return successfulUpdate;
        });
    }
    /**
     * Persists the licensing and MATLAB version information to the cached configuration file.
     * @private
     */
    persistConfigData() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNoLicensing()) {
                yield this.deleteCachedConfigFile();
            }
            else {
                const matlabVersion = yield (0, config_1.getMatlabVersion)();
                const dataToWrite = {
                    licensing: this.data,
                    matlab: {
                        version: matlabVersion
                    }
                };
                yield (0, FsUtils_1.writeJSONDataToFile)(Licensing.mwiConfigFilePath, dataToWrite);
            }
        });
    }
    /**
     * Resets and deletes the cached configuration file.
     * @private
     */
    resetAndDeleteCachedConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            this.data = null;
            yield this.deleteCachedConfigFile();
            Logger_1.default.log('Successfully unset licensing');
        });
    }
    /**
     * Deletes the cached configuration file.
     * @private
     */
    deleteCachedConfigFile() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, FsUtils_1.deleteFile)(Licensing.mwiConfigFilePath);
        });
    }
    /**
     * Creates the directory for storing the cached configuration file if it doesn't exist.
     * @private
     */
    createCachedConfigDirectory() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, FsUtils_1.createDirectoryIfNotExist)(Licensing.mwiConfigFolderPath);
        });
    }
}
exports["default"] = Licensing;
// NOTE: If wsEnv's are introduced, ./server/routeHandlers.ts::createStatusResponse() return
// value needs to be updated accordingly.
Licensing.mwaApiEndpoint = `https://login.mathworks.com/authenticationws/service/v4`;
Licensing.mhlmApiEndpoint = `https://licensing.mathworks.com/mls/service/v1/entitlement/list`;
Licensing.mwiConfigFolderPath = path.join(os.homedir(), '.matlab', 'MWI', 'hosts', os.hostname());
Licensing.mwiConfigFilePath = path.join(Licensing.mwiConfigFolderPath, 'proxy_app_config.json');
Licensing.type = {
    NO_LICENSE: '',
    MHLM_LICENSE: ' as',
    NLM_LICENSE: ' using',
    EXISTING_LICENSE: '.'
};


/***/ }),

/***/ "./src/licensing/mw.ts":
/*!*****************************!*\
  !*** ./src/licensing/mw.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchEntitlements = exports.fetchAccessToken = exports.fetchExpandToken = void 0;
// Copyright 2024 The MathWorks, Inc.
const xml2js = __importStar(__webpack_require__(/*! xml2js */ "./node_modules/xml2js/lib/xml2js.js"));
const NetworkUtils_1 = __importDefault(__webpack_require__(/*! ../utils/NetworkUtils */ "./src/utils/NetworkUtils.ts"));
const LicensingUtils_1 = __webpack_require__(/*! ../utils/LicensingUtils */ "./src/utils/LicensingUtils.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/licensing/errors.ts");
/**
 * Fetches an expand token from the MathWorks Access (MWA) service.
 * @param mwaUrl - The URL of the MathWorks Access service.
 * @param identityToken - The identity token to use for authentication.
 * @param sourceId - The source ID for the request.
 * @returns {Promise<{expiry: string, first_name: string, last_name: string, display_name: string, user_id: string, profile_id: string}>} A Promise that resolves with an object containing the expiry date, first name, last name, display name, user ID, and profile ID.
 * @throws {OnlineLicensingError} If there is an error fetching the access token
*/
function fetchExpandToken(mwaUrl, identityToken, sourceId) {
    return __awaiter(this, void 0, void 0, function* () {
        const accessTokenUrl = mwaUrl + '/tokens';
        const data = {
            tokenString: identityToken,
            tokenPolicyName: 'R2',
            sourceId
        };
        const formData = new URLSearchParams(data).toString();
        const options = {
            method: 'POST',
            headers: {
                'content-type': 'application/x-www-form-urlencoded',
                accept: 'application/json',
                X_MW_WS_callerId: 'desktop-jupyter'
            },
            body: formData
        };
        const response = yield (0, NetworkUtils_1.default)(accessTokenUrl, options);
        if (response == null || !response.ok) {
            throw new errors_1.OnlineLicensingError(`Communication with ${mwaUrl} failed.`);
        }
        const jsonData = yield response.json();
        return {
            expiry: jsonData.expirationDate,
            first_name: jsonData.referenceDetail.firstName,
            last_name: jsonData.referenceDetail.lastName,
            display_name: jsonData.referenceDetail.displayName,
            user_id: jsonData.referenceDetail.userId,
            profile_id: jsonData.referenceDetail.referenceId
        };
    });
}
exports.fetchExpandToken = fetchExpandToken;
/**
 * Fetches an access token from the MathWorks Access (MWA) service.
 * @param mwaUrl - The URL of the MathWorks Access service.
 * @param identityToken - The identity token to use for authentication.
 * @param sourceId - The source ID for the request.
 * @returns {Promise<{token: string}>} A Promise that resolves with an object containing the access token.
 * @throws {OnlineLicensingError} If there is an error fetching the access token
 */
function fetchAccessToken(mwaUrl, identityToken, sourceId) {
    return __awaiter(this, void 0, void 0, function* () {
        const accessTokenUrl = mwaUrl + '/tokens/access';
        const data = {
            tokenString: identityToken,
            type: 'MWAS',
            sourceId
        };
        const formData = new URLSearchParams(data).toString();
        const options = {
            method: 'POST',
            headers: {
                'content-type': 'application/x-www-form-urlencoded',
                accept: 'application/json',
                X_MW_WS_callerId: 'desktop-jupyter'
            },
            body: formData
        };
        const response = yield (0, NetworkUtils_1.default)(accessTokenUrl, options);
        if (response == null || !response.ok) {
            throw new errors_1.OnlineLicensingError('HTTP request failed');
        }
        const jsonData = yield response.json();
        return {
            token: jsonData.accessTokenString
        };
    });
}
exports.fetchAccessToken = fetchAccessToken;
/**
 * Fetches entitlements from the MathWorks Hosted License Manager (MHLM) service.
 * @param mhlmUrl - The URL of the MathWorks Hosted License Manager service.
 * @param accessToken - The access token to use for authentication.
 * @param matlabVersion - The version of MATLAB for which to fetch entitlements.
 * @returns {Promise<Entitlement[]>} A Promise that resolves with an array of Entitlement objects.
 * @throws {EntitlementError} If there is an error fetching or parsing the entitlements.
 */
function fetchEntitlements(mhlmUrl, accessToken, matlabVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = {
            token: accessToken,
            release: matlabVersion,
            coreProduct: 'ML',
            context: 'jupyter',
            excludeExpired: 'true'
        };
        const formData = new URLSearchParams(data).toString();
        const options = {
            method: 'POST',
            headers: {
                'content-type': 'application/x-www-form-urlencoded'
            },
            body: formData
        };
        const response = yield (0, NetworkUtils_1.default)(mhlmUrl, options);
        if (response == null || !response.ok) {
            throw new errors_1.EntitlementError(`Communication with ${mhlmUrl} failed`);
        }
        const text = yield response.text();
        const jsonData = yield xml2js.parseStringPromise(text);
        if (!Object.prototype.hasOwnProperty.call(jsonData.describe_entitlements_response, 'entitlements')) {
            throw new errors_1.EntitlementError('Failed to extract entitlements');
        }
        const entitlementsData = (0, LicensingUtils_1.findAllEntitlements)(jsonData.describe_entitlements_response.entitlements);
        if (entitlementsData.length === 0) {
            throw new errors_1.EntitlementError(`Your MathWorks account is not linked to a valid license for MATLAB ${matlabVersion}.\nSign out and login with a licensed user.`);
        }
        const entitlements = entitlementsData.map(entitlementData => {
            const entitlement = entitlementData[0];
            return {
                id: String(entitlement.id),
                label: String(entitlement.label),
                license_number: String(entitlement.license_number)
            };
        });
        return entitlements;
    });
}
exports.fetchEntitlements = fetchEntitlements;


/***/ }),

/***/ "./src/licensing/server/index.ts":
/*!***************************************!*\
  !*** ./src/licensing/server/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stopLicensingServer = exports.startLicensingServer = exports.url = exports.matlabLifecycleManager = void 0;
const express_1 = __importDefault(__webpack_require__(/*! express */ "./node_modules/express/index.js"));
const os_1 = __importDefault(__webpack_require__(/*! os */ "os"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const routes_1 = __webpack_require__(/*! ./routes */ "./src/licensing/server/routes.ts");
const middlewares_1 = __webpack_require__(/*! ./middlewares */ "./src/licensing/server/middlewares.ts");
const tokenAuth_1 = __webpack_require__(/*! ./tokenAuth */ "./src/licensing/server/tokenAuth.ts");
const config_1 = __webpack_require__(/*! ../config */ "./src/licensing/config.ts");
const FsUtils_1 = __webpack_require__(/*! ../../utils/FsUtils */ "./src/utils/FsUtils.ts");
const NetworkUtils_1 = __webpack_require__(/*! ../../utils/NetworkUtils */ "./src/utils/NetworkUtils.ts");
let server = null;
let port = null;
let licensingUrlFilePath = path_1.default.join(os_1.default.tmpdir(), "url.json");
/**
 * The URL of the running server.
 */
exports.url = null;
/**
 * Starts the server and returns its URL.
 *
 * @param buildPath - The path to the build directory.
 * @returns {string} The URL of the running server.
 */
function startLicensingServer(buildPath, mLM) {
    return __awaiter(this, void 0, void 0, function* () {
        if (exports.url !== null) {
            return exports.url;
        }
        // If in a codespaces environment, getExistingUrl() will return 
        // a previously started licensing server in the event of a page reload.
        const existingUrl = yield getExistingUrl();
        if (existingUrl) {
            exports.url = existingUrl;
            return exports.url;
        }
        exports.matlabLifecycleManager = mLM;
        server = (0, express_1.default)();
        (0, middlewares_1.addMiddlwares)(server, buildPath);
        // Add routes
        (0, routes_1.addRoutes)(server);
        // Start the server on a random port.
        const app = server.listen(0);
        const address = app.address();
        port = address.port;
        // Generate auth token
        const authToken = (0, tokenAuth_1.generateAuthToken)(config_1.MWI_AUTH_TOKEN_LENGTH);
        exports.url = `http://localhost:${port}/index.html?${config_1.MWI_AUTH_TOKEN_NAME_FOR_HTTP}=${authToken}`;
        // Write url to file for handling new server start on page reload.
        (0, FsUtils_1.writeJSONDataToFile)(licensingUrlFilePath, { url: exports.url });
        return exports.url;
    });
}
exports.startLicensingServer = startLicensingServer;
/**
 * Stops the running server.
 */
function stopLicensingServer() {
    if (server != null) {
        server.close(() => {
            console.log('Server stopped successfully');
        });
        (0, FsUtils_1.deleteFile)(licensingUrlFilePath).then(() => { });
    }
}
exports.stopLicensingServer = stopLicensingServer;
/**
 * Retrieves an existing URL of the licensing server if it was started previously. Useful in Github codespaces.

 * @returns {Promise<string>} A promise resolving to the URL string if the port is occupied, or an empty string otherwise.
 */
function getExistingUrl() {
    return __awaiter(this, void 0, void 0, function* () {
        if (fs_1.default.existsSync(licensingUrlFilePath)) {
            const data = JSON.parse(fs_1.default.readFileSync(licensingUrlFilePath, 'utf8'));
            const serverUrl = new URL(data.url);
            if (yield (0, NetworkUtils_1.isPortFree)(Number(serverUrl.port))) {
                return '';
            }
            else {
                return serverUrl.toString();
            }
        }
        return '';
    });
}


/***/ }),

/***/ "./src/licensing/server/middlewares.ts":
/*!*********************************************!*\
  !*** ./src/licensing/server/middlewares.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addMiddlwares = exports.authenticateRequest = void 0;
const express_1 = __importDefault(__webpack_require__(/*! express */ "./node_modules/express/index.js"));
const cookie_parser_1 = __importDefault(__webpack_require__(/*! cookie-parser */ "./node_modules/cookie-parser/index.js"));
const express_session_1 = __importDefault(__webpack_require__(/*! express-session */ "./node_modules/express-session/index.js"));
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "crypto"));
const tokenAuth_1 = __webpack_require__(/*! ./tokenAuth */ "./src/licensing/server/tokenAuth.ts");
const config_1 = __webpack_require__(/*! ../config */ "./src/licensing/config.ts");
/**
 * Middleware function to authenticate an incoming request.
 * If the request is authentic, passes control to the next middleware or route handler.
 * If not, sends a 403 Forbidden response.
 * @param req - The Express request object.
 * @param res - The Express response object.
 * @param next - The next function to pass control to the next middleware/route handler.
 * @returns {void}
 */
function authenticateRequest(req, res, next) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield (0, tokenAuth_1.isRequestAuthentic)(req)) {
            next(); // Handover the request to the endpoint
        }
        else {
            res.sendStatus(403); // Return 403 immediately without handing over the request to the endpoint.
        }
    });
}
exports.authenticateRequest = authenticateRequest;
/**
 * Adds various middlewares to an Express server instance.
 * @param server - The Express server instance to which middlewares will be added.
 * @param buildPath - The path to the directory containing static files to serve.
 * @returns {void}
 */
function addMiddlwares(server, buildPath) {
    // Adds paths to static file content
    server.use(express_1.default.static(buildPath));
    // Adds ability to parse json
    server.use(express_1.default.json());
    // Adds ability to parse cookies
    server.use((0, cookie_parser_1.default)());
    // Adds ability to create sessions
    const uniqifySessionCookie = crypto_1.default.randomBytes(16).toString('hex');
    server.use((0, express_session_1.default)({
        name: `${config_1.MWI_LICENSING_SESSION_COOKIE_NAME}-${uniqifySessionCookie}`,
        secret: crypto_1.default.randomBytes(config_1.MWI_AUTH_TOKEN_LENGTH).toString('hex'),
        resave: false,
        saveUninitialized: true,
        cookie: {
            secure: false
        }
    }));
}
exports.addMiddlwares = addMiddlwares;


/***/ }),

/***/ "./src/licensing/server/routeHandlers.ts":
/*!***********************************************!*\
  !*** ./src/licensing/server/routeHandlers.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.authenticate = exports.updateEntitlement = exports.deleteLicensingInfo = exports.setLicensingInfo = exports.fallbackEndpoint = exports.getStatus = exports.getEnvConfig = void 0;
const path = __importStar(__webpack_require__(/*! path */ "path"));
const tokenAuth = __importStar(__webpack_require__(/*! ./tokenAuth */ "./src/licensing/server/tokenAuth.ts"));
const config_1 = __webpack_require__(/*! ../config */ "./src/licensing/config.ts");
const index_1 = __importDefault(__webpack_require__(/*! ../index */ "./src/licensing/index.ts"));
const LicensingUtils_1 = __webpack_require__(/*! ../../utils/LicensingUtils */ "./src/utils/LicensingUtils.ts");
const config = __importStar(__webpack_require__(/*! ../config */ "./src/licensing/config.ts"));
const errors_1 = __webpack_require__(/*! ../errors */ "./src/licensing/errors.ts");
const NotificationService_1 = __importStar(__webpack_require__(/*! ../../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const index_2 = __webpack_require__(/*! ./index */ "./src/licensing/server/index.ts");
let tokenAuthError = null;
/**
 * Creates a status response object containing MATLAB version, environment suffix, error information, warnings, and licensing information.
 * @param licensing - The Licensing object containing licensing data.
 * @returns {CreateStatusResponse} An object representing the status response with MATLAB version, environment suffix, error information, warnings, and licensing information.
 */
function createStatusResponse(licensing) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, config_1.getMatlabVersion)().then(version => {
            return {
                matlab: {
                    version
                },
                wsEnv: "",
                error: (0, LicensingUtils_1.marshalErrorInfo)((tokenAuthError != null) ? tokenAuthError : licensing.error),
                warnings: [],
                licensing: (0, LicensingUtils_1.marshalLicensingInfo)(licensing.data)
            };
        });
    });
}
/**
 * Retrieves the environment configuration including the MATLAB version and supported versions.
 * @param _req - The Express request object (not used).
 * @param res - The Express response object.
 * @returns {Promise<void>} A promise that resolves when the environment config is sent as a response.
 */
function getEnvConfig(req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, config_1.getMatlabVersion)().then(version => {
            res.send({
                matlab: {
                    version
                },
                authentication: {
                    enabled: config.MWI_ENABLE_TOKEN_AUTH,
                    status: tokenAuth.isRequestAuthentic(req)
                }
            });
        });
    });
}
exports.getEnvConfig = getEnvConfig;
/**
 * Retrieves the licensing status, including MATLAB version, licensing information, error information, and warnings.
 * @param _req - The Express request object (not used).
 * @param res - The Express response object.
 * @returns {Promise<void>} A promise that resolves when the server status is sent as a response.
 */
function getStatus(_req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const licensing = new index_1.default();
        res.send(yield createStatusResponse(licensing));
    });
}
exports.getStatus = getStatus;
/**
 * Fallback endpoint for handling requests coming from the React application.
 * Serves the index.html file from the build directory.
 * @param _req - The Express request object (not used).
 * @param res - The Express response object.
 */
function fallbackEndpoint(_req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        res.sendFile(path.join(__dirname, '/build/index.html'));
    });
}
exports.fallbackEndpoint = fallbackEndpoint;
/**
 * Sets the licensing information for MATLAB.
 * @param req - The Express request object containing the licensing information in the request body.
 * @param res - The Express response object.
 * @returns {Promise<void>} A promise that resolves when the server status is sent as a response.
 */
function setLicensingInfo(req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const licensing = new index_1.default();
        const jsonData = req.body;
        // If user needed to provide matlabVersion (as it was not determinable in getEnvConfig)
        // then update in config.
        if ('matlabVersion' in jsonData) {
            config.setMatlabVersion(jsonData.matlabVersion);
        }
        yield licensing.setLicensingInfo(jsonData);
        if (licensing.error == null) {
            // Start licensed MATLAB if there's no error related to licensing
            index_2.matlabLifecycleManager.eventEmitter.emit('StartLicensedMatlab');
        }
        else {
            // When there is a licensing error, unset the matlabVersion in config
            // if it was sent by the front-end
            if ('matlabVersion' in jsonData) {
                config.setMatlabVersion('');
            }
        }
        res.send(yield createStatusResponse(licensing));
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
    });
}
exports.setLicensingInfo = setLicensingInfo;
/**
 * Deletes the licensing information for MATLAB.
 * @param _req - The Express request object (not used).
 * @param res - The Express response object.
* @returns {Promise<void>} A promise that resolves when the server status is sent as a response.
 */
function deleteLicensingInfo(_req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const licensing = new index_1.default();
        yield licensing.unsetLicensing();
        res.send(yield createStatusResponse(licensing));
    });
}
exports.deleteLicensingInfo = deleteLicensingInfo;
/**
 * Updates the user-selected entitlement information for MATLAB.
 * @param req - The Express request object containing the entitlement ID in the request body.
 * @param res - The Express response object.
 * @returns {Promise<void>} A promise that resolves when the server status is sent as a response.
 */
function updateEntitlement(req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const licensing = new index_1.default();
        const jsonData = req.body;
        const entitlementId = jsonData.entitlement_id;
        yield licensing.updateUserSelectedEntitlementInfo(entitlementId);
        if (licensing.error == null) {
            // Start licensed MATLAB if there's no error related to licensing
            index_2.matlabLifecycleManager.eventEmitter.emit('StartLicensedMatlab');
        }
        res.send(yield createStatusResponse(licensing));
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
    });
}
exports.updateEntitlement = updateEntitlement;
/**
 * Authenticates the user based on the token provided in the request.
 * @param req - The Express request object containing the authentication token.
 * @param res - The Express response object.
 * @returns {Promise<void>} A promise that resolves when the authentication status is sent as a response.
 */
function authenticate(req, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const isAuthentic = tokenAuth.isRequestAuthentic(req);
        tokenAuthError = isAuthentic ? null : new errors_1.InvalidTokenError('Token invalid. Please enter a valid token to authenticate');
        const status = {
            status: isAuthentic,
            error: (0, LicensingUtils_1.marshalErrorInfo)(tokenAuthError)
        };
        res.send(status);
    });
}
exports.authenticate = authenticate;


/***/ }),

/***/ "./src/licensing/server/routes.ts":
/*!****************************************!*\
  !*** ./src/licensing/server/routes.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addRoutes = void 0;
const routeHandlers_1 = __webpack_require__(/*! ./routeHandlers */ "./src/licensing/server/routeHandlers.ts");
const middlewares_1 = __webpack_require__(/*! ./middlewares */ "./src/licensing/server/middlewares.ts");
/**
 * Adds routes to the express application
 * @param app - The Express application object.
 */
function addRoutes(app) {
    // Endpoints that do not require token authentication
    app.get('/get_env_config', routeHandlers_1.getEnvConfig);
    app.get('/get_status', routeHandlers_1.getStatus);
    app.post('/authenticate', routeHandlers_1.authenticate);
    // Endpoints that require token authentication
    app.put('/set_licensing_info', middlewares_1.authenticateRequest, routeHandlers_1.setLicensingInfo);
    app.put('/update_entitlement', middlewares_1.authenticateRequest, routeHandlers_1.updateEntitlement);
    app.delete('/set_licensing_info', middlewares_1.authenticateRequest, routeHandlers_1.deleteLicensingInfo);
    // Fallback endpoint for handling requests coming in from react.
    // NOTE: This endpoint does not need authentication
    // NOTE: Comment out if working with react dev server
    app.get('*', routeHandlers_1.fallbackEndpoint);
}
exports.addRoutes = addRoutes;


/***/ }),

/***/ "./src/licensing/server/tokenAuth.ts":
/*!*******************************************!*\
  !*** ./src/licensing/server/tokenAuth.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isRequestAuthentic = exports.getAuthToken = exports.generateAuthToken = void 0;
const crypto = __importStar(__webpack_require__(/*! crypto */ "crypto"));
const config_1 = __webpack_require__(/*! ../config */ "./src/licensing/config.ts");
let authToken;
let authTokenHashed = null;
/**
 * Checks if the authentication token is present in the session cookie and is valid.
 * @param  req - The Express request object.
 * @returns True if the token is valid and present in the session cookie, otherwise false.
 */
function isAuthTokenInSessionCookie(req) {
    const token = req.session['mwi-auth-token'];
    if (isValidToken(token)) {
        return true;
    }
    return false;
}
/**
 * Checks if the authentication token is present in the request headers and is valid.
 * If the token is valid, it is also stored in the session cookie.
 * @param req - The Express request object.
 * @returns True if the token is valid and present in the request headers, otherwise false.
 */
function isAuthTokenInRequestHeaders(req) {
    const token = req.headers[config_1.MWI_AUTH_TOKEN_NAME_FOR_HTTP];
    if (isValidToken(token)) {
        req.session['mwi-auth-token'] = token;
        return true;
    }
    return false;
}
/**
 * Checks if the authentication token is present in the request parameters and is valid.
 * @param req - The Express request object.
 * @returns True if the token is valid and present in the request parameters, otherwise false.
 */
function isAuthTokenInRequestParams(req) {
    const token = req.query[config_1.MWI_AUTH_TOKEN_NAME_FOR_HTTP];
    if (isValidToken(token)) {
        return true;
    }
    return false;
}
/**
 * Generates a new authentication token of the specified length if one does not already exist.
 * The token is then hashed and stored.
 * @param length - The length of the authentication token to generate.
 * @returns The generated authentication token.
 */
function generateAuthToken(length) {
    if (isValidToken(authToken)) {
        return authToken;
    }
    authToken = crypto.randomBytes(length).toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '')
        .substring(0, length);
    const hash = crypto.createHash('sha256');
    hash.update(authToken);
    authTokenHashed = hash.digest('hex');
    return authToken;
}
exports.generateAuthToken = generateAuthToken;
/**
 * Retrieves the current authentication token.
 * @returns The current authentication token.
 */
function getAuthToken() {
    return authToken;
}
exports.getAuthToken = getAuthToken;
/**
 * Checks if the incoming request is authentic by verifying the presence and validity of the authentication token
 * in the session cookie, request headers, or request parameters.
 * @param req - The Express request object.
 * @returns True if the request is authentic, otherwise false.
 */
function isRequestAuthentic(req) {
    return isAuthTokenInSessionCookie(req) || isAuthTokenInRequestHeaders(req) || isAuthTokenInRequestParams(req);
}
exports.isRequestAuthentic = isRequestAuthentic;
/**
 * Validates the provided authentication token against the stored token and its hashed version.
 * @param token - The token to validate.
 * @returns True if the token is valid, otherwise false.
 */
function isValidToken(token) {
    return token !== null && token !== undefined && (token === authToken || token === authTokenHashed);
}


/***/ }),

/***/ "./src/licensing/types.ts":
/*!********************************!*\
  !*** ./src/licensing/types.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNoLicensingDataType = exports.isExistingLicensingDataType = exports.isNLMLicensingDataType = exports.isMHLMLicensingDataType = exports.ExistingLicenseType = exports.NLMLicenseType = exports.MHLMLicenseType = void 0;
// Licensing data types
exports.MHLMLicenseType = 'mhlm';
exports.NLMLicenseType = 'nlm';
exports.ExistingLicenseType = 'existing_license';
/**
 * Checks if the provided LicensingData is of type MHLMLicensingData.
 *
 * @param data - The LicensingData object to check.
 * @returns A boolean indicating whether the data is of type MHLMLicensingData.
 */
function isMHLMLicensingDataType(data) {
    return typeof data === 'object' && data !== null &&
        'identity_token' in data && data.identity_token !== null &&
        'source_id' in data && data.source_id !== null &&
        'expiry' in data && data.expiry !== null &&
        'entitlement_id' in data;
}
exports.isMHLMLicensingDataType = isMHLMLicensingDataType;
/**
 * Checks if the provided LicensingData is of type NLMLicensingData.
 *
 * @param data - The LicensingData object to check.
 * @returns A boolean indicating whether the data is of type NLMLicensingData.
 */
function isNLMLicensingDataType(data) {
    return typeof data === 'object' && data != null &&
        Object.keys(data).length === 2 &&
        'conn_str' in data && data.conn_str !== null;
}
exports.isNLMLicensingDataType = isNLMLicensingDataType;
/**
 * Checks if the provided LicensingData is of type ExistingLicenseData.
 *
 * @param data - The LicensingData object to check.
 * @returns A boolean indicating whether the data is of type ExistingLicenseData.
 */
function isExistingLicensingDataType(data) {
    return typeof data === 'object' && data != null &&
        Object.keys(data).length === 1 &&
        'type' in data && data.type === exports.ExistingLicenseType;
}
exports.isExistingLicensingDataType = isExistingLicensingDataType;
/**
 * Checks if the provided LicensingData is of type NoLicensingData (null).
 *
 * @param data - The LicensingData object to check.
 * @returns A boolean indicating whether the data is of type NoLicensingData (null).
 */
function isNoLicensingDataType(data) {
    return data === null;
}
exports.isNoLicensingDataType = isNoLicensingDataType;


/***/ }),

/***/ "./src/lifecycle/ConfigurationManager.ts":
/*!***********************************************!*\
  !*** ./src/lifecycle/ConfigurationManager.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionTiming = exports.Argument = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const TelemetryUtils_1 = __webpack_require__(/*! ../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const CliUtils_1 = __webpack_require__(/*! ../utils/CliUtils */ "./src/utils/CliUtils.ts");
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ../ClientConnection */ "./src/ClientConnection.ts"));
var Argument;
(function (Argument) {
    // Basic arguments
    Argument["MatlabLaunchCommandArguments"] = "matlabLaunchCommandArgs";
    Argument["MatlabInstallationPath"] = "matlabInstallPath";
    Argument["MatlabConnectionTiming"] = "matlabConnectionTiming";
    Argument["ShouldIndexWorkspace"] = "indexWorkspace";
    // Advanced arguments
    Argument["MatlabUrl"] = "matlabUrl";
    Argument["SnippetIgnoreList"] = "snippetIgnoreList";
})(Argument = exports.Argument || (exports.Argument = {}));
var ConnectionTiming;
(function (ConnectionTiming) {
    ConnectionTiming["OnStart"] = "onStart";
    ConnectionTiming["OnDemand"] = "onDemand";
    ConnectionTiming["Never"] = "never";
})(ConnectionTiming = exports.ConnectionTiming || (exports.ConnectionTiming = {}));
const SETTING_NAMES = [
    'installPath',
    'matlabConnectionTiming',
    'indexWorkspace',
    'telemetry',
    'maxFileSizeForAnalysis',
    'signIn'
];
class ConfigurationManager {
    constructor() {
        var _a, _b, _c, _d, _e, _f;
        this.configuration = null;
        this.hasConfigurationCapability = false;
        // Map to keep track of callbacks to execute when a specific setting changes
        this.settingChangeCallbacks = new Map();
        const cliArgs = (0, CliUtils_1.getCliArgs)();
        this.defaultConfiguration = {
            installPath: '',
            matlabConnectionTiming: ConnectionTiming.OnStart,
            indexWorkspace: false,
            telemetry: true,
            maxFileSizeForAnalysis: 0,
            signIn: false
        };
        this.globalSettings = {
            installPath: (_a = cliArgs[Argument.MatlabInstallationPath]) !== null && _a !== void 0 ? _a : this.defaultConfiguration.installPath,
            matlabConnectionTiming: (_b = cliArgs[Argument.MatlabConnectionTiming]) !== null && _b !== void 0 ? _b : this.defaultConfiguration.matlabConnectionTiming,
            indexWorkspace: (_c = cliArgs[Argument.ShouldIndexWorkspace]) !== null && _c !== void 0 ? _c : this.defaultConfiguration.indexWorkspace,
            telemetry: this.defaultConfiguration.telemetry,
            maxFileSizeForAnalysis: this.defaultConfiguration.maxFileSizeForAnalysis,
            signIn: this.defaultConfiguration.signIn
        };
        this.additionalArguments = {
            [Argument.MatlabLaunchCommandArguments]: (_d = cliArgs[Argument.MatlabLaunchCommandArguments]) !== null && _d !== void 0 ? _d : '',
            [Argument.MatlabUrl]: (_e = cliArgs[Argument.MatlabUrl]) !== null && _e !== void 0 ? _e : '',
            [Argument.SnippetIgnoreList]: (_f = cliArgs[Argument.SnippetIgnoreList]) !== null && _f !== void 0 ? _f : ''
        };
    }
    static getInstance() {
        if (ConfigurationManager.instance == null) {
            ConfigurationManager.instance = new ConfigurationManager();
        }
        return ConfigurationManager.instance;
    }
    /**
     * Sets up the configuration manager
     *
     * @param capabilities The client capabilities
     */
    setup(capabilities) {
        var _a;
        const connection = ClientConnection_1.default.getConnection();
        this.hasConfigurationCapability = ((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) != null;
        if (this.hasConfigurationCapability) {
            // Register for configuration changes
            void connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type);
        }
        connection.onDidChangeConfiguration(params => { void this.handleConfigurationChanged(params); });
    }
    /**
     * Registers a callback for setting changes.
     *
     * @param settingName - The setting to listen for.
     * @param onSettingChangeCallback - The callback invoked on setting change.
     * @throws {Error} For invalid setting names.
     */
    addSettingCallback(settingName, onSettingChangeCallback) {
        if (this.settingChangeCallbacks.get(settingName) == null) {
            this.settingChangeCallbacks.set(settingName, onSettingChangeCallback);
        }
    }
    /**
     * Gets the configuration for the langauge server
     *
     * @returns The current configuration
     */
    getConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasConfigurationCapability) {
                if (this.configuration == null) {
                    const connection = ClientConnection_1.default.getConnection();
                    this.configuration = (yield connection.workspace.getConfiguration('MATLAB'));
                }
                return Object.assign(this.defaultConfiguration, this.configuration);
            }
            return Object.assign(this.defaultConfiguration, this.globalSettings);
        });
    }
    /**
     * Gets the value of the given argument
     *
     * @param argument The argument
     * @returns The argument's value
     */
    getArgument(argument) {
        return this.additionalArguments[argument];
    }
    /**
     * Handles a change in the configuration
     * @param params The configuration changed params
     */
    handleConfigurationChanged(params) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let oldConfig;
            let newConfig;
            if (this.hasConfigurationCapability) {
                oldConfig = this.configuration;
                // Clear cached configuration
                this.configuration = null;
                // Force load new configuration
                newConfig = yield this.getConfiguration();
            }
            else {
                oldConfig = this.globalSettings;
                this.globalSettings = (_b = (_a = params.settings) === null || _a === void 0 ? void 0 : _a.matlab) !== null && _b !== void 0 ? _b : this.defaultConfiguration;
                newConfig = this.globalSettings;
            }
            this.compareSettingChanges(oldConfig, newConfig);
        });
    }
    compareSettingChanges(oldConfiguration, newConfiguration) {
        if (oldConfiguration == null) {
            // Not yet initialized
            return;
        }
        for (let i = 0; i < SETTING_NAMES.length; i++) {
            const settingName = SETTING_NAMES[i];
            const oldValue = oldConfiguration[settingName];
            const newValue = newConfiguration[settingName];
            if (oldValue !== newValue) {
                (0, TelemetryUtils_1.reportTelemetrySettingsChange)(settingName, newValue.toString(), oldValue.toString());
                // As the setting changed, execute the corresponding callback for it.
                const callback = this.settingChangeCallbacks.get(settingName);
                if (callback != null) {
                    callback(newConfiguration);
                }
            }
        }
    }
}
exports["default"] = ConfigurationManager.getInstance();


/***/ }),

/***/ "./src/lifecycle/LifecycleNotificationHelper.ts":
/*!******************************************************!*\
  !*** ./src/lifecycle/LifecycleNotificationHelper.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
class LifecycleNotificationHelper {
    constructor() {
        this.didMatlabLaunchFail = false;
    }
    static getInstance() {
        if (LifecycleNotificationHelper.instance == null) {
            LifecycleNotificationHelper.instance = new LifecycleNotificationHelper();
        }
        return LifecycleNotificationHelper.instance;
    }
    /**
     * Sends notification to the language client of a change in the MATLAB connection state.
     *
     * @param connectionStatus The connection state
     */
    notifyConnectionStatusChange(connectionStatus) {
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.MatlabConnectionServerUpdate, {
            connectionStatus
        });
    }
    /**
     * Sends notification to the language client to inform user that MATLAB is required for an action.
     */
    notifyMatlabRequirement() {
        // Indicate different messages if MATLAB failed to launch (i.e. could not be found)
        const notification = this.didMatlabLaunchFail ? NotificationService_1.Notification.MatlabFeatureUnavailableNoMatlab : NotificationService_1.Notification.MatlabFeatureUnavailable;
        NotificationService_1.default.sendNotification(notification);
    }
}
exports["default"] = LifecycleNotificationHelper.getInstance();


/***/ }),

/***/ "./src/lifecycle/MatlabLifecycleManager.ts":
/*!*************************************************!*\
  !*** ./src/lifecycle/MatlabLifecycleManager.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! events */ "events");
const ConfigurationManager_1 = __importStar(__webpack_require__(/*! ./ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
const MatlabSession_1 = __webpack_require__(/*! ./MatlabSession */ "./src/lifecycle/MatlabSession.ts");
class MatlabLifecycleManager {
    constructor() {
        this.eventEmitter = new events_1.EventEmitter();
        this.matlabSession = null;
        this.connectionPromise = null;
    }
    /**
     * Gets the current connection to MATLAB.
     *
     * @param startMatlab If no existing MATLAB connection exists, this determines whether
     * a new connection should be established. If true, this will attempt to establish a
     * new connection. If false, it will not and will return null.
     *
     * @returns The MATLAB connection object, or null if no connection exists.
     */
    getMatlabConnection(startMatlab = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // If MATLAB is already connected, return the current connection
            if (this.matlabSession != null) {
                return this.matlabSession.getConnection();
            }
            // If MATLAB is actively connecting, wait for the connection to be established
            if (this.connectionPromise != null) {
                const connectionPromise = this.connectionPromise;
                return yield new Promise(resolve => {
                    connectionPromise.then(matlabSession => {
                        resolve(matlabSession.getConnection());
                    }).catch(() => {
                        resolve(null);
                    });
                });
            }
            // No connection currently established or establishing. Attempt to connect to MATLAB if desired.
            const matlabConnectionTiming = (yield ConfigurationManager_1.default.getConfiguration()).matlabConnectionTiming;
            const shouldStartMatlab = startMatlab && matlabConnectionTiming !== ConfigurationManager_1.ConnectionTiming.Never;
            if (shouldStartMatlab) {
                try {
                    const matlabSession = yield this.connectToMatlab();
                    return matlabSession.getConnection();
                }
                catch (err) {
                    return null;
                }
            }
            else {
                return null;
            }
        });
    }
    /**
     * Attempt to connect to MATLAB. This will not create a second connection to MATLAB
     * if a session already exists.
     *
     * @returns The active MATLAB session
     */
    connectToMatlab() {
        return __awaiter(this, void 0, void 0, function* () {
            // If MATLAB is already connected, do not try to connect again
            if (this.matlabSession != null) {
                return this.matlabSession;
            }
            // If MATLAB is actively connecting, wait and return that session
            if (this.connectionPromise != null) {
                const connectionPromise = this.connectionPromise;
                // MATLAB is actively connecting
                return yield new Promise((resolve, reject) => {
                    connectionPromise.then(matlabSession => {
                        resolve(matlabSession);
                    }).catch(reason => {
                        reject(reason);
                    });
                });
            }
            // Start a new session
            if (shouldConnectToRemoteMatlab()) {
                return yield this.connectToRemoteMatlab();
            }
            else {
                return yield this.connectToLocalMatlab();
            }
        });
    }
    /**
     * Terminate the current MATLAB session.
     *
     * Emits a 'disconnected' event.
     */
    disconnectFromMatlab() {
        if (this.matlabSession == null) {
            return;
        }
        this.matlabSession.shutdown();
        this.matlabSession = null;
        this.eventEmitter.emit('disconnected');
    }
    /**
     * Determine if MATLAB is connected.
     *
     * @returns True if there is an active MATLAB session, false otherwise
     */
    isMatlabConnected() {
        return this.matlabSession != null || this.connectionPromise != null;
    }
    /**
     * Gets the release of the currently connected MATLAB.
     *
     * @returns The MATLAB release (e.g. "R2023b") of the active session, or null if unknown
     */
    getMatlabRelease() {
        return this.matlabSession == null ? null : this.matlabSession.getMatlabRelease();
    }
    /**
     * Starts a new session with a locally installed MATLAB instance.
     *
     * @returns The new MATLAB session
     */
    connectToLocalMatlab() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connectionPromise = (0, MatlabSession_1.launchNewMatlab)(this);
            return yield new Promise((resolve, reject) => {
                var _a;
                (_a = this.connectionPromise) === null || _a === void 0 ? void 0 : _a.then(matlabSession => {
                    this.matlabSession = matlabSession;
                    this.matlabSession.eventEmitter.on('shutdown', () => {
                        this.matlabSession = null;
                        this.eventEmitter.emit('disconnected');
                    });
                    this.eventEmitter.emit('connected');
                    resolve(matlabSession);
                }).catch(reason => {
                    reject(reason);
                }).finally(() => {
                    this.connectionPromise = null;
                });
            });
        });
    }
    /**
     * Starts a new session with a MATLAB instance over a URL.
     *
     * @returns The new MATLAB session
     */
    connectToRemoteMatlab() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = ConfigurationManager_1.default.getArgument(ConfigurationManager_1.Argument.MatlabUrl);
            this.connectionPromise = (0, MatlabSession_1.connectToMatlab)(url);
            return yield new Promise((resolve, reject) => {
                var _a;
                (_a = this.connectionPromise) === null || _a === void 0 ? void 0 : _a.then(matlabSession => {
                    this.matlabSession = matlabSession;
                    this.matlabSession.eventEmitter.on('shutdown', () => {
                        this.matlabSession = null;
                        this.eventEmitter.emit('disconnected');
                    });
                    this.eventEmitter.emit('connected');
                    resolve(matlabSession);
                }).catch(reason => {
                    reject(reason);
                }).finally(() => {
                    this.connectionPromise = null;
                });
            });
        });
    }
}
exports["default"] = MatlabLifecycleManager;
/**
 * Whether or not the language server should attempt to connect to an existing
 * MATLAB instance.
 *
 * @returns True if the language server should attempt to connect to an
 * already-running instance of MATLAB. False otherwise.
 */
function shouldConnectToRemoteMatlab() {
    // Assume we should connect to existing MATLAB if the matlabUrl startup flag has been provided
    return Boolean(ConfigurationManager_1.default.getArgument(ConfigurationManager_1.Argument.MatlabUrl));
}


/***/ }),

/***/ "./src/lifecycle/MatlabSession.ts":
/*!****************************************!*\
  !*** ./src/lifecycle/MatlabSession.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectToMatlab = exports.launchNewMatlab = exports.ConnectionState = void 0;
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const ConfigurationManager_1 = __importStar(__webpack_require__(/*! ./ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
const LifecycleNotificationHelper_1 = __importDefault(__webpack_require__(/*! ./LifecycleNotificationHelper */ "./src/lifecycle/LifecycleNotificationHelper.ts"));
const MatlabCommunicationManager_1 = __importStar(__webpack_require__(/*! ./MatlabCommunicationManager */ "./src/lifecycle/MatlabCommunicationManager.js"));
const chokidar = __importStar(__webpack_require__(/*! chokidar */ "./node_modules/chokidar/index.js"));
const fsPromises = __importStar(__webpack_require__(/*! fs/promises */ "fs/promises"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const events_1 = __webpack_require__(/*! events */ "events");
const DeprecationUtils_1 = __webpack_require__(/*! ../utils/DeprecationUtils */ "./src/utils/DeprecationUtils.ts");
const ProxyUtils_1 = __webpack_require__(/*! ../utils/ProxyUtils */ "./src/utils/ProxyUtils.ts");
const licensing_1 = __importDefault(__webpack_require__(/*! ../licensing */ "./src/licensing/index.ts"));
const server_1 = __webpack_require__(/*! ../licensing/server */ "./src/licensing/server/index.ts");
const config_1 = __webpack_require__(/*! ../licensing/config */ "./src/licensing/config.ts");
var ConnectionState;
(function (ConnectionState) {
    ConnectionState["CONNECTING"] = "connecting";
    ConnectionState["CONNECTED"] = "connected";
    ConnectionState["DISCONNECTED"] = "disconnected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
/**
 * Launches and connects to a new MATLAB instance.
 *
 * @returns The MATLAB session
 */
function launchNewMatlab(matlabLifecycleManager) {
    return __awaiter(this, void 0, void 0, function* () {
        LifecycleNotificationHelper_1.default.didMatlabLaunchFail = false;
        LifecycleNotificationHelper_1.default.notifyConnectionStatusChange(ConnectionState.CONNECTING);
        let environmentVariables = {};
        // Trigger licensing workflows if required
        const configuration = yield ConfigurationManager_1.default.getConfiguration();
        if (configuration.signIn) {
            const licensing = new licensing_1.default();
            if (!licensing.isLicensed()) {
                const url = yield (0, server_1.startLicensingServer)(config_1.staticFolderPath, matlabLifecycleManager);
                // If there's no cached licensing, start licensing server and send the url to the client
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingServerUrl, url);
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
                return new Promise((resolve) => {
                    // Setup a onetime event listener for starting matlab session with licensing environment variables.
                    // The 'StartLicensedMatlab' event will be fired by the licensing server after licensing is successful.
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises
                    matlabLifecycleManager.eventEmitter.once('StartLicensedMatlab', () => __awaiter(this, void 0, void 0, function* () {
                        // Gather the environment variables specific to licensing and pass it on for MATLAB launch.
                        environmentVariables = yield licensing.setupEnvironmentVariables();
                        resolve(yield startMatlabSession(environmentVariables));
                    }));
                });
            }
            else {
                // Found cached licensing, so just marshal environment variables and pass it on for MATLAB launch.
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
                environmentVariables = yield licensing.setupEnvironmentVariables();
                return yield startMatlabSession(environmentVariables);
            }
        }
        else {
            // Licensing workflows are not enabled, so start MATLAB as before.
            return yield startMatlabSession(environmentVariables);
        }
    });
}
exports.launchNewMatlab = launchNewMatlab;
/**
 * Starts a MATLAB session with the given environment variables.
 *
 * @param environmentVariables - The environment variables to be used when launching MATLAB.
 * @returns A promise that resolves to a MatlabSession object when MATLAB is successfully started and connected.
 * @throws Will reject the promise if there is an error in launching MATLAB or establishing the connection.
 */
function startMatlabSession(environmentVariables) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // Setup file watch for MATLAB starting
            const outFile = path.join(Logger_1.default.logDir, 'matlabls_conn.json');
            const matlabSession = new LocalMatlabSession();
            const watcher = chokidar.watch(outFile, {
                persistent: true,
                useFsEvents: false
            });
            // This callback will be triggered when MATLAB has launched and writes the watched file.
            watcher.on('add', () => __awaiter(this, void 0, void 0, function* () {
                Logger_1.default.log(`Started MATLAB (session ${matlabSession.sessionId})`);
                // First change detected - close watcher
                void watcher.close();
                // Read startup info from file
                const connectionInfo = yield readStartupInfo(outFile);
                const { pid, release, port, certFile, sessionKey } = connectionInfo;
                // Check if the launched MATLAB is supported. We do not abort the connection, as this may
                // be the user's desire and some functionality may work (althought it is not guaranteed).
                (0, DeprecationUtils_1.checkIfMatlabDeprecated)(release);
                matlabSession.startConnection(port, certFile, pid, release).then(() => {
                    LifecycleNotificationHelper_1.default.notifyConnectionStatusChange(ConnectionState.CONNECTED);
                    Logger_1.default.log(`MATLAB session ${matlabSession.sessionId} connected to ${release}`);
                    (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.StartMatlab, release);
                    (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.MatlabSessionKey, sessionKey);
                    resolve(matlabSession);
                }).catch(reason => {
                    Logger_1.default.error(`MATLAB session ${matlabSession.sessionId} failed to connect`);
                    matlabSession.shutdown();
                    (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.StartMatlab, 'Failed to connect to MATLAB');
                    reject(reason);
                });
                // outFile is no longer needed - delete
                void fsPromises.rm(outFile, { force: true });
            }));
            // Launch MATLAB process
            Logger_1.default.log('Launching MATLAB...');
            const { command, args } = yield getMatlabLaunchCommand(outFile);
            const envVars = Object.assign(Object.assign({}, environmentVariables), (0, ProxyUtils_1.getProxyEnvironmentVariables)() // Proxy specific environment variables.
            );
            const matlabProcessInfo = MatlabCommunicationManager_1.default.launchNewMatlab(command, args, Logger_1.default.logDir, envVars);
            if (matlabProcessInfo == null) {
                // Error occurred while spawning MATLAB process
                matlabSession.shutdown('Error spawning MATLAB process');
                void watcher.close();
                Logger_1.default.error(`Error launching MATLAB with command: ${command}`);
                LifecycleNotificationHelper_1.default.didMatlabLaunchFail = true;
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.MatlabLaunchFailed);
                reject(new Error('Failed to launch local MATLAB'));
                return;
            }
            // Initialize the new session
            const { matlabConnection, matlabProcess } = matlabProcessInfo;
            matlabSession.initialize(matlabConnection, matlabProcess);
            // Handles additional errors with launching the MATLAB process
            matlabProcess === null || matlabProcess === void 0 ? void 0 : matlabProcess.on('error', error => {
                reject(new Error('Error from MATLAB child process'));
                // Error occurred in child process
                matlabSession.shutdown('Error launching MATLAB');
                void watcher.close();
                Logger_1.default.error(`Error launching MATLAB: (${error.name}) ${error.message}`);
                if (error.stack != null) {
                    Logger_1.default.error(`Error stack:\n${error.stack}`);
                }
                LifecycleNotificationHelper_1.default.didMatlabLaunchFail = true;
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.MatlabLaunchFailed);
            });
            // Handles the MATLAB process being terminated unexpectedly/externally.
            // This could include the user killing the process.
            matlabProcess.on('close', () => {
                // Close connection
                reject(new Error('MATLAB process terminated unexpectedly'));
                Logger_1.default.log(`MATLAB process (session ${matlabSession.sessionId}) terminated`);
                matlabSession.shutdown();
            });
        }));
    });
}
/**
 * Connects to a MATLAB instance over the given URL.
 *
 * @param url The URL at which to find MATLAB
 *
 * @returns The MATLAB session
 */
function connectToMatlab(url) {
    return __awaiter(this, void 0, void 0, function* () {
        LifecycleNotificationHelper_1.default.notifyConnectionStatusChange(ConnectionState.CONNECTING);
        const matlabSession = new RemoteMatlabSession();
        const matlabConnection = yield MatlabCommunicationManager_1.default.connectToExistingMatlab(url);
        matlabSession.initialize(matlabConnection);
        yield matlabSession.startConnection();
        return matlabSession;
    });
}
exports.connectToMatlab = connectToMatlab;
let sessionIdCt = 1;
class AbstractMatlabSession {
    constructor() {
        this.sessionId = sessionIdCt++;
        this.eventEmitter = new events_1.EventEmitter();
        this.isValid = true;
    }
    getConnection() {
        var _a;
        return (_a = this.matlabConnection) !== null && _a !== void 0 ? _a : null;
    }
    getMatlabRelease() {
        var _a;
        return (_a = this.matlabRelease) !== null && _a !== void 0 ? _a : null;
    }
    notifyConnectionStatusChange(status) {
        if (this.isValid) {
            // Only sent notifications about status changes for valid
            // sessions, to avoid potential poor interactions between
            // a session shutting down and a new session starting.
            LifecycleNotificationHelper_1.default.notifyConnectionStatusChange(status);
        }
    }
}
/**
 * Represents a session with a locally installed MATLAB.
 */
class LocalMatlabSession extends AbstractMatlabSession {
    initialize(matlabConnection, matlabProcess) {
        this.matlabConnection = matlabConnection;
        this.matlabProcess = matlabProcess;
        this.setupListeners();
    }
    /**
     * Instantiates the connection with MATLAB.
     *
     * @param port MATLAB's secure port number
     * @param certFile The file location for MATLAB's self-signed certificate
     * @param matlabPid MATLAB's process ID
     * @param matlabRelease The MATLAB release
     */
    startConnection(port, certFile, matlabPid, matlabRelease) {
        return __awaiter(this, void 0, void 0, function* () {
            this.matlabPid = matlabPid;
            this.matlabRelease = matlabRelease;
            if (this.matlabConnection == null) {
                Logger_1.default.error('Attempting to start connection to MATLAB without first initializing');
                return yield Promise.reject(new Error('LocalMatlabSession not initialized'));
            }
            return yield this.matlabConnection.initialize(port, certFile);
        });
    }
    shutdown(shutdownMessage) {
        var _a, _b;
        if (!this.isValid) {
            // Don't attempt to shut down more than once
            return;
        }
        Logger_1.default.log(`Shutting down MATLAB session ${this.sessionId}`);
        // Report shutdown
        this.notifyConnectionStatusChange(ConnectionState.DISCONNECTED);
        (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.ShutdownMatlab, shutdownMessage);
        this.eventEmitter.emit('shutdown');
        this.isValid = false;
        // Close the connection and kill MATLAB process
        if (os.platform() === 'win32' && this.matlabPid != null) {
            // Need to kill MATLAB's child process which is launched on Windows
            try {
                process.kill(this.matlabPid, 'SIGTERM');
            }
            catch (_c) {
                Logger_1.default.warn('Unable to kill MATLAB child process - child process already killed');
            }
        }
        (_a = this.matlabConnection) === null || _a === void 0 ? void 0 : _a.close();
        try {
            (_b = this.matlabProcess) === null || _b === void 0 ? void 0 : _b.kill('SIGTERM');
        }
        catch (_d) {
            Logger_1.default.warn('Unable to kill MATLAB process - process already killed');
        }
    }
    setupListeners() {
        var _a, _b, _c;
        // Handle messages from MATLAB's standard err channel. Because MATLAB is launched
        // with the -log flag, all of MATLAB's output is pushed through stderr. Write this
        // to a log file
        (_b = (_a = this.matlabProcess) === null || _a === void 0 ? void 0 : _a.stderr) === null || _b === void 0 ? void 0 : _b.on('data', data => {
            const stderrStr = data.toString().trim();
            Logger_1.default.writeMatlabLog(stderrStr);
        });
        // Set up lifecycle listener
        (_c = this.matlabConnection) === null || _c === void 0 ? void 0 : _c.setLifecycleListener(lifecycleEvent => {
            if (lifecycleEvent === MatlabCommunicationManager_1.LifecycleEventType.DISCONNECTED) {
                Logger_1.default.warn('Error while communicating with MATLAB - disconnecting');
                this.shutdown('Error while communicating with MATLAB');
            }
        });
    }
}
/**
 * Represents a session with a (potentially) remote MATLAB instance over a URL.
 */
class RemoteMatlabSession extends AbstractMatlabSession {
    initialize(matlabConnection) {
        this.matlabConnection = matlabConnection;
        this.setupListeners();
    }
    /**
     * Instantiates the connection with MATLAB.
     */
    startConnection() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.matlabConnection == null) {
                Logger_1.default.error('Attempting to start connection to MATLAB without first initializing');
                return yield Promise.reject(new Error('RemoteMatlabSession not initialized'));
            }
            return yield ((_a = this.matlabConnection) === null || _a === void 0 ? void 0 : _a.initialize());
        });
    }
    shutdown(shutdownMessage) {
        var _a;
        if (!this.isValid) {
            // Don't attempt to shut down more than once
            return;
        }
        // Report shutdown
        this.notifyConnectionStatusChange(ConnectionState.DISCONNECTED);
        (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.ShutdownMatlab, shutdownMessage);
        this.eventEmitter.emit('shutdown');
        this.isValid = false;
        // Close the connection
        (_a = this.matlabConnection) === null || _a === void 0 ? void 0 : _a.close();
    }
    setupListeners() {
        var _a;
        (_a = this.matlabConnection) === null || _a === void 0 ? void 0 : _a.setLifecycleListener(lifecycleEvent => {
            if (lifecycleEvent === MatlabCommunicationManager_1.LifecycleEventType.CONNECTED) {
                this.notifyConnectionStatusChange(ConnectionState.CONNECTED);
            }
            else if (lifecycleEvent === MatlabCommunicationManager_1.LifecycleEventType.DISCONNECTED) {
                this.shutdown('Remote MATLAB disconnected');
            }
        });
    }
}
/**
 * Reads the startup info generated by MATLAB when it is launched.
 *
 * @param file The file from which to read
 * @returns The MATLAB startup info
 */
function readStartupInfo(file) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield fsPromises.readFile(file);
        return JSON.parse(data.toString());
    });
}
/**
 * Gets the command with which MATLAB should be launched.
 *
 * @param outFile The file in which MATLAB should output connection details
 * @returns The MATLAB launch command and arguments
 */
function getMatlabLaunchCommand(outFile) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const matlabInstallPath = (yield ConfigurationManager_1.default.getConfiguration()).installPath;
        let command = 'matlab';
        if (matlabInstallPath !== '') {
            command = path.normalize(path.join(matlabInstallPath.trim(), 'bin', 'matlab'));
        }
        const args = [
            '-log',
            '-memmgr', 'release',
            '-noAppIcon',
            '-nosplash',
            '-r', getMatlabStartupCommand(outFile),
            '-useStartupFolderPref',
            '-nodesktop' // Hide the MATLAB desktop
        ];
        if (os.platform() === 'win32') {
            args.push('-noDisplayDesktop'); // Workaround for '-nodesktop' on Windows until a better solution is implemented
            args.push('-wait');
        }
        const argsFromSettings = (_a = ConfigurationManager_1.default.getArgument(ConfigurationManager_1.Argument.MatlabLaunchCommandArguments)) !== null && _a !== void 0 ? _a : null;
        if (argsFromSettings != null) {
            args.push(argsFromSettings);
        }
        return {
            command,
            args
        };
    });
}
/**
 * Gets the MATLAB command which the MATLAB application should run at startup.
 *
 * Note: This will sanitize the file paths so that they can be safely used within
 * character vectors in MATLAB. This is done by replacing all single-quote characters
 * with double single-quotes.
 *
 * @param outFile The file in which MATLAB should output connection details
 * @returns The MATLAB startup command
 */
function getMatlabStartupCommand(outFile) {
    // Sanitize file paths for MATLAB:
    // Replace single-quotes in the file path with double single-quotes
    // to preserve the quote when used within a MATLAB character vector.
    const extensionInstallationDir = __dirname.replace(/'/g, "''");
    const outFilePath = outFile.replace(/'/g, "''");
    return `addpath(fullfile('${extensionInstallationDir}', '..', 'matlab')); initmatlabls('${outFilePath}')`;
}


/***/ }),

/***/ "./src/logging/Logger.ts":
/*!*******************************!*\
  !*** ./src/logging/Logger.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const SERVER_LOG = 'languageServerLog.txt';
const MATLAB_LOG = 'matlabLog.txt';
class Logger {
    constructor() {
        // Create Log Directory
        const pid = process.pid;
        this.logDir = path.join(os.tmpdir(), `matlabls_${pid}`);
        if (fs.existsSync(this.logDir)) {
            let i = 1;
            while (fs.existsSync(`${this.logDir}_${i}`)) {
                i++;
            }
            this.logDir = `${this.logDir}_${i}`;
        }
        fs.mkdirSync(this.logDir);
        // Get name of log file
        this.languageServerLogFile = path.join(this.logDir, SERVER_LOG);
        this.matlabLogFile = path.join(this.logDir, MATLAB_LOG);
    }
    initialize(console) {
        this.console = console;
        this.log(`Log Directory: ${this.logDir}`);
    }
    static getInstance() {
        if (Logger.instance == null) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
    /**
     * Logs an informational message to both the console and the log file.
     *
     * @param message The message
     */
    log(message) {
        var _a;
        const msg = `(${getCurrentTimeString()}) matlabls: ${message}`;
        (_a = this.console) === null || _a === void 0 ? void 0 : _a.log(msg);
        this._writeToLogFile(msg, this.languageServerLogFile);
    }
    /**
     * Logs a warning message to both the console and the log file.
     *
     * @param message The warning message
     */
    warn(message) {
        var _a;
        const msg = `(${getCurrentTimeString()}) matlabls - WARNING: ${message}`;
        (_a = this.console) === null || _a === void 0 ? void 0 : _a.warn(msg);
        this._writeToLogFile(msg, this.languageServerLogFile);
    }
    /**
     * Logs an error message to both the console and the log file.
     *
     * @param message The error message
     */
    error(message) {
        var _a;
        const msg = `(${getCurrentTimeString()}) matlabls - ERROR: ${message}`;
        (_a = this.console) === null || _a === void 0 ? void 0 : _a.error(msg);
        this._writeToLogFile(msg, this.languageServerLogFile);
    }
    /**
     * Log MATLAB application output to a log file on disk, separate from
     * the language server logs.
     *
     * @param message The message
     */
    writeMatlabLog(message) {
        this._writeToLogFile(message, this.matlabLogFile);
    }
    _writeToLogFile(message, filePath) {
        // Log to file
        fs.writeFile(filePath, `${message}\n`, { flag: 'a+' }, err => {
            var _a;
            if (err !== null) {
                (_a = this.console) === null || _a === void 0 ? void 0 : _a.error('Failed to write to log file');
            }
        });
    }
}
function getCurrentTimeString() {
    const d = new Date();
    const strFormatter = (x) => x.toString().padStart(2, '0');
    return `${strFormatter(d.getHours())}:${strFormatter(d.getMinutes())}:${strFormatter(d.getSeconds())}`;
}
exports["default"] = Logger.getInstance();


/***/ }),

/***/ "./src/logging/TelemetryUtils.ts":
/*!***************************************!*\
  !*** ./src/logging/TelemetryUtils.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2023-2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportTelemetrySettingsChange = exports.reportTelemetryAction = exports.ActionErrorConditions = exports.Actions = void 0;
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
var EventKeys;
(function (EventKeys) {
    EventKeys["Action"] = "ACTIONS";
    EventKeys["SettingChange"] = "SETTING_CHANGE";
})(EventKeys || (EventKeys = {}));
var Actions;
(function (Actions) {
    Actions["OpenFile"] = "openFile";
    Actions["StartMatlab"] = "startMATLAB";
    Actions["ShutdownMatlab"] = "shutdownMATLAB";
    Actions["MatlabSessionKey"] = "getMATLABSession";
    Actions["FormatDocument"] = "formatDocument";
    Actions["GoToReference"] = "goToReference";
    Actions["GoToDefinition"] = "goToDefinition";
    Actions["DocumentSymbol"] = "documentSymbol";
    Actions["RenameSymbol"] = "renameSymbol";
})(Actions = exports.Actions || (exports.Actions = {}));
var ActionErrorConditions;
(function (ActionErrorConditions) {
    ActionErrorConditions["MatlabUnavailable"] = "MATLAB unavailable";
})(ActionErrorConditions = exports.ActionErrorConditions || (exports.ActionErrorConditions = {}));
/**
 * Reports a telemetry event to the client
 *
 * @param eventKey The event key
 * @param data The event's data
 */
function reportTelemetry(eventKey, data) {
    NotificationService_1.default.sendNotification(NotificationService_1.Notification.LogTelemetryData, {
        eventKey,
        data
    });
}
/**
 * Reports telemetry about a simple action
 *
 * @param actionType The action's type
 * @param data The action's data
 */
function reportTelemetryAction(actionType, data = '') {
    reportTelemetry(EventKeys.Action, {
        action_type: actionType,
        result: data
    });
}
exports.reportTelemetryAction = reportTelemetryAction;
/**
 * Reports telemetry about a settings change
 *
 * @param settingName The setting's name
 * @param newValue The new value
 * @param oldValue The old value
 */
function reportTelemetrySettingsChange(settingName, newValue, oldValue) {
    reportTelemetry(EventKeys.SettingChange, {
        setting_name: settingName,
        new_value: newValue,
        old_value: oldValue
    });
}
exports.reportTelemetrySettingsChange = reportTelemetrySettingsChange;


/***/ }),

/***/ "./src/mvm/MVMServer.ts":
/*!******************************!*\
  !*** ./src/mvm/MVMServer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
const NotificationService_1 = __webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts");
const MVM_1 = __webpack_require__(/*! ./impl/MVM */ "./src/mvm/impl/MVM.js");
/**
 * Provides an interface for sending evals and fevals and listening to the results.
 */
class MVMServer {
    constructor(mvm, notificationService) {
        this._mvm = mvm;
        this._notificationService = notificationService;
        this._setupListeners();
        // Set up connection notification listeners
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMEvalRequest, this._doEval.bind(this));
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMFevalRequest, this._doFeval.bind(this));
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMInterruptRequest, this._doInterrupt.bind(this));
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMSetBreakpointRequest, this._doSetBreakpoint.bind(this));
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMClearBreakpointRequest, this._doClearBreakpoint.bind(this));
        this._notificationService.registerNotificationListener(NotificationService_1.Notification.MVMUnpauseRequest, this._doUnpause.bind(this));
    }
    _setupListeners() {
        this._mvm.on(MVM_1.IMVM.Events.stateChange, this._handleMvmStateChange.bind(this));
        this._mvm.on(MVM_1.IMVM.Events.output, this._handleOutput.bind(this));
        this._mvm.on(MVM_1.IMVM.Events.clc, this._handleClc.bind(this));
        this._mvm.on(MVM_1.IMVM.Events.promptChange, this._handlePromptChange.bind(this));
    }
    _handleMvmStateChange(state, release) {
        this._notificationService.sendNotification(NotificationService_1.Notification.MVMStateChange, { state, release });
    }
    _doEval(data) {
        var _a;
        const requestId = data.requestId;
        if (requestId === undefined) {
            return;
        }
        void ((_a = this._mvm.eval(data.command, data.isUserEval, data.capabilitiesToRemove)) === null || _a === void 0 ? void 0 : _a.then(() => {
            this._notificationService.sendNotification(NotificationService_1.Notification.MVMEvalComplete, {
                requestId
            });
        }));
    }
    _doFeval(data) {
        var _a;
        const requestId = data.requestId;
        if (requestId === undefined) {
            return;
        }
        void ((_a = this._mvm.feval(data.functionName, data.nargout, data.args, data.capabilitiesToRemove)) === null || _a === void 0 ? void 0 : _a.then((result) => {
            this._notificationService.sendNotification(NotificationService_1.Notification.MVMFevalComplete, {
                requestId,
                result
            });
        }));
    }
    _doSetBreakpoint(data) {
        var _a;
        const requestId = data.requestId;
        if (requestId === undefined) {
            return;
        }
        void ((_a = this._mvm.setBreakpoint(data.fileName, data.lineNumber, data.condition, data.anonymousIndex)) === null || _a === void 0 ? void 0 : _a.then((result) => {
            this._notificationService.sendNotification(NotificationService_1.Notification.MVMSetBreakpointComplete, {
                requestId,
                result
            });
        }));
    }
    _doClearBreakpoint(data) {
        var _a;
        const requestId = data.requestId;
        if (requestId === undefined) {
            return;
        }
        void ((_a = this._mvm.clearBreakpoint(data.fileName, data.lineNumber, data.condition, data.anonymousIndex)) === null || _a === void 0 ? void 0 : _a.then((result) => {
            this._notificationService.sendNotification(NotificationService_1.Notification.MVMClearBreakpointComplete, {
                requestId,
                result
            });
        }));
    }
    _doInterrupt() {
        this._mvm.interrupt();
    }
    _doUnpause() {
        this._mvm.unpause();
    }
    _handleOutput(data) {
        this._notificationService.sendNotification(NotificationService_1.Notification.MVMText, data);
    }
    _handleClc() {
        this._notificationService.sendNotification(NotificationService_1.Notification.MVMClc);
    }
    _handlePromptChange(state, isIdle) {
        this._notificationService.sendNotification(NotificationService_1.Notification.MVMPromptChange, {
            state,
            isIdle
        });
    }
}
exports["default"] = MVMServer;


/***/ }),

/***/ "./src/notifications/NotificationService.ts":
/*!**************************************************!*\
  !*** ./src/notifications/NotificationService.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Notification = void 0;
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ../ClientConnection */ "./src/ClientConnection.ts"));
var Notification;
(function (Notification) {
    // Connection Status Updates
    Notification["MatlabConnectionClientUpdate"] = "matlab/connection/update/client";
    Notification["MatlabConnectionServerUpdate"] = "matlab/connection/update/server";
    // Errors
    Notification["MatlabLaunchFailed"] = "matlab/launchfailed";
    Notification["MatlabFeatureUnavailable"] = "feature/needsmatlab";
    Notification["MatlabFeatureUnavailableNoMatlab"] = "feature/needsmatlab/nomatlab";
    // MATLAB Version Deprecation
    Notification["MatlabVersionDeprecation"] = "matlab/version/deprecation";
    // Execution
    Notification["MatlabRequestInstance"] = "matlab/request";
    Notification["MVMEvalRequest"] = "evalRequest";
    Notification["MVMEvalComplete"] = "evalResponse";
    Notification["MVMFevalRequest"] = "fevalRequest";
    Notification["MVMFevalComplete"] = "fevalResponse";
    Notification["MVMSetBreakpointRequest"] = "setBreakpointRequest";
    Notification["MVMSetBreakpointComplete"] = "setBreakpointResponse";
    Notification["MVMClearBreakpointRequest"] = "clearBreakpointRequest";
    Notification["MVMClearBreakpointComplete"] = "clearBreakpointResponse";
    Notification["MVMText"] = "text";
    Notification["MVMClc"] = "clc";
    Notification["MVMPromptChange"] = "mvmPromptChange";
    Notification["MVMInterruptRequest"] = "interruptRequest";
    Notification["MVMUnpauseRequest"] = "unpauseRequest";
    Notification["MVMStateChange"] = "mvmStateChange";
    Notification["DebuggingStateChange"] = "DebuggingStateChange";
    Notification["DebugAdaptorRequest"] = "DebugAdaptorRequest";
    Notification["DebugAdaptorResponse"] = "DebugAdaptorResponse";
    Notification["DebugAdaptorEvent"] = "DebugAdaptorEvent";
    // Telemetry
    Notification["LogTelemetryData"] = "telemetry/logdata";
    // MATLAB File Sections Updates
    Notification["MatlabSections"] = "matlab/sections";
    // Licensing
    Notification["LicensingServerUrl"] = "licensing/server/url";
    Notification["LicensingData"] = "licensing/data";
    Notification["LicensingDelete"] = "licensing/delete";
    Notification["LicensingError"] = "licensing/error";
})(Notification = exports.Notification || (exports.Notification = {}));
class NotificationService {
    static getInstance() {
        if (NotificationService.instance == null) {
            NotificationService.instance = new NotificationService();
        }
        return NotificationService.instance;
    }
    /**
     * Sends a notification to the language client
     *
     * @param name The name of the notification
     * @param params Any parameters to send with the notification
     */
    sendNotification(name, params) {
        void ClientConnection_1.default.getConnection().sendNotification(name, params);
    }
    /**
     * Registers a notification listener for the specified notification name.
     *
     * @param name - The name of the notification to listen for.
     * @param callback - The callback function that will be invoked when the notification is received.
     * @returns A disposable object that can be used to unregister the notification listener.
     */
    registerNotificationListener(name, callback) {
        return ClientConnection_1.default.getConnection().onNotification(name, callback);
    }
}
exports["default"] = NotificationService.getInstance();


/***/ }),

/***/ "./src/providers/completion/CompletionSupportProvider.ts":
/*!***************************************************************!*\
  !*** ./src/providers/completion/CompletionSupportProvider.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
const ConfigurationManager_1 = __importStar(__webpack_require__(/*! ../../lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
// Maps the completion type, as returned by MATLAB, to the corresponding CompletionItemKind
const MatlabCompletionToKind = {
    literal: vscode_languageserver_1.CompletionItemKind.Text,
    unknown: vscode_languageserver_1.CompletionItemKind.Function,
    pathItem: vscode_languageserver_1.CompletionItemKind.File,
    mFile: vscode_languageserver_1.CompletionItemKind.Function,
    pFile: vscode_languageserver_1.CompletionItemKind.Function,
    mlxFile: vscode_languageserver_1.CompletionItemKind.Function,
    mlappFile: vscode_languageserver_1.CompletionItemKind.Function,
    mex: vscode_languageserver_1.CompletionItemKind.Function,
    mdlFile: vscode_languageserver_1.CompletionItemKind.Function,
    slxFile: vscode_languageserver_1.CompletionItemKind.Function,
    slxpFile: vscode_languageserver_1.CompletionItemKind.Function,
    sscFile: vscode_languageserver_1.CompletionItemKind.Function,
    sscpFile: vscode_languageserver_1.CompletionItemKind.Function,
    sfxFile: vscode_languageserver_1.CompletionItemKind.Class,
    folder: vscode_languageserver_1.CompletionItemKind.Folder,
    logical: vscode_languageserver_1.CompletionItemKind.Value,
    function: vscode_languageserver_1.CompletionItemKind.Function,
    filename: vscode_languageserver_1.CompletionItemKind.File,
    localFunction: vscode_languageserver_1.CompletionItemKind.Function,
    fieldname: vscode_languageserver_1.CompletionItemKind.Field,
    username: vscode_languageserver_1.CompletionItemKind.Text,
    variable: vscode_languageserver_1.CompletionItemKind.Variable,
    feature: vscode_languageserver_1.CompletionItemKind.Text,
    cellString: vscode_languageserver_1.CompletionItemKind.Value,
    class: vscode_languageserver_1.CompletionItemKind.Class,
    package: vscode_languageserver_1.CompletionItemKind.Module,
    property: vscode_languageserver_1.CompletionItemKind.Property,
    method: vscode_languageserver_1.CompletionItemKind.Method,
    enumeration: vscode_languageserver_1.CompletionItemKind.EnumMember,
    messageId: vscode_languageserver_1.CompletionItemKind.Text,
    keyword: vscode_languageserver_1.CompletionItemKind.Keyword,
    attribute: vscode_languageserver_1.CompletionItemKind.Keyword,
    codeSnippet: vscode_languageserver_1.CompletionItemKind.Snippet
};
/**
 * Handles requests for completion-related features.
 * Currently, this handles auto-completion as well as function signature help.
 */
class CompletionSupportProvider {
    constructor(matlabLifecycleManager) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.REQUEST_CHANNEL = '/matlabls/completions/request';
        this.RESPONSE_CHANNEL = '/matlabls/completions/response';
    }
    /**
     * Handles a request for auto-completion choices.
     *
     * @param params Parameters from the onCompletion request
     * @param documentManager The text document manager
     * @returns An array of possible completions
     */
    handleCompletionRequest(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = documentManager.get(params.textDocument.uri);
            if (doc == null) {
                return vscode_languageserver_1.CompletionList.create();
            }
            const completionData = yield this.retrieveCompletionData(doc, params.position);
            return this.parseCompletionItems(completionData);
        });
    }
    /**
     * Handles a request for function signature help.
     *
     * @param params Parameters from the onSignatureHelp request
     * @param documentManager The text document manager
     * @returns The signature help, or null if no signature help is available
     */
    handleSignatureHelpRequest(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = documentManager.get(params.textDocument.uri);
            if (doc == null) {
                return null;
            }
            const completionData = yield this.retrieveCompletionData(doc, params.position);
            return this.parseSignatureHelp(completionData);
        });
    }
    /**
     * Retrieves raw completion data from MATLAB.
     *
     * @param doc The text document
     * @param position The cursor position in the document
     * @returns The raw completion data
     */
    retrieveCompletionData(doc, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const docUri = doc.uri;
            const code = doc.getText();
            const fileName = vscode_uri_1.URI.parse(docUri).fsPath;
            const cursorPosition = doc.offsetAt(position);
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            if (matlabConnection == null) {
                return {};
            }
            return yield new Promise(resolve => {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    resolve(message);
                });
                matlabConnection.publish(this.REQUEST_CHANNEL, {
                    code,
                    fileName,
                    cursorPosition,
                    channelId
                });
            });
        });
    }
    /**
     * Parses the raw completion data to extract possible auto-completions.
     *
     * @param completionData The raw completion data
     * @returns A list of completion items
     */
    parseCompletionItems(completionData) {
        var _a, _b;
        const completionItems = [];
        const completionsMap = new Map();
        // Gather completions from top-level object. This should find function completions.
        this.gatherCompletions(completionData, completionsMap);
        // Gather completions from each signature. This should find function argument completions.
        let signatures = completionData.signatures;
        if (signatures != null) {
            signatures = Array.isArray(signatures) ? signatures : [signatures];
            signatures.forEach(signature => {
                let inputArguments = signature.inputArguments;
                if (inputArguments == null) {
                    return;
                }
                inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments];
                inputArguments.forEach(inputArgument => {
                    this.gatherCompletions(inputArgument, completionsMap);
                });
            });
        }
        let index = 0;
        completionsMap.forEach((completionData, completionName) => {
            // Preserve the sorting from MATLAB
            const sortText = String(index).padStart(10, '0');
            const completionItem = vscode_languageserver_1.CompletionItem.create(completionName);
            completionItem.kind = completionData.kind;
            completionItem.detail = completionData.doc;
            completionItem.data = index++;
            completionItem.sortText = sortText;
            if (completionData.kind === vscode_languageserver_1.CompletionItemKind.Snippet) {
                completionItem.insertText = completionData.insertText;
                completionItem.insertTextFormat = vscode_languageserver_1.InsertTextFormat.Snippet;
            }
            completionItems.push(completionItem);
        });
        return vscode_languageserver_1.CompletionList.create(completionItems, (_b = (_a = completionData.widgetData) === null || _a === void 0 ? void 0 : _a.truncated) !== null && _b !== void 0 ? _b : false);
    }
    /**
     * Parses raw completion and argument data and stores info about possible completions in the provided map.
     *
     * @param completionDataObj Raw completion or argument data
     * @param completionMap A map in which to store info about possible completions
     */
    gatherCompletions(completionDataObj, completionMap) {
        var _a;
        let choices = (_a = completionDataObj.widgetData) === null || _a === void 0 ? void 0 : _a.choices;
        if (choices == null) {
            return;
        }
        choices = Array.isArray(choices) ? choices : [choices];
        choices = this.filterSnippetChoices(choices);
        choices.forEach(choice => {
            var _a, _b, _c, _d, _e;
            let completion = choice.completion;
            let isPath = false;
            switch (choice.matchType) {
                case 'folder':
                case 'filename':
                    // For files and folders, the completion is the full path whereas the displayString is the path to be added
                    completion = (_a = choice.displayString) !== null && _a !== void 0 ? _a : '';
                    isPath = true;
                    break;
                case 'messageId':
                    // Remove quotes from completion
                    completion = ((_b = choice.displayString) !== null && _b !== void 0 ? _b : '').replace(/['"]/g, '');
                    break;
                case 'codeSnippet':
                    completion = (_c = choice.displayString) !== null && _c !== void 0 ? _c : '';
                    break;
            }
            if (choice.matchType !== 'codeSnippet') {
                const dotIdx = choice.completion.lastIndexOf('.');
                if (dotIdx > 0 && !isPath) {
                    completion = completion.slice(dotIdx + 1);
                }
            }
            completionMap.set(completion, {
                kind: (_d = MatlabCompletionToKind[choice.matchType]) !== null && _d !== void 0 ? _d : vscode_languageserver_1.CompletionItemKind.Function,
                doc: choice.purpose,
                insertText: (_e = choice.completion) !== null && _e !== void 0 ? _e : ''
            });
        });
    }
    /**
     * Parses the raw completion data to extract function signature help.
     *
     * @param completionData The raw completion data
     * @returns The signature help, or null if no signature help is available
     */
    parseSignatureHelp(completionData) {
        let signatureData = completionData.signatures;
        if (signatureData == null) {
            return null;
        }
        signatureData = Array.isArray(signatureData) ? signatureData : [signatureData];
        const signatureHelp = {
            activeParameter: 0,
            activeSignature: 0,
            signatures: []
        };
        // Parse each signature
        signatureData.forEach(sigData => {
            const params = [];
            // Handle function inputs
            const argNames = [];
            let inputArguments = sigData.inputArguments;
            if (inputArguments == null) {
                return;
            }
            inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments];
            inputArguments.forEach((inputArg, index) => {
                let paramDoc = '';
                if (inputArg.purpose != null) {
                    paramDoc += inputArg.purpose;
                }
                if (inputArg.valueSummary != null) {
                    paramDoc += (paramDoc.length > 0 ? '\n' : '') + inputArg.valueSummary;
                }
                const paramDocArgs = paramDoc.length > 0 ? [paramDoc] : [];
                params.push(vscode_languageserver_1.ParameterInformation.create(inputArg.name, ...paramDocArgs));
                argNames.push(inputArg.name);
                if (inputArg.status === 'presenting') {
                    signatureHelp.activeParameter = index;
                }
            });
            let argStr = '';
            if (argNames.length === 1) {
                argStr = argNames[0];
            }
            else if (argNames.length > 1) {
                argStr = argNames.join(', ');
            }
            // Handle function outputs
            let outStr = '';
            let outputArguments = sigData.outputArguments;
            if (outputArguments != null) {
                outputArguments = Array.isArray(outputArguments) ? outputArguments : [outputArguments];
                outStr = outputArguments.length === 1
                    ? outputArguments[0].name
                    : `[${outputArguments.map(output => output.name).join(', ')}]`;
                outStr += ' = ';
            }
            const id = `${outStr}${sigData.functionName}(${argStr})`;
            signatureHelp.signatures.push(vscode_languageserver_1.SignatureInformation.create(id, undefined, ...params));
        });
        return signatureHelp;
    }
    /**
     * Filters out the snippet choices from the list of choices based on the configured snippet ignore list.
     *
     * @param choices The list of completion choices to filter
     * @returns The list of completion choices with snippet choices filtered out based on the configured snippet ignore list
     */
    filterSnippetChoices(choices) {
        // Get the snippet ignore list from the configuration manager
        const snippetIgnoreList = ConfigurationManager_1.default.getArgument(ConfigurationManager_1.Argument.SnippetIgnoreList).split(';');
        return choices.filter(choice => {
            return choice.matchType !== 'codeSnippet' || (choice.displayString !== undefined && !snippetIgnoreList.includes(choice.displayString));
        });
    }
}
exports["default"] = CompletionSupportProvider;


/***/ }),

/***/ "./src/providers/folding/FoldingSupportProvider.ts":
/*!*********************************************************!*\
  !*** ./src/providers/folding/FoldingSupportProvider.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
class FoldingSupportProvider {
    constructor(matlabLifecycleManager) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.REQUEST_CHANNEL = '/matlabls/foldDocument/request';
        this.RESPONSE_CHANNEL = '/matlabls/foldDocument/response';
    }
    handleFoldingRangeRequest(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const docToFold = documentManager.get(params.textDocument.uri);
            if (docToFold == null) {
                return null;
            }
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            const isMatlabAvailable = (matlabConnection != null);
            const matlabRelease = this.matlabLifecycleManager.getMatlabRelease();
            // check for connection and release
            if (!isMatlabAvailable || (matlabRelease == null) || (matlabRelease < 'R2024b')) {
                return null;
            }
            const fileName = vscode_uri_1.URI.parse(docToFold.uri).fsPath;
            const code = docToFold.getText();
            const frArray = yield this.getFoldingRangesFromMatlab(code, fileName, matlabConnection);
            const foldingRanges = this.processFoldingRanges(frArray);
            return foldingRanges;
        });
    }
    /**
     * Gets folding ranges from MATLAB.
     *
     * @param code The code in the file
     * @param fileName The file's name
     * @param matlabConnection The connection to MATLAB
     * @returns An array of line numbers
     */
    getFoldingRangesFromMatlab(code, fileName, matlabConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise(resolve => {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    resolve(message);
                });
                matlabConnection.publish(this.REQUEST_CHANNEL, {
                    code,
                    fileName,
                    channelId
                });
            });
        });
    }
    /**
     * Processes folding range data from MATLAB.
     *
     * @param frArray An array of line numbers from MATLAB
     * @returns An array of FoldingRanges
     */
    processFoldingRanges(frArray) {
        const fRangeArray = [];
        for (let i = 0; i < frArray.length; i = i + 2) {
            const fRange = vscode_languageserver_1.FoldingRange.create(frArray[i] - 1, frArray[i + 1] - 1);
            fRangeArray.push(fRange);
        }
        return fRangeArray;
    }
}
exports["default"] = FoldingSupportProvider;


/***/ }),

/***/ "./src/providers/formatting/FormatSupportProvider.ts":
/*!***********************************************************!*\
  !*** ./src/providers/formatting/FormatSupportProvider.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const LifecycleNotificationHelper_1 = __importDefault(__webpack_require__(/*! ../../lifecycle/LifecycleNotificationHelper */ "./src/lifecycle/LifecycleNotificationHelper.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ../../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const TextDocumentUtils = __importStar(__webpack_require__(/*! ../../utils/TextDocumentUtils */ "./src/utils/TextDocumentUtils.ts"));
/**
 * Handles requests for format-related features.
 * Currently, this handles formatting the entire document. In the future, this may be expanded to
 * include formatting a range witin the documemt.
 */
class FormatSupportProvider {
    constructor(matlabLifecycleManager) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.REQUEST_CHANNEL = '/matlabls/formatDocument/request';
        this.RESPONSE_CHANNEL = '/matlabls/formatDocument/response';
    }
    /**
     * Handles a request for document formatting.
     *
     * @param params Parameters from the onDocumentFormatting request
     * @param documentManager The text document manager
     * @param connection The language server connection
     * @returns An array of text edits required for the formatting operation, or null if the operation cannot be performed
     */
    handleDocumentFormatRequest(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const docToFormat = documentManager.get(params.textDocument.uri);
            if (docToFormat == null) {
                return null;
            }
            return yield this.formatDocument(docToFormat, params.options);
        });
    }
    /**
     * Determines the edits required to format the given document.
     *
     * @param doc The document being formatted
     * @param options The formatting options
     * @returns An array of text edits required to format the document
     */
    formatDocument(doc, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // For format, we try to instantiate MATLAB if it is not already running
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection(true);
            // If MATLAB is not available, no-op
            if (matlabConnection == null) {
                LifecycleNotificationHelper_1.default.notifyMatlabRequirement();
                (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.FormatDocument, TelemetryUtils_1.ActionErrorConditions.MatlabUnavailable);
                return [];
            }
            return yield new Promise(resolve => {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    const newCode = message.data;
                    const endRange = TextDocumentUtils.getRangeUntilLineEnd(doc, doc.lineCount - 1, 0);
                    const edit = vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), endRange.end), newCode);
                    (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.FormatDocument);
                    resolve([edit]);
                });
                matlabConnection.publish(this.REQUEST_CHANNEL, {
                    data: doc.getText(),
                    insertSpaces: options.insertSpaces,
                    tabSize: options.tabSize,
                    channelId
                });
            });
        });
    }
}
exports["default"] = FormatSupportProvider;


/***/ }),

/***/ "./src/providers/linting/LintingSupportProvider.ts":
/*!*********************************************************!*\
  !*** ./src/providers/linting/LintingSupportProvider.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
const ConfigurationManager_1 = __importDefault(__webpack_require__(/*! ../../lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
const Logger_1 = __importDefault(__webpack_require__(/*! ../../logging/Logger */ "./src/logging/Logger.ts"));
const fs = __importStar(__webpack_require__(/*! fs/promises */ "fs/promises"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const which = __webpack_require__(/*! which */ "./node_modules/which/which.js");
const ExecuteCommandProvider_1 = __webpack_require__(/*! ../lspCommands/ExecuteCommandProvider */ "./src/providers/lspCommands/ExecuteCommandProvider.ts");
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ../../ClientConnection */ "./src/ClientConnection.ts"));
const LINT_DELAY = 500; // Delay (in ms) after keystroke before attempting to lint the document
// Lint result parsing constants
const LINT_MESSAGE_REGEX = /L (\d+) \(C (\d+)-?(\d*)\): ([\dA-Za-z]+): ML(\d): (.*)/;
const FIX_FLAG_REGEX = /\(CAN FIX\)/;
const FIX_MESSAGE_REGEX = /----FIX MESSAGE<\w+>\s+<([^>]*)>/;
const FIX_CHANGE_REGEX = /----CHANGE MESSAGE L (\d+) \(C (\d+)\);\s+L (\d+) \(C (\d+)\):\s+<([^>]*)>/;
/**
 * Handles requests for linting-related features.
 * Currently, this handles displaying diagnostics, providing quick-fixes,
 * and suppressing diagnostics.
 *
 * Note: When MATLAB is not connected, diagnostics are only updated when
 * the file is saved and suppressing warnings is not available.
 */
class LintingSupportProvider {
    constructor(matlabLifecycleManager) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.LINTING_REQUEST_CHANNEL = '/matlabls/linting/request';
        this.LINTING_RESPONSE_CHANNEL = '/matlabls/linting/response';
        this.SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL = '/matlabls/linting/suppressdiagnostic/request';
        this.SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL = '/matlabls/linting/suppressdiagnostic/response';
        this.SEVERITY_MAP = {
            0: vscode_languageserver_1.DiagnosticSeverity.Information,
            1: vscode_languageserver_1.DiagnosticSeverity.Warning,
            2: vscode_languageserver_1.DiagnosticSeverity.Error,
            3: vscode_languageserver_1.DiagnosticSeverity.Error,
            4: vscode_languageserver_1.DiagnosticSeverity.Error
        };
        this._pendingFilesToLint = new Map();
        this._availableCodeActions = new Map();
    }
    /**
     * Queues a document to be linted. This handles debouncing so
     * that linting is not performed on every keystroke.
     *
     * @param textDocument The document to be linted
     * @param connection The language server connection
     */
    queueLintingForDocument(textDocument) {
        const uri = textDocument.uri;
        this.clearTimerForDocumentUri(uri);
        this._pendingFilesToLint.set(uri, setTimeout(() => {
            void this.lintDocument(textDocument);
        }, LINT_DELAY) // Specify timeout for debouncing, to avoid re-linting every keystroke while a user types
        );
    }
    /**
     * Lints the document and displays diagnostics.
     *
     * @param textDocument The document being linted
     * @param connection The language server connection
     */
    lintDocument(textDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = textDocument.uri;
            this.clearTimerForDocumentUri(uri);
            this.clearCodeActionsForDocumentUri(uri);
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            const isMatlabAvailable = matlabConnection != null;
            const isMFile = this.isMFile(uri);
            const fileName = isMFile ? vscode_uri_1.URI.parse(uri).fsPath : "untitled.m";
            let lintData = [];
            const code = textDocument.getText();
            const analysisLimit = (yield ConfigurationManager_1.default.getConfiguration()).maxFileSizeForAnalysis;
            if (analysisLimit > 0 && code.length > analysisLimit) {
                this.clearDiagnosticsForDocument(textDocument); // Clear document to handle setting changing value
                return;
            }
            if (isMatlabAvailable) {
                // Use MATLAB-based linting for better results and fixes
                lintData = yield this.getLintResultsFromMatlab(code, fileName, matlabConnection);
            }
            else if (isMFile) {
                // Try to use mlint executable for basic linting
                lintData = yield this.getLintResultsFromExecutable(fileName);
            }
            const lintResults = this.processLintResults(uri, lintData);
            const diagnostics = lintResults.diagnostics;
            // Store code actions
            this._availableCodeActions.set(uri, lintResults.codeActions);
            // Report diagnostics
            void ClientConnection_1.default.getConnection().sendDiagnostics({
                uri,
                diagnostics
            });
        });
    }
    clearDiagnosticsForDocument(textDocument) {
        void ClientConnection_1.default.getConnection().sendDiagnostics({
            uri: textDocument.uri,
            diagnostics: []
        });
    }
    /**
     * Handles a request for code actions.
     *
     * @param params Parameters from the onCodeAction request
     */
    handleCodeActionRequest(params) {
        var _a;
        const uri = params.textDocument.uri;
        const actions = (_a = this._availableCodeActions.get(uri)) !== null && _a !== void 0 ? _a : [];
        let codeActions = [...actions];
        // Filter to find unique diagnostics
        codeActions = codeActions.filter(action => {
            var _a;
            const diagnostic = (_a = action.diagnostics) === null || _a === void 0 ? void 0 : _a[0];
            if (diagnostic == null) {
                return false;
            }
            return params.context.diagnostics.some(diag => this.isSameDiagnostic(diagnostic, diag));
        });
        if (!this.matlabLifecycleManager.isMatlabConnected()) {
            // Cannot suppress warnings without MATLAB
            return codeActions;
        }
        // Add suppression commands
        const diagnostics = params.context.diagnostics;
        const commands = [];
        diagnostics.forEach(diagnostic => {
            // Don't allow suppressing errors
            if (diagnostic.severity === vscode_languageserver_1.DiagnosticSeverity.Error) {
                return;
            }
            const diagnosticCode = diagnostic.code;
            // Add suppress-on-line option
            commands.push(vscode_languageserver_1.Command.create(`Suppress message ${diagnosticCode} on this line`, ExecuteCommandProvider_1.MatlabLSCommands.MLINT_SUPPRESS_ON_LINE, {
                id: diagnosticCode,
                range: diagnostic.range,
                uri
            }));
            // Add suppress-in-file option
            commands.push(vscode_languageserver_1.Command.create(`Suppress message ${diagnosticCode} in this file`, ExecuteCommandProvider_1.MatlabLSCommands.MLINT_SUPPRESS_IN_FILE, {
                id: diagnosticCode,
                range: diagnostic.range,
                uri
            }));
        });
        commands.forEach(command => {
            // Add suppression actions as Commands to be processed later.
            codeActions.push(vscode_languageserver_1.CodeAction.create(command.title, command, vscode_languageserver_1.CodeActionKind.QuickFix));
        });
        return codeActions;
    }
    /**
     * Attempt to suppress a diagnostic.
     *
     * @param textDocument The document
     * @param range The range of the diagnostic being suppress
     * @param id The diagnostic's ID
     * @param shouldSuppressThroughoutFile Whether or not to suppress the diagnostic throughout the entire file
     */
    suppressDiagnostic(textDocument, range, id, shouldSuppressThroughoutFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection();
            if (matlabConnection == null) {
                return;
            }
            const channelId = matlabConnection.getChannelId();
            const channel = `${this.SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL}/${channelId}`;
            const responseSub = matlabConnection.subscribe(channel, message => {
                matlabConnection.unsubscribe(responseSub);
                const suppressionEdits = message.suppressionEdits;
                const edit = {
                    changes: {
                        [textDocument.uri]: suppressionEdits
                    },
                    documentChanges: [
                        vscode_languageserver_1.TextDocumentEdit.create(vscode_languageserver_1.VersionedTextDocumentIdentifier.create(textDocument.uri, textDocument.version), suppressionEdits)
                    ]
                };
                void ClientConnection_1.default.getConnection().workspace.applyEdit(edit);
            });
            matlabConnection.publish(this.SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL, {
                code: textDocument.getText(),
                diagnosticId: id,
                line: range.start.line + 1,
                suppressInFile: shouldSuppressThroughoutFile,
                channelId
            });
        });
    }
    /**
     * Clears any active linting timers for the provided document URI.
     *
     * @param uri The document URI
     */
    clearTimerForDocumentUri(uri) {
        const timerId = this._pendingFilesToLint.get(uri);
        if (timerId != null) {
            clearTimeout(timerId);
            this._pendingFilesToLint.delete(uri);
        }
    }
    /**
     * Clears any cached code actions for the provided document URI.
     *
     * @param uri The document URI
     */
    clearCodeActionsForDocumentUri(uri) {
        this._availableCodeActions.set(uri, []);
    }
    /**
     * Gets raw linting data from MATLAB.
     *
     * @param code The code to be linted
     * @param fileName The file's name
     * @param matlabConnection The connection to MATLAB
     * @returns Raw lint data for the code
     */
    getLintResultsFromMatlab(code, fileName, matlabConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise(resolve => {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.LINTING_RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    resolve(message.lintData);
                });
                matlabConnection.publish(this.LINTING_REQUEST_CHANNEL, {
                    code,
                    fileName,
                    channelId
                });
            });
        });
    }
    /**
     * Gets raw linting data using the mlint executable.
     *
     * @param fileName The file's name
     * @returns Raw lint data for the file
     */
    getLintResultsFromExecutable(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const mlintExecutable = yield this.getMlintExecutable();
            if (mlintExecutable == null) {
                // Unable to locate executable
                return [];
            }
            const mlintArgs = [
                fileName,
                '-id',
                '-severity',
                '-fix'
            ];
            return yield new Promise(resolve => {
                try {
                    (0, child_process_1.execFile)(mlintExecutable, mlintArgs, (error, stdout, stderr) => {
                        var _a;
                        if (error != null) {
                            Logger_1.default.error(`Error from mlint executable: ${error.message}\n${(_a = error.stack) !== null && _a !== void 0 ? _a : ''}`);
                            resolve([]);
                        }
                        resolve(stderr.split('\n')); // For some reason, mlint appears to output on stderr instead of stdout
                    });
                }
                catch (e) {
                    Logger_1.default.error(`Error executing mlint executable at ${mlintExecutable}`);
                }
            });
        });
    }
    /**
     * Attempts to determine the path to the mlint executable.
     *
     * @returns The path to the mlint executable, or null if it cannot be determined
     */
    getMlintExecutable() {
        return __awaiter(this, void 0, void 0, function* () {
            const platformDirs = this.getBinDirectoriesForPlatform();
            if (platformDirs == null) {
                // Unable to determine platform
                return null;
            }
            const matlabInstallPath = (yield ConfigurationManager_1.default.getConfiguration()).installPath.trim();
            let binPath = '';
            if (matlabInstallPath !== '') {
                // Find the executable from the root installation directory
                binPath = path.normalize(path.join(matlabInstallPath, 'bin'));
            }
            else {
                // Try to find the executable based on the location of the `matlab` executable
                try {
                    let resolvedPath = yield which('matlab');
                    if (resolvedPath !== '') {
                        resolvedPath = yield fs.realpath(resolvedPath);
                        binPath = path.dirname(resolvedPath);
                    }
                }
                catch (_a) {
                    // `matlab` not found on path - no action
                }
            }
            if (binPath === '') {
                return null;
            }
            for (const platformDir of platformDirs) {
                const mlintExecutablePath = path.normalize(path.join(binPath, platformDir, process.platform === 'win32' ? 'mlint.exe' : 'mlint'));
                try {
                    yield fs.access(mlintExecutablePath);
                    return mlintExecutablePath; // return the first existing path
                }
                catch (_b) {
                    // continue to the next iteration
                }
            }
            Logger_1.default.error(`Error finding mlint executable in ${binPath}`);
            return null;
        });
    }
    /**
     * Gets the name of platform-specific binary directory.
     *
     * @returns The binary directory name, or null if the platform is not recognized
     */
    getBinDirectoriesForPlatform() {
        switch (process.platform) {
            case 'win32':
                return ['win64'];
            case 'darwin':
                return ['maci64', 'maca64'];
            case 'linux':
                return ['glnxa64'];
            default:
                return null;
        }
    }
    /**
     * Parses diagnostics and code actions from the raw lint data.
     *
     * @param uri THe linted document's URI
     * @param lintData The lint data for the document
     * @returns Parsed diagnostics and code actions
     */
    processLintResults(uri, lintData) {
        const diagnostics = [];
        const codeActions = [];
        let dataIndex = 0;
        while (dataIndex < lintData.length) {
            const message = lintData[dataIndex++];
            if (message === '') {
                continue;
            }
            // Parse lint message
            // Diagnostics will be reported with a line like the following:
            //     L {lineNumber} (C {columnNumber}): {diagnosticId}: ML{severity}: {diagnosticMessage} (CAN FIX)
            // If the diagnostic cannot be fixed, the '(CAN FIX)' will not be present
            const parsedLine = message.match(LINT_MESSAGE_REGEX);
            if (parsedLine == null) {
                continue;
            }
            const line = Math.max(parseInt(parsedLine[1]) - 1, 0);
            const startColumn = Math.max(parseInt(parsedLine[2]) - 1, 0);
            const endColumn = (parsedLine[3] !== '') ? parseInt(parsedLine[3]) : startColumn + 1; // +1 for open interval
            const id = parsedLine[4];
            const severity = this.SEVERITY_MAP[parsedLine[5]];
            let lintMessage = parsedLine[6];
            // Check if there are available fixes for this diagnostic
            const fixMatch = lintMessage.match(FIX_FLAG_REGEX);
            if (fixMatch != null) {
                lintMessage = lintMessage.replace(FIX_FLAG_REGEX, '').trim();
            }
            const diagnostic = vscode_languageserver_1.Diagnostic.create(vscode_languageserver_1.Range.create(line, startColumn, line, endColumn), lintMessage, severity, id, 'MATLAB');
            diagnostics.push(diagnostic);
            // Parse fix data for this diagnostic, if it exists
            if (fixMatch == null) {
                continue;
            }
            const fixInfo = lintData[dataIndex++];
            // Parse fix message
            // Diagnostic fixes will be reported with lines like the following:
            //     ----FIX MESSAGE<{diagnosticFixId}> <{message}>
            //     ----CHANGE MESSAGE L {lineNumber} (C {columnNumber});  L {lineNumber} (C {columnNumber}):  <{text}>
            const fixMsgMatch = fixInfo.match(FIX_MESSAGE_REGEX);
            if (fixMsgMatch == null) {
                continue;
            }
            const fixMsg = fixMsgMatch[1];
            // Gather fixes
            const changes = {
                [uri]: []
            };
            const wsEdit = {
                changes
            };
            while (dataIndex < lintData.length) {
                const actionMsg = lintData[dataIndex];
                const actionMsgMatch = actionMsg.match(FIX_CHANGE_REGEX);
                if (actionMsgMatch == null) {
                    break;
                }
                // Consume, since we matched
                dataIndex++;
                const startLine = parseInt(actionMsgMatch[1]) - 1;
                const startColumn = parseInt(actionMsgMatch[2]) - 1;
                const endLine = parseInt(actionMsgMatch[3]) - 1;
                const endColumn = parseInt(actionMsgMatch[4]);
                const replaceText = actionMsgMatch[5];
                // Translate data into edits
                let edit;
                if (startLine === endLine && startColumn === endColumn) {
                    // 1. Insert
                    edit = vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(startLine, startColumn + 1), replaceText);
                }
                else if (replaceText.length === 0) {
                    // 2. Delete
                    edit = vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(startLine, startColumn, endLine, endColumn));
                }
                else {
                    // 3. Replace
                    edit = vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(startLine, startColumn, endLine, endColumn), replaceText);
                }
                changes[uri].push(edit);
            }
            // If a fix has been processed, create a code action
            if (changes[uri].length > 0) {
                const action = vscode_languageserver_1.CodeAction.create(fixMsg, wsEdit, vscode_languageserver_1.CodeActionKind.QuickFix);
                action.diagnostics = [diagnostics[diagnostics.length - 1]];
                codeActions.push(action);
            }
        }
        return {
            diagnostics,
            codeActions
        };
    }
    /**
     * Determines whether two diagnostics are equivalent.
     *
     * @param a The first diagnostic
     * @param b The second diagnostic
     * @returns True if the diagnostics are the same. False otherwise.
     */
    isSameDiagnostic(a, b) {
        return a.code === b.code &&
            a.message === b.message &&
            a.range.start.character === b.range.start.character &&
            a.range.start.line === b.range.start.line &&
            a.range.end.character === b.range.end.character &&
            a.range.end.line === b.range.end.line &&
            a.severity === b.severity &&
            a.source === b.source;
    }
    /**
     * Checks if the given URI corresponds to a MATLAB M-file.
     *
     * @param uri - The URI of the file to check.
     * @returns True if the file is a MATLAB M-file (.m), false otherwise.
     */
    isMFile(uri) {
        return vscode_uri_1.URI.parse(uri).fsPath.endsWith(".m");
    }
}
exports["default"] = LintingSupportProvider;


/***/ }),

/***/ "./src/providers/lspCommands/ExecuteCommandProvider.ts":
/*!*************************************************************!*\
  !*** ./src/providers/lspCommands/ExecuteCommandProvider.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatlabLSCommands = void 0;
exports.MatlabLSCommands = {
    MLINT_SUPPRESS_ON_LINE: 'matlabls.lint.suppress.line',
    MLINT_SUPPRESS_IN_FILE: 'matlabls.lint.suppress.file'
};
/**
 * Handles requests to execute commands
 */
class ExecuteCommandProvider {
    constructor(lintingSupportProvider) {
        this.lintingSupportProvider = lintingSupportProvider;
    }
    /**
     * Handles command execution requests.
     *
     * @param params Parameters from the onExecuteCommand request
     * @param documentManager The text document manager
     * @param connection The language server connection
     */
    handleExecuteCommand(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (params.command) {
                case exports.MatlabLSCommands.MLINT_SUPPRESS_ON_LINE:
                case exports.MatlabLSCommands.MLINT_SUPPRESS_IN_FILE:
                    void this.handleLintingSuppression(params, documentManager);
            }
        });
    }
    /**
     * Handles command to suppress a linting diagnostic.
     *
     * @param params Parameters from the onExecuteCommand request
     * @param documentManager The text document manager
     * @param connection The language server connection
     */
    handleLintingSuppression(params, documentManager) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = (_a = params.arguments) === null || _a === void 0 ? void 0 : _a[0];
            const range = args.range;
            const uri = args.uri;
            const doc = documentManager.get(uri);
            if (doc == null) {
                return;
            }
            const shouldSuppressThroughoutFile = params.command === exports.MatlabLSCommands.MLINT_SUPPRESS_IN_FILE;
            void this.lintingSupportProvider.suppressDiagnostic(doc, range, args.id, shouldSuppressThroughoutFile);
        });
    }
}
exports["default"] = ExecuteCommandProvider;


/***/ }),

/***/ "./src/providers/navigation/NavigationSupportProvider.ts":
/*!***************************************************************!*\
  !*** ./src/providers/navigation/NavigationSupportProvider.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const FileInfoIndex_1 = __importDefault(__webpack_require__(/*! ../../indexing/FileInfoIndex */ "./src/indexing/FileInfoIndex.ts"));
const LifecycleNotificationHelper_1 = __importDefault(__webpack_require__(/*! ../../lifecycle/LifecycleNotificationHelper */ "./src/lifecycle/LifecycleNotificationHelper.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ../../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const ExpressionUtils_1 = __webpack_require__(/*! ../../utils/ExpressionUtils */ "./src/utils/ExpressionUtils.ts");
const SymbolSearchService_1 = __importStar(__webpack_require__(/*! ../../indexing/SymbolSearchService */ "./src/indexing/SymbolSearchService.ts"));
const NotificationService_1 = __importStar(__webpack_require__(/*! ../../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
class NavigationSupportProvider {
    constructor(matlabLifecycleManager, indexer, documentIndexer, pathResolver) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.indexer = indexer;
        this.documentIndexer = documentIndexer;
        this.pathResolver = pathResolver;
        /**
         * Caches document symbols for URIs to deal with the case when indexing
         * temporarily fails while the user is in the middle of an edit. We might
         * consider moving logic like this into the indexer logic later as clearing
         * out index data in the middle of an edit will have other ill effects.
         */
        this._documentSymbolCache = new Map();
    }
    /**
     * Handles requests for definitions or references.
     *
     * @param params Parameters for the definition or references request
     * @param documentManager The text document manager
     * @param requestType The type of request (definition or references)
     * @returns An array of locations
     */
    handleDefOrRefRequest(params, documentManager, requestType) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection(true);
            if (matlabConnection == null) {
                LifecycleNotificationHelper_1.default.notifyMatlabRequirement();
                (0, SymbolSearchService_1.reportTelemetry)(requestType, TelemetryUtils_1.ActionErrorConditions.MatlabUnavailable);
                return [];
            }
            const uri = params.textDocument.uri;
            const textDocument = documentManager.get(uri);
            if (textDocument == null) {
                (0, SymbolSearchService_1.reportTelemetry)(requestType, 'No document');
                return [];
            }
            // Find ID for which to find the definition or references
            const expression = (0, ExpressionUtils_1.getExpressionAtPosition)(textDocument, params.position);
            if (expression == null) {
                // No target found
                (0, SymbolSearchService_1.reportTelemetry)(requestType, 'No navigation target');
                return [];
            }
            if (requestType === SymbolSearchService_1.RequestType.Definition) {
                return yield SymbolSearchService_1.default.findDefinition(uri, params.position, expression, matlabConnection, this.pathResolver, this.indexer);
            }
            else {
                return SymbolSearchService_1.default.findReferences(uri, params.position, expression, documentManager, requestType);
            }
        });
    }
    /**
     *
     * @param params Parameters for the document symbol request
     * @param documentManager The text document manager
     * @param requestType The type of request
     * @returns Array of symbols found in the document
     */
    handleDocumentSymbol(params, documentManager, requestType) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Get or wait for the MATLAB connection to handle files opened before MATLAB is ready.
            // We do not want to trigger MATLAB to launch due to the frequency of this callback.
            // However, simply returning [] in this case could cause a delay between MATLAB started
            // and the symbols being identified.
            // eslint-disable-next-line no-async-promise-executor
            const matlabConnection = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (this.matlabLifecycleManager.isMatlabConnected()) {
                    resolve(yield this.matlabLifecycleManager.getMatlabConnection());
                }
                else {
                    // MATLAB is not already connected, so wait until it has connected to
                    // resolve the connection.
                    this.matlabLifecycleManager.eventEmitter.once('connected', () => __awaiter(this, void 0, void 0, function* () {
                        resolve(yield this.matlabLifecycleManager.getMatlabConnection());
                    }));
                }
            }));
            if (matlabConnection == null) {
                (0, SymbolSearchService_1.reportTelemetry)(requestType, TelemetryUtils_1.ActionErrorConditions.MatlabUnavailable);
                return [];
            }
            const uri = params.textDocument.uri;
            const textDocument = documentManager.get(uri);
            if (textDocument == null) {
                (0, SymbolSearchService_1.reportTelemetry)(requestType, 'No document');
                return [];
            }
            // Ensure document index is up to date
            yield this.documentIndexer.ensureDocumentIndexIsUpdated(textDocument);
            const codeData = FileInfoIndex_1.default.codeDataCache.get(uri);
            if (codeData == null) {
                (0, SymbolSearchService_1.reportTelemetry)(requestType, 'No code data');
                return [];
            }
            // Result symbols in documented
            const result = [];
            // Avoid duplicates coming from different data sources
            const visitedRanges = new Set();
            /**
             * Push symbol info to result set
             */
            function pushSymbol(name, kind, symbolRange) {
                if (!visitedRanges.has(symbolRange)) {
                    result.push(vscode_languageserver_1.SymbolInformation.create(name, kind, symbolRange, uri));
                    visitedRanges.add(symbolRange);
                }
            }
            if (codeData.isMainClassDefDocument && codeData.classInfo != null) {
                const classInfo = codeData.classInfo;
                if (codeData.classInfo.range != null) {
                    pushSymbol(classInfo.name, vscode_languageserver_1.SymbolKind.Class, codeData.classInfo.range);
                }
                classInfo.methods.forEach((info, name) => pushSymbol(name, vscode_languageserver_1.SymbolKind.Method, info.range));
                classInfo.enumerations.forEach((info, name) => pushSymbol(name, vscode_languageserver_1.SymbolKind.EnumMember, info.range));
                classInfo.properties.forEach((info, name) => pushSymbol(name, vscode_languageserver_1.SymbolKind.Property, info.range));
            }
            codeData.functions.forEach((info, name) => pushSymbol(name, info.isClassMethod ? vscode_languageserver_1.SymbolKind.Method : vscode_languageserver_1.SymbolKind.Function, info.range));
            codeData.sections.forEach((range, title) => {
                range.forEach(range => {
                    pushSymbol(title, vscode_languageserver_1.SymbolKind.Module, range);
                });
            });
            /**
             * Handle a case when the indexer fails due to the user being in the middle of an edit.
             * Here the documentSymbol cache has some symbols but the codeData cache has none. So we
             * assume that the user will soon fix their code and just fall back to what we knew for now.
             */
            if (result.length === 0 && codeData.errorMessage !== undefined) {
                const cached = (_a = this._documentSymbolCache.get(uri)) !== null && _a !== void 0 ? _a : result;
                if (cached.length > 0) {
                    return cached;
                }
            }
            this._documentSymbolCache.set(uri, result);
            this._sendSectionRangesForHighlighting(result, uri);
            return result;
        });
    }
    _sendSectionRangesForHighlighting(result, uri) {
        const sections = result.filter(result => result.kind === vscode_languageserver_1.SymbolKind.Module);
        const sectionRanges = [];
        sections.forEach((section) => {
            sectionRanges.push(section.location.range);
        });
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.MatlabSections, { uri, sectionRanges });
    }
}
exports["default"] = NavigationSupportProvider;


/***/ }),

/***/ "./src/providers/navigation/PathResolver.ts":
/*!**************************************************!*\
  !*** ./src/providers/navigation/PathResolver.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_uri_1 = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/umd/index.js");
class PathResolver {
    constructor() {
        this.REQUEST_CHANNEL = '/matlabls/navigation/resolvePath/request';
        this.RESPONSE_CHANNEL = '/matlabls/navigation/resolvePath/response';
    }
    /**
     * Attempts to resolve the given names to the files in which the names are defined.
     * For example, 'MyClass' may be resolved to 'file:///path/to/MyClass.m'.
     *
     * @param names The names which should be resolved to paths
     * @param contextFileUri The file from which the context of the path resolution should be made
     * @param matlabConnection The connection to MATLAB
     *
     * @returns The resolved URIs. Any URIs which could not be determiend are denoted by empty strings.
     */
    resolvePaths(names, contextFileUri, matlabConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            const contextFile = vscode_uri_1.URI.parse(contextFileUri).fsPath;
            return yield new Promise(resolve => {
                const channelId = matlabConnection.getChannelId();
                const channel = `${this.RESPONSE_CHANNEL}/${channelId}`;
                const responseSub = matlabConnection.subscribe(channel, message => {
                    matlabConnection.unsubscribe(responseSub);
                    const resolvedPaths = message.data;
                    // Convert file system paths from MATLAB to URIs
                    const resolvedUris = resolvedPaths.map(resolvedPath => {
                        const filePath = resolvedPath.path;
                        const uri = (filePath === '') ? '' : vscode_uri_1.URI.file(filePath).toString();
                        return {
                            name: resolvedPath.name,
                            uri
                        };
                    });
                    resolve(resolvedUris);
                });
                matlabConnection.publish(this.REQUEST_CHANNEL, {
                    names,
                    contextFile,
                    channelId
                });
            });
        });
    }
}
exports["default"] = PathResolver;


/***/ }),

/***/ "./src/providers/rename/RenameSymbolProvider.ts":
/*!******************************************************!*\
  !*** ./src/providers/rename/RenameSymbolProvider.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
const LifecycleNotificationHelper_1 = __importDefault(__webpack_require__(/*! ../../lifecycle/LifecycleNotificationHelper */ "./src/lifecycle/LifecycleNotificationHelper.ts"));
const TextDocumentUtils_1 = __webpack_require__(/*! ../../utils/TextDocumentUtils */ "./src/utils/TextDocumentUtils.ts");
const FileInfoIndex_1 = __importDefault(__webpack_require__(/*! ../../indexing/FileInfoIndex */ "./src/indexing/FileInfoIndex.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ../../logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const ExpressionUtils_1 = __webpack_require__(/*! ../../utils/ExpressionUtils */ "./src/utils/ExpressionUtils.ts");
const SymbolSearchService_1 = __importStar(__webpack_require__(/*! ../../indexing/SymbolSearchService */ "./src/indexing/SymbolSearchService.ts"));
class RenameSymbolProvider {
    constructor(matlabLifecycleManager, documentIndexer) {
        this.matlabLifecycleManager = matlabLifecycleManager;
        this.documentIndexer = documentIndexer;
    }
    /**
     * Determines if a symbol that can be renamed exists at the specified position.
     *
     * @param params Parameters for the prepare rename request
     * @param documentManager The text document manager
     * @returns A range and placeholder text
     */
    prepareRename(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection(true);
            if (matlabConnection == null) {
                LifecycleNotificationHelper_1.default.notifyMatlabRequirement();
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, TelemetryUtils_1.ActionErrorConditions.MatlabUnavailable);
                return null;
            }
            const uri = params.textDocument.uri;
            const textDocument = documentManager.get(uri);
            if (textDocument == null) {
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, 'No document');
                return null;
            }
            const text = textDocument.getText();
            const offset = textDocument.offsetAt(params.position);
            // Find the start of the expression
            let startOffset = offset;
            while (startOffset > 0 && /\w/.test(text.charAt(startOffset - 1))) {
                startOffset--;
            }
            // Find the end of the expression
            let endOffset = offset;
            while (endOffset < text.length && /\w/.test(text.charAt(endOffset))) {
                endOffset++;
            }
            // Check if an expression exists at the given position
            if (startOffset === endOffset) {
                return null;
            }
            const startPosition = textDocument.positionAt(startOffset);
            const endPosition = textDocument.positionAt(endOffset);
            const range = vscode_languageserver_1.Range.create(startPosition, endPosition);
            // Find ID for which to find the definition or references
            const expression = (0, ExpressionUtils_1.getExpressionAtPosition)(textDocument, params.position);
            if (expression == null) {
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, 'No rename target');
                return null;
            }
            // Check if expression contains only whitespace
            if (expression.fullExpression.trim().length === 0) {
                return null;
            }
            // Check if references exist
            if (SymbolSearchService_1.default.findReferences(uri, params.position, expression, documentManager, SymbolSearchService_1.RequestType.RenameSymbol).length === 0) {
                return null;
            }
            return { range, placeholder: expression.unqualifiedTarget };
        });
    }
    /**
     * Handles requests for renaming.
     *
     * @param params Parameters for the rename request
     * @param documentManager The text document manager
     * @returns A WorkspaceEdit object
     */
    handleRenameRequest(params, documentManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const matlabConnection = yield this.matlabLifecycleManager.getMatlabConnection(true);
            if (matlabConnection == null) {
                LifecycleNotificationHelper_1.default.notifyMatlabRequirement();
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, TelemetryUtils_1.ActionErrorConditions.MatlabUnavailable);
                return null;
            }
            const uri = params.textDocument.uri;
            const textDocument = documentManager.get(uri);
            if (textDocument == null) {
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, 'No document');
                return null;
            }
            // Find ID for which to find the definition or references
            const expression = (0, ExpressionUtils_1.getExpressionAtPosition)(textDocument, params.position);
            if (expression == null) {
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, 'No rename target');
                return null;
            }
            // Ensure document index is up to date
            yield this.documentIndexer.ensureDocumentIndexIsUpdated(textDocument);
            const codeData = FileInfoIndex_1.default.codeDataCache.get(uri);
            if (codeData == null) {
                (0, SymbolSearchService_1.reportTelemetry)(SymbolSearchService_1.RequestType.RenameSymbol, 'No code data');
                return null;
            }
            const refs = SymbolSearchService_1.default.findReferences(uri, params.position, expression, documentManager, SymbolSearchService_1.RequestType.RenameSymbol);
            const workspaceEdit = {
                changes: {
                    [uri]: []
                }
            };
            refs.forEach(location => {
                const range = {
                    start: {
                        line: location.range.start.line,
                        character: location.range.start.character
                    },
                    end: {
                        line: location.range.end.line,
                        character: location.range.end.character
                    }
                };
                if (expression.components.length > 1 && expression.selectedComponent !== 0) {
                    const newName = expression.components.slice();
                    newName[expression.selectedComponent] = params.newName;
                    const newEdit = {
                        range,
                        newText: newName.join('.')
                    };
                    if (location.uri === uri && (workspaceEdit.changes != null)) {
                        workspaceEdit.changes[uri].push(newEdit);
                    }
                }
                else {
                    const newEdit = {
                        range,
                        newText: params.newName
                    };
                    if (location.uri === uri && (workspaceEdit.changes != null)) {
                        workspaceEdit.changes[uri].push(newEdit);
                    }
                }
            });
            // Check if there is a class definition and rename as necessary
            if (codeData.isClassDef && (codeData.classInfo != null) && (codeData.classInfo.declaration != null)) {
                const lineNumber = codeData.classInfo.declaration.start.line;
                const declaration = (0, TextDocumentUtils_1.getTextOnLine)(textDocument, lineNumber);
                if (declaration.split(/\s+/).includes(expression.unqualifiedTarget)) {
                    const range = {
                        start: {
                            line: lineNumber,
                            character: 9 // Offset by 9 to get past classdef_
                        },
                        end: {
                            line: lineNumber,
                            character: 9 + expression.unqualifiedTarget.length
                        }
                    };
                    const newEdit = {
                        range,
                        newText: params.newName
                    };
                    if (workspaceEdit.changes != null) {
                        workspaceEdit.changes[uri].push(newEdit);
                    }
                }
            }
            // Checks if properties need to be renamed
            const propertyInfo = SymbolSearchService_1.default.getPropertyDeclaration(codeData, expression.unqualifiedTarget);
            if (propertyInfo != null && expression.components.length > 1) {
                const newEdit = {
                    range: propertyInfo.range,
                    newText: params.newName
                };
                if (workspaceEdit.changes != null) {
                    workspaceEdit.changes[uri].push(newEdit);
                }
            }
            return workspaceEdit;
        });
    }
}
exports["default"] = RenameSymbolProvider;


/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startServer = void 0;
const vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ "./node_modules/vscode-languageserver-textdocument/lib/esm/main.js");
const node_1 = __webpack_require__(/*! vscode-languageserver/node */ "./node_modules/vscode-languageserver/node.js");
const DocumentIndexer_1 = __importDefault(__webpack_require__(/*! ./indexing/DocumentIndexer */ "./src/indexing/DocumentIndexer.ts"));
const WorkspaceIndexer_1 = __importDefault(__webpack_require__(/*! ./indexing/WorkspaceIndexer */ "./src/indexing/WorkspaceIndexer.ts"));
const ConfigurationManager_1 = __importStar(__webpack_require__(/*! ./lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts"));
const MatlabLifecycleManager_1 = __importDefault(__webpack_require__(/*! ./lifecycle/MatlabLifecycleManager */ "./src/lifecycle/MatlabLifecycleManager.ts"));
const Logger_1 = __importDefault(__webpack_require__(/*! ./logging/Logger */ "./src/logging/Logger.ts"));
const TelemetryUtils_1 = __webpack_require__(/*! ./logging/TelemetryUtils */ "./src/logging/TelemetryUtils.ts");
const NotificationService_1 = __importStar(__webpack_require__(/*! ./notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const CompletionSupportProvider_1 = __importDefault(__webpack_require__(/*! ./providers/completion/CompletionSupportProvider */ "./src/providers/completion/CompletionSupportProvider.ts"));
const FormatSupportProvider_1 = __importDefault(__webpack_require__(/*! ./providers/formatting/FormatSupportProvider */ "./src/providers/formatting/FormatSupportProvider.ts"));
const LintingSupportProvider_1 = __importDefault(__webpack_require__(/*! ./providers/linting/LintingSupportProvider */ "./src/providers/linting/LintingSupportProvider.ts"));
const ExecuteCommandProvider_1 = __importStar(__webpack_require__(/*! ./providers/lspCommands/ExecuteCommandProvider */ "./src/providers/lspCommands/ExecuteCommandProvider.ts"));
const NavigationSupportProvider_1 = __importDefault(__webpack_require__(/*! ./providers/navigation/NavigationSupportProvider */ "./src/providers/navigation/NavigationSupportProvider.ts"));
const LifecycleNotificationHelper_1 = __importDefault(__webpack_require__(/*! ./lifecycle/LifecycleNotificationHelper */ "./src/lifecycle/LifecycleNotificationHelper.ts"));
const MVM_1 = __importDefault(__webpack_require__(/*! ./mvm/impl/MVM */ "./src/mvm/impl/MVM.js"));
const FoldingSupportProvider_1 = __importDefault(__webpack_require__(/*! ./providers/folding/FoldingSupportProvider */ "./src/providers/folding/FoldingSupportProvider.ts"));
const ClientConnection_1 = __importDefault(__webpack_require__(/*! ./ClientConnection */ "./src/ClientConnection.ts"));
const PathResolver_1 = __importDefault(__webpack_require__(/*! ./providers/navigation/PathResolver */ "./src/providers/navigation/PathResolver.ts"));
const Indexer_1 = __importDefault(__webpack_require__(/*! ./indexing/Indexer */ "./src/indexing/Indexer.ts"));
const RenameSymbolProvider_1 = __importDefault(__webpack_require__(/*! ./providers/rename/RenameSymbolProvider */ "./src/providers/rename/RenameSymbolProvider.ts"));
const SymbolSearchService_1 = __webpack_require__(/*! ./indexing/SymbolSearchService */ "./src/indexing/SymbolSearchService.ts");
const ProxyUtils_1 = __webpack_require__(/*! ./utils/ProxyUtils */ "./src/utils/ProxyUtils.ts");
const MatlabDebugAdaptorServer_1 = __importDefault(__webpack_require__(/*! ./debug/MatlabDebugAdaptorServer */ "./src/debug/MatlabDebugAdaptorServer.ts"));
const DebugServices_1 = __webpack_require__(/*! ./debug/DebugServices */ "./src/debug/DebugServices.ts");
const MVMServer_1 = __importDefault(__webpack_require__(/*! ./mvm/MVMServer */ "./src/mvm/MVMServer.ts"));
const server_1 = __webpack_require__(/*! ./licensing/server */ "./src/licensing/server/index.ts");
const config_1 = __webpack_require__(/*! ./licensing/config */ "./src/licensing/config.ts");
const LicensingUtils_1 = __webpack_require__(/*! ./utils/LicensingUtils */ "./src/utils/LicensingUtils.ts");
function startServer() {
    return __awaiter(this, void 0, void 0, function* () {
        (0, ProxyUtils_1.cacheAndClearProxyEnvironmentVariables)();
        // Create a connection for the server
        const connection = ClientConnection_1.default.getConnection();
        // Initialize Logger
        Logger_1.default.initialize(connection.console);
        // Instantiate services
        const pathResolver = new PathResolver_1.default();
        const matlabLifecycleManager = new MatlabLifecycleManager_1.default();
        const indexer = new Indexer_1.default(matlabLifecycleManager, pathResolver);
        const workspaceIndexer = new WorkspaceIndexer_1.default(indexer);
        const documentIndexer = new DocumentIndexer_1.default(indexer);
        const formatSupportProvider = new FormatSupportProvider_1.default(matlabLifecycleManager);
        const foldingSupportProvider = new FoldingSupportProvider_1.default(matlabLifecycleManager);
        const lintingSupportProvider = new LintingSupportProvider_1.default(matlabLifecycleManager);
        const executeCommandProvider = new ExecuteCommandProvider_1.default(lintingSupportProvider);
        const completionSupportProvider = new CompletionSupportProvider_1.default(matlabLifecycleManager);
        const navigationSupportProvider = new NavigationSupportProvider_1.default(matlabLifecycleManager, indexer, documentIndexer, pathResolver);
        const renameSymbolProvider = new RenameSymbolProvider_1.default(matlabLifecycleManager, documentIndexer);
        // Create basic text document manager
        const documentManager = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
        let mvm;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        let mvmServer;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        let matlabDebugAdaptor;
        let hasMatlabBeenRequested = false;
        matlabLifecycleManager.eventEmitter.on('connected', () => {
            // Handle things after MATLAB has launched
            hasMatlabBeenRequested = false;
            // Initiate workspace indexing
            void workspaceIndexer.indexWorkspace();
            documentManager.all().forEach(textDocument => {
                // Lint the open documents
                void lintingSupportProvider.lintDocument(textDocument);
                // Index the open document
                void documentIndexer.indexDocument(textDocument);
            });
        });
        let capabilities;
        // Handles an initialization request
        connection.onInitialize((params) => {
            capabilities = params.capabilities;
            // Defines the capabilities supported by this language server
            const initResult = {
                capabilities: {
                    codeActionProvider: true,
                    completionProvider: {
                        triggerCharacters: [
                            '.',
                            '(',
                            ' ',
                            ',',
                            '/',
                            '\\' // File path
                        ]
                    },
                    definitionProvider: true,
                    documentFormattingProvider: true,
                    executeCommandProvider: {
                        commands: Object.values(ExecuteCommandProvider_1.MatlabLSCommands)
                    },
                    foldingRangeProvider: true,
                    referencesProvider: true,
                    signatureHelpProvider: {
                        triggerCharacters: ['(', ',']
                    },
                    documentSymbolProvider: true,
                    renameProvider: {
                        prepareProvider: true
                    }
                }
            };
            return initResult;
        });
        // Handles the initialized notification
        /* eslint-disable @typescript-eslint/no-explicit-any */
        connection.onInitialized(() => __awaiter(this, void 0, void 0, function* () {
            ConfigurationManager_1.default.setup(capabilities);
            // Add callbacks when settings change.
            ConfigurationManager_1.default.addSettingCallback('signIn', LicensingUtils_1.handleSignInChanged);
            ConfigurationManager_1.default.addSettingCallback('installPath', LicensingUtils_1.handleInstallPathSettingChanged);
            const configuration = yield ConfigurationManager_1.default.getConfiguration();
            // If "signIn" setting is checked, setup notification listeners for it.
            if (configuration.signIn) {
                yield (0, LicensingUtils_1.setupLicensingNotificationListenersAndUpdateClient)(matlabLifecycleManager);
                // If installPath setting is not empty, update installPath in licensing config required for its workflows.
                if (configuration.installPath !== '') {
                    (0, config_1.setInstallPath)(configuration.installPath);
                }
            }
            workspaceIndexer.setupCallbacks(capabilities);
            mvm = new MVM_1.default(matlabLifecycleManager);
            mvmServer = new MVMServer_1.default(mvm, NotificationService_1.default);
            matlabDebugAdaptor = new MatlabDebugAdaptorServer_1.default(mvm, new DebugServices_1.DebugServices(mvm));
            void startMatlabIfOnStartLaunch();
        }));
        function startMatlabIfOnStartLaunch() {
            return __awaiter(this, void 0, void 0, function* () {
                // Launch MATLAB if it should be launched early
                const connectionTiming = (yield ConfigurationManager_1.default.getConfiguration()).matlabConnectionTiming;
                if (connectionTiming === ConfigurationManager_1.ConnectionTiming.OnStart) {
                    void matlabLifecycleManager.connectToMatlab().catch(reason => {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        Logger_1.default.error(`MATLAB onStart connection failed: ${reason}`);
                    });
                }
            });
        }
        // Handles a shutdown request
        connection.onShutdown(() => __awaiter(this, void 0, void 0, function* () {
            // Shut down MATLAB
            matlabLifecycleManager.disconnectFromMatlab();
            // If licensing workflows are enabled, shutdown the licensing server too.
            if ((yield ConfigurationManager_1.default.getConfiguration()).signIn) {
                (0, server_1.stopLicensingServer)();
            }
        }));
        // Set up connection notification listeners
        NotificationService_1.default.registerNotificationListener(NotificationService_1.Notification.MatlabConnectionClientUpdate, (data) => {
            switch (data.connectionAction) {
                case 'connect':
                    void matlabLifecycleManager.connectToMatlab().catch(reason => {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        Logger_1.default.error(`Connection request failed: ${reason}`);
                    });
                    break;
                case 'disconnect':
                    matlabLifecycleManager.disconnectFromMatlab();
            }
        });
        // Set up MATLAB startup request listener
        NotificationService_1.default.registerNotificationListener(NotificationService_1.Notification.MatlabRequestInstance, () => __awaiter(this, void 0, void 0, function* () {
            if (hasMatlabBeenRequested) {
                return;
            }
            hasMatlabBeenRequested = true;
            const matlabConnection = yield matlabLifecycleManager.getMatlabConnection(true);
            if (matlabConnection === null) {
                LifecycleNotificationHelper_1.default.notifyMatlabRequirement();
            }
        }));
        // Handles files opened
        documentManager.onDidOpen(params => {
            reportFileOpened(params.document);
            void lintingSupportProvider.lintDocument(params.document);
            void documentIndexer.indexDocument(params.document);
        });
        documentManager.onDidClose(params => {
            lintingSupportProvider.clearDiagnosticsForDocument(params.document);
        });
        // Handles files saved
        documentManager.onDidSave(params => {
            void lintingSupportProvider.lintDocument(params.document);
        });
        // Handles changes to the text document
        documentManager.onDidChangeContent(params => {
            if (matlabLifecycleManager.isMatlabConnected()) {
                // Only want to lint on content changes when linting is being backed by MATLAB
                lintingSupportProvider.queueLintingForDocument(params.document);
                documentIndexer.queueIndexingForDocument(params.document);
            }
        });
        // Handle execute command requests
        connection.onExecuteCommand(params => {
            void executeCommandProvider.handleExecuteCommand(params, documentManager);
        });
        /** -------------------- COMPLETION SUPPORT -------------------- **/
        connection.onCompletion((params) => __awaiter(this, void 0, void 0, function* () {
            // Gather a list of possible completions to be displayed by the IDE
            return yield completionSupportProvider.handleCompletionRequest(params, documentManager);
        }));
        connection.onSignatureHelp((params) => __awaiter(this, void 0, void 0, function* () {
            // Gather a list of possible function signatures to be displayed by the IDE
            return yield completionSupportProvider.handleSignatureHelpRequest(params, documentManager);
        }));
        /** -------------------- FOLDING SUPPORT -------------------- **/
        connection.onFoldingRanges((params) => __awaiter(this, void 0, void 0, function* () {
            // Retrieve the folding ranges
            // If there are valid folding ranges, hand them back to the IDE
            // Else, return null, so the IDE falls back to indent-based folding
            return yield foldingSupportProvider.handleFoldingRangeRequest(params, documentManager);
        }));
        /** -------------------- FORMATTING SUPPORT -------------------- **/
        connection.onDocumentFormatting((params) => __awaiter(this, void 0, void 0, function* () {
            // Gather a set of document edits required for formatting, which the IDE will execute
            return yield formatSupportProvider.handleDocumentFormatRequest(params, documentManager);
        }));
        /** --------------------  LINTING SUPPORT   -------------------- **/
        connection.onCodeAction(params => {
            // Retrieve a list of possible code actions to be displayed by the IDE
            return lintingSupportProvider.handleCodeActionRequest(params);
        });
        /** --------------------  NAVIGATION SUPPORT   -------------------- **/
        connection.onDefinition((params) => __awaiter(this, void 0, void 0, function* () {
            return yield navigationSupportProvider.handleDefOrRefRequest(params, documentManager, SymbolSearchService_1.RequestType.Definition);
        }));
        connection.onReferences((params) => __awaiter(this, void 0, void 0, function* () {
            return yield navigationSupportProvider.handleDefOrRefRequest(params, documentManager, SymbolSearchService_1.RequestType.References);
        }));
        connection.onDocumentSymbol((params) => __awaiter(this, void 0, void 0, function* () {
            return yield navigationSupportProvider.handleDocumentSymbol(params, documentManager, SymbolSearchService_1.RequestType.DocumentSymbol);
        }));
        // Start listening to open/change/close text document events
        documentManager.listen(connection);
        /** --------------------  RENAME SUPPORT   -------------------- **/
        connection.onPrepareRename((params) => __awaiter(this, void 0, void 0, function* () {
            return yield renameSymbolProvider.prepareRename(params, documentManager);
        }));
        connection.onRenameRequest((params) => __awaiter(this, void 0, void 0, function* () {
            return yield renameSymbolProvider.handleRenameRequest(params, documentManager);
        }));
    });
}
exports.startServer = startServer;
/** -------------------- Helper Functions -------------------- **/
function reportFileOpened(document) {
    const roughSize = Math.ceil(document.getText().length / 1024); // in KB
    (0, TelemetryUtils_1.reportTelemetryAction)(TelemetryUtils_1.Actions.OpenFile, roughSize.toString());
}


/***/ }),

/***/ "./src/utils/CliUtils.ts":
/*!*******************************!*\
  !*** ./src/utils/CliUtils.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2022 - 2023 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCliArgs = void 0;
const yargs = __importStar(__webpack_require__(/*! yargs */ "./node_modules/yargs/index.cjs"));
const ConfigurationManager_1 = __webpack_require__(/*! ../lifecycle/ConfigurationManager */ "./src/lifecycle/ConfigurationManager.ts");
/**
 * Creates a yargs parser to extract command line arguments.
 *
 * @returns The parsed command line arguments
 */
function makeParser() {
    const argParser = yargs.option(ConfigurationManager_1.Argument.MatlabLaunchCommandArguments, {
        description: 'Arguments passed to MATLAB when launching',
        type: 'string',
        requiresArg: true
    }).option(ConfigurationManager_1.Argument.MatlabInstallationPath, {
        description: 'The full path to the top-level directory of the MATLAB installation. If not specified, the environment path will be checked for the location of the `matlab` executable.',
        type: 'string',
        default: ''
    }).option(ConfigurationManager_1.Argument.MatlabConnectionTiming, {
        description: 'When the language server should attempt to connect to MATLAB.',
        type: 'string',
        default: 'onStart',
        choices: ['onStart', 'onDemand', 'never']
    }).option(ConfigurationManager_1.Argument.ShouldIndexWorkspace, {
        boolean: true,
        default: false,
        description: 'Whether or not the user\'s workspace should be indexed.',
        requiresArg: false
    }).option(ConfigurationManager_1.Argument.MatlabUrl, {
        type: 'string',
        description: 'URL for communicating with an existing MATLAB instance',
        requiresArg: true
    }).option(ConfigurationManager_1.Argument.SnippetIgnoreList, {
        type: 'string',
        description: 'A semi-colon separated list of MATLAB code snippets to ignore',
        default: ''
    }).usage('Usage: $0 {--node-ipc | --stdio | --socket=socket} options\n' +
        '\n' +
        '\tAn LSP server for MATLAB. This is meant to be invoked from an editor or IDE.\n').group(['node-ipc', 'stdio', 'socket'], 'Required IPC flag').option('node-ipc', {
        description: 'Use Node IPC'
    }).option('stdio', {
        description: 'Use stdio for IPC'
    }).option('socket', {
        description: 'Use specified socket for IPC',
        requiresArg: true
    }).help('help').alias('h', 'help');
    return argParser;
}
/**
 * Parse the command line arguments.
 *
 * @param args If provided, these are the arguments to parse. Otherwise, the true
 * command line arguments will be parsed. This is primarily meant for testing.
 * @returns The parsed CLI arguments
 */
function getCliArgs(args) {
    const cliParser = makeParser();
    return (args != null) ? cliParser.parseSync(args) : cliParser.parseSync();
}
exports.getCliArgs = getCliArgs;


/***/ }),

/***/ "./src/utils/DeprecationUtils.ts":
/*!***************************************!*\
  !*** ./src/utils/DeprecationUtils.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkIfMatlabDeprecated = void 0;
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const ORIGINAL_MIN_RELEASE = 'R2021a';
const CURRENT_MIN_RELEASE = 'R2021b';
const FUTURE_MIN_RELEASE = 'R2021b';
var DeprecationType;
(function (DeprecationType) {
    DeprecationType[DeprecationType["NEVER_SUPPORTED"] = 1] = "NEVER_SUPPORTED";
    DeprecationType[DeprecationType["DEPRECATED"] = 2] = "DEPRECATED";
    DeprecationType[DeprecationType["TO_BE_DEPRECATED"] = 3] = "TO_BE_DEPRECATED";
})(DeprecationType || (DeprecationType = {}));
/**
 * Checks if the given MATLAB release is unsupported, has been deprecated, or is planned
 * for deprecation in a future release. If it falls under one of these categories, a
 * notification is sent to the client, which may display a message to the user.
 *
 * @param matlabRelease The MATLAB release (e.g. "R2021a") which is being checked
 */
function checkIfMatlabDeprecated(matlabRelease) {
    let deprecationType;
    if (matlabRelease < ORIGINAL_MIN_RELEASE) {
        // The launched MATLAB version has never been supported
        deprecationType = DeprecationType.NEVER_SUPPORTED;
        Logger_1.default.error(`MATLAB ${matlabRelease} is not supported`);
    }
    else if (matlabRelease >= ORIGINAL_MIN_RELEASE && matlabRelease < CURRENT_MIN_RELEASE) {
        // The launched MATLAB version is no longer supported
        deprecationType = DeprecationType.DEPRECATED;
        Logger_1.default.error(`MATLAB ${matlabRelease} is no longer supported`);
    }
    else if (matlabRelease >= CURRENT_MIN_RELEASE && matlabRelease < FUTURE_MIN_RELEASE) {
        // Support for the launched MATLAB version will end in an upcoming release
        deprecationType = DeprecationType.TO_BE_DEPRECATED;
        Logger_1.default.warn(`Support for MATLAB ${matlabRelease} will end in a future update`);
    }
    else {
        // Support for the launched MATLAB version is not yet planned to end
        return;
    }
    const message = {
        deprecationType,
        deprecationInfo: {
            matlabVersion: matlabRelease,
            minVersion: CURRENT_MIN_RELEASE,
            futureMinVersion: FUTURE_MIN_RELEASE
        }
    };
    NotificationService_1.default.sendNotification(NotificationService_1.Notification.MatlabVersionDeprecation, message);
}
exports.checkIfMatlabDeprecated = checkIfMatlabDeprecated;


/***/ }),

/***/ "./src/utils/ExpressionUtils.ts":
/*!**************************************!*\
  !*** ./src/utils/ExpressionUtils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExpressionAtPosition = void 0;
const TextDocumentUtils_1 = __webpack_require__(/*! ./TextDocumentUtils */ "./src/utils/TextDocumentUtils.ts");
const DOTTED_IDENTIFIER_REGEX = /\b(?:[a-zA-Z][\w]*)(?:\.[a-zA-Z][\w]*)*\b/; // Matches a word followed by optional dotted words
/**
 * Represents a code expression, either a single identifier or a dotted expression.
 * For example, "plot" or "pkg.Class.func".
 */
class Expression {
    constructor(components, selectedComponent) {
        this.components = components;
        this.selectedComponent = selectedComponent;
    }
    /**
     * The full, dotted expression
     */
    get fullExpression() {
        return this.components.join('.');
    }
    /**
     * The dotted expression up to and including the selected component
     */
    get targetExpression() {
        return this.components.slice(0, this.selectedComponent + 1).join('.');
    }
    /**
     * Only the selected component of the expression
     */
    get unqualifiedTarget() {
        return this.components[this.selectedComponent];
    }
    /**
     * The first component of the expression
     */
    get first() {
        return this.components[0];
    }
    /**
     * The last component of the expression
     */
    get last() {
        return this.components[this.components.length - 1];
    }
}
/**
 * Gets the definition/references request target expression.
 *
 * @param textDocument The text document
 * @param position The position in the document
 * @returns The expression at the given position, or null if no expression is found
 */
function getExpressionAtPosition(textDocument, position) {
    const idAtPosition = getIdentifierAtPosition(textDocument, position);
    if (idAtPosition.identifier === '') {
        return null;
    }
    const idComponents = idAtPosition.identifier.split('.');
    // Determine what component was targeted
    let length = 0;
    let i = 0;
    while (i < idComponents.length && length <= position.character - idAtPosition.start) {
        length += idComponents[i].length + 1; // +1 for '.'
        i++;
    }
    return new Expression(idComponents, i - 1); // Compensate for extra increment in loop
}
exports.getExpressionAtPosition = getExpressionAtPosition;
/**
 * Determines the identifier (or dotted expression) at the given position in the document.
 *
 * @param textDocument The text document
 * @param position The position in the document
 * @returns An object containing the string identifier at the position, as well as the column number at which the identifier starts.
 */
function getIdentifierAtPosition(textDocument, position) {
    let lineText = (0, TextDocumentUtils_1.getTextOnLine)(textDocument, position.line);
    const result = {
        identifier: '',
        start: -1
    };
    let matchResults = lineText.match(DOTTED_IDENTIFIER_REGEX);
    let offset = 0;
    while (matchResults != null) {
        if (matchResults.index == null) {
            // No result found
            break;
        }
        const startChar = offset + matchResults.index;
        if (startChar > position.character) {
            // Passed the cursor - no match found
            break;
        }
        if (startChar + matchResults[0].length >= position.character) {
            // Found overlapping identifier
            result.identifier = matchResults[0];
            result.start = startChar;
            break;
        }
        // Match found too early in line - check for following matches
        lineText = lineText.substring(matchResults.index + matchResults[0].length);
        offset = startChar + matchResults[0].length;
        matchResults = lineText.match(DOTTED_IDENTIFIER_REGEX);
    }
    return result;
}
exports["default"] = Expression;


/***/ }),

/***/ "./src/utils/FsUtils.ts":
/*!******************************!*\
  !*** ./src/utils/FsUtils.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findExecutableOnPath = exports.resolveSymlink = exports.deleteFile = exports.writeJSONDataToFile = exports.createDirectoryIfNotExist = void 0;
const fs = __importStar(__webpack_require__(/*! fs/promises */ "fs/promises"));
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const util_1 = __webpack_require__(/*! util */ "util");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const execPromise = (0, util_1.promisify)(child_process_1.exec);
/**
 * Creates a directory if it does not exist.
 * @param directoryPath - The path of the directory to create.
 * @returns {Promise<void>}
 */
function createDirectoryIfNotExist(directoryPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.mkdir(directoryPath, { recursive: true });
            Logger_1.default.log(`Directory created or already exists: ${directoryPath}`);
        }
        catch (error) {
            Logger_1.default.error(`Error creating directory: ${error.message}`);
        }
    });
}
exports.createDirectoryIfNotExist = createDirectoryIfNotExist;
/**
 * Writes JSON data to a file.
 * @param filePath - The path of the file to write to.
 * @param data - The data to write to the file.
 * @returns {Promise<void>}
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
function writeJSONDataToFile(filePath, data) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const dataString = JSON.stringify(data, null, 4);
            yield fs.writeFile(filePath, dataString, 'utf8');
            Logger_1.default.log(`File written successfully to ${filePath}`);
        }
        catch (error) {
            Logger_1.default.error(`Error writing file: ${error.message}`);
        }
    });
}
exports.writeJSONDataToFile = writeJSONDataToFile;
/**
 * Deletes a file.
 * @param filePath - The path of the file to delete.
 * @returns {Promise<void>}
 */
function deleteFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.unlink(filePath);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                Logger_1.default.log(`File at path ${filePath} does not exist`);
            }
            else {
                Logger_1.default.error(`Error deleting file: ${String(error)}`);
            }
        }
    });
}
exports.deleteFile = deleteFile;
/**
 * Resolves a symbolic link to its target path.
 * @param executablePath - The path of the symbolic link.
 * @returns {Promise<string>} The resolved target path.
 */
function resolveSymlink(executablePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (executablePath === null || executablePath === undefined || executablePath === '') {
            return '';
        }
        try {
            const linkTarget = yield fs.readlink(executablePath);
            const absolutePath = yield fs.realpath(linkTarget);
            return absolutePath;
        }
        catch (error) {
            return path.resolve(executablePath);
        }
    });
}
exports.resolveSymlink = resolveSymlink;
/**
 * Asynchronously finds the path of an executable on the system's PATH.
 *
 * @param executable - The name of the executable to find.
 * @returns {Promise<string|null>} A promise that resolves to the path of the executable if found, or null if not found.
 */
function findExecutableOnPath(executable) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { stdout } = yield execPromise(`which ${executable}`);
            return stdout.trim();
        }
        catch (err) {
            return null;
        }
    });
}
exports.findExecutableOnPath = findExecutableOnPath;


/***/ }),

/***/ "./src/utils/LicensingUtils.ts":
/*!*************************************!*\
  !*** ./src/utils/LicensingUtils.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleInstallPathSettingChanged = exports.handleSignInChanged = exports.removeLicensingNotificationListenersAndUpdateClient = exports.setupLicensingNotificationListenersAndUpdateClient = exports.marshalErrorInfo = exports.marshalLicensingInfo = exports.findAllEntitlements = void 0;
const types_1 = __webpack_require__(/*! ../licensing/types */ "./src/licensing/types.ts");
const licensing_1 = __importDefault(__webpack_require__(/*! ../licensing */ "./src/licensing/index.ts"));
const config_1 = __webpack_require__(/*! ../licensing/config */ "./src/licensing/config.ts");
const NotificationService_1 = __importStar(__webpack_require__(/*! ../notifications/NotificationService */ "./src/notifications/NotificationService.ts"));
const Logger_1 = __importDefault(__webpack_require__(/*! ../logging/Logger */ "./src/logging/Logger.ts"));
const server_1 = __webpack_require__(/*! ../licensing/server */ "./src/licensing/server/index.ts");
/**
 * Recursively finds all occurrences of the "entitlement" key in the given object and its nested objects.
 *
 * @param obj - The object to search.
 * @returns {Entitlement[][]} An array of arrays containing the entitlement values found.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
function findAllEntitlements(obj) {
    const result = [];
    const keyToFind = 'entitlement';
    function recursiveSearch(obj) {
        if (obj === null || obj === undefined || typeof obj !== 'object') {
            return;
        }
        if (Object.prototype.hasOwnProperty.call(obj, keyToFind)) {
            const entitlementValue = obj[keyToFind];
            if (Array.isArray(entitlementValue)) {
                result.push(entitlementValue);
            }
        }
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                recursiveSearch(obj[key]);
            }
        }
    }
    recursiveSearch(obj);
    return result;
}
exports.findAllEntitlements = findAllEntitlements;
/**
 * Marshals the licensing data into a standardized format based on the license type.
 *
 * @param data - The licensing data to be marshaled.
 * @returns {Object} The marshaled licensing information.
 */
function marshalLicensingInfo(data) {
    if ((data == null) || !('type' in data)) {
        return {};
    }
    if (data.type === types_1.MHLMLicenseType) {
        return {
            type: types_1.MHLMLicenseType,
            emailAddress: data.email_addr,
            entitlements: data.entitlements,
            entitlementId: data.entitlement_id
        };
    }
    else if (data.type === types_1.NLMLicenseType) {
        return {
            type: types_1.NLMLicenseType,
            connectionString: data.conn_str
        };
    }
    else if (data.type === types_1.ExistingLicenseType) {
        return {
            type: types_1.ExistingLicenseType
        };
    }
    else {
        return {};
    }
}
exports.marshalLicensingInfo = marshalLicensingInfo;
/**
 * Marshals the error information into a standardized format.
 *
 * @param error - The error object to be marshaled.
 * @returns The marshaled error information, or null if no error is provided.
 */
function marshalErrorInfo(error) {
    if (error == null)
        return null;
    return {
        message: error.message,
        logs: error.logs,
        type: error.constructor.name
    };
}
exports.marshalErrorInfo = marshalErrorInfo;
let licensingDeleteNotificationListener = null;
let licensingServerUrlNotificationListener = null;
let mLM;
/**
 * Sets up notification listeners required for licensing and updates languageserver client
 *
 */
function setupLicensingNotificationListenersAndUpdateClient(matlabLifecycleManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const licensing = new licensing_1.default();
        mLM = matlabLifecycleManager;
        if (licensingDeleteNotificationListener == null) {
            licensingDeleteNotificationListener = NotificationService_1.default.registerNotificationListener(NotificationService_1.Notification.LicensingDelete, 
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            () => __awaiter(this, void 0, void 0, function* () {
                Logger_1.default.log('Received notification to delete licensing from the extension');
                yield licensing.unsetLicensing();
                // Update language client 
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
            }));
        }
        if (licensingServerUrlNotificationListener == null) {
            licensingServerUrlNotificationListener = NotificationService_1.default.registerNotificationListener(NotificationService_1.Notification.LicensingServerUrl, () => __awaiter(this, void 0, void 0, function* () {
                const url = yield (0, server_1.startLicensingServer)(config_1.staticFolderPath, mLM);
                Logger_1.default.log(`Received Notification requesting for licensing server url: ${url}`);
                // Update language client
                NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingServerUrl, url);
            }));
        }
        NotificationService_1.default.sendNotification(NotificationService_1.Notification.LicensingData, licensing.getMinimalLicensingInfo());
    });
}
exports.setupLicensingNotificationListenersAndUpdateClient = setupLicensingNotificationListenersAndUpdateClient;
/**
 * Removes notification listeners required for licensing and updates languageserver client
 *
 */
function removeLicensingNotificationListenersAndUpdateClient() {
    if (licensingDeleteNotificationListener != null) {
        licensingDeleteNotificationListener.dispose();
        licensingDeleteNotificationListener = null;
    }
    if (licensingServerUrlNotificationListener != null) {
        licensingServerUrlNotificationListener.dispose();
        licensingServerUrlNotificationListener = null;
    }
}
exports.removeLicensingNotificationListenersAndUpdateClient = removeLicensingNotificationListenersAndUpdateClient;
/**
 * Handles the changes to the "signIn" setting in the configuration.
 *
 * @param configuration - The configuration object.
 * @returns {Promise<void>} A Promise that resolves when the handling is complete.
 */
function handleSignInChanged(configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration.signIn) {
            yield setupLicensingNotificationListenersAndUpdateClient(mLM);
        }
        else {
            removeLicensingNotificationListenersAndUpdateClient();
        }
    });
}
exports.handleSignInChanged = handleSignInChanged;
/**
 * Handles the changes to the "installPath" setting in the configuration.
 *
 * @param configuration - The configuration object.
 */
function handleInstallPathSettingChanged(configuration) {
    (0, config_1.setInstallPath)(configuration.installPath);
    const licensing = new licensing_1.default();
    // Entitlements are based on the MATLAB version
    // As installPath is changed, we need to update the entitlements using the 
    // new MATLAB version.
    if (licensing.isMHLMLicensing()) {
        licensing.updateAndPersistLicensing().then(isSuccessful => {
            if (isSuccessful) {
                Logger_1.default.log("Successfully updated entitlements using the new MATLAB version");
            }
            else {
                Logger_1.default.log("Failed to update entitlements using the new MATLAB version");
            }
        });
    }
}
exports.handleInstallPathSettingChanged = handleInstallPathSettingChanged;


/***/ }),

/***/ "./src/utils/NetworkUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/NetworkUtils.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright 2024 The MathWorks, Inc.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isPortFree = void 0;
const node_fetch_1 = __importDefault(__webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/index.js"));
const ProxyUtils_1 = __webpack_require__(/*! ./ProxyUtils */ "./src/utils/ProxyUtils.ts");
const net_1 = __importDefault(__webpack_require__(/*! net */ "net"));
/**
 * Sends an HTTP request to the specified URL with the provided options.
 *
 * @param url - The URL to send the request to.
 * @param options - The options for the request.
 * @returns {Promise<Response | null>} A Promise that resolves with the Response object if the request is successful, or null if an error occurs.
 */
function sendRequest(url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const proxyAgent = (0, ProxyUtils_1.getProxyAgent)(url);
            if (proxyAgent != null) {
                options.agent = proxyAgent;
                console.log(`Will use NETWORK PROXY for sending request to: ${url}`);
            }
            const response = yield (0, node_fetch_1.default)(url, options);
            if (!response.ok) {
                throw new Error(`Error: ${response.status}`);
            }
            return response;
        }
        catch (error) {
            console.error('Failed to send HTTP request: ', error);
            return null;
        }
    });
}
exports["default"] = sendRequest;
/**
 * Checks if a specified port is free to use.
 *
 * @param  port - The port number to check.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the port is free or `false` if the port is occupied.
 */
function isPortFree(port) {
    return new Promise((resolve) => {
        const server = net_1.default.createServer();
        server.once('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                resolve(false);
            }
            else {
                resolve(false);
            }
        });
        server.once('listening', () => {
            server.close(() => {
                resolve(true);
            });
        });
        server.listen(port);
    });
}
exports.isPortFree = isPortFree;


/***/ }),

/***/ "./src/utils/PositionUtils.ts":
/*!************************************!*\
  !*** ./src/utils/PositionUtils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright 2022 - 2023 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isPositionGreaterThanOrEqualTo = exports.isPositionGreaterThan = exports.isPositionLessThanOrEqualTo = exports.isPositionLessThan = void 0;
/**
 * Determines whether a position is less than another position.
 *
 * @param a The first position
 * @param b The second position
 * @returns true if position A is before position B
 */
function isPositionLessThan(a, b) {
    return checkLessThan(a, b);
}
exports.isPositionLessThan = isPositionLessThan;
/**
 * Determines whether a position is less than or equal to another position.
 *
 * @param a The first position
 * @param b The second position
 * @returns true if position A is before position B, or the same position
 */
function isPositionLessThanOrEqualTo(a, b) {
    return checkLessThan(a, b, true);
}
exports.isPositionLessThanOrEqualTo = isPositionLessThanOrEqualTo;
/**
 * Determines whether a position is greater than another position.
 *
 * @param a The first position
 * @param b The second position
 * @returns True if position A is after position B
 */
function isPositionGreaterThan(a, b) {
    return checkGreaterThan(a, b);
}
exports.isPositionGreaterThan = isPositionGreaterThan;
/**
 * Determines whether a position is greater than or equal to another position.
 *
 * @param a The first position
 * @param b The second position
 * @returns True if position A is after position B, or the same position
 */
function isPositionGreaterThanOrEqualTo(a, b) {
    return checkGreaterThan(a, b, true);
}
exports.isPositionGreaterThanOrEqualTo = isPositionGreaterThanOrEqualTo;
/**
 * Performs a "less than (or equal to)" check on two positions.
 *
 * @param a The first position
 * @param b The second position
 * @param orEqual Whether or not an "or equal to" check should be performed
 * @returns true if position A is before position B
 */
function checkLessThan(a, b, orEqual = false) {
    if (a.line < b.line) {
        return true;
    }
    if (a.line === b.line) {
        return orEqual
            ? a.character <= b.character
            : a.character < b.character;
    }
    return false;
}
/**
 * Performs a "greater than (or equal to)" check on two positions.
 *
 * @param a The first position
 * @param b The second position
 * @param orEqual Whether or not an "or equal to" check should be performed
 * @returns true if position A is after position B
 */
function checkGreaterThan(a, b, orEqual = false) {
    if (a.line > b.line) {
        return true;
    }
    if (a.line === b.line) {
        return orEqual
            ? a.character >= b.character
            : a.character > b.character;
    }
    return false;
}


/***/ }),

/***/ "./src/utils/PromiseUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/PromiseUtils.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createResolvablePromise = void 0;
/**
 * Creates a resolvable promise
 * @returns A resolvable promise
 */
function createResolvablePromise() {
    let res, rej;
    const p = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
    });
    p.resolve = res;
    p.reject = rej;
    return p;
}
exports.createResolvablePromise = createResolvablePromise;


/***/ }),

/***/ "./src/utils/ProxyUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/ProxyUtils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2024 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProxyAgent = exports.getProxyEnvironmentVariables = exports.isProxyEnvironment = exports.cacheAndClearProxyEnvironmentVariables = void 0;
const hpagent_1 = __webpack_require__(/*! hpagent */ "./node_modules/hpagent/index.js");
const proxyEnvironmentVariables = {};
/**
 * Workaround for connection issue with proxy environments: cache values for HTTP_PROXY,
 * HTTPS_PROXY, and NO_PROXY environment variables, then delete variables from environment.
 */
function cacheAndClearProxyEnvironmentVariables() {
    var _a, _b, _c;
    const httpProxy = (_a = process.env.HTTP_PROXY) !== null && _a !== void 0 ? _a : process.env.http_proxy;
    const httpsProxy = (_b = process.env.HTTPS_PROXY) !== null && _b !== void 0 ? _b : process.env.https_proxy;
    const noProxy = (_c = process.env.NO_PROXY) !== null && _c !== void 0 ? _c : process.env.no_proxy;
    delete process.env.HTTP_PROXY;
    delete process.env.http_proxy;
    delete process.env.HTTPS_PROXY;
    delete process.env.https_proxy;
    delete process.env.NO_PROXY;
    delete process.env.no_proxy;
    if (httpProxy != null) {
        proxyEnvironmentVariables.HTTP_PROXY = httpProxy;
    }
    if (httpsProxy != null) {
        proxyEnvironmentVariables.HTTPS_PROXY = httpsProxy;
    }
    if (noProxy != null) {
        proxyEnvironmentVariables.NO_PROXY = noProxy;
    }
}
exports.cacheAndClearProxyEnvironmentVariables = cacheAndClearProxyEnvironmentVariables;
/**
 * Determines if running within a proxy environment.
 *
 * @returns True if within a proxy environment, false otherwise
 */
function isProxyEnvironment() {
    return Object.keys(proxyEnvironmentVariables).length > 0;
}
exports.isProxyEnvironment = isProxyEnvironment;
/**
 * Gets any proxy environment variables and their values that had been set prior to
 * `cacheAndClearProxyEnvironmentVariables` being called.
 *
 * @returns An object containing any proxy-related environment variables and their values
 */
function getProxyEnvironmentVariables() {
    return proxyEnvironmentVariables;
}
exports.getProxyEnvironmentVariables = getProxyEnvironmentVariables;
/**
 * Returns an HTTP or HTTPS proxy agent based on the provided URL.
 *
 * @param url - The URL to determine the proxy agent for.
 * @returns {HttpProxyAgent | HttpsProxyAgent | undefined} - The proxy agent, or undefined if no proxy is used.
 */
function getProxyAgent(url) {
    const parsedUrl = new URL(url);
    if (!isProxyEnvironment()) {
        return undefined;
    }
    const proxyEnvironmentVariables = getProxyEnvironmentVariables();
    // Determine if we should bypass the proxy
    const noProxy = proxyEnvironmentVariables.NO_PROXY;
    if (typeof noProxy !== 'undefined' && noProxy !== null && noProxy.trim() !== '') {
        const noProxyHosts = noProxy.split(',').map(host => host.trim());
        if (noProxyHosts.includes(parsedUrl.hostname)) {
            return undefined;
        }
    }
    // Determine which proxy to use based on the protocol
    if (parsedUrl.protocol === 'http:') {
        const httpProxy = proxyEnvironmentVariables.HTTP_PROXY;
        if (httpProxy !== undefined && httpProxy !== null && httpProxy !== '') {
            return new hpagent_1.HttpProxyAgent({
                proxy: httpProxy
            });
        }
    }
    if (parsedUrl.protocol === 'https:') {
        const httpsProxy = proxyEnvironmentVariables.HTTPS_PROXY;
        if (httpsProxy !== undefined && httpsProxy !== null && httpsProxy !== '') {
            return new hpagent_1.HttpProxyAgent({
                proxy: httpsProxy
            });
        }
    }
    return undefined;
}
exports.getProxyAgent = getProxyAgent;


/***/ }),

/***/ "./src/utils/TextDocumentUtils.ts":
/*!****************************************!*\
  !*** ./src/utils/TextDocumentUtils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright 2022 - 2023 The MathWorks, Inc.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTextOnLine = exports.getRangeUntilLineEnd = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "./node_modules/vscode-languageserver/lib/node/main.js");
/**
 * Gets a Range within a text document from the given line/column position to
 * the end of the provided line.
 *
 * @param doc The text document
 * @param line The line number
 * @param char The character number on the line
 * @returns A range
 */
function getRangeUntilLineEnd(doc, line, char) {
    const lineText = getTextOnLine(doc, line);
    const endChar = lineText.length;
    // Note: Range will throw when provided a negative character number,
    // so we do not need to explicitly capture that case ourselves
    if (char > endChar) {
        throw new Error(`Start character exceeds line length (${char} > ${endChar})`);
    }
    return vscode_languageserver_1.Range.create(line, char, line, lineText.length);
}
exports.getRangeUntilLineEnd = getRangeUntilLineEnd;
/**
 * Gets the text on the given line of the document.
 *
 * @param doc The text document
 * @param line The line number
 * @returns The text on the line
 */
function getTextOnLine(doc, line) {
    const textLines = doc.getText().split('\n');
    if (line < 0 || line >= textLines.length) {
        throw new Error('Cannot get text for nonexistent line');
    }
    return textLines[line];
}
exports.getTextOnLine = getTextOnLine;


/***/ }),

/***/ "./node_modules/type-is/index.js":
/*!***************************************!*\
  !*** ./node_modules/type-is/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var typer = __webpack_require__(/*! media-typer */ "./node_modules/media-typer/index.js")
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis (value, types_) {
  var i
  var types = types_

  // remove parameters and normalize
  var val = tryNormalizeType(value)

  // no type or invalid
  if (!val) {
    return false
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  // no matches
  return false
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

function typeofrequest (req, types_) {
  var types = types_

  // no body
  if (!hasbody(req)) {
    return null
  }

  // support flattened arguments
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // request content type
  var value = req.headers['content-type']

  return typeis(value, types)
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */

function normalize (type) {
  if (typeof type !== 'string') {
    // invalid type
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type
  }

  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */

function mimeMatch (expected, actual) {
  // invalid type
  if (expected === false) {
    return false
  }

  // split types
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  // validate suffix wildcard
  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function normalizeType (value) {
  // parse the type
  var type = typer.parse(value)

  // remove the parameters
  type.parameters = undefined

  // reformat it
  return typer.format(type)
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function tryNormalizeType (value) {
  if (!value) {
    return null
  }

  try {
    return normalizeType(value)
  } catch (err) {
    return null
  }
}


/***/ }),

/***/ "./node_modules/uid-safe/index.js":
/*!****************************************!*\
  !*** ./node_modules/uid-safe/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * uid-safe
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var randomBytes = __webpack_require__(/*! random-bytes */ "./node_modules/random-bytes/index.js")

/**
 * Module variables.
 * @private
 */

var EQUAL_END_REGEXP = /=+$/
var PLUS_GLOBAL_REGEXP = /\+/g
var SLASH_GLOBAL_REGEXP = /\//g

/**
 * Module exports.
 * @public
 */

module.exports = uid
module.exports.sync = uidSync

/**
 * Create a unique ID.
 *
 * @param {number} length
 * @param {function} [callback]
 * @return {Promise}
 * @public
 */

function uid (length, callback) {
  // validate callback is a function, if provided
  if (callback !== undefined && typeof callback !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!callback && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  if (callback) {
    // classic callback style
    return generateUid(length, callback)
  }

  return new Promise(function executor (resolve, reject) {
    generateUid(length, function onUid (err, str) {
      if (err) return reject(err)
      resolve(str)
    })
  })
}

/**
 * Create a unique ID sync.
 *
 * @param {number} length
 * @return {string}
 * @public
 */

function uidSync (length) {
  return toString(randomBytes.sync(length))
}

/**
 * Generate a unique ID string.
 *
 * @param {number} length
 * @param {function} callback
 * @private
 */

function generateUid (length, callback) {
  randomBytes(length, function (err, buf) {
    if (err) return callback(err)
    callback(null, toString(buf))
  })
}

/**
 * Change a Buffer into a string.
 *
 * @param {Buffer} buf
 * @return {string}
 * @private
 */

function toString (buf) {
  return buf.toString('base64')
    .replace(EQUAL_END_REGEXP, '')
    .replace(PLUS_GLOBAL_REGEXP, '-')
    .replace(SLASH_GLOBAL_REGEXP, '_')
}


/***/ }),

/***/ "./node_modules/unpipe/index.js":
/*!**************************************!*\
  !*** ./node_modules/unpipe/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = unpipe

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}


/***/ }),

/***/ "./node_modules/utils-merge/index.js":
/*!*******************************************!*\
  !*** ./node_modules/utils-merge/index.js ***!
  \*******************************************/
/***/ ((module, exports) => {

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports = module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};


/***/ }),

/***/ "./node_modules/vary/index.js":
/*!************************************!*\
  !*** ./node_modules/vary/index.js ***!
  \************************************/
/***/ ((module) => {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/api.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const sharedArrayCancellation_1 = __webpack_require__(/*! ./sharedArrayCancellation */ "./node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js");
Object.defineProperty(exports, "SharedArraySenderStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } }));
Object.defineProperty(exports, "SharedArrayReceiverStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const messageBuffer_1 = __webpack_require__(/*! ./messageBuffer */ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
Object.defineProperty(exports, "AbstractMessageBuffer", ({ enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
Object.defineProperty(exports, "MessageStrategy", ({ enumerable: true, get: function () { return connection_1.MessageStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues = exports.TraceValues || (exports.TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var IdCancellationReceiverStrategy;
(function (IdCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    IdCancellationReceiverStrategy.is = is;
})(IdCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = {}));
var RequestCancellationReceiverStrategy;
(function (RequestCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    RequestCancellationReceiverStrategy.is = is;
})(RequestCancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var MessageStrategy;
(function (MessageStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
    }
    MessageStrategy.is = is;
})(MessageStrategy = exports.MessageStrategy || (exports.MessageStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
        }
        else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
        }
        else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
        }
        else {
            handleInvalidMessage(message);
        }
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
                messageStrategy.handleMessage(message, handleMessage);
            }
            else {
                handleMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
                logger.error(`Sending notification failed.`);
                throw error;
            });
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            // This should not await but simple return to ensure that we don't have another
            // async scheduling. Otherwise one send could overtake another send.
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const requestMessage = {
                jsonrpc: version,
                id: id,
                method: method,
                params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                try {
                    await messageWriter.write(requestMessage);
                    responsePromises.set(id, responsePromise);
                }
                catch (error) {
                    logger.error(`Sending request failed.`);
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                    throw error;
                }
            });
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/is.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('content-length');
                if (!contentLength) {
                    this.fireError(new Error('Header must provide a Content-Length property.'));
                    return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    this.fireError(new Error('Content-Length value must be a number.'));
                    return;
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            // Make sure that we convert one received message after the
            // other. Otherwise it could happen that a decoding of a second
            // smaller message finished before the decoding of a first larger
            // message and then we would deliver the second message first.
            this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== undefined
                    ? await this.options.contentDecoder.decode(body)
                    : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
            }).catch((error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message = exports.Message || (exports.Message = {}));


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancellationState;
(function (CancellationState) {
    CancellationState.Continue = 0;
    CancellationState.Cancelled = 1;
})(CancellationState || (CancellationState = {}));
class SharedArraySenderStrategy {
    constructor() {
        this.buffers = new Map();
    }
    enableCancellation(request) {
        if (request.id === null) {
            return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === undefined) {
            return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
        this.buffers.delete(id);
    }
    dispose() {
        this.buffers.clear();
    }
}
exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
class SharedArrayBufferCancellationToken {
    constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
}
class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
}
class SharedArrayReceiverStrategy {
    constructor() {
        this.kind = 'request';
    }
    createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === undefined) {
            return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
    }
}
exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/main.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "./node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js");
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
        super();
        this.onData = new api_1.Emitter;
        port.on('close', () => this.fireClose);
        port.on('error', (error) => this.fireError(error));
        port.on('message', (message) => {
            this.onData.fire(message);
        });
    }
    listen(callback) {
        return this.onData.event(callback);
    }
}
exports.PortMessageReader = PortMessageReader;
class PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on('close', () => this.fireClose());
        port.on('error', (error) => this.fireError(error));
    }
    write(msg) {
        try {
            this.port.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.PortMessageWriter = PortMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(/*! util */ "util");
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js");
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return api_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/node.js":
/*!*********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js"), exports);
var connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js");
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.RequestFailed = -32803;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js");
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js");
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolder_1 = __webpack_require__(/*! ./protocol.workspaceFolder */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js");
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js");
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js");
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js");
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js");
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js");
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js");
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js");
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(/*! ./protocol.semanticTokens */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js");
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(/*! ./protocol.showDocument */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js");
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(/*! ./protocol.linkedEditingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js");
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(/*! ./protocol.fileOperations */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js");
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(/*! ./protocol.moniker */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js");
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
const protocol_typeHierarchy_1 = __webpack_require__(/*! ./protocol.typeHierarchy */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js");
Object.defineProperty(exports, "TypeHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } }));
Object.defineProperty(exports, "TypeHierarchySubtypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } }));
Object.defineProperty(exports, "TypeHierarchySupertypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } }));
const protocol_inlineValue_1 = __webpack_require__(/*! ./protocol.inlineValue */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js");
Object.defineProperty(exports, "InlineValueRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } }));
Object.defineProperty(exports, "InlineValueRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } }));
const protocol_inlayHint_1 = __webpack_require__(/*! ./protocol.inlayHint */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js");
Object.defineProperty(exports, "InlayHintRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } }));
Object.defineProperty(exports, "InlayHintResolveRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } }));
Object.defineProperty(exports, "InlayHintRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } }));
const protocol_diagnostic_1 = __webpack_require__(/*! ./protocol.diagnostic */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js");
Object.defineProperty(exports, "DiagnosticServerCancellationData", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } }));
Object.defineProperty(exports, "DocumentDiagnosticReportKind", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } }));
Object.defineProperty(exports, "DocumentDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } }));
Object.defineProperty(exports, "WorkspaceDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } }));
Object.defineProperty(exports, "DiagnosticRefreshRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } }));
const protocol_notebook_1 = __webpack_require__(/*! ./protocol.notebook */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js");
Object.defineProperty(exports, "NotebookCellKind", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } }));
Object.defineProperty(exports, "ExecutionSummary", ({ enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } }));
Object.defineProperty(exports, "NotebookCell", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } }));
Object.defineProperty(exports, "NotebookDocument", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } }));
Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } }));
Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } }));
Object.defineProperty(exports, "NotebookCellArrayChange", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } }));
Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var TextDocumentFilter;
(function (TextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    TextDocumentFilter.is = is;
})(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookDocumentFilter;
(function (NotebookDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter.is = is;
})(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookCellTextDocumentFilter;
(function (NotebookCellTextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
            && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter.is = is;
})(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.method = 'client/registerCapability';
    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.method = 'client/unregisterCapability';
    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
var PositionEncodingKind;
(function (PositionEncodingKind) {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    PositionEncodingKind.UTF8 = 'utf-8';
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    PositionEncodingKind.UTF16 = 'utf-16';
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    PositionEncodingKind.UTF32 = 'utf-32';
})(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.method = 'initialize';
    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeErrorCodes`;
 */
var InitializeErrorCodes;
(function (InitializeErrorCodes) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeErrorCodes.unknownProtocolVersion = 1;
})(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.method = 'initialized';
    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.method = 'shutdown';
    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.method = 'exit';
    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.method = 'window/showMessage';
    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.method = 'window/showMessageRequest';
    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.method = 'window/logMessage';
    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.method = 'telemetry/event';
    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var RelativePattern;
(function (RelativePattern) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern.is = is;
})(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */
var WorkspaceSymbolResolveRequest;
(function (WorkspaceSymbolResolveRequest) {
    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
})(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.method = 'workspace/executeCommand';
    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/node.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotatedTextEdit: () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   ChangeAnnotation: () => (/* binding */ ChangeAnnotation),
/* harmony export */   ChangeAnnotationIdentifier: () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   CodeAction: () => (/* binding */ CodeAction),
/* harmony export */   CodeActionContext: () => (/* binding */ CodeActionContext),
/* harmony export */   CodeActionKind: () => (/* binding */ CodeActionKind),
/* harmony export */   CodeActionTriggerKind: () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   CodeDescription: () => (/* binding */ CodeDescription),
/* harmony export */   CodeLens: () => (/* binding */ CodeLens),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   ColorInformation: () => (/* binding */ ColorInformation),
/* harmony export */   ColorPresentation: () => (/* binding */ ColorPresentation),
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   CompletionItem: () => (/* binding */ CompletionItem),
/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),
/* harmony export */   CompletionItemLabelDetails: () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),
/* harmony export */   CompletionList: () => (/* binding */ CompletionList),
/* harmony export */   CreateFile: () => (/* binding */ CreateFile),
/* harmony export */   DeleteFile: () => (/* binding */ DeleteFile),
/* harmony export */   Diagnostic: () => (/* binding */ Diagnostic),
/* harmony export */   DiagnosticRelatedInformation: () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   DiagnosticSeverity: () => (/* binding */ DiagnosticSeverity),
/* harmony export */   DiagnosticTag: () => (/* binding */ DiagnosticTag),
/* harmony export */   DocumentHighlight: () => (/* binding */ DocumentHighlight),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   DocumentLink: () => (/* binding */ DocumentLink),
/* harmony export */   DocumentSymbol: () => (/* binding */ DocumentSymbol),
/* harmony export */   DocumentUri: () => (/* binding */ DocumentUri),
/* harmony export */   EOL: () => (/* binding */ EOL),
/* harmony export */   FoldingRange: () => (/* binding */ FoldingRange),
/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),
/* harmony export */   FormattingOptions: () => (/* binding */ FormattingOptions),
/* harmony export */   Hover: () => (/* binding */ Hover),
/* harmony export */   InlayHint: () => (/* binding */ InlayHint),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlayHintLabelPart: () => (/* binding */ InlayHintLabelPart),
/* harmony export */   InlineValueContext: () => (/* binding */ InlineValueContext),
/* harmony export */   InlineValueEvaluatableExpression: () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   InlineValueText: () => (/* binding */ InlineValueText),
/* harmony export */   InlineValueVariableLookup: () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   InsertReplaceEdit: () => (/* binding */ InsertReplaceEdit),
/* harmony export */   InsertTextFormat: () => (/* binding */ InsertTextFormat),
/* harmony export */   InsertTextMode: () => (/* binding */ InsertTextMode),
/* harmony export */   Location: () => (/* binding */ Location),
/* harmony export */   LocationLink: () => (/* binding */ LocationLink),
/* harmony export */   MarkedString: () => (/* binding */ MarkedString),
/* harmony export */   MarkupContent: () => (/* binding */ MarkupContent),
/* harmony export */   MarkupKind: () => (/* binding */ MarkupKind),
/* harmony export */   OptionalVersionedTextDocumentIdentifier: () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   ParameterInformation: () => (/* binding */ ParameterInformation),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   Range: () => (/* binding */ Range),
/* harmony export */   RenameFile: () => (/* binding */ RenameFile),
/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),
/* harmony export */   SemanticTokenModifiers: () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   SemanticTokenTypes: () => (/* binding */ SemanticTokenTypes),
/* harmony export */   SemanticTokens: () => (/* binding */ SemanticTokens),
/* harmony export */   SignatureInformation: () => (/* binding */ SignatureInformation),
/* harmony export */   SymbolInformation: () => (/* binding */ SymbolInformation),
/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),
/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),
/* harmony export */   TextDocument: () => (/* binding */ TextDocument),
/* harmony export */   TextDocumentEdit: () => (/* binding */ TextDocumentEdit),
/* harmony export */   TextDocumentIdentifier: () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   TextDocumentItem: () => (/* binding */ TextDocumentItem),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   VersionedTextDocumentIdentifier: () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   WorkspaceChange: () => (/* binding */ WorkspaceChange),
/* harmony export */   WorkspaceEdit: () => (/* binding */ WorkspaceEdit),
/* harmony export */   WorkspaceFolder: () => (/* binding */ WorkspaceFolder),
/* harmony export */   WorkspaceSymbol: () => (/* binding */ WorkspaceSymbol),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   uinteger: () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name: name, kind: kind, location: { uri: uri, range: range } }
            : { name: name, kind: kind, location: { uri: uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range: range, text: text };
    }
    InlineValueText.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range: range, expression: expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId: frameId, stoppedLocation: stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value: value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        var result = { position: position, label: label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/api.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "./node_modules/vscode-languageserver/lib/common/semanticTokens.js");
Object.defineProperty(exports, "SemanticTokensBuilder", ({ enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } }));
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/ */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js"), exports);
const textDocuments_1 = __webpack_require__(/*! ./textDocuments */ "./node_modules/vscode-languageserver/lib/common/textDocuments.js");
Object.defineProperty(exports, "TextDocuments", ({ enumerable: true, get: function () { return textDocuments_1.TextDocuments; } }));
const notebook_1 = __webpack_require__(/*! ./notebook */ "./node_modules/vscode-languageserver/lib/common/notebook.js");
Object.defineProperty(exports, "NotebookDocuments", ({ enumerable: true, get: function () { return notebook_1.NotebookDocuments; } }));
__exportStar(__webpack_require__(/*! ./server */ "./node_modules/vscode-languageserver/lib/common/server.js"), exports);
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features',
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/callHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/callHierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.CallHierarchyFeature = CallHierarchyFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver/lib/common/utils/is.js");
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                if (Array.isArray(result)) {
                    return Array.isArray(arg) ? result : result[0];
                }
                else {
                    return Array.isArray(arg) ? [] : null;
                }
            });
        }
    };
};
exports.ConfigurationFeature = ConfigurationFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/diagnostic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/diagnostic.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const DiagnosticFeature = (Base) => {
    return class extends Base {
        get diagnostics() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
                    });
                },
                onWorkspace: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
                    });
                }
            };
        }
    };
};
exports.DiagnosticFeature = DiagnosticFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/fileOperations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/fileOperations.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
exports.FileOperationsFeature = FileOperationsFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/inlayHint.js":
/*!********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/inlayHint.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const InlayHintFeature = (Base) => {
    return class extends Base {
        get inlayHint() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params));
                    });
                },
                resolve: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                        return handler(params, cancel);
                    });
                }
            };
        }
    };
};
exports.InlayHintFeature = InlayHintFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/inlineValue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/inlineValue.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const InlineValueFeature = (Base) => {
    return class extends Base {
        get inlineValue() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params));
                    });
                }
            };
        }
    };
};
exports.InlineValueFeature = InlineValueFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/linkedEditingRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/linkedEditingRange.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/moniker.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/moniker.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
exports.MonikerFeature = MonikerFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/notebook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/notebook.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocuments = exports.NotebookSyncFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const textDocuments_1 = __webpack_require__(/*! ./textDocuments */ "./node_modules/vscode-languageserver/lib/common/textDocuments.js");
const NotebookSyncFeature = (Base) => {
    return class extends Base {
        get synchronization() {
            return {
                onDidOpenNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidChangeNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidSaveNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidCloseNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                }
            };
        }
    };
};
exports.NotebookSyncFeature = NotebookSyncFeature;
class CellTextDocumentConnection {
    onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });
    }
    openTextDocument(params) {
        this.openHandler && this.openHandler(params);
    }
    onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });
    }
    changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
    }
    onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });
    }
    closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
    }
    onWillSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onWillSaveTextDocumentWaitUntil() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onDidSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
}
CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });
class NotebookDocuments {
    constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
        }
        else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = new Map();
        this.notebookCellMap = new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
    }
    get cellTextDocuments() {
        return this._cellTextDocuments;
    }
    getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
    }
    getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
    }
    getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
    }
    findNotebookDocumentForCell(cell) {
        const key = typeof cell === 'string' ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
    }
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    get onDidSave() {
        return this._onDidSave.event;
    }
    get onDidChange() {
        return this._onDidChange.event;
    }
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the notebook documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
     *  and `onDidCloseNotebookDocument`.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== undefined) {
                metadataChanged = true;
                notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== undefined) {
                const changedCells = change.cells;
                if (changedCells.structure !== undefined) {
                    const array = changedCells.structure.array;
                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));
                    // Additional open cell text documents.
                    if (changedCells.structure.didOpen !== undefined) {
                        for (const open of changedCells.structure.didOpen) {
                            cellTextDocumentConnection.openTextDocument({ textDocument: open });
                            opened.push(open.uri);
                        }
                    }
                    // Additional closed cell test documents.
                    if (changedCells.structure.didClose) {
                        for (const close of changedCells.structure.didClose) {
                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                            closed.push(close.uri);
                        }
                    }
                }
                if (changedCells.data !== undefined) {
                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));
                    for (let i = 0; i <= notebookDocument.cells.length; i++) {
                        const change = cellUpdates.get(notebookDocument.cells[i].document);
                        if (change !== undefined) {
                            const old = notebookDocument.cells.splice(i, 1, change);
                            data.push({ old: old[0], new: change });
                            cellUpdates.delete(change.document);
                            if (cellUpdates.size === 0) {
                                break;
                            }
                        }
                    }
                }
                if (changedCells.textContent !== undefined) {
                    for (const cellTextDocument of changedCells.textContent) {
                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                        text.push(cellTextDocument.document.uri);
                    }
                }
            }
            // Update internal data structure.
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
                added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
                removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change of text) {
                textContent.push(this.getNotebookCell(change));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
                changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {
                this._onDidChange.fire(changeEvent);
            }
        }));
        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
                this.notebookCellMap.delete(cell.document);
            }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
    }
    updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
    }
}
exports.NotebookDocuments = NotebookDocuments;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/progress.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/progress.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageserver/lib/common/utils/uuid.js");
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = (0, uuid_1.generateUuid)();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
exports.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/semanticTokens.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/semanticTokens.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
                },
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensDiff {
    constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
    }
    computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            // if one moved behind the start index move them forward again
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
                originalEndIndex++;
                modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            // If we moved behind the start index we could have missed a simple delete.
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
                return [
                    { start: startIndex, deleteCount: deleteCount - 1 }
                ];
            }
            else {
                return [
                    { start: startIndex, deleteCount, data: newData }
                ];
            }
        }
        else if (startIndex < modifiedLength) {
            return [
                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
        }
        else if (startIndex < originalLength) {
            return [
                { start: startIndex, deleteCount: originalLength - startIndex }
            ];
        }
        else {
            // The two arrays are the same.
            return [];
        }
    }
}
exports.SemanticTokensDiff = SemanticTokensDiff;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            return {
                resultId: this.id,
                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()
            };
        }
        else {
            return this.build();
        }
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/server.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/server.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver/lib/common/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageserver/lib/common/utils/uuid.js");
const progress_1 = __webpack_require__(/*! ./progress */ "./node_modules/vscode-languageserver/lib/common/progress.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./node_modules/vscode-languageserver/lib/common/configuration.js");
const workspaceFolder_1 = __webpack_require__(/*! ./workspaceFolder */ "./node_modules/vscode-languageserver/lib/common/workspaceFolder.js");
const callHierarchy_1 = __webpack_require__(/*! ./callHierarchy */ "./node_modules/vscode-languageserver/lib/common/callHierarchy.js");
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "./node_modules/vscode-languageserver/lib/common/semanticTokens.js");
const showDocument_1 = __webpack_require__(/*! ./showDocument */ "./node_modules/vscode-languageserver/lib/common/showDocument.js");
const fileOperations_1 = __webpack_require__(/*! ./fileOperations */ "./node_modules/vscode-languageserver/lib/common/fileOperations.js");
const linkedEditingRange_1 = __webpack_require__(/*! ./linkedEditingRange */ "./node_modules/vscode-languageserver/lib/common/linkedEditingRange.js");
const typeHierarchy_1 = __webpack_require__(/*! ./typeHierarchy */ "./node_modules/vscode-languageserver/lib/common/typeHierarchy.js");
const inlineValue_1 = __webpack_require__(/*! ./inlineValue */ "./node_modules/vscode-languageserver/lib/common/inlineValue.js");
const inlayHint_1 = __webpack_require__(/*! ./inlayHint */ "./node_modules/vscode-languageserver/lib/common/inlayHint.js");
const diagnostic_1 = __webpack_require__(/*! ./diagnostic */ "./node_modules/vscode-languageserver/lib/common/diagnostic.js");
const notebook_1 = __webpack_require__(/*! ./notebook */ "./node_modules/vscode-languageserver/lib/common/notebook.js");
const moniker_1 = __webpack_require__(/*! ./moniker */ "./node_modules/vscode-languageserver/lib/common/moniker.js");
function null2Undefined(value) {
    if (value === null) {
        return undefined;
    }
    return value;
}
/**
 * Helps tracking error message. Equal occurrences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        }).catch(() => {
            // Very hard to decide what to do. We tried to send a log
            // message which failed so we can't simply send another :-(.
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
    }
}
class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
    }
}
exports._LanguagesImpl = _LanguagesImpl;
const LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
class _NotebooksImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
    }
}
exports._NotebooksImpl = _NotebooksImpl;
const NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineLanguagesFeatures = combineLanguagesFeatures;
function combineNotebooksFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineNotebooksFeatures = combineNotebooksFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(connectionFactory, watchDog, factories) {
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                return connection.sendNotification(method);
            }
            else {
                return connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => {
            initializeHandler = handler;
            return {
                dispose: () => {
                    initializeHandler = undefined;
                }
            };
        },
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
                dispose: () => {
                    shutdownHandler = undefined;
                }
            };
        },
        onExit: (handler) => {
            exitHandler = handler;
            return {
                dispose: () => {
                    exitHandler = undefined;
                }
            };
        },
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        get notebooks() { return notebooks; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (watchDog.shutdownReceived) {
                watchDog.exit(0);
            }
            else {
                watchDog.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
exports.createConnection = createConnection;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/showDocument.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/showDocument.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
    };
};
exports.ShowDocumentFeature = ShowDocumentFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/textDocuments.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/textDocuments.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextDocuments = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
/**
 * A manager for simple text documents. The manager requires at a minimum that
 * the server registered for the following text document sync events in the
 * initialize handler or via dynamic registration:
 *
 * - open and close events.
 * - change events.
 *
 * Registering for save and will save events is optional.
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._syncedDocuments.get(uri);
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Array.from(this._syncedDocuments.values());
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Array.from(this._syncedDocuments.keys());
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document);
            const toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            const { version } = td;
            if (version === null || version === undefined) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== undefined) {
                syncedDocument = this._configuration.update(syncedDocument, changes, version);
                this._syncedDocuments.set(td.uri, syncedDocument);
                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        disposables.push(connection.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._syncedDocuments.delete(event.textDocument.uri);
                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        disposables.push(connection.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
        }));
        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            }
            else {
                return [];
            }
        }));
        disposables.push(connection.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
    }
}
exports.TextDocuments = TextDocuments;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/typeHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/typeHierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const TypeHierarchyFeature = (Base) => {
    return class extends Base {
        get typeHierarchy() {
            return {
                onPrepare: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onSupertypes: (handler) => {
                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onSubtypes: (handler) => {
                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.TypeHierarchyFeature = TypeHierarchyFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/utils/is.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/utils/is.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/utils/uuid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/utils/uuid.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/workspaceFolder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/workspaceFolder.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/node/files.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/node/files.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = (0, child_process_1.fork)('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    const env = Object.create(null);
    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
    env['NO_UPDATE_NOTIFIER'] = 'true';
    const options = {
        encoding: 'utf8',
        env
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;


/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/node/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/node/main.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.Files = void 0;
const Is = __webpack_require__(/*! ../common/utils/is */ "./node_modules/vscode-languageserver/lib/common/utils/is.js");
const server_1 = __webpack_require__(/*! ../common/server */ "./node_modules/vscode-languageserver/lib/common/server.js");
const fm = __webpack_require__(/*! ./files */ "./node_modules/vscode-languageserver/lib/node/files.js");
const node_1 = __webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js");
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageserver/lib/common/api.js"), exports);
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let _protocolConnection;
function endProtocolConnection() {
    if (_protocolConnection === undefined) {
        return;
    }
    try {
        _protocolConnection.end();
    }
    catch (_err) {
        // Ignore. The client process could have already
        // did and we can't send an end into the connection.
    }
}
let _shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        endProtocolConnection();
                        process.exit(_shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
const watchDog = {
    initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === undefined) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(_shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
    },
    get shutdownReceived() {
        return _shutdownReceived;
    },
    set shutdownReceived(value) {
        _shutdownReceived = value;
    },
    exit: (code) => {
        endProtocolConnection();
        process.exit(code);
    }
};
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let options;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        options = arg3;
    }
    return _createConnection(input, output, options, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, options, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new node_1.IPCMessageReader(process);
                output = new node_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = (0, node_1.createServerSocketTransport)(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = (0, node_1.createServerPipeTransport)(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
    }
    const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        return result;
    };
    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
}


/***/ }),

/***/ "./node_modules/vscode-languageserver/node.js":
/*!****************************************************!*\
  !*** ./node_modules/vscode-languageserver/node.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageserver/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-uri/lib/umd/index.js":
/*!**************************************************!*\
  !*** ./node_modules/vscode-uri/lib/umd/index.js ***!
  \**************************************************/
/***/ (function(module) {

!function(t,e){if(true)module.exports=e();else { var n, r; }}(this,(()=>(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else{if(47===r)break;r=47}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){-1===h?(n="",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=a,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2)}else n.length>0?n+="/"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u)}var d="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+="..":d+="/..");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===h&&(s=!1,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h))}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===i&&(o=!1,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,a=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return-1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},674:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:!0}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf("Windows")>=0}},796:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.uriToFsPath=e.URI=void 0;const n=r(674),i=/^\w[\w\d+.-]*$/,o=/^\//,s=/^\/\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!i.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const h="",c="/",f=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==c&&(e=c+e):e=c}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o))}get fsPath(){return v(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=!1){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c)}return new d("file",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\//g,"\\")),r}function y(t,e){const r=e?m:g;let n="",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=c,n+=c),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=":",n+=r(e.substr(t+1),!1,!0)),n+="@"}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return a&&(n+="?",n+=r(a,!1,!1)),h&&(n+="#",n+=e?h:g(h,!1,!1)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},679:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=void 0;const s=o(r(470)),a=s.posix||s,h="/";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==h&&(r=h+r,n=!0);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)}}(c||(e.Utils=c={}))}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Utils=t.URI=void 0;const e=r(796);Object.defineProperty(t,"URI",{enumerable:!0,get:function(){return e.URI}});const i=r(679);Object.defineProperty(t,"Utils",{enumerable:!0,get:function(){return i.Utils}})})(),n})()));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    function noop() {
        return undefined;
    }

    function typeIsObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    const rethrowAssertionErrorRejection = noop;
    function setFunctionName(fn, name) {
        try {
            Object.defineProperty(fn, 'name', {
                value: name,
                configurable: true
            });
        }
        catch (_a) {
            // This property is non-configurable in older browsers, so ignore if this throws.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
        }
    }

    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    // https://webidl.spec.whatwg.org/#a-new-promise
    function newPromise(executor) {
        return new originalPromise(executor);
    }
    // https://webidl.spec.whatwg.org/#a-promise-resolved-with
    function promiseResolvedWith(value) {
        return newPromise(resolve => resolve(value));
    }
    // https://webidl.spec.whatwg.org/#a-promise-rejected-with
    function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned
    // from that handler. To prevent this, return null instead of void from all handlers.
    // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it
    function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    let _queueMicrotask = callback => {
        if (typeof queueMicrotask === 'function') {
            _queueMicrotask = queueMicrotask;
        }
        else {
            const resolvedPromise = promiseResolvedWith(undefined);
            _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
    };
    function reflectCall(F, V, args) {
        if (typeof F !== 'function') {
            throw new TypeError('Argument is not a function');
        }
        return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
        try {
            return promiseResolvedWith(reflectCall(F, V, args));
        }
        catch (value) {
            return promiseRejectedWith(value);
        }
    }

    // Original from Chromium
    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
    const QUEUE_MAX_ARRAY_SIZE = 16384;
    /**
     * Simple queue structure.
     *
     * Avoids scalability issues with using a packed array directly by using
     * multiple arrays in a linked list and keeping the array size bounded.
     */
    class SimpleQueue {
        constructor() {
            this._cursor = 0;
            this._size = 0;
            // _front and _back are always defined.
            this._front = {
                _elements: [],
                _next: undefined
            };
            this._back = this._front;
            // The cursor is used to avoid calling Array.shift().
            // It contains the index of the front element of the array inside the
            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
            this._cursor = 0;
            // When there is only one node, size === elements.length - cursor.
            this._size = 0;
        }
        get length() {
            return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                    _elements: [],
                    _next: undefined
                };
            }
            // push() is the mutation most likely to throw an exception, so it
            // goes first.
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
            }
            ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() { // must not be called on an empty queue
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
            }
            // No mutations before this point.
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
                this._front = newFront;
            }
            // Permit shifted element to be garbage collected.
            elements[oldCursor] = undefined;
            return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== undefined) {
                if (i === elements.length) {
                    node = node._next;
                    elements = node._elements;
                    i = 0;
                    if (elements.length === 0) {
                        break;
                    }
                }
                callback(elements[i]);
                ++i;
            }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() { // must not be called on an empty queue
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
        }
    }

    const AbortSteps = Symbol('[[AbortSteps]]');
    const ErrorSteps = Symbol('[[ErrorSteps]]');
    const CancelSteps = Symbol('[[CancelSteps]]');
    const PullSteps = Symbol('[[PullSteps]]');
    const ReleaseSteps = Symbol('[[ReleaseSteps]]');

    function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseInitialize(reader);
        }
        else if (stream._state === 'closed') {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
        }
        else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
    }
    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
    // check.
    function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = undefined;
        reader._ownerReadableStream = undefined;
    }
    // Helper functions for the readers.
    function readerLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released reader');
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
        });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
            return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
    const NumberIsFinite = Number.isFinite || function (x) {
        return typeof x === 'number' && isFinite(x);
    };

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
    const MathTrunc = Math.trunc || function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };

    // https://heycam.github.io/webidl/#idl-dictionaries
    function isDictionary(x) {
        return typeof x === 'object' || typeof x === 'function';
    }
    function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-callback-functions
    function assertFunction(x, context) {
        if (typeof x !== 'function') {
            throw new TypeError(`${context} is not a function.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-object
    function isObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    function assertObject(x, context) {
        if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
    }
    function assertRequiredField(x, field, context) {
        if (x === undefined) {
            throw new TypeError(`${field} is required in '${context}'.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-unrestricted-double
    function convertUnrestrictedDouble(value) {
        return Number(value);
    }
    function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
    }
    function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
    }
    // https://heycam.github.io/webidl/#idl-unsigned-long-long
    function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x) || x === 0) {
            return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
    }

    function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
        }
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
            readRequest._closeSteps();
        }
        else {
            readRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A default reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamDefaultReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('read'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: () => resolvePromise({ value: undefined, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            ReadableStreamDefaultReaderRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');
    setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');
    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamDefaultReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'closed') {
            readRequest._closeSteps();
        }
        else if (stream._state === 'errored') {
            readRequest._errorSteps(stream._storedError);
        }
        else {
            stream._readableStreamController[PullSteps](readRequest);
        }
    }
    function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError('Reader was released');
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
    }
    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach(readRequest => {
            readRequest._errorSteps(e);
        });
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }

    /// <reference lib="es2018.asynciterable" />
    /* eslint-disable @typescript-eslint/no-empty-function */
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);

    /// <reference lib="es2018.asynciterable" />
    class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
            this._ongoingPromise = undefined;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
        }
        next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :
                nextSteps();
            return this._ongoingPromise;
        }
        return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :
                returnSteps();
        }
        _nextSteps() {
            if (this._isFinished) {
                return Promise.resolve({ value: undefined, done: true });
            }
            const reader = this._reader;
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => {
                    this._ongoingPromise = undefined;
                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
                    // FIXME Is this a bug in the specification, or in the test?
                    _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
                },
                _closeSteps: () => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    resolvePromise({ value: undefined, done: true });
                },
                _errorSteps: reason => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    rejectPromise(reason);
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
        }
        _returnSteps(value) {
            if (this._isFinished) {
                return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (!this._preventCancel) {
                const result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
        }
    }
    const ReadableStreamAsyncIteratorPrototype = {
        next() {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
            }
            return this._asyncIteratorImpl.next();
        },
        return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
            }
            return this._asyncIteratorImpl.return(value);
        }
    };
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
            return false;
        }
        try {
            // noinspection SuspiciousTypeOfGuard
            return x._asyncIteratorImpl instanceof
                ReadableStreamAsyncIteratorImpl;
        }
        catch (_a) {
            return false;
        }
    }
    // Helper functions for the ReadableStream.
    function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
    const NumberIsNaN = Number.isNaN || function (x) {
        // eslint-disable-next-line no-self-compare
        return x !== x;
    };

    var _a, _b, _c;
    function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === 'function') {
            TransferArrayBuffer = buffer => buffer.transfer();
        }
        else if (typeof structuredClone === 'function') {
            TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });
        }
        else {
            // Not implemented correctly
            TransferArrayBuffer = buffer => buffer;
        }
        return TransferArrayBuffer(O);
    };
    let IsDetachedBuffer = (O) => {
        if (typeof O.detached === 'boolean') {
            IsDetachedBuffer = buffer => buffer.detached;
        }
        else {
            // Not implemented correctly
            IsDetachedBuffer = buffer => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
    };
    function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
            return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
    }
    function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === undefined || func === null) {
            return undefined;
        }
        if (typeof func !== 'function') {
            throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
    }
    function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,
        // we use yield* inside an async generator function to achieve the same result.
        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.
        const syncIterable = {
            [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        // Create an async generator function and immediately invoke it.
        const asyncIterator = (async function* () {
            return yield* syncIterable;
        }());
        // Return as an async iterator record.
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
    }
    // Aligns with core-js/modules/es.symbol.async-iterator.js
    const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, 'Symbol.asyncIterator')) !== null && _c !== void 0 ? _c : '@@asyncIterator';
    function GetIterator(obj, hint = 'sync', method) {
        if (method === undefined) {
            if (hint === 'async') {
                method = GetMethod(obj, SymbolAsyncIterator);
                if (method === undefined) {
                    const syncMethod = GetMethod(obj, Symbol.iterator);
                    const syncIteratorRecord = GetIterator(obj, 'sync', syncMethod);
                    return CreateAsyncFromSyncIterator(syncIteratorRecord);
                }
            }
            else {
                method = GetMethod(obj, Symbol.iterator);
            }
        }
        if (method === undefined) {
            throw new TypeError('The object is not iterable');
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
            throw new TypeError('The iterator method must return an object');
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
    }
    function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
            throw new TypeError('The iterator.next() method must return an object');
        }
        return result;
    }
    function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
    }
    function IteratorValue(iterResult) {
        return iterResult.value;
    }

    function IsNonNegativeNumber(v) {
        if (typeof v !== 'number') {
            return false;
        }
        if (NumberIsNaN(v)) {
            return false;
        }
        if (v < 0) {
            return false;
        }
        return true;
    }
    function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
    }

    function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
        }
        return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
    }
    function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
    }

    function isDataViewConstructor(ctor) {
        return ctor === DataView;
    }
    function isDataView(view) {
        return isDataViewConstructor(view.constructor);
    }
    function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
            return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
    }

    /**
     * A pull-into request in a {@link ReadableByteStreamController}.
     *
     * @public
     */
    class ReadableStreamBYOBRequest {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('view');
            }
            return this._view;
        }
        respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respond');
            }
            assertRequiredArgument(bytesWritten, 1, 'respond');
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(this._view.buffer)) {
                throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
            }
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respondWithNewView');
            }
            assertRequiredArgument(view, 1, 'respondWithNewView');
            if (!ArrayBuffer.isView(view)) {
                throw new TypeError('You can only respond with array buffer views');
            }
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(view.buffer)) {
                throw new TypeError('The given view\'s buffer has been detached and so cannot be used as a response');
            }
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');
    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamBYOBRequest',
            configurable: true
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableByteStreamController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('byobRequest');
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('desiredSize');
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('close');
            }
            if (this._closeRequested) {
                throw new TypeError('The stream has already been closed; do not close it again!');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('enqueue');
            }
            assertRequiredArgument(chunk, 1, 'enqueue');
            if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError('chunk must be an array buffer view');
            }
            if (chunk.byteLength === 0) {
                throw new TypeError('chunk must have non-zero byteLength');
            }
            if (chunk.buffer.byteLength === 0) {
                throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
                throw new TypeError('stream is closed or draining');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('error');
            }
            ReadableByteStreamControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
                ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
                return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== undefined) {
                let buffer;
                try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                }
                catch (bufferE) {
                    readRequest._errorSteps(bufferE);
                    return;
                }
                const pullIntoDescriptor = {
                    buffer,
                    bufferByteLength: autoAllocateChunkSize,
                    byteOffset: 0,
                    byteLength: autoAllocateChunkSize,
                    bytesFilled: 0,
                    minimumFill: 1,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: 'default'
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
            if (this._pendingPullIntos.length > 0) {
                const firstPullInto = this._pendingPullIntos.peek();
                firstPullInto.readerType = 'none';
                this._pendingPullIntos = new SimpleQueue();
                this._pendingPullIntos.push(firstPullInto);
            }
        }
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableByteStreamController.prototype.close, 'close');
    setFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');
    setFunctionName(ReadableByteStreamController.prototype.error, 'error');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
            value: 'ReadableByteStreamController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableByteStreamController.
    function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
            return false;
        }
        return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
            return null;
        }, e => {
            ReadableByteStreamControllerError(controller, e);
            return null;
        });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === 'closed') {
            done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'default') {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
        }
        else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
            clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        }
        catch (cloneE) {
            ReadableByteStreamControllerError(controller, cloneE);
            throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
    }
    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
        // of the queue, so the underlying source can keep filling it.
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
            }
            else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
        }
        else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
            return;
        }
        controller._byobRequest._associatedReadableByteStreamController = undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            const readRequest = reader._readRequests.shift();
            ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
    }
    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
            buffer = TransferArrayBuffer(view.buffer);
        }
        catch (e) {
            readIntoRequest._errorSteps(e);
            return;
        }
        const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset,
            byteLength,
            bytesFilled: 0,
            minimumFill,
            elementSize,
            viewConstructor: ctor,
            readerType: 'byob'
        };
        if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
            // - No change happens on desiredSize
            // - The source has already been notified of that there's at least 1 pending read(view)
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
        }
        if (stream._state === 'closed') {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
        }
        if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
            }
            if (controller._closeRequested) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                readIntoRequest._errorSteps(e);
                return;
            }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === 'none') {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'none') {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
            return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
            // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
            // of the queue, so the underlying source can keep filling it.
            return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        }
        else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return false;
        }
        if (controller._closeRequested) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
    function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
        }
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                throw e;
            }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
            throw new TypeError('chunk\'s buffer is detached and so cannot be enqueued');
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
                throw new TypeError('The BYOB request\'s buffer has been detached and so cannot be filled with an enqueued chunk');
            }
            ReadableByteStreamControllerInvalidateBYOBRequest(controller);
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
            if (firstPendingPullInto.readerType === 'none') {
                ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
            }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
            ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            }
            else {
                if (controller._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
        }
        else if (ReadableStreamHasBYOBReader(stream)) {
            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (bytesWritten !== 0) {
                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
            }
        }
        else {
            if (bytesWritten === 0) {
                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError('bytesWritten out of range');
            }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (view.byteLength !== 0) {
                throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
            }
        }
        else {
            if (view.byteLength === 0) {
                throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
            }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError('The region specified by view does not match byobRequest');
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError('The buffer of view has different capacity than byobRequest');
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError('The region specified by view is larger than byobRequest');
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
            return null;
        }, r => {
            ReadableByteStreamControllerError(controller, r);
            return null;
        });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== undefined) {
            startAlgorithm = () => underlyingByteSource.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingByteSource.pull !== undefined) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        else {
            pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingByteSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
            throw new TypeError('autoAllocateChunkSize must be greater than 0');
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
    }
    // Helper functions for the ReadableStreamBYOBRequest.
    function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    // Helper functions for the ReadableByteStreamController.
    function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }

    function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
    }
    function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== 'byob') {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
    }
    function convertByobReadOptions(options, context) {
        var _a;
        assertDictionary(options, context);
        const min = (_a = options === null || options === void 0 ? void 0 : options.min) !== null && _a !== void 0 ? _a : 1;
        return {
            min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
            readIntoRequest._closeSteps(chunk);
        }
        else {
            readIntoRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A BYOB reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamBYOBReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +
                    'source');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('read'));
            }
            if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError('view must be an array buffer view'));
            }
            if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
            }
            if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer)) {
                return promiseRejectedWith(new TypeError('view\'s buffer has been detached'));
            }
            let options;
            try {
                options = convertByobReadOptions(rawOptions, 'options');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const min = options.min;
            if (min === 0) {
                return promiseRejectedWith(new TypeError('options.min must be greater than 0'));
            }
            if (!isDataView(view)) {
                if (min > view.length) {
                    return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\'s length'));
                }
            }
            else if (min > view.byteLength) {
                return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\'s byteLength'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readIntoRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            ReadableStreamBYOBReaderRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');
    setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');
    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamBYOBReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'errored') {
            readIntoRequest._errorSteps(stream._storedError);
        }
        else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
    }
    function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError('Reader was released');
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
    }
    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach(readIntoRequest => {
            readIntoRequest._errorSteps(e);
        });
    }
    // Helper functions for the ReadableStreamBYOBReader.
    function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }

    function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === undefined) {
            return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError('Invalid highWaterMark');
        }
        return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
            return () => 1;
        }
        return size;
    }

    function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
    }
    function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return chunk => convertUnrestrictedDouble(fn(chunk));
    }

    function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
            abort: abort === undefined ?
                undefined :
                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === undefined ?
                undefined :
                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === undefined ?
                undefined :
                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
        };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }

    function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
        }
    }

    function isAbortSignal(value) {
        if (typeof value !== 'object' || value === null) {
            return false;
        }
        try {
            return typeof value.aborted === 'boolean';
        }
        catch (_a) {
            // AbortSignal.prototype.aborted throws if its brand check fails
            return false;
        }
    }
    const supportsAbortController = typeof AbortController === 'function';
    /**
     * Construct a new AbortController, if supported by the platform.
     *
     * @internal
     */
    function createAbortController() {
        if (supportsAbortController) {
            return new AbortController();
        }
        return undefined;
    }

    /**
     * A writable stream represents a destination for data, into which you can write.
     *
     * @public
     */
    class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === undefined) {
                rawUnderlyingSink = null;
            }
            else {
                assertObject(rawUnderlyingSink, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== undefined) {
                throw new RangeError('Invalid type is specified');
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('locked');
            }
            return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = undefined) {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('abort'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
            }
            return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('close'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('getWriter');
            }
            return AcquireWritableStreamDefaultWriter(this);
        }
    }
    Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
    });
    setFunctionName(WritableStream.prototype.abort, 'abort');
    setFunctionName(WritableStream.prototype.close, 'close');
    setFunctionName(WritableStream.prototype.getWriter, 'getWriter');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
            value: 'WritableStream',
            configurable: true
        });
    }
    // Abstract operations for the WritableStream.
    function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
    }
    // Throws if and only if startAlgorithm throws.
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    function InitializeWritableStream(stream) {
        stream._state = 'writable';
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
    }
    function IsWritableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
            return false;
        }
        return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === 'closed' || stream._state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(reason);
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
            return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === 'erroring') {
            wasAlreadyErroring = true;
            // reason will not be used, so don't keep a reference to it.
            reason = undefined;
        }
        const promise = newPromise((resolve, reject) => {
            stream._pendingAbortRequest = {
                _promise: undefined,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
            };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
        }
        return promise;
    }
    function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
            const closeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== undefined && stream._backpressure && state === 'writable') {
            defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
    }
    // WritableStream API exposed for controllers.
    function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
            const writeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._writeRequests.push(writeRequest);
        });
        return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === 'writable') {
            WritableStreamStartErroring(stream, error);
            return;
        }
        WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = 'erroring';
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== undefined) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
        }
    }
    function WritableStreamFinishErroring(stream) {
        stream._state = 'errored';
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach(writeRequest => {
            writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
        }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
        });
    }
    function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        const state = stream._state;
        if (state === 'erroring') {
            // The error was too late to do anything, so it is ignored.
            stream._storedError = undefined;
            if (stream._pendingAbortRequest !== undefined) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = undefined;
            }
        }
        stream._state = 'closed';
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseResolve(writer);
        }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
    }
    // TODO(ricea): Fix alphabetical order.
    function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = undefined;
        }
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
            if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
            }
            else {
                defaultWriterReadyPromiseResolve(writer);
            }
        }
        stream._backpressure = backpressure;
    }
    /**
     * A default writer vended by a {@link WritableStream}.
     *
     * @public
     */
    class WritableStreamDefaultWriter {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
            assertWritableStream(stream, 'First parameter');
            if (IsWritableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive writing by another writer');
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === 'writable') {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                    defaultWriterReadyPromiseInitialize(this);
                }
                else {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'erroring') {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'closed') {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
            }
            else {
                const storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('desiredSize');
            }
            if (this._ownerWritableStream === undefined) {
                throw defaultWriterLockException('desiredSize');
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
            }
            return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('abort'));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('close'));
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('close'));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('releaseLock');
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return;
            }
            WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('write'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('write to'));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
        }
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
    });
    setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');
    setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');
    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');
    setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
            value: 'WritableStreamDefaultWriter',
            configurable: true
        });
    }
    // Abstract operations for the WritableStreamDefaultWriter.
    function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultWriter;
    }
    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
    function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === 'pending') {
            defaultWriterClosedPromiseReject(writer, error);
        }
        else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === 'pending') {
            defaultWriterReadyPromiseReject(writer, error);
        }
        else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === 'errored' || state === 'erroring') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException('write to'));
        }
        const state = stream._state;
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
        }
        if (state === 'erroring') {
            return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
    }
    const closeSentinel = {};
    /**
     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
     *
     * @public
     */
    class WritableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('abortReason');
            }
            return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('signal');
            }
            if (this._abortController === undefined) {
                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
            }
            return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e = undefined) {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('error');
            }
            const state = this._controlledWritableStream._state;
            if (state !== 'writable') {
                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
                // just treat it as a no-op.
                return;
            }
            WritableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [ErrorSteps]() {
            ResetQueue(this);
        }
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'WritableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations implementing interface required by the WritableStream.
    function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
        }, r => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
            return null;
        });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== undefined) {
            startAlgorithm = () => underlyingSink.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingSink.write !== undefined) {
            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
        }
        else {
            writeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.close !== undefined) {
            closeAlgorithm = () => underlyingSink.close();
        }
        else {
            closeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.abort !== undefined) {
            abortAlgorithm = reason => underlyingSink.abort(reason);
        }
        else {
            abortAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
            return controller._strategySizeAlgorithm(chunk);
        }
        catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
        }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
        }
        catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    // Abstract operations for the WritableStreamDefaultController.
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
            return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
            return;
        }
        const state = stream._state;
        if (state === 'erroring') {
            WritableStreamFinishErroring(stream);
            return;
        }
        if (controller._queue.length === 0) {
            return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
        }
        else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
        }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === 'writable') {
            WritableStreamDefaultControllerError(controller, error);
        }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
            return null;
        }, reason => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
            return null;
        });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
        }, reason => {
            if (stream._state === 'writable') {
                WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
            return null;
        });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
    }
    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
    function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
    }
    // Helper functions for the WritableStream.
    function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    // Helper functions for the WritableStreamDefaultController.
    function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    // Helper functions for the WritableStreamDefaultWriter.
    function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released writer');
    }
    function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = 'pending';
        });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'rejected';
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
            return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'resolved';
    }
    function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = 'pending';
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'rejected';
    }
    function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
            return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'fulfilled';
    }

    /// <reference lib="dom" />
    function getGlobals() {
        if (typeof globalThis !== 'undefined') {
            return globalThis;
        }
        else if (typeof self !== 'undefined') {
            return self;
        }
        else if (typeof global !== 'undefined') {
            return global;
        }
        return undefined;
    }
    const globals = getGlobals();

    /// <reference types="node" />
    function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
            return false;
        }
        if (ctor.name !== 'DOMException') {
            return false;
        }
        try {
            new ctor();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Support:
     * - Web browsers
     * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)
     */
    function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : undefined;
    }
    /**
     * Support:
     * - All platforms
     */
    function createPolyfill() {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const ctor = function DOMException(message, name) {
            this.message = message || '';
            this.name = name || 'Error';
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        };
        setFunctionName(ctor, 'DOMException');
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });
        return ctor;
    }
    // eslint-disable-next-line @typescript-eslint/no-redeclare
    const DOMException = getFromGlobal() || createPolyfill();

    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        let currentWrite = promiseResolvedWith(undefined);
        return newPromise((resolve, reject) => {
            let abortAlgorithm;
            if (signal !== undefined) {
                abortAlgorithm = () => {
                    const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');
                    const actions = [];
                    if (!preventAbort) {
                        actions.push(() => {
                            if (dest._state === 'writable') {
                                return WritableStreamAbort(dest, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    if (!preventCancel) {
                        actions.push(() => {
                            if (source._state === 'readable') {
                                return ReadableStreamCancel(source, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
                };
                if (signal.aborted) {
                    abortAlgorithm();
                    return;
                }
                signal.addEventListener('abort', abortAlgorithm);
            }
            // Using reader and writer, read all chunks from this and write them to dest
            // - Backpressure must be enforced
            // - Shutdown must stop all activity
            function pipeLoop() {
                return newPromise((resolveLoop, rejectLoop) => {
                    function next(done) {
                        if (done) {
                            resolveLoop();
                        }
                        else {
                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                            PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                    }
                    next(false);
                });
            }
            function pipeStep() {
                if (shuttingDown) {
                    return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, () => {
                    return newPromise((resolveRead, rejectRead) => {
                        ReadableStreamDefaultReaderRead(reader, {
                            _chunkSteps: chunk => {
                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                                resolveRead(false);
                            },
                            _closeSteps: () => resolveRead(true),
                            _errorSteps: rejectRead
                        });
                    });
                });
            }
            // Errors must be propagated forward
            isOrBecomesErrored(source, reader._closedPromise, storedError => {
                if (!preventAbort) {
                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
                return null;
            });
            // Errors must be propagated backward
            isOrBecomesErrored(dest, writer._closedPromise, storedError => {
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
                return null;
            });
            // Closing must be propagated forward
            isOrBecomesClosed(source, reader._closedPromise, () => {
                if (!preventClose) {
                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
                }
                else {
                    shutdown();
                }
                return null;
            });
            // Closing must be propagated backward
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
                }
                else {
                    shutdown(true, destClosed);
                }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
                // for that too.
                const oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
            }
            function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === 'errored') {
                    action(stream._storedError);
                }
                else {
                    uponRejection(promise, action);
                }
            }
            function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === 'closed') {
                    action();
                }
                else {
                    uponFulfillment(promise, action);
                }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), doTheRest);
                }
                else {
                    doTheRest();
                }
                function doTheRest() {
                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
                    return null;
                }
            }
            function shutdown(isError, error) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
                }
                else {
                    finalize(isError, error);
                }
            }
            function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== undefined) {
                    signal.removeEventListener('abort', abortAlgorithm);
                }
                if (isError) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
                return null;
            }
        });
    }

    /**
     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('desiredSize');
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('close');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits close');
            }
            ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('enqueue');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits enqueue');
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('error');
            }
            ReadableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
                const chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                    ReadableStreamDefaultControllerClearAlgorithms(this);
                    ReadableStreamClose(stream);
                }
                else {
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
            }
            else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
        }
        /** @internal */
        [ReleaseSteps]() {
            // Do nothing.
        }
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultController.prototype.close, 'close');
    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');
    setFunctionName(ReadableStreamDefaultController.prototype.error, 'error');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableStreamDefaultController.
    function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
            return null;
        }, e => {
            ReadableStreamDefaultControllerError(controller, e);
            return null;
        });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
    function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
        }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
        }
        else {
            let chunkSize;
            try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
            }
            catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
            }
            try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
            }
            catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
            }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== 'readable') {
            return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    // This is used in the implementation of TransformStream.
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
        }
        return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === 'readable') {
            return true;
        }
        return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(controller, r);
            return null;
        });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== undefined) {
            startAlgorithm = () => underlyingSource.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingSource.pull !== undefined) {
            pullAlgorithm = () => underlyingSource.pull(controller);
        }
        else {
            pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingSource.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // Helper functions for the ReadableStreamDefaultController.
    function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }

    function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
            if (reading) {
                readAgain = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgain = false;
                        const chunk1 = chunk;
                        const chunk2 = chunk;
                        // There is no way to access the cloning code right now in the reference implementation.
                        // If we add one then we'll need an implementation for serializable objects.
                        // if (!canceled2 && cloneForBranch2) {
                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                        // }
                        if (!canceled1) {
                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgain) {
                            pullAlgorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            // do nothing
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
            }
            return null;
        });
        return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, r => {
                if (thisReader !== reader) {
                    return null;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r);
                ReadableByteStreamControllerError(branch2._readableStreamController, r);
                if (!canceled1 || !canceled2) {
                    resolveCancelPromise(undefined);
                }
                return null;
            });
        }
        function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
            }
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const chunk1 = chunk;
                        let chunk2 = chunk;
                        if (!canceled1 && !canceled2) {
                            try {
                                chunk2 = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                        }
                        if (!canceled1) {
                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableByteStreamControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableByteStreamControllerClose(branch2._readableStreamController);
                    }
                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                    }
                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const byobCanceled = forBranch2 ? canceled2 : canceled1;
                        const otherCanceled = forBranch2 ? canceled1 : canceled2;
                        if (!otherCanceled) {
                            let clonedChunk;
                            try {
                                clonedChunk = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                            if (!byobCanceled) {
                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                            }
                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                        }
                        else if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: chunk => {
                    reading = false;
                    const byobCanceled = forBranch2 ? canceled2 : canceled1;
                    const otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!byobCanceled) {
                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                    }
                    if (!otherCanceled) {
                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                    }
                    if (chunk !== undefined) {
                        if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                        }
                    }
                    if (!byobCanceled || !otherCanceled) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
            if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
            if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
    }

    function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== 'undefined';
    }

    function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
            return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
    }
    function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, 'async');
        const startAlgorithm = noop;
        function pullAlgorithm() {
            let nextResult;
            try {
                nextResult = IteratorNext(iteratorRecord);
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const nextPromise = promiseResolvedWith(nextResult);
            return transformPromiseWith(nextPromise, iterResult => {
                if (!typeIsObject(iterResult)) {
                    throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');
                }
                const done = IteratorComplete(iterResult);
                if (done) {
                    ReadableStreamDefaultControllerClose(stream._readableStreamController);
                }
                else {
                    const value = IteratorValue(iterResult);
                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
                }
            });
        }
        function cancelAlgorithm(reason) {
            const iterator = iteratorRecord.iterator;
            let returnMethod;
            try {
                returnMethod = GetMethod(iterator, 'return');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (returnMethod === undefined) {
                return promiseResolvedWith(undefined);
            }
            let returnResult;
            try {
                returnResult = reflectCall(returnMethod, iterator, [reason]);
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const returnPromise = promiseResolvedWith(returnResult);
            return transformPromiseWith(returnPromise, iterResult => {
                if (!typeIsObject(iterResult)) {
                    throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');
                }
                return undefined;
            });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
    }
    function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop;
        function pullAlgorithm() {
            let readPromise;
            try {
                readPromise = reader.read();
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            return transformPromiseWith(readPromise, readResult => {
                if (!typeIsObject(readResult)) {
                    throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');
                }
                if (readResult.done) {
                    ReadableStreamDefaultControllerClose(stream._readableStreamController);
                }
                else {
                    const value = readResult.value;
                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
                }
            });
        }
        function cancelAlgorithm(reason) {
            try {
                return promiseResolvedWith(reader.cancel(reason));
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
    }

    function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?
                undefined :
                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === undefined ?
                undefined :
                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === undefined ?
                undefined :
                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== 'bytes') {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
    }

    function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
    }

    function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
        };
    }
    function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
        }
    }

    function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, 'readable', 'ReadableWritablePair');
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, 'writable', 'ReadableWritablePair');
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
    }

    /**
     * A readable stream represents a source of data, from which you can read.
     *
     * @public
     */
    class ReadableStream {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === undefined) {
                rawUnderlyingSource = null;
            }
            else {
                assertObject(rawUnderlyingSource, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
            InitializeReadableStream(this);
            if (underlyingSource.type === 'bytes') {
                if (strategy.size !== undefined) {
                    throw new RangeError('The strategy for a byte stream cannot have a size function');
                }
                const highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            }
            else {
                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                const highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('locked');
            }
            return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = undefined) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('cancel'));
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
            }
            return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('getReader');
            }
            const options = convertReaderOptions(rawOptions, 'First parameter');
            if (options.mode === undefined) {
                return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('pipeThrough');
            }
            assertRequiredArgument(rawTransform, 1, 'pipeThrough');
            const transform = convertReadableWritablePair(rawTransform, 'First parameter');
            const options = convertPipeOptions(rawOptions, 'Second parameter');
            if (IsReadableStreamLocked(this)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
            }
            if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
            }
            if (destination === undefined) {
                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
                options = convertPipeOptions(rawOptions, 'Second parameter');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
            }
            if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('tee');
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
        }
        values(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('values');
            }
            const options = convertIteratorOptions(rawOptions, 'First parameter');
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
            // Stub implementation, overridden below
            return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
            return ReadableStreamFrom(asyncIterable);
        }
    }
    Object.defineProperties(ReadableStream, {
        from: { enumerable: true }
    });
    Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
    });
    setFunctionName(ReadableStream.from, 'from');
    setFunctionName(ReadableStream.prototype.cancel, 'cancel');
    setFunctionName(ReadableStream.prototype.getReader, 'getReader');
    setFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');
    setFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');
    setFunctionName(ReadableStream.prototype.tee, 'tee');
    setFunctionName(ReadableStream.prototype.values, 'values');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {
            value: 'ReadableStream',
            configurable: true
        });
    }
    Object.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {
        value: ReadableStream.prototype.values,
        writable: true,
        configurable: true
    });
    // Abstract operations for the ReadableStream.
    // Throws if and only if startAlgorithm throws.
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    // Throws if and only if startAlgorithm throws.
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
        return stream;
    }
    function InitializeReadableStream(stream) {
        stream._state = 'readable';
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
    }
    function IsReadableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
            return false;
        }
        return x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
            return false;
        }
        return true;
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (stream._state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
            const readIntoRequests = reader._readIntoRequests;
            reader._readIntoRequests = new SimpleQueue();
            readIntoRequests.forEach(readIntoRequest => {
                readIntoRequest._closeSteps(undefined);
            });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
        stream._state = 'closed';
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
            const readRequests = reader._readRequests;
            reader._readRequests = new SimpleQueue();
            readRequests.forEach(readRequest => {
                readRequest._closeSteps();
            });
        }
    }
    function ReadableStreamError(stream, e) {
        stream._state = 'errored';
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamDefaultReaderErrorReadRequests(reader, e);
        }
        else {
            ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
        }
    }
    // Helper functions for the ReadableStream.
    function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }

    function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
        return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
    }

    // The size function must not have a prototype property nor be a constructor
    const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
    };
    setFunctionName(byteLengthSizeFunction, 'size');
    /**
     * A queuing strategy that counts the number of bytes in each chunk.
     *
     * @public
     */
    class ByteLengthQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('highWaterMark');
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('size');
            }
            return byteLengthSizeFunction;
        }
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
            value: 'ByteLengthQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the ByteLengthQueuingStrategy.
    function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
    }

    // The size function must not have a prototype property nor be a constructor
    const countSizeFunction = () => {
        return 1;
    };
    setFunctionName(countSizeFunction, 'size');
    /**
     * A queuing strategy that counts the number of chunks.
     *
     * @public
     */
    class CountQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'CountQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('highWaterMark');
            }
            return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('size');
            }
            return countSizeFunction;
        }
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
            value: 'CountQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the CountQueuingStrategy.
    function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof CountQueuingStrategy;
    }

    function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
            cancel: cancel === undefined ?
                undefined :
                convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            flush: flush === undefined ?
                undefined :
                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === undefined ?
                undefined :
                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === undefined ?
                undefined :
                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
        };
    }
    function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }

    // Class TransformStream
    /**
     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
     * made available for reading from the readable side.
     *
     * @public
     */
    class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === undefined) {
                rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
            const transformer = convertTransformer(rawTransformer, 'First parameter');
            if (transformer.readableType !== undefined) {
                throw new RangeError('Invalid readableType specified');
            }
            if (transformer.writableType !== undefined) {
                throw new RangeError('Invalid writableType specified');
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise(resolve => {
                startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== undefined) {
                startPromise_resolve(transformer.start(this._transformStreamController));
            }
            else {
                startPromise_resolve(undefined);
            }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('readable');
            }
            return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('writable');
            }
            return this._writable;
        }
    }
    Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
            value: 'TransformStream',
            configurable: true
        });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
            return startPromise;
        }
        function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
            return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
            return false;
        }
        return x instanceof TransformStream;
    }
    // This is a no-op if both sides are already errored.
    function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        TransformStreamUnblockWrite(stream);
    }
    function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
            // _backpressure is set.
            TransformStreamSetBackpressure(stream, false);
        }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
            stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(resolve => {
            stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
    }
    // Class TransformStreamDefaultController
    /**
     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
     *
     * @public
     */
    class TransformStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('desiredSize');
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('enqueue');
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('error');
            }
            TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('terminate');
            }
            TransformStreamDefaultControllerTerminate(this);
        }
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');
    setFunctionName(TransformStreamDefaultController.prototype.error, 'error');
    setFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'TransformStreamDefaultController',
            configurable: true
        });
    }
    // Transform Stream Default Controller Abstract Operations
    function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
            return false;
        }
        return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = undefined;
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== undefined) {
            transformAlgorithm = chunk => transformer.transform(chunk, controller);
        }
        else {
            transformAlgorithm = chunk => {
                try {
                    TransformStreamDefaultControllerEnqueue(controller, chunk);
                    return promiseResolvedWith(undefined);
                }
                catch (transformResultE) {
                    return promiseRejectedWith(transformResultE);
                }
            };
        }
        if (transformer.flush !== undefined) {
            flushAlgorithm = () => transformer.flush(controller);
        }
        else {
            flushAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (transformer.cancel !== undefined) {
            cancelAlgorithm = reason => transformer.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError('Readable side is not in a state that permits enqueue');
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        }
        catch (e) {
            // This happens when readableStrategy.size() throws.
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
        }
    }
    function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, r => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
        });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError('TransformStream terminated');
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    // TransformStreamDefaultSink Algorithms
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
                const writable = stream._writable;
                const state = writable._state;
                if (state === 'erroring') {
                    throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,
        // we don't run the _cancelAlgorithm again.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
            if (readable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, readable._storedError);
            }
            else {
                ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(readable._readableStreamController, r);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,
        // we don't also run the _cancelAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
            if (readable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, readable._storedError);
            }
            else {
                ReadableStreamDefaultControllerClose(readable._readableStreamController);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(readable._readableStreamController, r);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    // TransformStreamDefaultSource Algorithms
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
    }
    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._writable cannot change after construction, so caching it across a call to user code is safe.
        const writable = stream._writable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or
        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the
        // _flushAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
            if (writable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, writable._storedError);
            }
            else {
                WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
                TransformStreamUnblockWrite(stream);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    // Helper functions for the TransformStreamDefaultController.
    function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === undefined) {
            return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    // Helper functions for the TransformStream.
    function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }

    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports.CountQueuingStrategy = CountQueuingStrategy;
    exports.ReadableByteStreamController = ReadableByteStreamController;
    exports.ReadableStream = ReadableStream;
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports.TransformStream = TransformStream;
    exports.TransformStreamDefaultController = TransformStreamDefaultController;
    exports.WritableStream = WritableStream;
    exports.WritableStreamDefaultController = WritableStreamDefaultController;
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;

}));
//# sourceMappingURL=ponyfill.es2018.js.map


/***/ }),

/***/ "./node_modules/which/which.js":
/*!*************************************!*\
  !*** ./node_modules/which/which.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(/*! path */ "path")
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(/*! isexe */ "./node_modules/isexe/index.js")

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),

/***/ "./node_modules/wrap-ansi/index.js":
/*!*****************************************!*\
  !*** ./node_modules/wrap-ansi/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stringWidth = __webpack_require__(/*! string-width */ "./node_modules/string-width/index.js");
const stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js");
const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/ansi-styles/index.js");

const ESCAPES = new Set([
	'\u001B',
	'\u009B'
]);

const END_CODE = 39;

const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsi = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
		}

		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}

			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		}

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows.push('');
		}

		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}

		rows[rows.length - 1] += word;
	}

	if (options.trim !== false) {
		rows = rows.map(stringVisibleTrimSpacesRight);
	}

	const pre = [...rows.join('\n')];

	for (const [index, character] of pre.entries()) {
		returnValue += character;

		if (ESCAPES.has(character)) {
			const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {groups: {}};
			if (groups.code !== undefined) {
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			} else if (groups.uri !== undefined) {
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			}
		}

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (pre[index + 1] === '\n') {
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink('');
			}

			if (escapeCode && code) {
				returnValue += wrapAnsi(code);
			}
		} else if (character === '\n') {
			if (escapeCode && code) {
				returnValue += wrapAnsi(escapeCode);
			}

			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink(escapeUrl);
			}
		}
	}

	return returnValue;
};

// For each newline, invoke the method separately
module.exports = (string, columns, options) => {
	return String(string)
		.normalize()
		.replace(/\r\n/g, '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
};


/***/ }),

/***/ "./node_modules/xml2js/lib/bom.js":
/*!****************************************!*\
  !*** ./node_modules/xml2js/lib/bom.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/builder.js":
/*!********************************************!*\
  !*** ./node_modules/xml2js/lib/builder.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = __webpack_require__(/*! xmlbuilder */ "./node_modules/xmlbuilder/lib/index.js");

  defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/xml2js/lib/defaults.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/parser.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");

  events = __webpack_require__(/*! events */ "events");

  bom = __webpack_require__(/*! ./bom */ "./node_modules/xml2js/lib/bom.js");

  processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");

  setImmediate = (__webpack_require__(/*! timers */ "timers").setImmediate);

  defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  defineProperty = function(obj, key, value) {
    var descriptor;
    descriptor = Object.create(null);
    descriptor.value = value;
    descriptor.writable = true;
    descriptor.enumerable = true;
    descriptor.configurable = true;
    return Object.defineProperty(obj, key, descriptor);
  };

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseStringPromise = bind(this.parseStringPromise, this);
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return defineProperty(obj, key, newValue);
        } else {
          return defineProperty(obj, key, [newValue]);
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          defineProperty(obj, key, [obj[key]]);
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                defineProperty(obj[attrkey], processedKey, newValue);
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            if (typeof _this.options.emptyTag === 'function') {
              obj = _this.options.emptyTag();
            } else {
              obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
            }
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            (function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                defineProperty(objClone, key, obj[key]);
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              defineProperty(obj, nodeName, old);
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    Parser.prototype.parseStringPromise = function(str) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.parseString(str, function(err, value) {
            if (err) {
              return reject(err);
            } else {
              return resolve(value);
            }
          });
        };
      })(this));
    };

    return Parser;

  })(events);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

  exports.parseStringPromise = function(str, a) {
    var options, parser;
    if (typeof a === 'object') {
      options = a;
    }
    parser = new exports.Parser(options);
    return parser.parseStringPromise(str);
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/processors.js":
/*!***********************************************!*\
  !*** ./node_modules/xml2js/lib/processors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/xml2js.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/xml2js.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, parser, processors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  defaults = __webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js");

  builder = __webpack_require__(/*! ./builder */ "./node_modules/xml2js/lib/builder.js");

  parser = __webpack_require__(/*! ./parser */ "./node_modules/xml2js/lib/parser.js");

  processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;

  exports.parseStringPromise = parser.parseStringPromise;

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/DocumentPosition.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/DocumentPosition.js ***!
  \*********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    Disconnected: 1,
    Preceding: 2,
    Following: 4,
    Contains: 8,
    ContainedBy: 16,
    ImplementationSpecific: 32
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/NodeType.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/NodeType.js ***!
  \*************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    Element: 1,
    Attribute: 2,
    Text: 3,
    CData: 4,
    EntityReference: 5,
    EntityDeclaration: 6,
    ProcessingInstruction: 7,
    Comment: 8,
    Document: 9,
    DocType: 10,
    DocumentFragment: 11,
    NotationDeclaration: 12,
    Declaration: 201,
    Raw: 202,
    AttributeDeclaration: 203,
    ElementDeclaration: 204,
    Dummy: 205
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/Utility.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/Utility.js ***!
  \************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  getValue = function(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

  module.exports.getValue = getValue;

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/WriterState.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/WriterState.js ***!
  \****************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  module.exports = {
    None: 0,
    OpenTag: 1,
    InsideTag: 2,
    CloseTag: 3
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLAttribute, XMLNode;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      if (name == null) {
        throw new Error("Missing attribute name. " + this.debugInfo(name));
      }
      this.name = this.stringify.name(name);
      this.value = this.stringify.attValue(value);
      this.type = NodeType.Attribute;
      this.isId = false;
      this.schemaTypeInfo = null;
    }

    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
      get: function() {
        return this.parent;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'specified', {
      get: function() {
        return true;
      }
    });

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
    };

    XMLAttribute.prototype.debugInfo = function(name) {
      name = name || this.name;
      if (name == null) {
        return "parent: <" + this.parent.name + ">";
      } else {
        return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
      }
    };

    XMLAttribute.prototype.isEqualNode = function(node) {
      if (node.namespaceURI !== this.namespaceURI) {
        return false;
      }
      if (node.prefix !== this.prefix) {
        return false;
      }
      if (node.localName !== this.localName) {
        return false;
      }
      if (node.value !== this.value) {
        return false;
      }
      return true;
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCData.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCData.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCData, XMLCharacterData,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text. " + this.debugInfo());
      }
      this.name = "#cdata-section";
      this.type = NodeType.CData;
      this.value = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
    };

    return XMLCData;

  })(XMLCharacterData);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCharacterData.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCharacterData.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCharacterData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLCharacterData = (function(superClass) {
    extend(XMLCharacterData, superClass);

    function XMLCharacterData(parent) {
      XMLCharacterData.__super__.constructor.call(this, parent);
      this.value = '';
    }

    Object.defineProperty(XMLCharacterData.prototype, 'data', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    Object.defineProperty(XMLCharacterData.prototype, 'length', {
      get: function() {
        return this.value.length;
      }
    });

    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    XMLCharacterData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCharacterData.prototype.substringData = function(offset, count) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.appendData = function(arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.insertData = function(offset, arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.deleteData = function(offset, count) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLCharacterData.prototype.isEqualNode = function(node) {
      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.data !== this.data) {
        return false;
      }
      return true;
    };

    return XMLCharacterData;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLComment.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLComment.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLComment,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text. " + this.debugInfo());
      }
      this.name = "#comment";
      this.type = NodeType.Comment;
      this.value = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.comment(this, this.options.writer.filterOptions(options));
    };

    return XMLComment;

  })(XMLCharacterData);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js":
/*!************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;

  XMLDOMErrorHandler = __webpack_require__(/*! ./XMLDOMErrorHandler */ "./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js");

  XMLDOMStringList = __webpack_require__(/*! ./XMLDOMStringList */ "./node_modules/xmlbuilder/lib/XMLDOMStringList.js");

  module.exports = XMLDOMConfiguration = (function() {
    function XMLDOMConfiguration() {
      var clonedSelf;
      this.defaultParams = {
        "canonical-form": false,
        "cdata-sections": false,
        "comments": false,
        "datatype-normalization": false,
        "element-content-whitespace": true,
        "entities": true,
        "error-handler": new XMLDOMErrorHandler(),
        "infoset": true,
        "validate-if-schema": false,
        "namespaces": true,
        "namespace-declarations": true,
        "normalize-characters": false,
        "schema-location": '',
        "schema-type": '',
        "split-cdata-sections": true,
        "validate": false,
        "well-formed": true
      };
      this.params = clonedSelf = Object.create(this.defaultParams);
    }

    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
      get: function() {
        return new XMLDOMStringList(Object.keys(this.defaultParams));
      }
    });

    XMLDOMConfiguration.prototype.getParameter = function(name) {
      if (this.params.hasOwnProperty(name)) {
        return this.params[name];
      } else {
        return null;
      }
    };

    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
      return true;
    };

    XMLDOMConfiguration.prototype.setParameter = function(name, value) {
      if (value != null) {
        return this.params[name] = value;
      } else {
        return delete this.params[name];
      }
    };

    return XMLDOMConfiguration;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js ***!
  \***********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMErrorHandler;

  module.exports = XMLDOMErrorHandler = (function() {
    function XMLDOMErrorHandler() {}

    XMLDOMErrorHandler.prototype.handleError = function(error) {
      throw new Error(error);
    };

    return XMLDOMErrorHandler;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js":
/*!*************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMImplementation.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMImplementation;

  module.exports = XMLDOMImplementation = (function() {
    function XMLDOMImplementation() {}

    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
      return true;
    };

    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLDOMImplementation.prototype.getFeature = function(feature, version) {
      throw new Error("This DOM method is not implemented.");
    };

    return XMLDOMImplementation;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMStringList.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMStringList.js ***!
  \*********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDOMStringList;

  module.exports = XMLDOMStringList = (function() {
    function XMLDOMStringList(arr) {
      this.arr = arr || [];
    }

    Object.defineProperty(XMLDOMStringList.prototype, 'length', {
      get: function() {
        return this.arr.length;
      }
    });

    XMLDOMStringList.prototype.item = function(index) {
      return this.arr[index] || null;
    };

    XMLDOMStringList.prototype.contains = function(str) {
      return this.arr.indexOf(str) !== -1;
    };

    return XMLDOMStringList;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      this.elementName = this.stringify.name(elementName);
      this.type = NodeType.AttributeDeclaration;
      this.attributeName = this.stringify.name(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      if (defaultValue) {
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      }
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.ElementDeclaration;
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD entity name. " + this.debugInfo(name));
      }
      if (value == null) {
        throw new Error("Missing DTD entity value. " + this.debugInfo(name));
      }
      this.pe = !!pe;
      this.name = this.stringify.name(name);
      this.type = NodeType.EntityDeclaration;
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
        this.internal = true;
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
        }
        this.internal = false;
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
        }
      }
    }

    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
      get: function() {
        return this.nData || null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
      get: function() {
        return null;
      }
    });

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD notation name. " + this.debugInfo(name));
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.NotationDeclaration;
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.type = NodeType.Declaration;
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocType.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var child, i, len, ref, ref1, ref2;
      XMLDocType.__super__.constructor.call(this, parent);
      this.type = NodeType.DocType;
      if (parent.children) {
        ref = parent.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.Element) {
            this.name = child.name;
            break;
          }
        }
      }
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
      }
      if (sysID == null) {
        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    Object.defineProperty(XMLDocType.prototype, 'entities', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'notations', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.NotationDeclaration) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.docType(this, this.options.writer.filterOptions(options));
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    XMLDocType.prototype.isEqualNode = function(node) {
      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.name !== this.name) {
        return false;
      }
      if (node.publicId !== this.publicId) {
        return false;
      }
      if (node.systemId !== this.systemId) {
        return false;
      }
      return true;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocument.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isPlainObject);

  XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js");

  XMLDOMConfiguration = __webpack_require__(/*! ./XMLDOMConfiguration */ "./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      this.name = "#document";
      this.type = NodeType.Document;
      this.documentURI = null;
      this.domConfig = new XMLDOMConfiguration();
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
    }

    Object.defineProperty(XMLDocument.prototype, 'implementation', {
      value: new XMLDOMImplementation()
    });

    Object.defineProperty(XMLDocument.prototype, 'doctype', {
      get: function() {
        var child, i, len, ref;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.DocType) {
            return child;
          }
        }
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'documentElement', {
      get: function() {
        return this.rootObject || null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
      get: function() {
        return false;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].encoding;
        } else {
          return null;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].standalone === 'yes';
        } else {
          return false;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].version;
        } else {
          return "1.0";
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'URL', {
      get: function() {
        return this.documentURI;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'origin', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'compatMode', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'characterSet', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'contentType', {
      get: function() {
        return null;
      }
    });

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      writerOptions = {};
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer;
      }
      return writer.document(this, writer.filterOptions(writerOptions));
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.document(this, this.options.writer.filterOptions(options));
    };

    XMLDocument.prototype.createElement = function(tagName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createDocumentFragment = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createTextNode = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createComment = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createCDATASection = function(data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createProcessingInstruction = function(target, data) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createAttribute = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createEntityReference = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByTagName = function(tagname) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.importNode = function(importedNode, deep) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementById = function(elementId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.adoptNode = function(source) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.normalizeDocument = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.getElementsByClassName = function(classNames) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createEvent = function(eventInterface) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createRange = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      this.name = "?xml";
      this.type = NodeType.Document;
      options || (options = {});
      writerOptions = {};
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.writer = options.writer;
      this.writerOptions = this.writer.filterOptions(writerOptions);
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.createChildNode = function(node) {
      var att, attName, attributes, child, i, len, ref1, ref2;
      switch (node.type) {
        case NodeType.CData:
          this.cdata(node.value);
          break;
        case NodeType.Comment:
          this.comment(node.value);
          break;
        case NodeType.Element:
          attributes = {};
          ref1 = node.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            attributes[attName] = att.value;
          }
          this.node(node.name, attributes);
          break;
        case NodeType.Dummy:
          this.dummy();
          break;
        case NodeType.Raw:
          this.raw(node.value);
          break;
        case NodeType.Text:
          this.text(node.value);
          break;
        case NodeType.ProcessingInstruction:
          this.instruction(node.target, node.value);
          break;
        default:
          throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
      }
      ref2 = node.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        child = ref2[i];
        this.createChildNode(child);
        if (child.type === NodeType.Element) {
          this.up();
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.dummy = function() {
      return this;
    };

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name.");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node. " + this.debugInfo(name));
      }
      this.openCurrent();
      name = getValue(name);
      if (attributes == null) {
        attributes = {};
      }
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      var child, i, len, oldValidationFlag, ref1, root;
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        this.dtdElement.apply(this, arguments);
      } else {
        if (Array.isArray(name) || isObject(name) || isFunction(name)) {
          oldValidationFlag = this.options.noValidation;
          this.options.noValidation = true;
          root = new XMLDocument(this.options).element('TEMP_ROOT');
          root.element(name);
          this.options.noValidation = oldValidationFlag;
          ref1 = root.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
        } else {
          this.node(name, attributes, text);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
      }
      if (name != null) {
        name = getValue(name);
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (this.options.keepNullAttributes && (value == null)) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
        } else if (value != null) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = getValue(target);
      }
      if (value != null) {
        value = getValue(value);
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node.");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name.");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node.");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent.");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      var att, chunk, name, ref1;
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
          this.root = node;
        }
        chunk = '';
        if (node.type === NodeType.Element) {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
          ref1 = node.attribs;
          for (name in ref1) {
            if (!hasProp.call(ref1, name)) continue;
            att = ref1[name];
            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
          }
          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
          this.writerOptions.state = WriterState.InsideTag;
        } else {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
          if (node.pubID && node.sysID) {
            chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            chunk += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children) {
            chunk += ' [';
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.CloseTag;
            chunk += '>';
          }
          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.onData(chunk, this.currentLevel);
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      var chunk;
      if (!node.isClosed) {
        chunk = '';
        this.writerOptions.state = WriterState.CloseTag;
        if (node.type === NodeType.Element) {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
        } else {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.writerOptions.state = WriterState.None;
        this.onData(chunk, this.currentLevel);
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk, level) {
      this.documentStarted = true;
      return this.onDataCallback(chunk, level + 1);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.debugInfo = function(name) {
      if (name == null) {
        return "";
      } else {
        return "node: <" + name + ">";
      }
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDummy.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDummy.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLDummy, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  module.exports = XMLDummy = (function(superClass) {
    extend(XMLDummy, superClass);

    function XMLDummy(parent) {
      XMLDummy.__super__.constructor.call(this, parent);
      this.type = NodeType.Dummy;
    }

    XMLDummy.prototype.clone = function() {
      return Object.create(this);
    };

    XMLDummy.prototype.toString = function(options) {
      return '';
    };

    return XMLDummy;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLElement.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLElement.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      var child, j, len, ref1;
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name. " + this.debugInfo());
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.Element;
      this.attribs = {};
      this.schemaTypeInfo = null;
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.type === NodeType.Document) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
        if (parent.children) {
          ref1 = parent.children;
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            if (child.type === NodeType.DocType) {
              child.name = this.name;
              break;
            }
          }
        }
      }
    }

    Object.defineProperty(XMLElement.prototype, 'tagName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLElement.prototype, 'id', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'className', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'classList', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'attributes', {
      get: function() {
        if (!this.attributeMap || !this.attributeMap.nodes) {
          this.attributeMap = new XMLNamedNodeMap(this.attribs);
        }
        return this.attributeMap;
      }
    });

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attribs = {};
      ref1 = this.attribs;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attribs[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = getValue(name);
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (this.options.keepNullAttributes && (value == null)) {
          this.attribs[name] = new XMLAttribute(this, name, "");
        } else if (value != null) {
          this.attribs[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, j, len;
      if (name == null) {
        throw new Error("Missing attribute name. " + this.debugInfo());
      }
      name = getValue(name);
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          attName = name[j];
          delete this.attribs[attName];
        }
      } else {
        delete this.attribs[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.element(this, this.options.writer.filterOptions(options));
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.getAttribute = function(name) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name].value;
      } else {
        return null;
      }
    };

    XMLElement.prototype.setAttribute = function(name, value) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNode = function(name) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name];
      } else {
        return null;
      }
    };

    XMLElement.prototype.setAttributeNode = function(newAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.removeAttributeNode = function(oldAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagName = function(name) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.hasAttribute = function(name) {
      return this.attribs.hasOwnProperty(name);
    };

    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setIdAttribute = function(name, isId) {
      if (this.attribs.hasOwnProperty(name)) {
        return this.attribs[name].isId;
      } else {
        return isId;
      }
    };

    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagName = function(tagname) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.getElementsByClassName = function(classNames) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLElement.prototype.isEqualNode = function(node) {
      var i, j, ref1;
      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.namespaceURI !== this.namespaceURI) {
        return false;
      }
      if (node.prefix !== this.prefix) {
        return false;
      }
      if (node.localName !== this.localName) {
        return false;
      }
      if (node.attribs.length !== this.attribs.length) {
        return false;
      }
      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (!this.attribs[i].isEqualNode(node.attribs[i])) {
          return false;
        }
      }
      return true;
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js ***!
  \********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNamedNodeMap;

  module.exports = XMLNamedNodeMap = (function() {
    function XMLNamedNodeMap(nodes) {
      this.nodes = nodes;
    }

    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
      get: function() {
        return Object.keys(this.nodes).length || 0;
      }
    });

    XMLNamedNodeMap.prototype.clone = function() {
      return this.nodes = null;
    };

    XMLNamedNodeMap.prototype.getNamedItem = function(name) {
      return this.nodes[name];
    };

    XMLNamedNodeMap.prototype.setNamedItem = function(node) {
      var oldNode;
      oldNode = this.nodes[node.nodeName];
      this.nodes[node.nodeName] = node;
      return oldNode || null;
    };

    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
      var oldNode;
      oldNode = this.nodes[name];
      delete this.nodes[name];
      return oldNode || null;
    };

    XMLNamedNodeMap.prototype.item = function(index) {
      return this.nodes[Object.keys(this.nodes)[index]] || null;
    };

    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
      throw new Error("This DOM method is not implemented.");
    };

    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
      throw new Error("This DOM method is not implemented.");
    };

    return XMLNamedNodeMap;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNode.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNode.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,
    hasProp = {}.hasOwnProperty;

  ref1 = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  XMLDummy = null;

  NodeType = null;

  XMLNodeList = null;

  XMLNamedNodeMap = null;

  DocumentPosition = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent1) {
      this.parent = parent1;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.value = null;
      this.children = [];
      this.baseURI = null;
      if (!XMLElement) {
        XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");
        XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");
        XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");
        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");
        XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");
        XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");
        XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");
        XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
        XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xmlbuilder/lib/XMLDummy.js");
        NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");
        XMLNodeList = __webpack_require__(/*! ./XMLNodeList */ "./node_modules/xmlbuilder/lib/XMLNodeList.js");
        XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
        DocumentPosition = __webpack_require__(/*! ./DocumentPosition */ "./node_modules/xmlbuilder/lib/DocumentPosition.js");
      }
    }

    Object.defineProperty(XMLNode.prototype, 'nodeName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeValue', {
      get: function() {
        return this.value;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'parentNode', {
      get: function() {
        return this.parent;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'childNodes', {
      get: function() {
        if (!this.childNodeList || !this.childNodeList.nodes) {
          this.childNodeList = new XMLNodeList(this.children);
        }
        return this.childNodeList;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'firstChild', {
      get: function() {
        return this.children[0] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'lastChild', {
      get: function() {
        return this.children[this.children.length - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'previousSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nextSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i + 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
      get: function() {
        return this.document() || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'textContent', {
      get: function() {
        var child, j, len, ref2, str;
        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
          str = '';
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (child.textContent) {
              str += child.textContent;
            }
          }
          return str;
        } else {
          return null;
        }
      },
      set: function(value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    XMLNode.prototype.setParent = function(parent) {
      var child, j, len, ref2, results;
      this.parent = parent;
      if (parent) {
        this.options = parent.options;
        this.stringify = parent.stringify;
      }
      ref2 = this.children;
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        results.push(child.setParent(this));
      }
      return results;
    };

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
      lastChild = null;
      if (attributes === null && (text == null)) {
        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
      }
      if (name != null) {
        name = getValue(name);
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
            lastChild = this.dummy();
          } else if (isObject(val) && isEmpty(val)) {
            lastChild = this.element(key);
          } else if (!this.options.keepNullNodes && (val == null)) {
            lastChild = this.dummy();
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.element(val);
            } else {
              lastChild = this.element(key);
              lastChild.element(val);
            }
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else if (!this.options.keepNullNodes && text === null) {
        lastChild = this.dummy();
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, newChild, refChild, removed;
      if (name != null ? name.type : void 0) {
        newChild = name;
        refChild = attributes;
        newChild.setParent(this);
        if (refChild) {
          i = children.indexOf(refChild);
          removed = children.splice(i);
          children.push(newChild);
          Array.prototype.push.apply(children, removed);
        } else {
          children.push(newChild);
        }
        return newChild;
      } else {
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      }
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref2;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element. " + this.debugInfo());
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref2;
      if (name != null) {
        name = getValue(name);
      }
      attributes || (attributes = {});
      attributes = getValue(attributes);
      if (!isObject(attributes)) {
        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      if (isObject(value)) {
        this.element(value);
      }
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.dummy = function() {
      var child;
      child = new XMLDummy(this);
      return child;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = getValue(target);
      }
      if (value != null) {
        value = getValue(value);
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children.length === 0) {
        doc.children.unshift(xmldec);
      } else if (doc.children[0].type === NodeType.Declaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref2 = doc.children;
      for (i = j = 0, len = ref2.length; j < len; i = ++j) {
        child = ref2[i];
        if (child.type === NodeType.DocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref3 = doc.children;
      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
        child = ref3[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.type === NodeType.Document) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.type === NodeType.Document) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node. " + this.debugInfo());
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node. " + this.debugInfo());
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.debugInfo = function(name) {
      var ref2, ref3;
      name = name || this.name;
      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
        return "";
      } else if (name == null) {
        return "parent: <" + this.parent.name + ">";
      } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
        return "node: <" + name + ">";
      } else {
        return "node: <" + name + ">, parent: <" + this.parent.name + ">";
      }
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    XMLNode.prototype.replaceChild = function(newChild, oldChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.removeChild = function(oldChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.appendChild = function(newChild) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.hasChildNodes = function() {
      return this.children.length !== 0;
    };

    XMLNode.prototype.cloneNode = function(deep) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.normalize = function() {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isSupported = function(feature, version) {
      return true;
    };

    XMLNode.prototype.hasAttributes = function() {
      return this.attribs.length !== 0;
    };

    XMLNode.prototype.compareDocumentPosition = function(other) {
      var ref, res;
      ref = this;
      if (ref === other) {
        return 0;
      } else if (this.document() !== other.document()) {
        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
        if (Math.random() < 0.5) {
          res |= DocumentPosition.Preceding;
        } else {
          res |= DocumentPosition.Following;
        }
        return res;
      } else if (ref.isAncestor(other)) {
        return DocumentPosition.Contains | DocumentPosition.Preceding;
      } else if (ref.isDescendant(other)) {
        return DocumentPosition.Contains | DocumentPosition.Following;
      } else if (ref.isPreceding(other)) {
        return DocumentPosition.Preceding;
      } else {
        return DocumentPosition.Following;
      }
    };

    XMLNode.prototype.isSameNode = function(other) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.lookupPrefix = function(namespaceURI) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.lookupNamespaceURI = function(prefix) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.isEqualNode = function(node) {
      var i, j, ref2;
      if (node.nodeType !== this.nodeType) {
        return false;
      }
      if (node.children.length !== this.children.length) {
        return false;
      }
      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
        if (!this.children[i].isEqualNode(node.children[i])) {
          return false;
        }
      }
      return true;
    };

    XMLNode.prototype.getFeature = function(feature, version) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.setUserData = function(key, data, handler) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.getUserData = function(key) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLNode.prototype.contains = function(other) {
      if (!other) {
        return false;
      }
      return other === this || this.isDescendant(other);
    };

    XMLNode.prototype.isDescendant = function(node) {
      var child, isDescendantChild, j, len, ref2;
      ref2 = this.children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (node === child) {
          return true;
        }
        isDescendantChild = child.isDescendant(node);
        if (isDescendantChild) {
          return true;
        }
      }
      return false;
    };

    XMLNode.prototype.isAncestor = function(node) {
      return node.isDescendant(this);
    };

    XMLNode.prototype.isPreceding = function(node) {
      var nodePos, thisPos;
      nodePos = this.treePosition(node);
      thisPos = this.treePosition(this);
      if (nodePos === -1 || thisPos === -1) {
        return false;
      } else {
        return nodePos < thisPos;
      }
    };

    XMLNode.prototype.isFollowing = function(node) {
      var nodePos, thisPos;
      nodePos = this.treePosition(node);
      thisPos = this.treePosition(this);
      if (nodePos === -1 || thisPos === -1) {
        return false;
      } else {
        return nodePos > thisPos;
      }
    };

    XMLNode.prototype.treePosition = function(node) {
      var found, pos;
      pos = 0;
      found = false;
      this.foreachTreeNode(this.document(), function(childNode) {
        pos++;
        if (!found && childNode === node) {
          return found = true;
        }
      });
      if (found) {
        return pos;
      } else {
        return -1;
      }
    };

    XMLNode.prototype.foreachTreeNode = function(node, func) {
      var child, j, len, ref2, res;
      node || (node = this.document());
      ref2 = node.children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (res = func(child)) {
          return res;
        } else {
          res = this.foreachTreeNode(child, func);
          if (res) {
            return res;
          }
        }
      }
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNodeList.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNodeList.js ***!
  \****************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNodeList;

  module.exports = XMLNodeList = (function() {
    function XMLNodeList(nodes) {
      this.nodes = nodes;
    }

    Object.defineProperty(XMLNodeList.prototype, 'length', {
      get: function() {
        return this.nodes.length || 0;
      }
    });

    XMLNodeList.prototype.clone = function() {
      return this.nodes = null;
    };

    XMLNodeList.prototype.item = function(index) {
      return this.nodes[index] || null;
    };

    return XMLNodeList;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target. " + this.debugInfo());
      }
      this.type = NodeType.ProcessingInstruction;
      this.target = this.stringify.insTarget(target);
      this.name = this.target;
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
    };

    XMLProcessingInstruction.prototype.isEqualNode = function(node) {
      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
        return false;
      }
      if (node.target !== this.target) {
        return false;
      }
      return true;
    };

    return XMLProcessingInstruction;

  })(XMLCharacterData);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLRaw.js":
/*!***********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text. " + this.debugInfo());
      }
      this.type = NodeType.Raw;
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.raw(this, this.options.writer.filterOptions(options));
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      this.stream = stream;
      XMLStreamWriter.__super__.constructor.call(this, options);
    }

    XMLStreamWriter.prototype.endline = function(node, options, level) {
      if (node.isLastRootNode && options.state === WriterState.CloseTag) {
        return '';
      } else {
        return XMLStreamWriter.__super__.endline.call(this, node, options, level);
      }
    };

    XMLStreamWriter.prototype.document = function(doc, options) {
      var child, i, j, k, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        child = ref[i];
        child.isLastRootNode = i === doc.children.length - 1;
      }
      options = this.filterOptions(options);
      ref1 = doc.children;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        child = ref1[k];
        results.push(this.writeChildNode(child, options, 0));
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
    };

    XMLStreamWriter.prototype.cdata = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.comment = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.declaration = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.docType = function(node, options, level) {
      var child, j, len, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      this.stream.write(this.indent(node, options, level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        this.stream.write(']');
      }
      options.state = WriterState.CloseTag;
      this.stream.write(options.spaceBeforeSlash + '>');
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    };

    XMLStreamWriter.prototype.element = function(node, options, level) {
      var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      this.stream.write(this.indent(node, options, level) + '<' + node.name);
      ref = node.attribs;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att, options, level);
      }
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
      })) {
        if (options.allowEmpty) {
          this.stream.write('>');
          options.state = WriterState.CloseTag;
          this.stream.write('</' + node.name + '>');
        } else {
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + '/>');
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
        this.stream.write('>');
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref1 = node.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
      }
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.raw = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.text = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringWriter, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc, options) {
      var child, i, len, r, ref;
      options = this.filterOptions(options);
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += this.writeChildNode(child, options, 0);
      }
      if (options.pretty && r.slice(-options.newline.length) === options.newline) {
        r = r.slice(0, -options.newline.length);
      }
      return r;
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*******************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalName = bind(this.assertLegalName, this);
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.options = options;
      if (!this.options.version) {
        this.options.version = '1.0';
      }
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.name = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalName('' + val || '');
    };

    XMLStringifier.prototype.text = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar(this.textEscape('' + val || ''));
    };

    XMLStringifier.prototype.cdata = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar(this.attEscape(val = '' + val || ''));
    };

    XMLStringifier.prototype.insTarget = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.insValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      if (this.options.noValidation) {
        return val;
      }
      return this.assertLegalChar('' + val || '');
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var regex, res;
      if (this.options.noValidation) {
        return str;
      }
      regex = '';
      if (this.options.version === '1.0') {
        regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        if (res = str.match(regex)) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
      } else if (this.options.version === '1.1') {
        regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        if (res = str.match(regex)) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
      }
      return str;
    };

    XMLStringifier.prototype.assertLegalName = function(str) {
      var regex;
      if (this.options.noValidation) {
        return str;
      }
      this.assertLegalChar(str);
      regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
      if (!str.match(regex)) {
        throw new Error("Invalid character in name");
      }
      return str;
    };

    XMLStringifier.prototype.textEscape = function(str) {
      var ampregex;
      if (this.options.noValidation) {
        return str;
      }
      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      if (this.options.noValidation) {
        return str;
      }
      ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLText.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLText.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, XMLCharacterData, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text. " + this.debugInfo());
      }
      this.name = "#text";
      this.type = NodeType.Text;
      this.value = this.stringify.text(text);
    }

    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLText.prototype, 'wholeText', {
      get: function() {
        var next, prev, str;
        str = '';
        prev = this.previousSibling;
        while (prev) {
          str = prev.data + str;
          prev = prev.previousSibling;
        }
        str += this.data;
        next = this.nextSibling;
        while (next) {
          str = str + next.data;
          next = next.nextSibling;
        }
        return str;
      }
    });

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.text(this, this.options.writer.filterOptions(options));
    };

    XMLText.prototype.splitText = function(offset) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    XMLText.prototype.replaceWholeText = function(content) {
      throw new Error("This DOM method is not implemented." + this.debugInfo());
    };

    return XMLText;

  })(XMLCharacterData);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign,
    hasProp = {}.hasOwnProperty;

  assign = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").assign);

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xmlbuilder/lib/XMLDummy.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, value;
      options || (options = {});
      this.options = options;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this["_" + key] = this[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.filterOptions = function(options) {
      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
      options || (options = {});
      options = assign({}, this.options, options);
      filteredOptions = {
        writer: this
      };
      filteredOptions.pretty = options.pretty || false;
      filteredOptions.allowEmpty = options.allowEmpty || false;
      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
      if (filteredOptions.spaceBeforeSlash === true) {
        filteredOptions.spaceBeforeSlash = ' ';
      }
      filteredOptions.suppressPrettyCount = 0;
      filteredOptions.user = {};
      filteredOptions.state = WriterState.None;
      return filteredOptions;
    };

    XMLWriterBase.prototype.indent = function(node, options, level) {
      var indentLevel;
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else if (options.pretty) {
        indentLevel = (level || 0) + options.offset + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return '';
    };

    XMLWriterBase.prototype.endline = function(node, options, level) {
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else {
        return options.newline;
      }
    };

    XMLWriterBase.prototype.attribute = function(att, options, level) {
      var r;
      this.openAttribute(att, options, level);
      r = ' ' + att.name + '="' + att.value + '"';
      this.closeAttribute(att, options, level);
      return r;
    };

    XMLWriterBase.prototype.cdata = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<![CDATA[';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ']]>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.comment = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!-- ';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ' -->' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.declaration = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?xml';
      options.state = WriterState.InsideTag;
      r += ' version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.docType = function(node, options, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        r += ']';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.element = function(node, options, level) {
      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
      level || (level = 0);
      prettySuppressed = false;
      r = '';
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r += this.indent(node, options, level) + '<' + node.name;
      ref = node.attribs;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att, options, level);
      }
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
      })) {
        if (options.allowEmpty) {
          r += '>';
          options.state = WriterState.CloseTag;
          r += '</' + node.name + '>' + this.endline(node, options, level);
        } else {
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
        r += '>';
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        r += this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        r += '</' + node.name + '>' + this.endline(node, options, level);
      } else {
        if (options.dontPrettyTextNodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {
              options.suppressPrettyCount++;
              prettySuppressed = true;
              break;
            }
          }
        }
        r += '>' + this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        r += this.indent(node, options, level) + '</' + node.name + '>';
        if (prettySuppressed) {
          options.suppressPrettyCount--;
        }
        r += this.endline(node, options, level);
        options.state = WriterState.None;
      }
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
      switch (node.type) {
        case NodeType.CData:
          return this.cdata(node, options, level);
        case NodeType.Comment:
          return this.comment(node, options, level);
        case NodeType.Element:
          return this.element(node, options, level);
        case NodeType.Raw:
          return this.raw(node, options, level);
        case NodeType.Text:
          return this.text(node, options, level);
        case NodeType.ProcessingInstruction:
          return this.processingInstruction(node, options, level);
        case NodeType.Dummy:
          return '';
        case NodeType.Declaration:
          return this.declaration(node, options, level);
        case NodeType.DocType:
          return this.docType(node, options, level);
        case NodeType.AttributeDeclaration:
          return this.dtdAttList(node, options, level);
        case NodeType.ElementDeclaration:
          return this.dtdElement(node, options, level);
        case NodeType.EntityDeclaration:
          return this.dtdEntity(node, options, level);
        case NodeType.NotationDeclaration:
          return this.dtdNotation(node, options, level);
        default:
          throw new Error("Unknown XML node type: " + node.constructor.name);
      }
    };

    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?';
      options.state = WriterState.InsideTag;
      r += node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.raw = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.text = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ATTLIST';
      options.state = WriterState.InsideTag;
      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdElement = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ELEMENT';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name + ' ' + node.value;
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ENTITY';
      options.state = WriterState.InsideTag;
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!NOTATION';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    };

    XMLWriterBase.prototype.openNode = function(node, options, level) {};

    XMLWriterBase.prototype.closeNode = function(node, options, level) {};

    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};

    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};

    return XMLWriterBase;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), assign = ref.assign, isFunction = ref.isFunction;

  XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js");

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name.");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.dtd(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

  module.exports.implementation = new XMLDOMImplementation();

  module.exports.nodeType = NodeType;

  module.exports.writerState = WriterState;

}).call(this);


/***/ }),

/***/ "./node_modules/yargs/build sync recursive":
/*!****************************************!*\
  !*** ./node_modules/yargs/build/ sync ***!
  \****************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/yargs/build sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/yargs/node_modules/yargs-parser/build sync recursive":
/*!******************************************************************!*\
  !*** ./node_modules/yargs/node_modules/yargs-parser/build/ sync ***!
  \******************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/yargs/node_modules/yargs-parser/build sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/yargs sync recursive":
/*!**********************************!*\
  !*** ./node_modules/yargs/ sync ***!
  \**********************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/yargs sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./src/lifecycle/MatlabCommunicationManager.js":
/*!*****************************************************!*\
  !*** ./src/lifecycle/MatlabCommunicationManager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

((()=>{var _0x25c6d4={0x3d7:(_0x171406,_0x1db9bb,_0x42534b)=>{'use strict';var _0x2855c6=_0x42534b(-0x11f2+-0x250e+0x53ae),_0x40450c=[];function _0x475d36(){this['task']=null,this['domain']=null;}_0x171406['exports']=function(_0x45817f){var _0x3afd8a;(_0x3afd8a=_0x40450c['length']?_0x40450c['pop']():new _0x475d36())['task']=_0x45817f,_0x3afd8a['domain']=process['domain'],_0x2855c6(_0x3afd8a);},_0x475d36['prototype']['call']=function(){this['domain']&&this['domain']['enter']();var _0x376fdf=!(-0x2552+-0x1f12+0x5b3*0xc);try{this['task']['call'](),_0x376fdf=!(-0x19eb+0x2*0x4a5+0x10a2),this['domain']&&this['domain']['exit']();}finally{_0x376fdf&&_0x2855c6['requestFlu'+'sh'](),this['task']=null,this['domain']=null,_0x40450c['push'](this);}};},0x1cae:(_0x1237b8,_0x5ca620,_0xe0d577)=>{'use strict';var _0x220abd,_0x148743='function'==typeof setImmediate;function _0xcb047d(_0x58b70b){_0x193d26['length']||(_0x4e8cc9(),_0x248538=!(-0x25ab+-0x1cdc*-0x1+-0xb*-0xcd)),_0x193d26[_0x193d26['length']]=_0x58b70b;}_0x1237b8['exports']=_0xcb047d;var _0x193d26=[],_0x248538=!(-0x1ed8+0x4ab*0x1+-0x45d*-0x6),_0xe25890=0x4*-0x706+-0x9cd+0x25e5,_0xcc34d1=0x623+-0x4f*-0x13+-0x800;function _0xaa8beb(){for(;_0xe25890<_0x193d26['length'];){var _0xa70fba=_0xe25890;if(_0xe25890+=0x1a7f+0x2173+0x63*-0x9b,_0x193d26[_0xa70fba]['call'](),_0xe25890>_0xcc34d1){for(var _0x584544=-0x148d+0x23b1*0x1+-0xf24,_0x2ba5c4=_0x193d26['length']-_0xe25890;_0x584544<_0x2ba5c4;_0x584544++)_0x193d26[_0x584544]=_0x193d26[_0x584544+_0xe25890];_0x193d26['length']-=_0xe25890,_0xe25890=0x90a+-0x97e+-0x3a*-0x2;}}_0x193d26['length']=-0x4*-0x77d+0x1*0x23e4+0xe*-0x4b4,_0xe25890=0x2519*-0x1+0x24b8+0x61,_0x248538=!(0x1*0x9aa+-0x1623+0xc7a);}function _0x4e8cc9(){var _0x26b3e5=process['domain'];_0x26b3e5&&(_0x220abd||(_0x220abd=_0xe0d577(0x2289+-0x15de+-0x26*0x2)),_0x220abd['active']=process['domain']=null),_0x248538&&_0x148743?setImmediate(_0xaa8beb):process['nextTick'](_0xaa8beb),_0x26b3e5&&(_0x220abd['active']=process['domain']=_0x26b3e5);}_0xcb047d['requestFlu'+'sh']=_0x4e8cc9;},0x923:(_0x48a00c,_0x54029e,_0x73be3e)=>{var _0x58a50e=('0123456789'+'abcdefghij'+'klmnopqrst'+'uvwxyz')['split'](''),_0x347d12=_0x73be3e(-0x3*0x4ee+-0x779*-0x3+0x13a5),_0x3b8784=_0x73be3e(-0x1462+-0x1*0x2502+0x3*0x1fbd);_0x48a00c['exports']=function(_0x434f9d,_0x356ccb){if(_0x434f9d=_0x434f9d||-0x2034+-0x5*0x139+-0x20b*-0x13,(_0x356ccb=_0x356ccb||-0xafa+-0x3fb*0x9+0x2edd)<0x103*0x11+0x1d7*0x1+-0x1308||_0x356ccb>-0x17*0x13e+-0x1506+-0x425*-0xc)throw new Error('radix\x20argu'+'ment\x20must\x20'+'be\x20between'+'\x202\x20and\x2036');for(var _0x125f2e=Math['ceil'](_0x434f9d*Math['log'](-0x7b*-0x1+-0x1c8+0x14f)/Math['log'](_0x356ccb)),_0x5b3235=_0x347d12['randomByte'+'s'](_0x434f9d),_0x5cdfa4=new _0x3b8784(_0x5b3235),_0x32b23e='';_0x32b23e['length']<_0x125f2e;)_0x32b23e+=_0x58a50e[_0x5cdfa4['generate'](_0x356ccb)];return _0x32b23e;};},0x108b:(_0xea3f2a,_0x6b4525,_0x364823)=>{'use strict';var _0x20bfee=_0x364823(0x37d+-0x25d*-0xf+-0x1e55*0x1)['Stream'],_0xee3638=_0x364823(-0xe07+0x21e4+0xf62),_0x69a804=_0x364823(0x19af*-0x1+0x1b*-0x169+0x68f*0xb),_0x2c6846=_0x364823(-0x11b2+-0x2f2*0xa+0x39f4),_0x55cad2=_0x364823(-0x2373+0x79*-0x67+0x6ee0),_0x35341f=_0x364823(-0xf19+-0x22d*0xa+0x2ea8),_0x217009=_0x364823(0xf*0x2a1+0x732+-0x19bc),_0x1e1bea=function(_0x32a876,_0x2193da,_0x2bfc0b){this['writable']=!(-0x100b+-0x232a+0x3335),_0x2bfc0b=_0x2bfc0b||{},this['_stream']=_0x2193da['socket'],this['_ping']=_0x2bfc0b['ping']||this['DEFAULT_PI'+'NG'],this['_retry']=_0x2bfc0b['retry']||this['DEFAULT_RE'+'TRY'];var _0x16053c=_0x69a804['isSecureRe'+'quest'](_0x32a876)?'https:':'http:';this['url']=_0x16053c+'//'+_0x32a876['headers']['host']+_0x32a876['url'],this['lastEventI'+'d']=_0x32a876['headers']['last-event'+'-id']||'',this['readyState']=_0x55cad2['CONNECTING'];var _0x49bc5d=new _0x2c6846(),_0x1a3702=this;if(_0x2bfc0b['headers']){for(var _0x59dd71 in _0x2bfc0b['headers'])_0x49bc5d['set'](_0x59dd71,_0x2bfc0b['headers'][_0x59dd71]);}if(this['_stream']&&this['_stream']['writable']){process['nextTick'](function(){_0x1a3702['_open']();}),this['_stream']['setTimeout'](0x52c+-0x214+-0x318),this['_stream']['setNoDelay'](!(-0x29*-0xe6+0x95*0x3b+-0x472d*0x1));var _0x15f58d='HTTP/1.1\x202'+'00\x20OK\x0d\x0aCon'+'tent-Type:'+'\x20text/even'+'t-stream\x0d\x0a'+'Cache-Cont'+'rol:\x20no-ca'+'che,\x20no-st'+'ore\x0d\x0aConne'+'ction:\x20clo'+'se\x0d\x0a'+_0x49bc5d['toString']()+'\x0d\x0aretry:\x20'+Math['floor']((0x17*0x57+0xd4f+-0x1138*0x1)*this['_retry'])+'\x0d\x0a\x0d\x0a';this['_write'](_0x15f58d),this['_stream']['on']('drain',function(){_0x1a3702['emit']('drain');}),this['_ping']&&(this['_pingTimer']=setInterval(function(){_0x1a3702['ping']();},(0x1d17+-0x6a*0x15+-0x9*0x1d5)*this['_ping'])),['error','end']['forEach'](function(_0x50a70e){_0x1a3702['_stream']['on'](_0x50a70e,function(){_0x1a3702['close']();});});}};_0xee3638['inherits'](_0x1e1bea,_0x20bfee),_0x1e1bea['isEventSou'+'rce']=function(_0x4edcb6){return'GET'===_0x4edcb6['method']&&(_0x4edcb6['headers']['accept']||'')['split'](/\s*,\s*/)['indexOf']('text/event'+'-stream')>=-0x2f6*-0x4+0x1*0xc73+-0x184b;};var _0x4ac3cc={'DEFAULT_PING':0xa,'DEFAULT_RETRY':0x5,'_write':function(_0x998441){if(!this['writable'])return!(-0x24f5+-0x25e3*0x1+0x4ad9);try{return this['_stream']['write'](_0x998441,'utf8');}catch(_0x2befbf){return!(0x1585+-0x1*0x84e+-0xd36);}},'_open':function(){if(this['readyState']===_0x55cad2['CONNECTING']){this['readyState']=_0x55cad2['OPEN'];var _0x4e104e=new _0x217009('open');_0x4e104e['initEvent']('open',!(-0x1*-0x102a+0x185e*-0x1+0x835),!(0x1342+-0x3*0x509+-0x426)),this['dispatchEv'+'ent'](_0x4e104e);}},'write':function(_0x430d40){return this['send'](_0x430d40);},'end':function(_0x2cfffe){void(-0xd2+0x1*0x934+-0x1d*0x4a)!==_0x2cfffe&&this['write'](_0x2cfffe),this['close']();},'send':function(_0x213ae4,_0x52964c){if(this['readyState']>_0x55cad2['OPEN'])return!(0x3*-0x50d+-0x840+0x1768);_0x213ae4=String(_0x213ae4)['replace'](/(\r\n|\r|\n)/g,'$1data:\x20');var _0x15815f='';return(_0x52964c=_0x52964c||{})['event']&&(_0x15815f+='event:\x20'+_0x52964c['event']+'\x0d\x0a'),_0x52964c['id']&&(_0x15815f+='id:\x20'+_0x52964c['id']+'\x0d\x0a'),_0x15815f+='data:\x20'+_0x213ae4+'\x0d\x0a\x0d\x0a',this['_write'](_0x15815f);},'ping':function(){return this['_write'](':\x0d\x0a\x0d\x0a');},'close':function(){if(this['readyState']>_0x55cad2['OPEN'])return!(0x40e+-0xc00+0x7f3);this['readyState']=_0x55cad2['CLOSED'],this['writable']=!(-0x21c6+-0x718*0x5+0x453f),this['_pingTimer']&&clearInterval(this['_pingTimer']),this['_stream']&&this['_stream']['end']();var _0xa24132=new _0x217009('close');return _0xa24132['initEvent']('close',!(-0x1*-0x2519+-0x1357+-0x11c1),!(0x54e*-0x2+0x3*-0x6f2+-0x53*-0x61)),this['dispatchEv'+'ent'](_0xa24132),!(-0xb6b+-0x2671+-0xc77*-0x4);}};for(var _0xb2bf9e in _0x4ac3cc)_0x1e1bea['prototype'][_0xb2bf9e]=_0x4ac3cc[_0xb2bf9e];for(var _0x5b5910 in _0x35341f)_0x1e1bea['prototype'][_0x5b5910]=_0x35341f[_0x5b5910];_0xea3f2a['exports']=_0x1e1bea;},0x32d:(_0x325d5a,_0x2bfa92,_0xca9561)=>{'use strict';var _0x2b61e7=_0xca9561(0x1cf*0x26+-0x1999+-0x2*0x3f1),_0x4195c5=_0xca9561(0x2392+-0x1947+0x3d*-0x8),_0x27e9da=_0xca9561(-0x29b4+0x1a*0x1d+0x4180),_0x374e83=function(_0x472a6f,_0x17b565,_0x5f2f75,_0x2c9a6f,_0x211c34){_0x211c34=_0x211c34||{},this['_stream']=_0x17b565,this['_driver']=_0x4195c5['http'](_0x472a6f,{'maxLength':_0x211c34['maxLength'],'protocols':_0x2c9a6f});var _0x445980=this;if(this['_stream']&&this['_stream']['writable']){if(!this['_stream']['readable'])return this['_stream']['end']();var _0x4523f6=function(){_0x445980['_stream']['removeList'+'ener']('data',_0x4523f6);};this['_stream']['on']('data',_0x4523f6),_0x27e9da['call'](this,_0x211c34),process['nextTick'](function(){_0x445980['_driver']['start'](),_0x445980['_driver']['io']['write'](_0x5f2f75);});}};_0x2b61e7['inherits'](_0x374e83,_0x27e9da),_0x374e83['isWebSocke'+'t']=function(_0x549927){return _0x4195c5['isWebSocke'+'t'](_0x549927);},_0x374e83['validateOp'+'tions']=function(_0x5b9801,_0x582906){_0x4195c5['validateOp'+'tions'](_0x5b9801,_0x582906);},_0x374e83['WebSocket']=_0x374e83,_0x374e83['Client']=_0xca9561(-0x24a5+-0x233b+0x1*0x4eef),_0x374e83['EventSourc'+'e']=_0xca9561(0xb20+0x24b*-0x2+0xa01),_0x325d5a['exports']=_0x374e83;},0x1abe:(_0x336466,_0x580309,_0x15654d)=>{'use strict';var _0x4e2087=_0x15654d(0x5*-0x53c+0x1019+0x12ae)['Stream'],_0x5d8143=_0x15654d(0x1*0x20ae+-0xae0+-0xd71*-0x1),_0x331867=_0x15654d(-0xa0a+0x53*0x7+0x1028),_0x219689=_0x15654d(-0x68*0x4e+-0x2593*-0x1+0x3ea),_0x5821b7=_0x15654d(-0x74b*0x3+-0x32d+0x2df3),_0x3ac0d0=function(_0x1bd2e2){_0x1bd2e2=_0x1bd2e2||{},_0x331867['validateOp'+'tions'](_0x1bd2e2,['headers','extensions','maxLength','ping','proxy','tls','ca']),this['readable']=this['writable']=!(0x2137+-0x5*-0x3dc+-0x3483);var _0x3e10a2=_0x1bd2e2['headers'];if(_0x3e10a2){for(var _0x3e0dcc in _0x3e10a2)this['_driver']['setHeader'](_0x3e0dcc,_0x3e10a2[_0x3e0dcc]);}var _0xc7fb4d=_0x1bd2e2['extensions'];_0xc7fb4d&&[]['concat'](_0xc7fb4d)['forEach'](this['_driver']['addExtensi'+'on'],this['_driver']),this['_ping']=_0x1bd2e2['ping'],this['_pingId']=-0xef8+0x26*0xb3+-0x2*0x5cd,this['readyState']=_0x3ac0d0['CONNECTING'],this['bufferedAm'+'ount']=-0x8de+0xb*0xca+0x30,this['protocol']='',this['url']=this['_driver']['url'],this['version']=this['_driver']['version'];var _0x30a131=this;this['_driver']['on']('open',function(_0x5453e5){_0x30a131['_open']();}),this['_driver']['on']('message',function(_0x3b4bf6){_0x30a131['_receiveMe'+'ssage'](_0x3b4bf6['data']);}),this['_driver']['on']('close',function(_0x5b1ea8){_0x30a131['_beginClos'+'e'](_0x5b1ea8['reason'],_0x5b1ea8['code']);}),this['_driver']['on']('error',function(_0x2252d4){_0x30a131['_emitError'](_0x2252d4['message']);}),this['on']('error',function(){}),this['_driver']['messages']['on']('drain',function(){_0x30a131['emit']('drain');}),this['_ping']&&(this['_pingTimer']=setInterval(function(){_0x30a131['_pingId']+=-0x5*0x184+0x1*0x1b9+-0x6*-0xfa,_0x30a131['ping'](_0x30a131['_pingId']['toString']());},(0xba*0x11+0x3*0x210+-0xea2)*this['_ping'])),this['_configure'+'Stream'](),this['_proxy']||(this['_stream']['pipe'](this['_driver']['io']),this['_driver']['io']['pipe'](this['_stream']));};_0x5d8143['inherits'](_0x3ac0d0,_0x4e2087),_0x3ac0d0['CONNECTING']=0x1*0x8d6+-0x87d*0x3+-0x10a1*-0x1,_0x3ac0d0['OPEN']=-0x4f0+-0x85*0x43+0x1*0x27c0,_0x3ac0d0['CLOSING']=0x1889+0x133a+0x1e7*-0x17,_0x3ac0d0['CLOSED']=-0x2a6*0x3+-0x1b5d+0x2352,_0x3ac0d0['CLOSE_TIME'+'OUT']=0x9bd2+-0x48*-0x4f+0x1e6d*-0x2;var _0x10a6ad={'write':function(_0x38b057){return this['send'](_0x38b057);},'end':function(_0x362bad){void(-0x1721+-0x1f5a+-0x3*-0x1229)!==_0x362bad&&this['send'](_0x362bad),this['close']();},'pause':function(){return this['_driver']['messages']['pause']();},'resume':function(){return this['_driver']['messages']['resume']();},'send':function(_0x2d50ba){return!(this['readyState']>_0x3ac0d0['OPEN'])&&(_0x2d50ba instanceof Buffer||(_0x2d50ba=String(_0x2d50ba)),this['_driver']['messages']['write'](_0x2d50ba));},'ping':function(_0x37cce3,_0xe5384e){return!(this['readyState']>_0x3ac0d0['OPEN'])&&this['_driver']['ping'](_0x37cce3,_0xe5384e);},'close':function(_0x3d53d3,_0x3d3728){if(void(0x807+-0x1*-0x127f+-0x1a86)===_0x3d53d3&&(_0x3d53d3=-0x1f18+0x1b85*-0x1+0x3e85),void(-0x26a7+0x1424+-0x1*-0x1283)===_0x3d3728&&(_0x3d3728=''),0xf1+-0x1d99+-0x209*-0x10!==_0x3d53d3&&(_0x3d53d3<-0x98*0x2f+-0x7a3+0x147*0x25||_0x3d53d3>0x1820+-0x2569*-0x1+0x2*-0x1501))throw new Error('Failed\x20to\x20'+'execute\x20\x27c'+'lose\x27\x20on\x20W'+'ebSocket:\x20'+'The\x20code\x20m'+'ust\x20be\x20eit'+'her\x201000,\x20'+'or\x20between'+'\x203000\x20and\x20'+'4999.\x20'+_0x3d53d3+('\x20is\x20neithe'+'r.'));if(this['readyState']<_0x3ac0d0['CLOSING']){var _0x3622de=this;this['_closeTime'+'r']=setTimeout(function(){_0x3622de['_beginClos'+'e']('',0x1b5*0xf+0x19*0x102+-0x47*0xa9);},_0x3ac0d0['CLOSE_TIME'+'OUT']);}this['readyState']!==_0x3ac0d0['CLOSED']&&(this['readyState']=_0x3ac0d0['CLOSING']),this['_driver']['close'](_0x3d3728,_0x3d53d3);},'_configureStream':function(){var _0xa91471=this;this['_stream']['setTimeout'](-0x2531+-0x2f*0x5+0x261c),this['_stream']['setNoDelay'](!(-0x55b+-0xc2b+0x1186)),['close','end']['forEach'](function(_0x5739e9){this['_stream']['on'](_0x5739e9,function(){_0xa91471['_finalizeC'+'lose']();});},this),this['_stream']['on']('error',function(_0x989e43){_0xa91471['_emitError']('Network\x20er'+'ror:\x20'+_0xa91471['url']+':\x20'+_0x989e43['message']),_0xa91471['_finalizeC'+'lose']();});},'_open':function(){if(this['readyState']===_0x3ac0d0['CONNECTING']){this['readyState']=_0x3ac0d0['OPEN'],this['protocol']=this['_driver']['protocol']||'';var _0x499353=new _0x5821b7('open');_0x499353['initEvent']('open',!(-0x655*0x2+0x351+0x95a),!(-0x2393+0x5*-0x745+-0x1*-0x47ed)),this['dispatchEv'+'ent'](_0x499353);}},'_receiveMessage':function(_0x580b9b){if(this['readyState']>_0x3ac0d0['OPEN'])return!(-0x17b*-0x13+-0xdd*0x23+0x5*0x6b);this['readable']&&this['emit']('data',_0x580b9b);var _0x30ddf5=new _0x5821b7('message',{'data':_0x580b9b});_0x30ddf5['initEvent']('message',!(-0x26a6+-0x3e7*0xa+-0x4dad*-0x1),!(-0xc*0x2a3+-0x1154+0x15*0x255)),this['dispatchEv'+'ent'](_0x30ddf5);},'_emitError':function(_0x20c0cd){if(!(this['readyState']>=_0x3ac0d0['CLOSING'])){var _0x2d5f53=new _0x5821b7('error',{'message':_0x20c0cd});_0x2d5f53['initEvent']('error',!(-0xda+0xbc*-0x2b+0x206f),!(0x202a+-0x1ecd+-0x15c)),this['dispatchEv'+'ent'](_0x2d5f53);}},'_beginClose':function(_0x355683,_0x11bfc9){this['readyState']!==_0x3ac0d0['CLOSED']&&(this['readyState']=_0x3ac0d0['CLOSING'],this['_closePara'+'ms']=[_0x355683,_0x11bfc9],this['_stream']&&(this['_stream']['destroy'](),this['_stream']['readable']||this['_finalizeC'+'lose']()));},'_finalizeClose':function(){if(this['readyState']!==_0x3ac0d0['CLOSED']){this['readyState']=_0x3ac0d0['CLOSED'],this['_closeTime'+'r']&&clearTimeout(this['_closeTime'+'r']),this['_pingTimer']&&clearInterval(this['_pingTimer']),this['_stream']&&this['_stream']['end'](),this['readable']&&this['emit']('end'),this['readable']=this['writable']=!(-0x25c4+-0x107f+0x3644);var _0x5096a7=this['_closePara'+'ms']?this['_closePara'+'ms'][0x2*-0xdd+0x1169+-0xfaf]:'',_0x123ad8=this['_closePara'+'ms']?this['_closePara'+'ms'][-0x5*0x7cf+-0x8a*0x14+-0x84e*-0x6]:0x267d+-0x2005+0x145*-0x2,_0x96d536=new _0x5821b7('close',{'code':_0x123ad8,'reason':_0x5096a7});_0x96d536['initEvent']('close',!(-0xd3*0x4+-0xe*-0x196+-0x12e7),!(0x207e+-0x12*-0x120+-0x34bd)),this['dispatchEv'+'ent'](_0x96d536);}}};for(var _0x17079a in _0x10a6ad)_0x3ac0d0['prototype'][_0x17079a]=_0x10a6ad[_0x17079a];for(var _0x80e97d in _0x219689)_0x3ac0d0['prototype'][_0x80e97d]=_0x219689[_0x80e97d];_0x336466['exports']=_0x3ac0d0;},0x14e5:_0x8d37f8=>{'use strict';var _0x24b566=function(_0x25dd3a,_0x52e0b7){for(var _0x3dcc33 in(this['type']=_0x25dd3a,_0x52e0b7))this[_0x3dcc33]=_0x52e0b7[_0x3dcc33];};_0x24b566['prototype']['initEvent']=function(_0x1112e4,_0x3ac0b7,_0x417d1a){this['type']=_0x1112e4,this['bubbles']=_0x3ac0b7,this['cancelable']=_0x417d1a;},_0x24b566['prototype']['stopPropag'+'ation']=function(){},_0x24b566['prototype']['preventDef'+'ault']=function(){},_0x24b566['CAPTURING_'+'PHASE']=-0x82f+0x1ad8*-0x1+-0x4*-0x8c2,_0x24b566['AT_TARGET']=0x11a7*0x2+-0xcd*-0x2e+-0x4822,_0x24b566['BUBBLING_P'+'HASE']=-0x4*0x6f1+-0xa8b+0x2652,_0x8d37f8['exports']=_0x24b566;},0x9cd:(_0x5e3c00,_0x46d153,_0x31a3f5)=>{'use strict';var _0x55b436=_0x31a3f5(-0x18*0x76+-0x22d5+0xce*0x53),_0x363291={'onopen':null,'onmessage':null,'onerror':null,'onclose':null,'addEventListener':function(_0x455871,_0xc87170,_0x49a0b3){this['on'](_0x455871,_0xc87170);},'removeEventListener':function(_0x1407d7,_0x57a1db,_0xdf60e5){this['removeList'+'ener'](_0x1407d7,_0x57a1db);},'dispatchEvent':function(_0x576adc){_0x576adc['target']=_0x576adc['currentTar'+'get']=this,_0x576adc['eventPhase']=_0x55b436['AT_TARGET'],this['on'+_0x576adc['type']]&&this['on'+_0x576adc['type']](_0x576adc),this['emit'](_0x576adc['type'],_0x576adc);}};_0x5e3c00['exports']=_0x363291;},0x70f:(_0x343169,_0x2ee8f9,_0x588e94)=>{'use strict';var _0x500091=_0x588e94(0x1e5b+0x1*0x1d72+-0x188e),_0xf3d758=_0x588e94(-0x2d40+0x9*-0xf1+-0x3*-0x1dfd),_0x167f40=_0x588e94(0x170c+-0x2*-0xb3e+-0x1af4),_0xb5b71=_0x588e94(-0x1d63+0xa41+0x2e8a),_0x8255e2=_0x588e94(-0x3*-0x8a5+0x1ba9+-0x2d35),_0x102980=_0x588e94(0x1234+-0x2826+0x290*0x13),_0x1e2e0f=(_0x588e94(-0x4c7+0x7bb*-0x2+0xd*0x32a),{'http:':0x50,'https:':0x1bb,'ws:':0x50,'wss:':0x1bb}),_0x300b39=['https:','wss:'],_0x22f9b5=function(_0x546ad5,_0x4f27af,_0x4527a4){_0x4527a4=_0x4527a4||{},this['url']=_0x546ad5,this['_driver']=_0x8255e2['client'](this['url'],{'maxLength':_0x4527a4['maxLength'],'protocols':_0x4f27af}),['open','error']['forEach'](function(_0x24f3ef){this['_driver']['on'](_0x24f3ef,function(){_0x43eb11['headers']=_0x43eb11['_driver']['headers'],_0x43eb11['statusCode']=_0x43eb11['_driver']['statusCode'];});},this);var _0x5ad673=_0x4527a4['proxy']||{},_0x4111a2=_0xb5b71['parse'](_0x5ad673['origin']||this['url']),_0x43ca5=_0x4111a2['port']||_0x1e2e0f[_0x4111a2['protocol']],_0x3eeeeb=_0x300b39['indexOf'](_0x4111a2['protocol'])>=-0x2f*0xc1+-0xf40+0x32af,_0x165cde=function(){_0x43eb11['_onConnect']();},_0x454fa7=_0x4527a4['net']||{},_0x3f2a81=_0x4527a4['tls']||{},_0x1b909b=_0x5ad673['origin']?_0x5ad673['tls']||{}:_0x3f2a81,_0x43eb11=this;_0x454fa7['host']=_0x1b909b['host']=_0x4111a2['hostname'],_0x454fa7['port']=_0x1b909b['port']=_0x43ca5,_0x3f2a81['ca']=_0x3f2a81['ca']||_0x4527a4['ca'],_0x1b909b['servername']=_0x1b909b['servername']||_0x4111a2['hostname'],this['_stream']=_0x3eeeeb?_0x167f40['connect'](_0x1b909b,_0x165cde):_0xf3d758['connect'](_0x454fa7,_0x165cde),_0x5ad673['origin']&&this['_configure'+'Proxy'](_0x5ad673,_0x3f2a81),_0x102980['call'](this,_0x4527a4);};_0x500091['inherits'](_0x22f9b5,_0x102980),_0x22f9b5['prototype']['_onConnect']=function(){(this['_proxy']||this['_driver'])['start']();},_0x22f9b5['prototype']['_configure'+'Proxy']=function(_0x1126a4,_0x392d60){var _0x2f88df,_0x29029d=_0xb5b71['parse'](this['url']),_0x151c19=_0x300b39['indexOf'](_0x29029d['protocol'])>=-0x11*-0xdd+-0x1*-0x14e5+0x13a*-0x1d,_0x430528=this;if(this['_proxy']=this['_driver']['proxy'](_0x1126a4['origin']),_0x1126a4['headers']){for(_0x2f88df in _0x1126a4['headers'])this['_proxy']['setHeader'](_0x2f88df,_0x1126a4['headers'][_0x2f88df]);}this['_proxy']['pipe'](this['_stream'],{'end':!(-0x9*0x3e4+-0x1c3e+0x3f43)}),this['_stream']['pipe'](this['_proxy']),this['_proxy']['on']('connect',function(){if(_0x151c19){var _0x1055e2={'socket':_0x430528['_stream'],'servername':_0x29029d['hostname']};for(_0x2f88df in _0x392d60)_0x1055e2[_0x2f88df]=_0x392d60[_0x2f88df];_0x430528['_stream']=_0x167f40['connect'](_0x1055e2),_0x430528['_configure'+'Stream']();}_0x430528['_driver']['io']['pipe'](_0x430528['_stream']),_0x430528['_stream']['pipe'](_0x430528['_driver']['io']),_0x430528['_driver']['start']();}),this['_proxy']['on']('error',function(_0x4e1942){_0x430528['_driver']['emit']('error',_0x4e1942);});},_0x343169['exports']=_0x22f9b5;},0x22bb:_0x3b4ea0=>{_0x3b4ea0['exports']={'TYPE_JSON':{'Content-Type':'applicatio'+'n/json;\x20ch'+'arset=utf-'+'8'},'TYPE_SCRIPT':{'Content-Type':'text/javas'+'cript;\x20cha'+'rset=utf-8'},'TYPE_TEXT':{'Content-Type':'text/plain'+';\x20charset='+'utf-8'}};},0xdf6:(_0x1dd6b5,_0xfa5c90,_0x1baf3f)=>{'use strict';var _0x28cb0b=_0x1baf3f(0x1c26+0x1e74+-0x2f6d)['Buffer'],_0x512ac9=_0x1baf3f(0xe87+0x12f9+-0x670),_0x4e4700=_0x1baf3f(0x127*-0xb+-0xd72+0x3*0xd3d),_0xe8bebf=_0x1baf3f(-0x90e+-0x2a*-0xad+-0xb*-0xbc),_0x40377c=_0x1baf3f(-0x2055+0x248c+-0x10a),_0x5b90f3=_0x40377c['EventSourc'+'e'],_0x30ef05=_0x1baf3f(-0x19e+-0x56e*-0x7+0x139*-0x17),_0x4edc04=_0x1baf3f(-0x4b*-0xf+0x1*-0x1c65+0x2543),_0x409801=_0x1baf3f(0x209+0x2fb6+-0x144a),_0x224934=_0x1baf3f(-0xee5+0x2c09+0x48),_0x368c3c=_0x1baf3f(-0x1768+-0xc90+0x3*0x111f),_0x4299e6=_0x1baf3f(-0x1be5*0x1+0x3*-0x6b6+0x4013),_0xc40ff9=_0x1baf3f(0x5*-0x337+-0xdcd+0x2f77),_0x57210d=_0x1baf3f(0x1*0x1b09+-0x295c+0x28bd),_0x5c3529=_0x1baf3f(-0x1*0x1b29+-0x1*0x133d+0xd*0x423),_0x56780e=_0x1baf3f(0x1776+-0x1897*-0x1+-0x23a8),_0x1298b1=_0x1baf3f(-0x29*-0xb9+-0x40a4+-0x71*-0x9e),_0x19bd36=_0x1baf3f(0x58*-0x43+-0x58*0x20+-0x1ec*-0x1d),_0x5f0b8e=_0x4299e6({'className':'NodeAdapte'+'r','DEFAULT_ENDPOINT':'/bayeux','SCRIPT_PATH':'faye-brows'+'er-min.js','VALID_JSONP_CALLBACK':/^[a-z_\$][a-z0-9_\$]*(\.[a-z_\$][a-z0-9_\$]*)*$/i,'initialize':function(_0x4d743c){this['_options']=_0x4d743c||{},_0x368c3c(this['_options'],['engine','mount','ping','timeout','extensions','websocketE'+'xtensions']),this['_extension'+'s']=[],this['_endpoint']=this['_options']['mount']||this['DEFAULT_EN'+'DPOINT'],this['_endpointR'+'e']=new RegExp('^'+this['_endpoint']['replace'](/\/$/,'')+('(/[^/]*)*('+'\x5c.[^\x5c.]+)?'+'$')),this['_server']=_0x56780e['create'](this['_options']),this['_static']=new _0x19bd36(_0x512ac9['join'](__dirname,'..','..','client'),/\.(?:js|map)$/),this['_static']['map'](_0x512ac9['basename'](this['_endpoint'])+'.js',this['SCRIPT_PAT'+'H']),this['_static']['map']('client.js',this['SCRIPT_PAT'+'H']);var _0x532f18,_0x32d2fa,_0x26fa7f=this['_options']['extensions'],_0x2c9973=this['_options']['websocketE'+'xtensions'];if(_0x26fa7f){for(_0x532f18=-0x1e73*0x1+-0x1171*0x2+0x4155,_0x32d2fa=(_0x26fa7f=[]['concat'](_0x26fa7f))['length'];_0x532f18<_0x32d2fa;_0x532f18++)this['addExtensi'+'on'](_0x26fa7f[_0x532f18]);}if(_0x2c9973){for(_0x532f18=0x108a+0x3*-0x332+-0x6f4,_0x32d2fa=(_0x2c9973=[]['concat'](_0x2c9973))['length'];_0x532f18<_0x32d2fa;_0x532f18++)this['addWebsock'+'etExtensio'+'n'](_0x2c9973[_0x532f18]);}},'listen':function(){throw new Error('The\x20listen'+'()\x20method\x20'+'is\x20depreca'+'ted\x20-\x20use\x20'+'the\x20attach'+'()\x20method\x20'+'to\x20bind\x20Fa'+'ye\x20to\x20an\x20h'+'ttp.Server');},'addExtension':function(_0x2313d4){return this['_server']['addExtensi'+'on'](_0x2313d4);},'removeExtension':function(_0x1296dd){return this['_server']['removeExte'+'nsion'](_0x1296dd);},'addWebsocketExtension':function(_0x463e16){this['_extension'+'s']['push'](_0x463e16);},'close':function(){return this['_server']['close']();},'getClient':function(){return this['_client']=this['_client']||new _0x5c3529(this['_server']);},'attach':function(_0x19f168){this['_overrideL'+'isteners'](_0x19f168,'request','handle'),this['_overrideL'+'isteners'](_0x19f168,'upgrade','handleUpgr'+'ade');},'_overrideListeners':function(_0x5879d2,_0x44c282,_0x39fee9){var _0x4d204a=_0x5879d2['listeners'](_0x44c282),_0x5d9a1a=this;_0x5879d2['removeAllL'+'isteners'](_0x44c282),_0x5879d2['on'](_0x44c282,function(_0x24679d){if(_0x5d9a1a['check'](_0x24679d))return _0x5d9a1a[_0x39fee9]['apply'](_0x5d9a1a,arguments);for(var _0x1d4104=-0x1304+-0xf14+0x2218,_0x3cc085=_0x4d204a['length'];_0x1d4104<_0x3cc085;_0x1d4104++)_0x4d204a[_0x1d4104]['apply'](this,arguments);});},'check':function(_0x5b04ca){var _0x506348=_0xe8bebf['parse'](_0x5b04ca['url'],!(-0xd*-0x149+0xa1+0x27a*-0x7))['pathname'];return!!this['_endpointR'+'e']['test'](_0x506348);},'handle':function(_0x13bdc4,_0x295da3){var _0x4b1819=_0xe8bebf['parse'](_0x13bdc4['url'],!(-0xec5*0x1+0x2364+-0x1*0x149f)),_0xbab8f4=_0x13bdc4['method'],_0x132860=this;return _0x13bdc4['originalUr'+'l']=_0x13bdc4['url'],_0x13bdc4['on']('error',function(_0x550198){_0x132860['_returnErr'+'or'](_0x295da3,_0x550198);}),_0x295da3['on']('error',function(_0x4f1acf){_0x132860['_returnErr'+'or'](null,_0x4f1acf);}),this['_static']['test'](_0x4b1819['pathname'])?this['_static']['call'](_0x13bdc4,_0x295da3):'OPTIONS'===_0xbab8f4||'POST'===_0x13bdc4['headers']['access-con'+'trol-reque'+'st-method']?this['_handleOpt'+'ions'](_0x13bdc4,_0x295da3):_0x5b90f3['isEventSou'+'rce'](_0x13bdc4)?this['handleEven'+'tSource'](_0x13bdc4,_0x295da3):'GET'===_0xbab8f4?this['_callWithP'+'arams'](_0x13bdc4,_0x295da3,_0x4b1819['query']):'POST'===_0xbab8f4?this['_concatStr'+'eam'](_0x13bdc4,function(_0x4f696f){var _0x4f7b9f='applicatio'+'n/json'===(_0x13bdc4['headers']['content-ty'+'pe']||'')['split'](';')[-0x291*-0x9+0x3*0x982+-0x371*0xf]?{'message':_0x4f696f}:_0x4e4700['parse'](_0x4f696f);_0x13bdc4['body']=_0x4f696f,this['_callWithP'+'arams'](_0x13bdc4,_0x295da3,_0x4f7b9f);},this):void this['_returnErr'+'or'](_0x295da3,{'message':'Unrecogniz'+'ed\x20request'+'\x20type'});},'_callWithParams':function(_0x4f29b2,_0x143e4d,_0x5b92ba){if(!_0x5b92ba['message'])return this['_returnErr'+'or'](_0x143e4d,{'message':'Received\x20r'+'equest\x20wit'+'h\x20no\x20messa'+'ge:\x20'+this['_formatReq'+'uest'](_0x4f29b2)});try{this['debug']('Received\x20m'+'essage\x20via'+'\x20HTTP\x20'+_0x4f29b2['method']+':\x20?',_0x5b92ba['message']);var _0x8aabb7=this['_parseJSON'](_0x5b92ba['message']),_0x3a67c3=_0x5b92ba['jsonp']||_0x30ef05['JSONP_CALL'+'BACK'],_0xf27cd='GET'===_0x4f29b2['method'],_0x189c82=_0xf27cd?_0x1298b1['TYPE_SCRIP'+'T']:_0x1298b1['TYPE_JSON'],_0x25e23a=_0x4edc04({},_0x189c82),_0x422301=_0x4f29b2['headers']['origin'];if(!this['VALID_JSON'+'P_CALLBACK']['test'](_0x3a67c3))return this['_returnErr'+'or'](_0x143e4d,{'message':'Invalid\x20JS'+'ON-P\x20callb'+'ack:\x20'+_0x3a67c3});_0x25e23a['Cache-Cont'+'rol']='no-cache,\x20'+'no-store',_0x25e23a['X-Content-'+'Type-Optio'+'ns']='nosniff',_0x422301&&(_0x25e23a['Access-Con'+'trol-Allow'+'-Credentia'+'ls']='true',_0x25e23a['Access-Con'+'trol-Allow'+'-Origin']=_0x422301),this['_server']['process'](_0x8aabb7,_0x4f29b2,function(_0x1419e9){var _0x6d4629=_0x224934(_0x1419e9);_0xf27cd&&(_0x6d4629='/**/'+_0x3a67c3+'('+this['_jsonpEsca'+'pe'](_0x6d4629)+');',_0x25e23a['Content-Di'+'sposition']='attachment'+';\x20filename'+'=f.txt'),_0x25e23a['Content-Le'+'ngth']=_0x28cb0b['from'](_0x6d4629,'utf8')['length']['toString'](),this['debug']('HTTP\x20respo'+'nse:\x20?',_0x6d4629),_0x143e4d['writeHead'](-0x157f+-0x339+0x1980,_0x25e23a),_0x143e4d['end'](_0x6d4629);},this);}catch(_0x1dd379){this['_returnErr'+'or'](_0x143e4d,_0x1dd379);}},'_jsonpEscape':function(_0xf536df){return _0xf536df['replace'](/\u2028/g,'\x5cu2028')['replace'](/\u2029/g,'\x5cu2029');},'handleUpgrade':function(_0xeb318,_0xdaa2b4,_0x179dac){var _0x5e5438={'extensions':this['_extension'+'s'],'ping':this['_options']['ping']},_0x49c03c=new _0x40377c(_0xeb318,_0xdaa2b4,_0x179dac,[],_0x5e5438),_0x14e740=null,_0x8672c6=this;_0xeb318['originalUr'+'l']=_0xeb318['url'],_0x49c03c['onmessage']=function(_0x117329){try{_0x8672c6['debug']('Received\x20m'+'essage\x20via'+'\x20WebSocket'+'['+_0x49c03c['version']+']:\x20?',_0x117329['data']);var _0x4e8f1f=_0x8672c6['_parseJSON'](_0x117329['data']),_0x2f5d77=_0x409801(_0x4e8f1f);_0x14e740&&_0x2f5d77&&_0x2f5d77!==_0x14e740&&_0x8672c6['_server']['closeSocke'+'t'](_0x14e740,!(-0x1*0xb26+-0x3*0xada+0x2bb5)),_0x8672c6['_server']['openSocket'](_0x2f5d77,_0x49c03c,_0xeb318),_0x2f5d77&&(_0x14e740=_0x2f5d77),_0x8672c6['_server']['process'](_0x4e8f1f,_0xeb318,function(_0x401336){_0x49c03c&&_0x49c03c['send'](_0x224934(_0x401336));});}catch(_0x4838f5){console['log'](_0x4838f5['stack']),_0x8672c6['error'](_0x4838f5['message']+('\x0aBacktrace'+':\x0a')+_0x4838f5['stack']);}},_0x49c03c['onclose']=function(_0xa71586){_0x8672c6['_server']['closeSocke'+'t'](_0x14e740),_0x49c03c=null;};},'handleEventSource':function(_0x27a16a,_0x549db6){var _0x272ef2=new _0x5b90f3(_0x27a16a,_0x549db6,{'ping':this['_options']['ping']}),_0x8b767a=_0x272ef2['url']['split']('/')['pop'](),_0x3529ea=this;this['debug']('Opened\x20Eve'+'ntSource\x20c'+'onnection\x20'+'for\x20?',_0x8b767a),this['_server']['openSocket'](_0x8b767a,_0x272ef2,_0x27a16a),_0x272ef2['onclose']=function(_0x552958){_0x3529ea['_server']['closeSocke'+'t'](_0x8b767a),_0x272ef2=null;};},'_handleOptions':function(_0x4251de,_0x512f2b){var _0x20707c={'Access-Control-Allow-Credentials':'true','Access-Control-Allow-Headers':'Accept,\x20Au'+'thorizatio'+'n,\x20Content'+'-Type,\x20Pra'+'gma,\x20X-Req'+'uested-Wit'+'h','Access-Control-Allow-Methods':'POST,\x20GET','Access-Control-Allow-Origin':_0x4251de['headers']['origin']||_0x4251de['headers']['referer']||'*','Access-Control-Max-Age':'86400'};_0x512f2b['writeHead'](0xd3*0x1f+-0x1a40+-0x17b*-0x1,_0x20707c),_0x512f2b['end']('');},'_concatStream':function(_0x1515cf,_0x2c576c,_0x1defbf){var _0x1dfed6=[],_0x1a742f=0x1*-0xb48+0x1*0x20e3+-0x159b;_0x1515cf['on']('data',function(_0x44eb77){_0x1dfed6['push'](_0x44eb77),_0x1a742f+=_0x44eb77['length'];}),_0x1515cf['on']('end',function(){for(var _0x253696=_0x28cb0b['alloc'](_0x1a742f),_0x196232=-0x1416+-0x249a*-0x1+-0x4*0x421,_0x65e25d=-0x1*-0x1dc1+-0x27c*-0xb+-0x3915*0x1,_0x63e225=_0x1dfed6['length'];_0x65e25d<_0x63e225;_0x65e25d++)_0x1dfed6[_0x65e25d]['copy'](_0x253696,_0x196232),_0x196232+=_0x1dfed6[_0x65e25d]['length'];_0x2c576c['call'](_0x1defbf,_0x253696['toString']('utf8'));});},'_parseJSON':function(_0x212616){var _0x8c31ac=JSON['parse'](_0x212616);if('object'==typeof _0x8c31ac)return _0x8c31ac;throw new SyntaxError('JSON\x20messa'+'ges\x20must\x20c'+'ontain\x20an\x20'+'object\x20or\x20'+'array');},'_formatRequest':function(_0x281002){var _0x1ee0ab=_0x281002['method']['toUpperCas'+'e'](),_0x3fa293='curl\x20-X\x20'+_0x1ee0ab;return _0x3fa293+='\x20\x27http://'+_0x281002['headers']['host']+_0x281002['url']+'\x27','POST'===_0x1ee0ab&&(_0x3fa293+='\x20-H\x20\x27Conte'+'nt-Type:\x20'+_0x281002['headers']['content-ty'+'pe']+'\x27',_0x3fa293+='\x20-d\x20\x27'+_0x281002['body']+'\x27'),_0x3fa293;},'_returnError':function(_0x33ab6c,_0x4f1322){var _0x41e552=_0x4f1322['message'];_0x4f1322['stack']&&(_0x41e552+='\x0aBacktrace'+':\x0a'+_0x4f1322['stack']),this['error'](_0x41e552),_0x33ab6c&&(_0x33ab6c['writeHead'](-0x1f1b+0x567+-0x2*-0xda2,_0x1298b1['TYPE_TEXT']),_0x33ab6c['end']('Bad\x20reques'+'t'));}});for(var _0x2c93d6 in _0x57210d)!function(_0x1a9545){_0x5f0b8e['prototype'][_0x1a9545]=function(){return this['_server']['_engine'][_0x1a9545]['apply'](this['_server']['_engine'],arguments);};}(_0x2c93d6);_0x4edc04(_0x5f0b8e['prototype'],_0xc40ff9),_0x1dd6b5['exports']=_0x5f0b8e;},0x15b4:(_0x1f23f5,_0x4578c8,_0x194657)=>{'use strict';var _0x12dcdb=_0x194657(-0x2485+0x1f3*0x17+0x12f6),_0x413d6f=_0x194657(-0x4525+-0x1*-0x2364+-0x3*-0x1823),_0x301582=_0x194657(-0x9*0x425+-0x7*0xfe+0x474f),_0x13991a=_0x194657(0xcf4*-0x1+0x7*0x31c+0x5*0x3b8),_0x1dfe85=_0x194657(0x26e*-0xd+-0x173e+0x46e0),_0x3ffb2a=_0x194657(-0x3*0x3d6+-0x38d+0x1c52),_0x5175d0=_0x194657(-0x139b+0x325e+0x3f8),_0x1b1266=_0x1dfe85({'initialize':function(_0x32bebb,_0x2cda7c){this['_directory']=_0x32bebb,this['_pathRegex']=_0x2cda7c,this['_pathMap']={},this['_index']={};},'map':function(_0x38cf9d,_0x37794a){this['_pathMap'][_0x38cf9d]=_0x37794a;},'test':function(_0x4536ee){return this['_pathRegex']['test'](_0x4536ee);},'call':function(_0x1cb86c,_0xbe6fb1){var _0x593941=_0x13991a['parse'](_0x1cb86c['url'],!(-0x1*-0x10f5+0x15d+-0x1252))['pathname'],_0x5cf4bd=_0x301582['basename'](_0x593941);_0x5cf4bd=this['_pathMap'][_0x5cf4bd]||_0x5cf4bd,this['_index'][_0x5cf4bd]=this['_index'][_0x5cf4bd]||{};var _0x565567=this['_index'][_0x5cf4bd],_0x47d491=_0x301582['join'](this['_directory'],_0x5cf4bd);try{_0x565567['content']=_0x565567['content']||_0x413d6f['readFileSy'+'nc'](_0x47d491),_0x565567['digest']=_0x565567['digest']||_0x12dcdb['createHash']('sha1')['update'](_0x565567['content'])['digest']('hex'),_0x565567['mtime']=_0x565567['mtime']||_0x413d6f['statSync'](_0x47d491)['mtime'];}catch(_0x46f5c7){return _0xbe6fb1['writeHead'](0x1*0x10df+0x1*-0x61f+-0x92c,{}),_0xbe6fb1['end']();}var _0x4fd83b=/\.js$/['test'](_0x593941)?'TYPE_SCRIP'+'T':'TYPE_JSON',_0x5f3a05=_0x1cb86c['headers']['if-modifie'+'d-since'],_0x2a966c={'ETag':_0x565567['digest'],'Last-Modified':_0x565567['mtime']['toGMTStrin'+'g']()};_0x1cb86c['headers']['if-none-ma'+'tch']===_0x565567['digest']||_0x5f3a05&&_0x565567['mtime']<=new Date(_0x5f3a05)?(_0xbe6fb1['writeHead'](0x10*0xf9+-0x9c8+-0x498,_0x2a966c),_0xbe6fb1['end']()):(_0x2a966c['Content-Le'+'ngth']=_0x565567['content']['length'],_0x3ffb2a(_0x2a966c,_0x5175d0[_0x4fd83b]),_0xbe6fb1['writeHead'](0xa43+0x1b0e+0xc7*-0x2f,_0x2a966c),_0xbe6fb1['end'](_0x565567['content']));}});_0x1f23f5['exports']=_0x1b1266;},0x15bf:(_0x448ce6,_0x4c75d0,_0x5e259d)=>{'use strict';var _0xac6c84=_0x5e259d(-0x11*-0x16a+-0x1*-0xa58+0x1*-0x1256),_0x5408db=_0x5e259d(0xccd+0x2035+-0x1fbf),_0x4991b4=_0x5e259d(0x927+0xc89*-0x1+-0x34*-0x87),_0x498ba8=_0x5e259d(0x33e5+0x4*0xcb2+0x4255*-0x1),_0x34f1a8=_0xac6c84({'initialize':function(_0x3fe812,_0x17e356,_0x47d765){this['_engine']=_0x3fe812,this['_id']=_0x17e356,this['_options']=_0x47d765,this['_inbox']=[];},'deliver':function(_0x4148d5){if(delete _0x4148d5['clientId'],this['socket'])return this['socket']['send'](_0x4148d5);this['_inbox']['push'](_0x4148d5),this['_beginDeli'+'veryTimeou'+'t']();},'connect':function(_0x28e793,_0x501879,_0x92cb9e){var _0x34d61c=void(-0x1*0x7de+0x869+-0x8b)!==(_0x28e793=_0x28e793||{})['timeout']?_0x28e793['timeout']/(-0xc92+0x4*0x471+-0x3*0x6e):this['_engine']['timeout'];this['setDeferre'+'dStatus']('unknown'),this['callback'](_0x501879,_0x92cb9e),this['_beginDeli'+'veryTimeou'+'t'](),this['_beginConn'+'ectionTime'+'out'](_0x34d61c);},'flush':function(){this['removeTime'+'out']('connection'),this['removeTime'+'out']('delivery'),this['setDeferre'+'dStatus']('succeeded',this['_inbox']),this['_inbox']=[],this['socket']||this['_engine']['closeConne'+'ction'](this['_id']);},'_beginDeliveryTimeout':function(){0x1838+-0x1710+-0x8*0x25!==this['_inbox']['length']&&this['addTimeout']('delivery',this['_engine']['MAX_DELAY'],this['flush'],this);},'_beginConnectionTimeout':function(_0x3b3f01){this['addTimeout']('connection',_0x3b3f01,this['flush'],this);}});_0x5408db(_0x34f1a8['prototype'],_0x4991b4),_0x5408db(_0x34f1a8['prototype'],_0x498ba8),_0x448ce6['exports']=_0x34f1a8;},0x1628:(_0x12aa41,_0x308a7e,_0x73b0b8)=>{'use strict';var _0x2071b6=_0x73b0b8(0x1c08+0x5*0x1af+0xf*-0x186),_0x38acee=_0x73b0b8(0x76*0x11+-0x1*-0x45b+0x112),_0x544658=_0x73b0b8(0x26e1+0x9be+0xe2*-0x24),_0x41e5fa=_0x73b0b8(-0x506+0x770*-0x4+-0x1a6*-0x21),_0x281909=_0x73b0b8(0x2321+-0xcf1*0x4+-0x9*-0x5e3),_0x1bad14=function(_0x455563,_0x521e22){this['_server']=_0x455563,this['_options']=_0x521e22||{},this['reset']();};_0x1bad14['create']=function(_0x5f0379,_0x280670){return new _0x1bad14(_0x5f0379,_0x280670);},_0x38acee(_0x1bad14['prototype']={'disconnect':function(){this['reset'](),this['removeAllT'+'imeouts']();},'reset':function(){this['_namespace']=new _0x544658(),this['_clients']={},this['_channels']={},this['_messages']={};},'createClient':function(_0x2a11a,_0x25eb24){var _0x391293=this['_namespace']['generate']();this['_server']['debug']('Created\x20ne'+'w\x20client\x20?',_0x391293),this['ping'](_0x391293),this['_server']['trigger']('handshake',_0x391293),_0x2a11a['call'](_0x25eb24,_0x391293);},'destroyClient':function(_0x3d5c8a,_0x4e0fd6,_0x328037){if(this['_namespace']['exists'](_0x3d5c8a)){var _0x4885f0=this['_clients'];_0x4885f0[_0x3d5c8a]&&_0x4885f0[_0x3d5c8a]['forEach'](function(_0x63f27a){this['unsubscrib'+'e'](_0x3d5c8a,_0x63f27a);},this),this['removeTime'+'out'](_0x3d5c8a),this['_namespace']['release'](_0x3d5c8a),delete this['_messages'][_0x3d5c8a],this['_server']['debug']('Destroyed\x20'+'client\x20?',_0x3d5c8a),this['_server']['trigger']('disconnect',_0x3d5c8a),this['_server']['trigger']('close',_0x3d5c8a),_0x4e0fd6&&_0x4e0fd6['call'](_0x328037);}},'clientExists':function(_0x6e39c,_0x1a5699,_0x2e51e5){_0x1a5699['call'](_0x2e51e5,this['_namespace']['exists'](_0x6e39c));},'ping':function(_0x49bc3d){var _0x131f90=this['_server']['timeout'];'number'==typeof _0x131f90&&(this['_server']['debug']('Ping\x20?,\x20?',_0x49bc3d,_0x131f90),this['removeTime'+'out'](_0x49bc3d),this['addTimeout'](_0x49bc3d,(0x18e*0x2+-0x1609*-0x1+-0x1923)*_0x131f90,function(){this['destroyCli'+'ent'](_0x49bc3d);},this));},'subscribe':function(_0x3b32e4,_0x2efd82,_0x25e1c2,_0x216678){var _0xacc1a1=this['_clients'],_0x1a9cff=this['_channels'];_0xacc1a1[_0x3b32e4]=_0xacc1a1[_0x3b32e4]||new _0x41e5fa();var _0x507826=_0xacc1a1[_0x3b32e4]['add'](_0x2efd82);_0x1a9cff[_0x2efd82]=_0x1a9cff[_0x2efd82]||new _0x41e5fa(),_0x1a9cff[_0x2efd82]['add'](_0x3b32e4),this['_server']['debug']('Subscribed'+'\x20client\x20?\x20'+'to\x20channel'+'\x20?',_0x3b32e4,_0x2efd82),_0x507826&&this['_server']['trigger']('subscribe',_0x3b32e4,_0x2efd82),_0x25e1c2&&_0x25e1c2['call'](_0x216678,!(0x1337*0x2+-0x1461+-0x120d*0x1));},'unsubscribe':function(_0x1e61be,_0xa2ab02,_0xebae9f,_0x11a81a){var _0x31b1bf=this['_clients'],_0x4ac76e=this['_channels'],_0x2fa32a=!(-0x1*0x2421+-0x1dce+0xd3*0x50);_0x31b1bf[_0x1e61be]&&(_0x2fa32a=_0x31b1bf[_0x1e61be]['remove'](_0xa2ab02),_0x31b1bf[_0x1e61be]['isEmpty']()&&delete _0x31b1bf[_0x1e61be]),_0x4ac76e[_0xa2ab02]&&(_0x4ac76e[_0xa2ab02]['remove'](_0x1e61be),_0x4ac76e[_0xa2ab02]['isEmpty']()&&delete _0x4ac76e[_0xa2ab02]),this['_server']['debug']('Unsubscrib'+'ed\x20client\x20'+'?\x20from\x20cha'+'nnel\x20?',_0x1e61be,_0xa2ab02),_0x2fa32a&&this['_server']['trigger']('unsubscrib'+'e',_0x1e61be,_0xa2ab02),_0xebae9f&&_0xebae9f['call'](_0x11a81a,!(0x2488+0x2434+-0x48bc));},'publish':function(_0x31476f,_0x1fe6b6){this['_server']['debug']('Publishing'+'\x20message\x20?',_0x31476f);for(var _0x13b2ec,_0x543e82=this['_messages'],_0x498121=new _0x41e5fa(),_0x422064=-0xd*0x161+-0x21fb*-0x1+0x19b*-0xa,_0x1b8c0d=_0x1fe6b6['length'];_0x422064<_0x1b8c0d;_0x422064++)(_0x13b2ec=this['_channels'][_0x1fe6b6[_0x422064]])&&_0x13b2ec['forEach'](_0x498121['add'],_0x498121);_0x498121['forEach'](function(_0x2f4bc9){this['_server']['debug']('Queueing\x20f'+'or\x20client\x20'+'?:\x20?',_0x2f4bc9,_0x31476f),_0x543e82[_0x2f4bc9]=_0x543e82[_0x2f4bc9]||[],_0x543e82[_0x2f4bc9]['push'](_0x2071b6(_0x31476f)),this['emptyQueue'](_0x2f4bc9);},this),this['_server']['trigger']('publish',_0x31476f['clientId'],_0x31476f['channel'],_0x31476f['data']);},'emptyQueue':function(_0xa4801e){this['_server']['hasConnect'+'ion'](_0xa4801e)&&(this['_server']['deliver'](_0xa4801e,this['_messages'][_0xa4801e]),delete this['_messages'][_0xa4801e]);}},_0x281909),_0x12aa41['exports']=_0x1bad14;},0x24af:(_0x254ab4,_0x49f005,_0x3cd99f)=>{'use strict';var _0xdf761c=_0x3cd99f(0x1*0x1e56+-0x1375+-0x70a),_0x31c95c=_0x3cd99f(0x6e8+0x68f*0x5+0x178*-0x12),_0x29a38b=_0x3cd99f(0x1eb1+0x95c*-0x1+-0x4*0x2d4),_0x4a1956=_0x3cd99f(-0x67f+-0x2195*-0x1+-0xb0a),_0x9382b8=(_0x3cd99f(-0x28d*0x7+0x2379*0x1+-0x1149),_0x3cd99f(0xc06*-0x3+-0xec1*-0x2+0x1827)),_0x29528c=_0x3cd99f(-0x31f9+-0x24f1*0x1+0x1*0x7154),_0x281365=_0x3cd99f(-0x3fb9+0x226e+0x3d76),_0x572659=_0x3cd99f(-0x151a+0x1*-0x40f+-0x9e*-0x4c),_0x4b9bce=_0x3cd99f(0x2b2+0x6c*0x3+0x1232),_0x367088=_0x31c95c(_0x4a1956({'className':'Engine.Pro'+'xy','MAX_DELAY':0x0,'INTERVAL':0x0,'TIMEOUT':0x3c,'initialize':function(_0x2d6fea){this['_options']=_0x2d6fea||{},this['_connectio'+'ns']={},this['interval']=this['_options']['interval']||this['INTERVAL'],this['timeout']=this['_options']['timeout']||this['TIMEOUT'];var _0x31119e=this['_options']['type']||_0x4b9bce;this['_engine']=_0x31119e['create'](this,this['_options']),this['bind']('close',function(_0x19015e){var _0xf046c=this;_0xdf761c(function(){_0xf046c['flushConne'+'ction'](_0x19015e);});},this),this['debug']('Created\x20ne'+'w\x20engine:\x20'+'?',this['_options']);},'connect':function(_0x45f22e,_0x303a89,_0x5cf505,_0x1a1f7d){this['debug']('Accepting\x20'+'connection'+'\x20from\x20?',_0x45f22e),this['_engine']['ping'](_0x45f22e),this['connection'](_0x45f22e,!(0x1*0xf71+0x1938+0x7*-0x5cf))['connect'](_0x303a89,_0x5cf505,_0x1a1f7d),this['_engine']['emptyQueue'](_0x45f22e);},'hasConnection':function(_0x10f07d){return this['_connectio'+'ns']['hasOwnProp'+'erty'](_0x10f07d);},'connection':function(_0x1c85ac,_0x2e507b){var _0x2ee283=this['_connectio'+'ns'][_0x1c85ac];return _0x2ee283||!_0x2e507b?_0x2ee283:(this['_connectio'+'ns'][_0x1c85ac]=new _0x572659(this,_0x1c85ac),this['trigger']('connection'+':open',_0x1c85ac),this['_connectio'+'ns'][_0x1c85ac]);},'closeConnection':function(_0x39bb87){this['debug']('Closing\x20co'+'nnection\x20f'+'or\x20?',_0x39bb87);var _0x1503f1=this['_connectio'+'ns'][_0x39bb87];_0x1503f1&&(_0x1503f1['socket']&&_0x1503f1['socket']['close'](),this['trigger']('connection'+':close',_0x39bb87),delete this['_connectio'+'ns'][_0x39bb87]);},'openSocket':function(_0x161ace,_0x3944a3){this['connection'](_0x161ace,!(0x2*0x1142+0x6fb*0x4+-0x3e70))['socket']=_0x3944a3;},'deliver':function(_0x5d2415,_0x47a2c8){if(!_0x47a2c8||-0xab4+-0x5f*-0x4c+-0x1180===_0x47a2c8['length'])return!(-0xa50+-0x22*-0x10b+0x1925*-0x1);var _0x5e4639=this['connection'](_0x5d2415,!(-0x1759+-0x283*0x2+-0x1c6*-0x10));if(!_0x5e4639)return!(0xe93+0x5a8*0x1+-0x1*0x143a);for(var _0x2635a4=-0x96a+-0x1991+0x1*0x22fb,_0x36e25d=_0x47a2c8['length'];_0x2635a4<_0x36e25d;_0x2635a4++)_0x5e4639['deliver'](_0x47a2c8[_0x2635a4]);return!(0x2249+-0x1d*0x2+-0x220f);},'generateId':function(){return _0x29a38b();},'flushConnection':function(_0xc939c1,_0x22eda7){if(_0xc939c1){this['debug']('Flushing\x20c'+'onnection\x20'+'for\x20?',_0xc939c1);var _0x319e8e=this['connection'](_0xc939c1,!(0x1*-0x2124+0xd8f+0x17*0xda));_0x319e8e&&(!(-0xc1*-0x5+0x1343+-0x1707)===_0x22eda7&&(_0x319e8e['socket']=null),_0x319e8e['flush'](),this['closeConne'+'ction'](_0xc939c1));}},'close':function(){for(var _0x4d1f75 in this['_connectio'+'ns'])this['flushConne'+'ction'](_0x4d1f75);this['_engine']['disconnect']();},'disconnect':function(){if(this['_engine']['disconnect'])return this['_engine']['disconnect']();},'publish':function(_0x1b49d1){var _0x4b80ee=_0x281365['expand'](_0x1b49d1['channel']);return this['_engine']['publish'](_0x1b49d1,_0x4b80ee);}}),{'get':function(_0x4c8939){return new _0x367088(_0x4c8939);}});['createClie'+'nt','clientExis'+'ts','destroyCli'+'ent','ping','subscribe','unsubscrib'+'e']['forEach'](function(_0x45b08f){_0x367088['prototype'][_0x45b08f]=function(){return this['_engine'][_0x45b08f]['apply'](this['_engine'],arguments);};}),_0x31c95c(_0x367088['prototype'],_0x29528c),_0x31c95c(_0x367088['prototype'],_0x9382b8),_0x254ab4['exports']=_0x367088;},0xa37:(_0x1538f0,_0xad5a89,_0x4d246f)=>{'use strict';var _0x51cc24=_0x4d246f(0x2141+0x1736+0x1f*-0x18e),_0x144c34=_0x4d246f(0x1a6b+-0x515+-0x89*0x7),_0x23c80b={'VERSION':_0x51cc24['VERSION'],'Client':_0x4d246f(-0x26e2+-0x11c3+0x4006),'Scheduler':_0x4d246f(0xc2+0x3382*-0x1+-0x1*-0x4d15),'NodeAdapter':_0x4d246f(0x857+0x689+0x1a*-0x9)};_0x144c34['wrapper']=_0x23c80b,_0x1538f0['exports']=_0x23c80b;},0x180a:(_0x98a81a,_0x1fd4ca,_0x3d5e2e)=>{'use strict';var _0x2d018c=_0x3d5e2e(0x3*-0x70a+-0x2e*0x49+0x2291*0x1);_0x98a81a['exports']={'then':function(_0x53aa0f,_0x209f92){var _0x15f5fb=this;return this['_promise']||(this['_promise']=new _0x2d018c(function(_0x5dcea7,_0x584c53){_0x15f5fb['_resolve']=_0x5dcea7,_0x15f5fb['_reject']=_0x584c53;})),0x155e+-0x2439+0xedb===arguments['length']?this['_promise']:this['_promise']['then'](_0x53aa0f,_0x209f92);},'callback':function(_0x1eedf6,_0x2f0641){return this['then'](function(_0x56aedb){_0x1eedf6['call'](_0x2f0641,_0x56aedb);});},'errback':function(_0x543597,_0x2da376){return this['then'](null,function(_0x98540){_0x543597['call'](_0x2da376,_0x98540);});},'timeout':function(_0x5b7996,_0x22375b){this['then']();var _0x199bda=this;this['_timer']=global['setTimeout'](function(){_0x199bda['_reject'](_0x22375b);},(0x1a5b+0x1e15+-0x3488)*_0x5b7996);},'setDeferredStatus':function(_0x3ca7ff,_0x336fc4){this['_timer']&&global['clearTimeo'+'ut'](this['_timer']),this['then'](),'succeeded'===_0x3ca7ff?this['_resolve'](_0x336fc4):'failed'===_0x3ca7ff?this['_reject'](_0x336fc4):delete this['_promise'];}};},0x1197:(_0xb9fc5b,_0x3a3be4,_0x5c2ed3)=>{'use strict';var _0x506d58=_0x5c2ed3(-0x32f2+-0x2*-0x190+0x4d3e*0x1),_0x2eb496={'LOG_LEVELS':{'fatal':0x4,'error':0x3,'warn':0x2,'info':0x1,'debug':0x0},'writeLog':function(_0x1f1b7b,_0x806529){var _0x577168=_0x2eb496['logger']||(_0x2eb496['wrapper']||_0x2eb496)['logger'];if(_0x577168){var _0x4799b3=Array['prototype']['slice']['apply'](_0x1f1b7b),_0x1e7126='[Faye',_0x18ff1b=this['className'],_0x3d0225=_0x4799b3['shift']()['replace'](/\?/g,function(){try{return _0x506d58(_0x4799b3['shift']());}catch(_0x306063){return'[Object]';}});_0x18ff1b&&(_0x1e7126+='.'+_0x18ff1b),_0x1e7126+=']\x20','function'==typeof _0x577168[_0x806529]?_0x577168[_0x806529](_0x1e7126+_0x3d0225):'function'==typeof _0x577168&&_0x577168(_0x1e7126+_0x3d0225);}}};for(var _0x22ed65 in _0x2eb496['LOG_LEVELS'])!function(_0xc2d757){_0x2eb496[_0xc2d757]=function(){this['writeLog'](arguments,_0xc2d757);};}(_0x22ed65);_0xb9fc5b['exports']=_0x2eb496;},0x1a6a:(_0x56fa3,_0xf5222e,_0x3e00ec)=>{'use strict';var _0x47baf6={'countListeners':function(_0x287046){return this['listeners'](_0x287046)['length'];},'bind':function(_0x2be54f,_0x508198,_0x3b5436){var _0x153223=Array['prototype']['slice'],_0x3e9b62=function(){_0x508198['apply'](_0x3b5436,_0x153223['call'](arguments));};return this['_listeners']=this['_listeners']||[],this['_listeners']['push']([_0x2be54f,_0x508198,_0x3b5436,_0x3e9b62]),this['on'](_0x2be54f,_0x3e9b62);},'unbind':function(_0x413ce0,_0x3c52f9,_0x5492ac){this['_listeners']=this['_listeners']||[];for(var _0x1e0af8,_0x4e8069=this['_listeners']['length'];_0x4e8069--;)(_0x1e0af8=this['_listeners'][_0x4e8069])[-0x4*0x4df+-0x2203+0x357f]===_0x413ce0&&(!_0x3c52f9||_0x1e0af8[-0xb*-0x25b+-0x9*-0x169+-0x2699*0x1]===_0x3c52f9&&_0x1e0af8[-0x186f+0x5ab*-0x5+0x34c8]===_0x5492ac)&&(this['_listeners']['splice'](_0x4e8069,0x4*0x6f5+-0x1b0c*-0x1+-0x36df),this['removeList'+'ener'](_0x413ce0,_0x1e0af8[-0x1df9*-0x1+-0x2*-0x2e6+0x11e1*-0x2]));}};_0x3e00ec(-0x11e2+0x1d34+0x1*0x1f1)(_0x47baf6,_0x3e00ec(0x16d6+-0x1e7c+0xa2f)['prototype']),_0x47baf6['trigger']=_0x47baf6['emit'],_0x56fa3['exports']=_0x47baf6;},0x2458:_0x1f2380=>{'use strict';_0x1f2380['exports']={'addTimeout':function(_0x3f64b0,_0x37e469,_0x13068a,_0x599a51){if(this['_timeouts']=this['_timeouts']||{},!this['_timeouts']['hasOwnProp'+'erty'](_0x3f64b0)){var _0x20d496=this;this['_timeouts'][_0x3f64b0]=global['setTimeout'](function(){delete _0x20d496['_timeouts'][_0x3f64b0],_0x13068a['call'](_0x599a51);},(-0x1a38+0x45d*0x5+0x2c5*0x3)*_0x37e469);}},'removeTimeout':function(_0x52ddac){this['_timeouts']=this['_timeouts']||{};var _0x2d963e=this['_timeouts'][_0x52ddac];_0x2d963e&&(global['clearTimeo'+'ut'](_0x2d963e),delete this['_timeouts'][_0x52ddac]);},'removeAllTimeouts':function(){for(var _0x22fe26 in(this['_timeouts']=this['_timeouts']||{},this['_timeouts']))this['removeTime'+'out'](_0x22fe26);}};},0x202b:(_0x52c25c,_0x169f84,_0x21697d)=>{'use strict';var _0x503259=_0x21697d(-0x9b*0x25+0x1*-0x97+0x1*0x270a),_0xa8ce23=_0x21697d(-0x17e*0x5+0x71*-0x2+0x159b),_0x23ffc8=_0x21697d(0x4*-0x558+-0x330d*0x1+0x62d7),_0x3d9396=(_0x21697d(0x24ea+-0xa0f+-0x22*0x6d),_0x503259({'initialize':function(_0x3df6f8){this['id']=this['name']=_0x3df6f8;},'push':function(_0x2f0fe2){this['trigger']('message',_0x2f0fe2);},'isUnused':function(){return-0x4*0x214+-0x9*-0x269+0x89*-0x19===this['countListe'+'ners']('message');}}));_0xa8ce23(_0x3d9396['prototype'],_0x23ffc8),_0xa8ce23(_0x3d9396,{'HANDSHAKE':'/meta/hand'+'shake','CONNECT':'/meta/conn'+'ect','SUBSCRIBE':'/meta/subs'+'cribe','UNSUBSCRIBE':'/meta/unsu'+'bscribe','DISCONNECT':'/meta/disc'+'onnect','META':'meta','SERVICE':'service','expand':function(_0x12f1e0){var _0x15bd71=this['parse'](_0x12f1e0),_0x427d82=['/**',_0x12f1e0],_0x113b5b=_0x15bd71['slice']();_0x113b5b[_0x113b5b['length']-(0x155f*0x1+0xe1b+-0x2379)]='*',_0x427d82['push'](this['unparse'](_0x113b5b));for(var _0x4d146a=-0x12cc+0xd2a+-0xd*-0x6f,_0x5b787a=_0x15bd71['length'];_0x4d146a<_0x5b787a;_0x4d146a++)(_0x113b5b=_0x15bd71['slice'](-0x310+0x1c5e*-0x1+0x53d*0x6,_0x4d146a))['push']('**'),_0x427d82['push'](this['unparse'](_0x113b5b));return _0x427d82;},'isValid':function(){return!(-0x1ba8*-0x1+-0x113e+-0xa6a);},'parse':function(_0x2fce8b){return this['isValid'](_0x2fce8b)?_0x2fce8b['split']('/')['slice'](0x1356+-0x1e05+0x26*0x48):null;},'unparse':function(_0x4ddbc3){return'/'+_0x4ddbc3['join']('/');},'isMeta':function(_0x1fc503){var _0x4fd4ee=this['parse'](_0x1fc503);return _0x4fd4ee?_0x4fd4ee[0x15ce*-0x1+0x9ef+-0x1*-0xbdf]===this['META']:null;},'isService':function(_0x3824bc){var _0x21cc0f=this['parse'](_0x3824bc);return _0x21cc0f?_0x21cc0f[0x1f*-0x1d+0x10b9+0x2*-0x69b]===this['SERVICE']:null;},'isSubscribable':function(_0x31c2e9){return this['isValid'](_0x31c2e9)?!this['isMeta'](_0x31c2e9)&&!this['isService'](_0x31c2e9):null;},'Set':_0x503259({'initialize':function(){this['_channels']={};},'getKeys':function(){var _0x20db12=[];for(var _0x24c8f4 in this['_channels'])_0x20db12['push'](_0x24c8f4);return _0x20db12;},'remove':function(_0x2754b6){delete this['_channels'][_0x2754b6];},'hasSubscription':function(_0xb69609){return this['_channels']['hasOwnProp'+'erty'](_0xb69609);},'subscribe':function(_0x164c55,_0x3e5823){for(var _0x3e6512,_0x97e27f=-0x1aa4+0x3a2+-0xa*-0x24d,_0x1ca928=_0x164c55['length'];_0x97e27f<_0x1ca928;_0x97e27f++)_0x3e6512=_0x164c55[_0x97e27f],(this['_channels'][_0x3e6512]=this['_channels'][_0x3e6512]||new _0x3d9396(_0x3e6512))['bind']('message',_0x3e5823);},'unsubscribe':function(_0x2fd77a,_0x4331b0){var _0x2b07ff=this['_channels'][_0x2fd77a];return!!_0x2b07ff&&(_0x2b07ff['unbind']('message',_0x4331b0),!!_0x2b07ff['isUnused']()&&(this['remove'](_0x2fd77a),!(-0x16d6+-0x2516+0x3b*0x104)));},'distributeMessage':function(_0x11dcd9){for(var _0x2b0864=_0x3d9396['expand'](_0x11dcd9['channel']),_0x274089=-0x1e*-0x122+0x1862+0x2*-0x1d2f,_0x424bac=_0x2b0864['length'];_0x274089<_0x424bac;_0x274089++){var _0x13035d=this['_channels'][_0x2b0864[_0x274089]];_0x13035d&&_0x13035d['trigger']('message',_0x11dcd9);}}})}),_0x52c25c['exports']=_0x3d9396;},0x761:(_0xe0ae41,_0x3b6526,_0x16cbd8)=>{'use strict';var _0xa07c44=_0x16cbd8(0x53a+0x1*-0x25f1+0x1247*0x2),_0x2eb039=_0x16cbd8(-0xb42+0x252d+-0x85*0x13),_0x3c524d=(_0x16cbd8(-0x3ff*-0x5+0xe*-0x21e+-0x2*-0x4ff),_0x16cbd8(0x6*-0x255+-0xe6+0x102d)),_0x6389d5=_0x16cbd8(-0xf5e+-0x528+0x1f3*0x13),_0x11cdbe=_0x16cbd8(0x1fdc*0x1+0x2*-0x131d+-0xea3*-0x1),_0x2c4dd4=_0x16cbd8(0x2*0xc75+0x1e02+-0x29a9),_0x4512e1=_0x16cbd8(-0x8e7+0x1*0x975+0x83*0x1d),_0x51a3a3=_0x16cbd8(-0x1f8c+0x1335+-0x8b*-0x43),_0x1dc159=_0x16cbd8(0xc45+0x803+-0x2b1),_0x5886f1=_0x16cbd8(0x2a64+-0xffb+-0x1*-0x1),_0x3615dc=_0x16cbd8(-0xd*-0x13+0x95b+-0x15d9*-0x1),_0x3d51e4=_0x16cbd8(0x18c1+0x3d*-0x9e+0x796*0x2),_0x1547e7=_0x16cbd8(-0x2*0x42+-0x167e+0x1ecc),_0x187a5b=_0x16cbd8(0xedb*0x2+0x525*-0x6+0x1f83),_0x3e8cea=_0x16cbd8(0x14f6+0xb71*0x3+-0x3733),_0x268f89=_0x16cbd8(0x2a4*-0xb+-0x27ee*-0x1+-0x1*-0xc11),_0x2ac6b7=_0x2eb039({'className':'Client','UNCONNECTED':0x1,'CONNECTING':0x2,'CONNECTED':0x3,'DISCONNECTED':0x4,'HANDSHAKE':'handshake','RETRY':'retry','NONE':'none','CONNECTION_TIMEOUT':0x3c,'DEFAULT_ENDPOINT':'/bayeux','INTERVAL':0x0,'initialize':function(_0x2e19c1,_0x7e5058){this['info']('New\x20client'+'\x20created\x20f'+'or\x20?',_0x2e19c1),_0x4512e1(_0x7e5058=_0x7e5058||{},['interval','timeout','endpoints','proxy','retry','scheduler','websocketE'+'xtensions','tls','ca']),this['_channels']=new _0x3615dc['Set'](),this['_dispatche'+'r']=_0x3d51e4['create'](this,_0x2e19c1||this['DEFAULT_EN'+'DPOINT'],_0x7e5058),this['_messageId']=0x1621+0x4*0x6d6+0x55*-0x95,this['_state']=this['UNCONNECTE'+'D'],this['_responseC'+'allbacks']={},this['_advice']={'reconnect':this['RETRY'],'interval':(-0x26c5+0x265d+0x450)*(_0x7e5058['interval']||this['INTERVAL']),'timeout':(-0x24*0x9+-0x2*0x10b2+0x1348*0x2)*(_0x7e5058['timeout']||this['CONNECTION'+'_TIMEOUT'])},this['_dispatche'+'r']['timeout']=this['_advice']['timeout']/(0x25*-0x26+0x1384+-0xa1e),this['_dispatche'+'r']['bind']('message',this['_receiveMe'+'ssage'],this),_0x6389d5['Event']&&void(0x10d8+0xa77+0x1*-0x1b4f)!==global['onbeforeun'+'load']&&_0x6389d5['Event']['on'](global,'beforeunlo'+'ad',function(){_0x3c524d['indexOf'](this['_dispatche'+'r']['_disabled'],'autodiscon'+'nect')<-0x9b*-0x5+-0x235*-0x2+-0x771&&this['disconnect']();},this);},'addWebsocketExtension':function(_0x52eb42){return this['_dispatche'+'r']['addWebsock'+'etExtensio'+'n'](_0x52eb42);},'disable':function(_0x5c027e){return this['_dispatche'+'r']['disable'](_0x5c027e);},'setHeader':function(_0x395aa1,_0x134537){return this['_dispatche'+'r']['setHeader'](_0x395aa1,_0x134537);},'handshake':function(_0x4fef6e,_0x5d2304){if(this['_advice']['reconnect']!==this['NONE']&&this['_state']===this['UNCONNECTE'+'D']){this['_state']=this['CONNECTING'];var _0x47ae47=this;this['info']('Initiating'+'\x20handshake'+'\x20with\x20?',this['_dispatche'+'r']['endpoint']['href']),this['_dispatche'+'r']['selectTran'+'sport'](_0x11cdbe['MANDATORY_'+'CONNECTION'+'_TYPES']),this['_sendMessa'+'ge']({'channel':_0x3615dc['HANDSHAKE'],'version':_0x11cdbe['BAYEUX_VER'+'SION'],'supportedConnectionTypes':this['_dispatche'+'r']['getConnect'+'ionTypes']()},{},function(_0x244e98){_0x244e98['successful']?(this['_state']=this['CONNECTED'],this['_dispatche'+'r']['clientId']=_0x244e98['clientId'],this['_dispatche'+'r']['selectTran'+'sport'](_0x244e98['supportedC'+'onnectionT'+'ypes']),this['info']('Handshake\x20'+'successful'+':\x20?',this['_dispatche'+'r']['clientId']),this['subscribe'](this['_channels']['getKeys'](),!(-0x1397+0x7d1+0x1*0xbc6)),_0x4fef6e&&_0xa07c44(function(){_0x4fef6e['call'](_0x5d2304);})):(this['info']('Handshake\x20'+'unsuccessf'+'ul'),global['setTimeout'](function(){_0x47ae47['handshake'](_0x4fef6e,_0x5d2304);},(0x1df*-0x3+-0xbd*0x2d+0x2abe)*this['_dispatche'+'r']['retry']),this['_state']=this['UNCONNECTE'+'D']);},this);}},'connect':function(_0x3096ff,_0x35be81){if(this['_advice']['reconnect']!==this['NONE']&&this['_state']!==this['DISCONNECT'+'ED']){if(this['_state']===this['UNCONNECTE'+'D'])return this['handshake'](function(){this['connect'](_0x3096ff,_0x35be81);},this);this['callback'](_0x3096ff,_0x35be81),this['_state']===this['CONNECTED']&&(this['info']('Calling\x20de'+'ferred\x20act'+'ions\x20for\x20?',this['_dispatche'+'r']['clientId']),this['setDeferre'+'dStatus']('succeeded'),this['setDeferre'+'dStatus']('unknown'),this['_connectRe'+'quest']||(this['_connectRe'+'quest']=!(0x42*0x7b+-0x2c5*-0xb+-0x3e2d*0x1),this['info']('Initiating'+'\x20connectio'+'n\x20for\x20?',this['_dispatche'+'r']['clientId']),this['_sendMessa'+'ge']({'channel':_0x3615dc['CONNECT'],'clientId':this['_dispatche'+'r']['clientId'],'connectionType':this['_dispatche'+'r']['connection'+'Type']},{},this['_cycleConn'+'ection'],this)));}},'disconnect':function(){if(this['_state']===this['CONNECTED']){this['_state']=this['DISCONNECT'+'ED'],this['info']('Disconnect'+'ing\x20?',this['_dispatche'+'r']['clientId']);var _0x4a25cc=new _0x3e8cea();return this['_sendMessa'+'ge']({'channel':_0x3615dc['DISCONNECT'],'clientId':this['_dispatche'+'r']['clientId']},{},function(_0x1b1633){_0x1b1633['successful']?(this['_dispatche'+'r']['close'](),_0x4a25cc['setDeferre'+'dStatus']('succeeded')):_0x4a25cc['setDeferre'+'dStatus']('failed',_0x1547e7['parse'](_0x1b1633['error']));},this),this['info']('Clearing\x20c'+'hannel\x20lis'+'teners\x20for'+'\x20?',this['_dispatche'+'r']['clientId']),this['_channels']=new _0x3615dc['Set'](),_0x4a25cc;}},'subscribe':function(_0x1e76a1,_0x9efc42,_0x4b1ec7){if(_0x1e76a1 instanceof Array)return _0x3c524d['map'](_0x1e76a1,function(_0x51d563){return this['subscribe'](_0x51d563,_0x9efc42,_0x4b1ec7);},this);var _0x2c720b=new _0x268f89(this,_0x1e76a1,_0x9efc42,_0x4b1ec7),_0x4fe6f4=!(0x1*0x3bd+-0x2ec+0xd1*-0x1)===_0x9efc42;return this['_channels']['hasSubscri'+'ption'](_0x1e76a1)&&!_0x4fe6f4?(this['_channels']['subscribe']([_0x1e76a1],_0x2c720b),_0x2c720b['setDeferre'+'dStatus']('succeeded'),_0x2c720b):(this['connect'](function(){this['info']('Client\x20?\x20a'+'ttempting\x20'+'to\x20subscri'+'be\x20to\x20?',this['_dispatche'+'r']['clientId'],_0x1e76a1),_0x4fe6f4||this['_channels']['subscribe']([_0x1e76a1],_0x2c720b),this['_sendMessa'+'ge']({'channel':_0x3615dc['SUBSCRIBE'],'clientId':this['_dispatche'+'r']['clientId'],'subscription':_0x1e76a1},{},function(_0x2c0814){if(!_0x2c0814['successful'])return _0x2c720b['setDeferre'+'dStatus']('failed',_0x1547e7['parse'](_0x2c0814['error'])),this['_channels']['unsubscrib'+'e'](_0x1e76a1,_0x2c720b);var _0x4b1754=[]['concat'](_0x2c0814['subscripti'+'on']);this['info']('Subscripti'+'on\x20acknowl'+'edged\x20for\x20'+'?\x20to\x20?',this['_dispatche'+'r']['clientId'],_0x4b1754),_0x2c720b['setDeferre'+'dStatus']('succeeded');},this);},this),_0x2c720b);},'unsubscribe':function(_0x455b29,_0x18bee7){if(_0x455b29 instanceof Array)return _0x3c524d['map'](_0x455b29,function(_0x53bf69){return this['unsubscrib'+'e'](_0x53bf69,_0x18bee7);},this);this['_channels']['unsubscrib'+'e'](_0x455b29,_0x18bee7)&&this['connect'](function(){this['info']('Client\x20?\x20a'+'ttempting\x20'+'to\x20unsubsc'+'ribe\x20from\x20'+'?',this['_dispatche'+'r']['clientId'],_0x455b29),this['_sendMessa'+'ge']({'channel':_0x3615dc['UNSUBSCRIB'+'E'],'clientId':this['_dispatche'+'r']['clientId'],'subscription':_0x455b29},{},function(_0x3d979f){if(_0x3d979f['successful']){var _0x23e4bd=[]['concat'](_0x3d979f['subscripti'+'on']);this['info']('Unsubscrip'+'tion\x20ackno'+'wledged\x20fo'+'r\x20?\x20from\x20?',this['_dispatche'+'r']['clientId'],_0x23e4bd);}},this);},this);},'publish':function(_0x49a605,_0x26f953,_0xc86959){_0x4512e1(_0xc86959||{},['attempts','deadline']);var _0x1c06ad=new _0x3e8cea();return this['connect'](function(){this['info']('Client\x20?\x20q'+'ueueing\x20pu'+'blished\x20me'+'ssage\x20to\x20?'+':\x20?',this['_dispatche'+'r']['clientId'],_0x49a605,_0x26f953),this['_sendMessa'+'ge']({'channel':_0x49a605,'data':_0x26f953,'clientId':this['_dispatche'+'r']['clientId']},_0xc86959,function(_0x584181){_0x584181['successful']?_0x1c06ad['setDeferre'+'dStatus']('succeeded'):_0x1c06ad['setDeferre'+'dStatus']('failed',_0x1547e7['parse'](_0x584181['error']));},this);},this),_0x1c06ad;},'_sendMessage':function(_0x343734,_0x353541,_0x152ad8,_0xff8c03){_0x343734['id']=this['_generateM'+'essageId']();var _0xd6d307=this['_advice']['timeout']?(0x7*-0x4bf+-0x15a9+0x1*0x36e3+0.19999999999999996)*this['_advice']['timeout']/(-0x24d+0xc2*0x15+-0x163*0x7):(0x1c07+0x710*0x2+-0x2a26+0.19999999999999996)*this['_dispatche'+'r']['retry'];this['pipeThroug'+'hExtension'+'s']('outgoing',_0x343734,null,function(_0x3637cf){_0x3637cf&&(_0x152ad8&&(this['_responseC'+'allbacks'][_0x3637cf['id']]=[_0x152ad8,_0xff8c03]),this['_dispatche'+'r']['sendMessag'+'e'](_0x3637cf,_0xd6d307,_0x353541||{}));},this);},'_generateMessageId':function(){return this['_messageId']+=0x7*-0x1b1+0x5ca+0x2*0x307,this['_messageId']>=Math['pow'](0x35*-0xb1+0xb12+0x1995,-0x1*-0x1417+-0x1*0x8f9+0x2a*-0x43)&&(this['_messageId']=0x2*0x1353+-0x1448+0x125e*-0x1),this['_messageId']['toString'](0x264d*0x1+-0x2118+0x511*-0x1);},'_receiveMessage':function(_0x4a0550){var _0x2a8576,_0x56d193=_0x4a0550['id'];void(-0x39c*0x9+0x28d*-0xe+0x4432)!==_0x4a0550['successful']&&(_0x2a8576=this['_responseC'+'allbacks'][_0x56d193],delete this['_responseC'+'allbacks'][_0x56d193]),this['pipeThroug'+'hExtension'+'s']('incoming',_0x4a0550,null,function(_0x5ce890){_0x5ce890&&(_0x5ce890['advice']&&this['_handleAdv'+'ice'](_0x5ce890['advice']),this['_deliverMe'+'ssage'](_0x5ce890),_0x2a8576&&_0x2a8576[0x7fe+-0x7ef*0x3+-0x47*-0x39]['call'](_0x2a8576[-0x2334+0x13d*-0x12+0x397f],_0x5ce890));},this);},'_handleAdvice':function(_0x1e8cca){_0x2c4dd4(this['_advice'],_0x1e8cca),this['_dispatche'+'r']['timeout']=this['_advice']['timeout']/(-0x1232+-0x1*0xaa5+-0x65*-0x53),this['_advice']['reconnect']===this['HANDSHAKE']&&this['_state']!==this['DISCONNECT'+'ED']&&(this['_state']=this['UNCONNECTE'+'D'],this['_dispatche'+'r']['clientId']=null,this['_cycleConn'+'ection']());},'_deliverMessage':function(_0x39a24c){_0x39a24c['channel']&&void(0xce8+-0x33f*-0xb+0x5*-0x9b9)!==_0x39a24c['data']&&(this['info']('Client\x20?\x20c'+'alling\x20lis'+'teners\x20for'+'\x20?\x20with\x20?',this['_dispatche'+'r']['clientId'],_0x39a24c['channel'],_0x39a24c['data']),this['_channels']['distribute'+'Message'](_0x39a24c));},'_cycleConnection':function(){this['_connectRe'+'quest']&&(this['_connectRe'+'quest']=null,this['info']('Closed\x20con'+'nection\x20fo'+'r\x20?',this['_dispatche'+'r']['clientId']));var _0x24e0d3=this;global['setTimeout'](function(){_0x24e0d3['connect']();},this['_advice']['interval']);}});_0x2c4dd4(_0x2ac6b7['prototype'],_0x51a3a3),_0x2c4dd4(_0x2ac6b7['prototype'],_0x5886f1),_0x2c4dd4(_0x2ac6b7['prototype'],_0x1dc159),_0x2c4dd4(_0x2ac6b7['prototype'],_0x187a5b),_0xe0ae41['exports']=_0x2ac6b7;},0x247:(_0x16ac30,_0x54f2b0,_0x41b06e)=>{'use strict';var _0x1edd30=_0x41b06e(0x10d7*-0x2+0x268c+0x12*0x9f),_0xfbd7ea=_0x41b06e(-0x1ce5+-0xd25+0x31c8),_0xcf02f5=_0x41b06e(0x7*0x3cb+-0x1aa2+-0xb*-0x285),_0x2c401a=_0x41b06e(0x1607+0x1*0x221b+-0x2adf),_0x40729f=_0x41b06e(0x80a+-0x1*-0x1b77+-0x2*0x8f5),_0x2b6853=_0x41b06e(0x250f+0x2874+-0x3319),_0x4ed78b=_0x41b06e(0x9af+-0x1f*-0xd+0x1b8*0x4),_0x14b5b2=_0x41b06e(-0x2cd8*-0x1+-0xd72+-0x511),_0xdc4ff7=_0x1edd30({'className':'Dispatcher','MAX_REQUEST_SIZE':0x800,'DEFAULT_RETRY':0x5,'UP':0x1,'DOWN':0x2,'initialize':function(_0xa5af81,_0x2b4f3d,_0x40e5e1){this['_client']=_0xa5af81,this['endpoint']=_0xfbd7ea['parse'](_0x2b4f3d),this['_alternate'+'s']=_0x40e5e1['endpoints']||{},this['cookies']=_0xcf02f5['CookieJar']&&new _0xcf02f5['CookieJar'](),this['_disabled']=[],this['_envelopes']={},this['headers']={},this['retry']=_0x40e5e1['retry']||this['DEFAULT_RE'+'TRY'],this['_scheduler']=_0x40e5e1['scheduler']||_0x14b5b2,this['_state']=0x15de*-0x1+-0x24c0+0x3a9e,this['transports']={},this['wsExtensio'+'ns']=[],this['proxy']=_0x40e5e1['proxy']||{},'string'==typeof this['_proxy']&&(this['_proxy']={'origin':this['_proxy']});var _0x31dbeb=_0x40e5e1['websocketE'+'xtensions'];if(_0x31dbeb){for(var _0x596d05=0x1*0x3ed+-0xd59+-0x25b*-0x4,_0x5596e1=(_0x31dbeb=[]['concat'](_0x31dbeb))['length'];_0x596d05<_0x5596e1;_0x596d05++)this['addWebsock'+'etExtensio'+'n'](_0x31dbeb[_0x596d05]);}for(var _0x1fff23 in(this['tls']=_0x40e5e1['tls']||{},this['tls']['ca']=this['tls']['ca']||_0x40e5e1['ca'],this['_alternate'+'s']))this['_alternate'+'s'][_0x1fff23]=_0xfbd7ea['parse'](this['_alternate'+'s'][_0x1fff23]);this['maxRequest'+'Size']=this['MAX_REQUES'+'T_SIZE'];},'endpointFor':function(_0x4938ff){return this['_alternate'+'s'][_0x4938ff]||this['endpoint'];},'addWebsocketExtension':function(_0x3341e6){this['wsExtensio'+'ns']['push'](_0x3341e6);},'disable':function(_0x567932){this['_disabled']['push'](_0x567932),_0x4ed78b['disable'](_0x567932);},'setHeader':function(_0x377d2e,_0x29a499){this['headers'][_0x377d2e]=_0x29a499;},'close':function(){var _0x1653d9=this['_transport'];delete this['_transport'],_0x1653d9&&_0x1653d9['close']();},'getConnectionTypes':function(){return _0x4ed78b['getConnect'+'ionTypes']();},'selectTransport':function(_0x2a2ff2){_0x4ed78b['get'](this,_0x2a2ff2,this['_disabled'],function(_0x18495b){this['debug']('Selected\x20?'+'\x20transport'+'\x20for\x20?',_0x18495b['connection'+'Type'],_0x18495b['endpoint']['href']),_0x18495b!==this['_transport']&&(this['_transport']&&this['_transport']['close'](),this['_transport']=_0x18495b,this['connection'+'Type']=_0x18495b['connection'+'Type']);},this);},'sendMessage':function(_0x1a45d6,_0x40f9a5,_0x4bae87){_0x4bae87=_0x4bae87||{};var _0xefdb45,_0x1ab974=_0x1a45d6['id'],_0x6ff841=_0x4bae87['attempts'],_0x137b34=_0x4bae87['deadline']&&new Date()['getTime']()+(-0x1194+-0x3c7+-0x1*-0x1943)*_0x4bae87['deadline'],_0x4920da=this['_envelopes'][_0x1ab974];_0x4920da||(_0xefdb45=new this['_scheduler'](_0x1a45d6,{'timeout':_0x40f9a5,'interval':this['retry'],'attempts':_0x6ff841,'deadline':_0x137b34}),_0x4920da=this['_envelopes'][_0x1ab974]={'message':_0x1a45d6,'scheduler':_0xefdb45}),this['_sendEnvel'+'ope'](_0x4920da);},'_sendEnvelope':function(_0x30ff9e){if(this['_transport']&&!_0x30ff9e['request']&&!_0x30ff9e['timer']){var _0x1d1a8d=_0x30ff9e['message'],_0x1abae8=_0x30ff9e['scheduler'],_0x35a959=this;if(!_0x1abae8['isDelivera'+'ble']())return _0x1abae8['abort'](),void delete this['_envelopes'][_0x1d1a8d['id']];_0x30ff9e['timer']=global['setTimeout'](function(){_0x35a959['handleErro'+'r'](_0x1d1a8d);},(0x97e+-0x1a0f*0x1+-0x1*-0x1479)*_0x1abae8['getTimeout']()),_0x1abae8['send'](),_0x30ff9e['request']=this['_transport']['sendMessag'+'e'](_0x1d1a8d);}},'handleResponse':function(_0x32e7cd){var _0x1c2b4e=this['_envelopes'][_0x32e7cd['id']];void(-0x20c5+0x225+0x1ea0)!==_0x32e7cd['successful']&&_0x1c2b4e&&(_0x1c2b4e['scheduler']['succeed'](),delete this['_envelopes'][_0x32e7cd['id']],global['clearTimeo'+'ut'](_0x1c2b4e['timer'])),this['trigger']('message',_0x32e7cd),this['_state']!==this['UP']&&(this['_state']=this['UP'],this['_client']['trigger']('transport:'+'up'));},'handleError':function(_0x58c3bf,_0x579ee3){var _0x147214=this['_envelopes'][_0x58c3bf['id']],_0x51f8aa=_0x147214&&_0x147214['request'],_0x45616a=this;if(_0x51f8aa){_0x51f8aa['then'](function(_0x29a850){_0x29a850&&_0x29a850['abort']&&_0x29a850['abort']();});var _0x352dc6=_0x147214['scheduler'];_0x352dc6['fail'](),global['clearTimeo'+'ut'](_0x147214['timer']),_0x147214['request']=_0x147214['timer']=null,_0x579ee3?this['_sendEnvel'+'ope'](_0x147214):_0x147214['timer']=global['setTimeout'](function(){_0x147214['timer']=null,_0x45616a['_sendEnvel'+'ope'](_0x147214);},(0x513*-0x3+-0x1b32+0x2e53)*_0x352dc6['getInterva'+'l']()),this['_state']!==this['DOWN']&&(this['_state']=this['DOWN'],this['_client']['trigger']('transport:'+'down'));}}});_0xdc4ff7['create']=function(_0x1b4b8e,_0x3ed87a,_0x35aa84){return new _0xdc4ff7(_0x1b4b8e,_0x3ed87a,_0x35aa84);},_0x2c401a(_0xdc4ff7['prototype'],_0x2b6853),_0x2c401a(_0xdc4ff7['prototype'],_0x40729f),_0x16ac30['exports']=_0xdc4ff7;},0x7ca:(_0x3dd1b7,_0x2620b2,_0x15f778)=>{'use strict';var _0x482a8f=_0x15f778(-0x19*-0x4a+0x19f9+-0x1*0x1127),_0x269169=_0x15f778(0x1212+0xa*0x1bb+-0x16ff),_0x5d4696=_0x482a8f({'initialize':function(_0x359a26,_0x1e5f45,_0x14a154){this['code']=_0x359a26,this['params']=Array['prototype']['slice']['call'](_0x1e5f45),this['message']=_0x14a154;},'toString':function(){return this['code']+':'+this['params']['join'](',')+':'+this['message'];}});_0x5d4696['parse']=function(_0x2a0e32){if(_0x2a0e32=_0x2a0e32||'',!_0x269169['ERROR']['test'](_0x2a0e32))return new _0x5d4696(null,[],_0x2a0e32);var _0x36bf7b=_0x2a0e32['split'](':'),_0x124795=parseInt(_0x36bf7b[0x50f+0x27f*0x9+-0xdc3*0x2]),_0x1df582=_0x36bf7b[0x24ae+-0x89c+-0x1c11]['split'](',');return _0x2a0e32=_0x36bf7b[-0x1f81+-0xffe+0x2f81],new _0x5d4696(_0x124795,_0x1df582,_0x2a0e32);};var _0x8e4c5f={'versionMismatch':[-0x6db+-0x871+-0x7c*-0x22,'Version\x20mi'+'smatch'],'conntypeMismatch':[0x49a+0xdae+-0x111b,'Connection'+'\x20types\x20not'+'\x20supported'],'extMismatch':[-0x4fd+0x2*0x1032+-0x1a39,'Extension\x20'+'mismatch'],'badRequest':[0x14*-0x164+0x5d1*-0x1+-0xd*-0x2b5,'Bad\x20reques'+'t'],'clientUnknown':[-0x4*-0x4a3+0x1e43+-0x2f3e,'Unknown\x20cl'+'ient'],'parameterMissing':[0xe5*0x15+-0x1181*0x1+0x4a,'Missing\x20re'+'quired\x20par'+'ameter'],'channelForbidden':[0x19*-0xaf+-0xf9b+0x11b*0x1f,'Forbidden\x20'+'channel'],'channelUnknown':[-0x2540+0xcee+-0x6*-0x451,'Unknown\x20ch'+'annel'],'channelInvalid':[0x1f*-0x1f+-0x7c*-0x2+0xd*0x56,'Invalid\x20ch'+'annel'],'extUnknown':[-0x2*-0x9f1+-0x7d3+-0x17f*0x7,'Unknown\x20ex'+'tension'],'publishFailed':[0x1dcb+-0x1ec6+0x292,'Failed\x20to\x20'+'publish'],'serverError':[-0x205d+0x68*0x2f+0xf39,'Internal\x20s'+'erver\x20erro'+'r']};for(var _0x2758ab in _0x8e4c5f)!function(_0x501884){_0x5d4696[_0x501884]=function(){return new _0x5d4696(_0x8e4c5f[_0x501884][0x1c5e+-0x31*-0x2f+-0x255d],arguments,_0x8e4c5f[_0x501884][-0x1*-0x496+0x10d6+-0x1*0x156b])['toString']();};}(_0x2758ab);_0x3dd1b7['exports']=_0x5d4696;},0x1e5b:(_0x142234,_0x413b83,_0xa772c)=>{'use strict';var _0x19616a={'addExtension':function(_0x3392c8){this['_extension'+'s']=this['_extension'+'s']||[],this['_extension'+'s']['push'](_0x3392c8),_0x3392c8['added']&&_0x3392c8['added'](this);},'removeExtension':function(_0x45ac87){if(this['_extension'+'s']){for(var _0x22bded=this['_extension'+'s']['length'];_0x22bded--;)this['_extension'+'s'][_0x22bded]===_0x45ac87&&(this['_extension'+'s']['splice'](_0x22bded,-0x1*-0x1e02+0x742+-0x2543),_0x45ac87['removed']&&_0x45ac87['removed'](this));}},'pipeThroughExtensions':function(_0x26b6b7,_0x54126e,_0x36a9e5,_0x2d255f,_0x3814f7){if(this['debug']('Passing\x20th'+'rough\x20?\x20ex'+'tensions:\x20'+'?',_0x26b6b7,_0x54126e),!this['_extension'+'s'])return _0x2d255f['call'](_0x3814f7,_0x54126e);var _0x503a69=this['_extension'+'s']['slice'](),_0x2895ce=function(_0x2eb6be){if(!_0x2eb6be)return _0x2d255f['call'](_0x3814f7,_0x2eb6be);var _0x3a101e=_0x503a69['shift']();if(!_0x3a101e)return _0x2d255f['call'](_0x3814f7,_0x2eb6be);var _0x4f9c41=_0x3a101e[_0x26b6b7];if(!_0x4f9c41)return _0x2895ce(_0x2eb6be);_0x4f9c41['length']>=0x1cd*0x1+-0x138a+0x11c0?_0x3a101e[_0x26b6b7](_0x2eb6be,_0x36a9e5,_0x2895ce):_0x3a101e[_0x26b6b7](_0x2eb6be,_0x2895ce);};_0x2895ce(_0x54126e);}};_0xa772c(0x1*-0xba2+0x13ff+0x16*0x39)(_0x19616a,_0xa772c(-0x4c5+0x1*-0x950+0x7eb*0x4)),_0x142234['exports']=_0x19616a;},0xc61:_0x155845=>{'use strict';_0x155845['exports']={'CHANNEL_NAME':/^\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,'CHANNEL_PATTERN':/^(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*\/\*{1,2}$/,'ERROR':/^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)$/,'VERSION':/^([0-9])+(\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*)*$/};},0x16:(_0xd12b8b,_0x2545f2,_0x5d9e32)=>{'use strict';var _0x75c4a3=_0x5d9e32(0x4aa*0x2+0x42d+0x28b*0x1),_0x43639f=_0x5d9e32(0x1c8e+-0x4a2*-0x9+-0xa*0x49f);_0xd12b8b['exports']=_0x75c4a3(_0x43639f);},0x1a55:(_0x5810b6,_0x3e4860,_0x55542d)=>{'use strict';var _0x1e652f=function(_0x435a84,_0x42235b){this['message']=_0x435a84,this['options']=_0x42235b,this['attempts']=0x1eb7*0x1+0x52*-0x31+-0x301*0x5;};_0x55542d(0x1c06+0x1*0xc1+0x52c*-0x3)(_0x1e652f['prototype'],{'getTimeout':function(){return this['options']['timeout'];},'getInterval':function(){return this['options']['interval'];},'isDeliverable':function(){var _0x1c9c17=this['options']['attempts'],_0x24d5d2=this['attempts'],_0x70aba1=this['options']['deadline'],_0x3c5aab=new Date()['getTime']();return!(void(-0x8e9*0x1+-0xc8f*0x1+0x1578)!==_0x1c9c17&&_0x24d5d2>=_0x1c9c17||void(0x2605+0x186f+-0x3e74)!==_0x70aba1&&_0x3c5aab>_0x70aba1);},'send':function(){this['attempts']+=-0x1*-0x259d+-0x96d*0x1+-0x1c2f;},'succeed':function(){},'fail':function(){},'abort':function(){}}),_0x5810b6['exports']=_0x1e652f;},0xc65:(_0x4b76ce,_0x3ae4eb,_0x4e9142)=>{'use strict';var _0x1d54e1=_0x4e9142(0x875+-0x74*0x35+0x1f9b),_0x5f5563=_0x4e9142(-0x1bbb+0xc91*0x2+-0x7*-0x8e),_0x257138=_0x4e9142(-0x8*0x422+-0x491*0x4+0x4097*0x1),_0x5eb43e=_0x4e9142(0x1c06+-0x2295+0xd*0x124),_0x3b9d04=_0x4e9142(-0x1398+0x93b+0x1bf4),_0x37a438=_0x4e9142(-0x3670+0x289+0x22*0x29b),_0x3fc2b3=_0x4e9142(0x20fe+-0x1*-0x1ed3+-0x1fa6),_0xaab991=_0x4e9142(0x9*0x107+-0x4*-0x92f+-0x3*0xcbb),_0x325bd1=_0x4e9142(0x1a*0x57+-0x1*-0x3b45+-0x25c0),_0x129af1=_0x4e9142(-0x1*-0x21c1+-0x63a+-0xf26),_0x76d4e0=_0x4e9142(-0xb*-0x26+-0x4*-0x5ee+0x1*-0x7),_0xca3d0c=_0x1d54e1({'className':'Server','initialize':function(_0x4c19be){this['_options']=_0x4c19be||{};var _0x3724f4=this['_options']['engine']||{};_0x3724f4['timeout']=this['_options']['timeout'],this['_engine']=_0x37a438['get'](_0x3724f4),this['info']('Created\x20ne'+'w\x20server:\x20'+'?',this['_options']);},'close':function(){return this['_engine']['close']();},'openSocket':function(_0x3f0542,_0x2ff6f9,_0x2f70e1){_0x3f0542&&_0x2ff6f9&&this['_engine']['openSocket'](_0x3f0542,new _0x76d4e0(this,_0x2ff6f9,_0x2f70e1));},'closeSocket':function(_0x311cbd,_0x11eab2){this['_engine']['flushConne'+'ction'](_0x311cbd,_0x11eab2);},'process':function(_0x29b318,_0x3491f0,_0x3d3576,_0x1e3c3e){var _0x2b7ab5=null===_0x3491f0;if(_0x29b318=[]['concat'](_0x29b318),this['info']('Processing'+'\x20messages:'+'\x20?\x20(local:'+'\x20?)',_0x29b318,_0x2b7ab5),-0xc9c+0x19d7+-0x469*0x3===_0x29b318['length'])return _0x3d3576['call'](_0x1e3c3e,[]);for(var _0x11b9f0=-0x2fc*-0x1+-0x2371+0x2075,_0x1abd0e=[],_0x26607c=this,_0x1f4638=function(_0x25fc08){if(_0x1abd0e=_0x1abd0e['concat'](_0x25fc08),!((_0x11b9f0+=0x1c5b+0xad5*-0x1+0x1*-0x1185)<_0x29b318['length'])){for(var _0x182daf=_0x1abd0e['length'];_0x182daf--;)_0x1abd0e[_0x182daf]||_0x1abd0e['splice'](_0x182daf,0x135d+-0x2264+0xf08);_0x26607c['info']('Returning\x20'+'replies:\x20?',_0x1abd0e),_0x3d3576['call'](_0x1e3c3e,_0x1abd0e);}},_0x560f02=function(_0x54b5bd){var _0x11554b=0x25*-0x1d+0x20*-0xa+0x571,_0x175498=_0x54b5bd['length'];-0x17eb*0x1+-0x2*0x839+0x285d*0x1===_0x175498&&_0x1f4638(_0x54b5bd);for(var _0x5e7098=-0x4d4+-0x2*-0xf79+-0x1a1e,_0x3ab342=_0x54b5bd['length'];_0x5e7098<_0x3ab342;_0x5e7098++)this['debug']('Processing'+'\x20reply:\x20?',_0x54b5bd[_0x5e7098]),function(_0x26f44a){_0x26607c['pipeThroug'+'hExtension'+'s']('outgoing',_0x54b5bd[_0x26f44a],_0x3491f0,function(_0x2287a2){_0x54b5bd[_0x26f44a]=_0x2287a2,(_0x11554b+=0x2086+0x247a+0x11*-0x40f)===_0x175498&&_0x1f4638(_0x54b5bd);});}(_0x5e7098);},_0x10085d=0x62c+0x47*0x33+-0x1451,_0x60eb90=_0x29b318['length'];_0x10085d<_0x60eb90;_0x10085d++)this['pipeThroug'+'hExtension'+'s']('incoming',_0x29b318[_0x10085d],_0x3491f0,function(_0x5f5750){this['_handle'](_0x5f5750,_0x2b7ab5,_0x560f02,this);},this);},'_makeResponse':function(_0x5169c4){var _0x480010={};return _0x5169c4['id']&&(_0x480010['id']=_0x5169c4['id']),_0x5169c4['clientId']&&(_0x480010['clientId']=_0x5169c4['clientId']),_0x5169c4['channel']&&(_0x480010['channel']=_0x5169c4['channel']),_0x5169c4['error']&&(_0x480010['error']=_0x5169c4['error']),_0x480010['successful']=!_0x480010['error'],_0x480010;},'_handle':function(_0x2c271b,_0x1ed5f8,_0x1cbc06,_0x4b124c){if(!_0x2c271b)return _0x1cbc06['call'](_0x4b124c,[]);this['info']('Handling\x20m'+'essage:\x20?\x20'+'(local:\x20?)',_0x2c271b,_0x1ed5f8);var _0x2afeac,_0xc88476=_0x2c271b['channel'],_0x3ef0ee=_0x2c271b['error'];if(_0x3fc2b3['isMeta'](_0xc88476))return this['_handleMet'+'a'](_0x2c271b,_0x1ed5f8,_0x1cbc06,_0x4b124c);_0x129af1['CHANNEL_NA'+'ME']['test'](_0xc88476)||(_0x3ef0ee=_0xaab991['channelInv'+'alid'](_0xc88476)),void(-0x7*0x189+0x1232+-0x773)===_0x2c271b['data']&&(_0x3ef0ee=_0xaab991['parameterM'+'issing']('data')),_0x3ef0ee||this['_engine']['publish'](_0x2c271b),_0x2afeac=this['_makeRespo'+'nse'](_0x2c271b),_0x3ef0ee&&(_0x2afeac['error']=_0x3ef0ee),_0x2afeac['successful']=!_0x2afeac['error'],_0x1cbc06['call'](_0x4b124c,[_0x2afeac]);},'_handleMeta':function(_0x50392f,_0x4e1185,_0x377b69,_0x152d96){var _0x31807e,_0x3ad8c8=this['_methodFor'](_0x50392f);if(null===_0x3ad8c8)return(_0x31807e=this['_makeRespo'+'nse'](_0x50392f))['error']=_0xaab991['channelFor'+'bidden'](_0x50392f['channel']),_0x31807e['successful']=!(-0xc33*-0x2+0x1241*-0x1+-0x624),_0x377b69['call'](_0x152d96,[_0x31807e]);this[_0x3ad8c8](_0x50392f,_0x4e1185,function(_0x104c0d){for(var _0x4dd7d0=0xf50+0x160e+-0x1*0x255e,_0x1917ba=(_0x104c0d=[]['concat'](_0x104c0d))['length'];_0x4dd7d0<_0x1917ba;_0x4dd7d0++)this['_advize'](_0x104c0d[_0x4dd7d0],_0x50392f['connection'+'Type']);_0x377b69['call'](_0x152d96,_0x104c0d);},this);},'_methodFor':function(_0x3ec54a){var _0x125605=_0x3ec54a['channel'];return _0x125605===_0x3fc2b3['HANDSHAKE']?'handshake':_0x125605===_0x3fc2b3['CONNECT']?'connect':_0x125605===_0x3fc2b3['SUBSCRIBE']?'subscribe':_0x125605===_0x3fc2b3['UNSUBSCRIB'+'E']?'unsubscrib'+'e':_0x125605===_0x3fc2b3['DISCONNECT']?'disconnect':null;},'_advize':function(_0x415423,_0x491f48){var _0xc266ed,_0x3963ca;_0x5f5563['indexOf']([_0x3fc2b3['HANDSHAKE'],_0x3fc2b3['CONNECT']],_0x415423['channel'])<0x2620+-0x1*-0x1492+-0x3ab2||('eventsourc'+'e'===_0x491f48?(_0xc266ed=Math['floor']((-0xeaa+-0xceb+0x1f7d)*this['_engine']['timeout']),_0x3963ca=0xb9e*0x1+-0x2045+0x14a7):(_0xc266ed=Math['floor']((-0xb30+0x1*-0xe5f+-0x13*-0x18d)*this['_engine']['interval']),_0x3963ca=Math['floor']((0x121a+-0x2261+0x142f)*this['_engine']['timeout'])),_0x415423['advice']=_0x415423['advice']||{},_0x415423['error']?_0x257138(_0x415423['advice'],{'reconnect':'handshake'},!(0x1*0x259b+0x1*0x1d25+-0x989*0x7)):_0x257138(_0x415423['advice'],{'reconnect':'retry','interval':_0xc266ed,'timeout':_0x3963ca},!(-0x55a+0x1253*-0x2+-0x1*-0x2a01)));},'handshake':function(_0x58c1c9,_0x50f1f,_0xc3efef,_0x112350){var _0x45a66c=this['_makeRespo'+'nse'](_0x58c1c9);_0x45a66c['version']=_0x5eb43e['BAYEUX_VER'+'SION'],_0x58c1c9['version']||(_0x45a66c['error']=_0xaab991['parameterM'+'issing']('version'));var _0x8efc08=_0x58c1c9['supportedC'+'onnectionT'+'ypes'];if(_0x45a66c['supportedC'+'onnectionT'+'ypes']=_0x5eb43e['CONNECTION'+'_TYPES'],_0x8efc08?-0xb10+-0x6cc+0x11dc===_0x5f5563['filter'](_0x8efc08,function(_0x1db153){return _0x5f5563['indexOf'](_0x5eb43e['CONNECTION'+'_TYPES'],_0x1db153)>=0x1*0x2693+-0x1d68+-0x1*0x92b;})['length']&&(_0x45a66c['error']=_0xaab991['conntypeMi'+'smatch'](_0x8efc08)):_0x45a66c['error']=_0xaab991['parameterM'+'issing']('supportedC'+'onnectionT'+'ypes'),_0x45a66c['successful']=!_0x45a66c['error'],!_0x45a66c['successful'])return _0xc3efef['call'](_0x112350,_0x45a66c);this['_engine']['createClie'+'nt'](function(_0x20d9ee){_0x45a66c['clientId']=_0x20d9ee,_0xc3efef['call'](_0x112350,_0x45a66c);},this);},'connect':function(_0x15e18d,_0x3dda6d,_0x54de17,_0x3d63dd){var _0x7cbd2c=this['_makeRespo'+'nse'](_0x15e18d),_0x1fe942=_0x15e18d['clientId'],_0x1ae5c7=_0x15e18d['connection'+'Type'];this['_engine']['clientExis'+'ts'](_0x1fe942,function(_0x5d1370){if(_0x5d1370||(_0x7cbd2c['error']=_0xaab991['clientUnkn'+'own'](_0x1fe942)),_0x1fe942||(_0x7cbd2c['error']=_0xaab991['parameterM'+'issing']('clientId')),_0x5f5563['indexOf'](_0x5eb43e['CONNECTION'+'_TYPES'],_0x1ae5c7)<0x16e5*-0x1+-0xc3*0x33+0x3dbe&&(_0x7cbd2c['error']=_0xaab991['conntypeMi'+'smatch'](_0x1ae5c7)),_0x1ae5c7||(_0x7cbd2c['error']=_0xaab991['parameterM'+'issing']('connection'+'Type')),_0x7cbd2c['successful']=!_0x7cbd2c['error'],!_0x7cbd2c['successful'])return delete _0x7cbd2c['clientId'],_0x54de17['call'](_0x3d63dd,_0x7cbd2c);'eventsourc'+'e'===_0x15e18d['connection'+'Type']&&(_0x15e18d['advice']=_0x15e18d['advice']||{},_0x15e18d['advice']['timeout']=0x9e7+-0xd58*-0x2+-0x143*0x1d),this['_engine']['connect'](_0x7cbd2c['clientId'],_0x15e18d['advice'],function(_0x7449cc){_0x54de17['call'](_0x3d63dd,[_0x7cbd2c]['concat'](_0x7449cc));});},this);},'disconnect':function(_0x2179ca,_0x5f2143,_0x4d6e08,_0x3ac642){var _0x28cedd=this['_makeRespo'+'nse'](_0x2179ca),_0x2ddefb=_0x2179ca['clientId'];this['_engine']['clientExis'+'ts'](_0x2ddefb,function(_0x4fb263){_0x4fb263||(_0x28cedd['error']=_0xaab991['clientUnkn'+'own'](_0x2ddefb)),_0x2ddefb||(_0x28cedd['error']=_0xaab991['parameterM'+'issing']('clientId')),_0x28cedd['successful']=!_0x28cedd['error'],_0x28cedd['successful']||delete _0x28cedd['clientId'],_0x28cedd['successful']&&this['_engine']['destroyCli'+'ent'](_0x2ddefb),_0x4d6e08['call'](_0x3ac642,_0x28cedd);},this);},'subscribe':function(_0x16f703,_0x4d2862,_0x13cdb0,_0x278099){var _0x265384,_0xd4a491=this['_makeRespo'+'nse'](_0x16f703),_0x56c59b=_0x16f703['clientId'],_0x3bbd6f=_0x16f703['subscripti'+'on'];_0x3bbd6f=_0x3bbd6f?[]['concat'](_0x3bbd6f):[],this['_engine']['clientExis'+'ts'](_0x56c59b,function(_0x36c4fd){_0x36c4fd||(_0xd4a491['error']=_0xaab991['clientUnkn'+'own'](_0x56c59b)),_0x56c59b||(_0xd4a491['error']=_0xaab991['parameterM'+'issing']('clientId')),_0x16f703['subscripti'+'on']||(_0xd4a491['error']=_0xaab991['parameterM'+'issing']('subscripti'+'on')),_0xd4a491['subscripti'+'on']=_0x16f703['subscripti'+'on']||[];for(var _0xd9f0de=0x3b*0x14+0x757*0x1+-0xbf3,_0x16cb24=_0x3bbd6f['length'];_0xd9f0de<_0x16cb24&&(_0x265384=_0x3bbd6f[_0xd9f0de],!_0xd4a491['error'])&&(_0x4d2862||_0x3fc2b3['isSubscrib'+'able'](_0x265384)||(_0xd4a491['error']=_0xaab991['channelFor'+'bidden'](_0x265384)),_0x3fc2b3['isValid'](_0x265384)||(_0xd4a491['error']=_0xaab991['channelInv'+'alid'](_0x265384)),!_0xd4a491['error']);_0xd9f0de++)this['_engine']['subscribe'](_0x56c59b,_0x265384);_0xd4a491['successful']=!_0xd4a491['error'],_0x13cdb0['call'](_0x278099,_0xd4a491);},this);},'unsubscribe':function(_0x3ba004,_0x1f9f08,_0xbccb62,_0x513946){var _0x58c510,_0x520222=this['_makeRespo'+'nse'](_0x3ba004),_0x10f01d=_0x3ba004['clientId'],_0x27ac81=_0x3ba004['subscripti'+'on'];_0x27ac81=_0x27ac81?[]['concat'](_0x27ac81):[],this['_engine']['clientExis'+'ts'](_0x10f01d,function(_0x2ed997){_0x2ed997||(_0x520222['error']=_0xaab991['clientUnkn'+'own'](_0x10f01d)),_0x10f01d||(_0x520222['error']=_0xaab991['parameterM'+'issing']('clientId')),_0x3ba004['subscripti'+'on']||(_0x520222['error']=_0xaab991['parameterM'+'issing']('subscripti'+'on')),_0x520222['subscripti'+'on']=_0x3ba004['subscripti'+'on']||[];for(var _0x1b33d5=0x1bd0+-0xecd*0x1+-0xd03*0x1,_0x7aa00c=_0x27ac81['length'];_0x1b33d5<_0x7aa00c&&(_0x58c510=_0x27ac81[_0x1b33d5],!_0x520222['error'])&&(_0x1f9f08||_0x3fc2b3['isSubscrib'+'able'](_0x58c510)||(_0x520222['error']=_0xaab991['channelFor'+'bidden'](_0x58c510)),_0x3fc2b3['isValid'](_0x58c510)||(_0x520222['error']=_0xaab991['channelInv'+'alid'](_0x58c510)),!_0x520222['error']);_0x1b33d5++)this['_engine']['unsubscrib'+'e'](_0x10f01d,_0x58c510);_0x520222['successful']=!_0x520222['error'],_0xbccb62['call'](_0x513946,_0x520222);},this);}});_0xca3d0c['create']=function(_0x52226d){return new _0xca3d0c(_0x52226d);},_0x257138(_0xca3d0c['prototype'],_0x3b9d04),_0x257138(_0xca3d0c['prototype'],_0x325bd1),_0x4b76ce['exports']=_0xca3d0c;},0x1953:(_0x4582f4,_0x1ea0f0,_0x5c24fa)=>{'use strict';var _0x26bb7f=_0x5c24fa(-0x4b4+-0x1996+0x2e56*0x1),_0x6aa9fc=_0x5c24fa(-0x2*-0xfb3+-0xa0*-0x3b+0x136d*-0x2);_0x4582f4['exports']=_0x26bb7f({'initialize':function(_0x508412,_0x5eb7d1,_0xe1a1af){this['_server']=_0x508412,this['_socket']=_0x5eb7d1,this['_request']=_0xe1a1af;},'send':function(_0x478e32){this['_server']['pipeThroug'+'hExtension'+'s']('outgoing',_0x478e32,this['_request'],function(_0x2cd534){this['_socket']&&this['_socket']['send'](_0x6aa9fc([_0x2cd534]));},this);},'close':function(){this['_socket']&&this['_socket']['close'](),delete this['_socket'];}});},0x16f3:(_0x560de0,_0x3d9b97,_0xc1110)=>{'use strict';var _0x5e2591=_0xc1110(0x7be+0xbcd+-0xb3*0x5),_0x79fe13=_0xc1110(-0x641+0x1*0x4c5+0xebf),_0x15e9b5=_0xc1110(-0x13b3+-0xc2*-0x2e+0x8e1),_0x2a495f=_0x5e2591({'initialize':function(_0x40e3e6,_0x4ec4de,_0x5a3273,_0x509f86){this['_client']=_0x40e3e6,this['_channels']=_0x4ec4de,this['_callback']=_0x5a3273,this['_context']=_0x509f86,this['_cancelled']=!(0xa39*0x3+0xa*-0x133+-0x14*0xef);},'withChannel':function(_0x31f8d6,_0x24edb9){return this['_withChann'+'el']=[_0x31f8d6,_0x24edb9],this;},'apply':function(_0x583b65,_0x5e6453){var _0x505ca7=_0x5e6453[-0x2526+-0xa23+0x2f49];this['_callback']&&this['_callback']['call'](this['_context'],_0x505ca7['data']),this['_withChann'+'el']&&this['_withChann'+'el'][-0xd11*-0x1+0xda1*0x1+0xc9*-0x22]['call'](this['_withChann'+'el'][-0x299+0x3*0x125+-0x47*0x3],_0x505ca7['channel'],_0x505ca7['data']);},'cancel':function(){this['_cancelled']||(this['_client']['unsubscrib'+'e'](this['_channels'],this),this['_cancelled']=!(-0x156d+0x9ae+0xbbf));},'unsubscribe':function(){this['cancel']();}});_0x79fe13(_0x2a495f['prototype'],_0x15e9b5),_0x560de0['exports']=_0x2a495f;},0xbe0:(_0x26e906,_0x90c2c,_0x1442ab)=>{'use strict';var _0x42d679=_0x1442ab(-0x5bc+0x428+0x5*0x28d)['Buffer'],_0x5183de=_0x1442ab(0x406d*0x1+-0x1bc8+0x1*-0x302),_0x1db67a=_0x1442ab(0x1856*-0x1+0xabd*0x3+0xe5b),_0x11006a=_0x1442ab(0x15a0+0x1fe6+-0x262f),_0x31d08e=_0x1442ab(0x481+0xc8b+0x2*-0x80),_0x131ce9=_0x1442ab(-0x9a8+0x2325+-0x11bf),_0x1ddf1d=_0x1442ab(0x1423*-0x1+-0x28c*-0x6+0x121e),_0x251c64=_0x1442ab(-0x3609+0x20*0x89+0x4255),_0x5425b8=_0x1442ab(0x1*0xf31+-0x299b+0x348e),_0x116d26=_0x1ddf1d(_0x31d08e(_0x5425b8,{'className':'NodeHttp','SECURE_PROTOCOLS':['https:','wss:'],'initialize':function(){_0x5425b8['prototype']['initialize']['apply'](this,arguments),this['_endpointS'+'ecure']=this['SECURE_PRO'+'TOCOLS']['indexOf'](this['endpoint']['protocol'])>=0x6ee+0x1*-0x1510+0x9*0x192,this['_httpClien'+'t']=this['_endpointS'+'ecure']?_0x1db67a:_0x5183de;var _0x4b5b4f=this['_proxy'];if(_0x4b5b4f['origin']){if(this['_proxyUri']=_0x131ce9['parse'](_0x4b5b4f['origin']),this['_proxySecu'+'re']=this['SECURE_PRO'+'TOCOLS']['indexOf'](this['_proxyUri']['protocol'])>=-0x1*0xf43+0x1ef*-0xf+-0xb11*-0x4,this['_endpointS'+'ecure']){var _0x44188d=_0x1ddf1d({'proxy':{'host':this['_proxyUri']['hostname'],'port':this['_proxyUri']['port']||this['DEFAULT_PO'+'RTS'][this['_proxyUri']['protocol']],'proxyAuth':this['_proxyUri']['auth'],'headers':_0x1ddf1d({'host':this['endpoint']['host']},_0x4b5b4f['headers'])}},this['_dispatche'+'r']['tls']);this['_proxySecu'+'re']?(_0x1ddf1d(_0x44188d['proxy'],_0x4b5b4f['tls']),this['_tunnel']=_0x11006a['httpsOverH'+'ttps'](_0x44188d)):this['_tunnel']=_0x11006a['httpsOverH'+'ttp'](_0x44188d);}else this['_httpClien'+'t']=this['_proxySecu'+'re']?_0x1db67a:_0x5183de;}},'encode':function(_0x7e4d2b){return _0x251c64(_0x7e4d2b);},'request':function(_0x5c8e33){var _0xb9bd12=_0x42d679['from'](this['encode'](_0x5c8e33),'utf8'),_0x2150e6=this['_buildPara'+'ms'](_0xb9bd12),_0x55f037=this['_httpClien'+'t']['request'](_0x2150e6),_0x22c902=this;return _0x55f037['on']('response',function(_0xcf2b8){_0x22c902['_handleRes'+'ponse'](_0x5c8e33,_0xcf2b8),_0x22c902['_storeCook'+'ies'](_0xcf2b8['headers']['set-cookie']);}),_0x55f037['on']('error',function(_0x2818e1){_0x22c902['error']('HTTP\x20error'+':\x20'+_0x2818e1['message']),_0x22c902['_handleErr'+'or'](_0x5c8e33);}),_0x55f037['end'](_0xb9bd12),_0x55f037;},'_buildParams':function(_0x517b20){var _0x5ee506=this['endpoint'],_0x1595b2=this['_proxyUri'],_0x3c3cdf=this['_tunnel']?_0x5ee506:_0x1595b2||_0x5ee506,_0x31dd88={'Content-Length':_0x517b20['length'],'Content-Type':'applicatio'+'n/json','Host':_0x5ee506['host']};_0x5ee506['auth']&&(_0x31dd88['Authorizat'+'ion']='Basic\x20'+_0x42d679['from'](_0x5ee506['auth'],'utf8')['toString']('base64'));var _0x1916a2={'method':'POST','host':_0x3c3cdf['hostname'],'port':_0x3c3cdf['port']||this['DEFAULT_PO'+'RTS'][_0x3c3cdf['protocol']],'path':_0x5ee506['path'],'headers':_0x1ddf1d(_0x31dd88,this['_dispatche'+'r']['headers'])},_0x5e9391=this['_getCookie'+'s']();return''!==_0x5e9391&&(_0x1916a2['headers']['Cookie']=_0x5e9391),this['_tunnel']?_0x1916a2['agent']=this['_tunnel']:this['_endpointS'+'ecure']?_0x1ddf1d(_0x1916a2,this['_dispatche'+'r']['tls']):_0x1595b2&&(_0x1916a2['path']=this['endpoint']['href'],_0x1ddf1d(_0x1916a2,this['_proxy']['tls']),_0x1595b2['auth']&&(_0x1916a2['headers']['Proxy-Auth'+'orization']=_0x42d679['from'](_0x1595b2['auth'],'utf8')['toString']('base64'))),_0x1916a2;},'_handleResponse':function(_0x2ae496,_0x57c234){var _0x30592b='',_0x3ed7ec=this;_0x57c234['setEncodin'+'g']('utf8'),_0x57c234['on']('data',function(_0x8550bc){_0x30592b+=_0x8550bc;}),_0x57c234['on']('end',function(){var _0x2f2f4e;try{_0x2f2f4e=JSON['parse'](_0x30592b);}catch(_0x31ac07){}_0x2f2f4e?_0x3ed7ec['_receive'](_0x2f2f4e):_0x3ed7ec['_handleErr'+'or'](_0x2ae496);});}}),{'isUsable':function(_0x1fe3ab,_0x2a085d,_0x30a631,_0x23ab95){_0x30a631['call'](_0x23ab95,_0x131ce9['isURI'](_0x2a085d));}});_0x26e906['exports']=_0x116d26;},0x1aed:(_0x3fed20,_0x176dd8,_0x34d917)=>{'use strict';var _0x1409ad=_0x34d917(-0x26b9+0x71*0x28+-0x63a*-0x4),_0x32b068=_0x34d917(0x2d*0x42+-0xa1+-0x1b1*-0x3),_0x57cb76=(_0x34d917(-0x1b92+0x10c2+0x128e*0x1),_0x34d917(-0x1*0x266a+-0xf6b+-0x112*-0x3f)),_0x38359e=_0x34d917(0x1f4*0x2+0x13fd+0x1*-0xaa2),_0x4acddd=_0x34d917(-0x22d+0x1a9c+0x17*-0x86),_0x1658cf=_0x38359e(_0x32b068(_0x34d917(0x2bfd+0x1367+-0x2*0x12a0),{'batching':!(0x6e2*-0x2+-0x6a*0x2a+0x1f29),'request':function(_0x55d7ae){_0x55d7ae=_0x57cb76(_0x55d7ae);var _0x297904=this;_0x1409ad(function(){_0x297904['endpoint']['process'](_0x55d7ae,null,function(_0x4fc57e){_0x297904['_receive'](_0x57cb76(_0x4fc57e));});});}}),{'isUsable':function(_0x264353,_0x2ea1ad,_0x167f95,_0x2a4c55){_0x167f95['call'](_0x2a4c55,_0x2ea1ad instanceof _0x4acddd);}});_0x3fed20['exports']=_0x1658cf;},0x1222:(_0x5315bf,_0x1a00f2,_0x1e81c7)=>{'use strict';var _0x572ee2=_0x1e81c7(0x10bf+-0x93f*0x5+-0xa0*-0x59);_0x572ee2['register']('in-process',_0x1e81c7(0xa5c+0x2477+-0x13e6*0x1)),_0x572ee2['register']('websocket',_0x1e81c7(-0x8c9+-0x13e5+0x217*0x13)),_0x572ee2['register']('long-polli'+'ng',_0x1e81c7(-0x1*0x356+0x15*0x95+0x2fd)),_0x5315bf['exports']=_0x572ee2;},0x1a24:(_0x2270d1,_0x4362e3,_0x168b82)=>{'use strict';var _0x5f3c26=_0x168b82(0x222e+0x7*-0x31c+0x3a2),_0x2b6c12=_0x168b82(0x7c3+0x22cb*0x1+-0xbf*0x14)['Cookie'],_0x1d4359=_0x168b82(0x6d0*-0x5+0x1bae+-0x6b7*-0x1),_0x270971=_0x168b82(-0xa5*0x32+-0x17*-0x22+0x1e75),_0x1e230f=_0x168b82(-0x9da+0x994+0x13b*0xb),_0x25495d=_0x168b82(0x83e+0x71f+0x23a),_0x493f2e=_0x168b82(0x284e+-0x2*-0x1467+-0x2cc4),_0x119543=_0x168b82(-0x848+-0x1411*0x1+0xf21*0x4),_0x29a6e3=_0x1e230f(_0x5f3c26({'className':'Transport','DEFAULT_PORTS':{'http:':0x50,'https:':0x1bb,'ws:':0x50,'wss:':0x1bb},'MAX_DELAY':0x0,'batching':!(-0x2681*0x1+0x2131+-0x154*-0x4),'initialize':function(_0x194a75,_0x57717e){this['_dispatche'+'r']=_0x194a75,this['endpoint']=_0x57717e,this['_outbox']=[],this['_proxy']=_0x1e230f({},this['_dispatche'+'r']['proxy']),this['_proxy']['origin']||(this['_proxy']['origin']=this['_findProxy']());},'close':function(){},'encode':function(_0x9f46ae){return'';},'sendMessage':function(_0x5c4a1c){return this['debug']('Client\x20?\x20s'+'ending\x20mes'+'sage\x20to\x20?:'+'\x20?',this['_dispatche'+'r']['clientId'],this['endpoint']['href'],_0x5c4a1c),this['batching']?(this['_outbox']['push'](_0x5c4a1c),this['_flushLarg'+'eBatch'](),_0x5c4a1c['channel']===_0x119543['HANDSHAKE']?this['_publish'](-0xb9a+0x1c9*-0x5+0x1487*0x1+0.01):(_0x5c4a1c['channel']===_0x119543['CONNECT']&&(this['_connectMe'+'ssage']=_0x5c4a1c),this['_publish'](this['MAX_DELAY']))):_0x1d4359['resolve'](this['request']([_0x5c4a1c]));},'_makePromise':function(){var _0x1f2700=this;this['_requestPr'+'omise']=this['_requestPr'+'omise']||new _0x1d4359(function(_0x16450c){_0x1f2700['_resolvePr'+'omise']=_0x16450c;});},'_publish':function(_0x3cda73){return this['_makePromi'+'se'](),this['addTimeout']('publish',_0x3cda73,function(){this['_flush'](),delete this['_requestPr'+'omise'];},this),this['_requestPr'+'omise'];},'_flush':function(){this['removeTime'+'out']('publish'),this['_outbox']['length']>0x1065*0x2+-0x1134+0x1*-0xf95&&this['_connectMe'+'ssage']&&(this['_connectMe'+'ssage']['advice']={'timeout':0x0}),this['_resolvePr'+'omise'](this['request'](this['_outbox'])),this['_connectMe'+'ssage']=null,this['_outbox']=[];},'_flushLargeBatch':function(){if(!(this['encode'](this['_outbox'])['length']<this['_dispatche'+'r']['maxRequest'+'Size'])){var _0x3007fa=this['_outbox']['pop']();this['_makePromi'+'se'](),this['_flush'](),_0x3007fa&&this['_outbox']['push'](_0x3007fa);}},'_receive':function(_0x38c65b){if(_0x38c65b){_0x38c65b=[]['concat'](_0x38c65b),this['debug']('Client\x20?\x20r'+'eceived\x20fr'+'om\x20?\x20via\x20?'+':\x20?',this['_dispatche'+'r']['clientId'],this['endpoint']['href'],this['connection'+'Type'],_0x38c65b);for(var _0x29e0c8=-0x1eb*0x10+-0x30a+0x21ba,_0x351a48=_0x38c65b['length'];_0x29e0c8<_0x351a48;_0x29e0c8++)this['_dispatche'+'r']['handleResp'+'onse'](_0x38c65b[_0x29e0c8]);}},'_handleError':function(_0x45925a,_0x18118f){_0x45925a=[]['concat'](_0x45925a),this['debug']('Client\x20?\x20f'+'ailed\x20to\x20s'+'end\x20to\x20?\x20v'+'ia\x20?:\x20?',this['_dispatche'+'r']['clientId'],this['endpoint']['href'],this['connection'+'Type'],_0x45925a);for(var _0x5a2986=-0x1*-0x1732+-0x1*0x581+0x11b1*-0x1,_0x12d2aa=_0x45925a['length'];_0x5a2986<_0x12d2aa;_0x5a2986++)this['_dispatche'+'r']['handleErro'+'r'](_0x45925a[_0x5a2986]);},'_getCookies':function(){var _0x31abf3=this['_dispatche'+'r']['cookies'],_0x107844=this['endpoint']['href'];return _0x31abf3?_0x270971['map'](_0x31abf3['getCookies'+'Sync'](_0x107844),function(_0xd85e4d){return _0xd85e4d['cookieStri'+'ng']();})['join'](';\x20'):'';},'_storeCookies':function(_0x1ad809){var _0x355cdb,_0x3640c9=this['_dispatche'+'r']['cookies'],_0x374787=this['endpoint']['href'];if(_0x1ad809&&_0x3640c9){for(var _0x5ea321=0xac6+0x2522+-0x2a*0x124,_0x489c38=(_0x1ad809=[]['concat'](_0x1ad809))['length'];_0x5ea321<_0x489c38;_0x5ea321++)_0x355cdb=_0x2b6c12['parse'](_0x1ad809[_0x5ea321]),_0x3640c9['setCookieS'+'ync'](_0x355cdb,_0x374787);}},'_findProxy':function(){if('undefined'!=typeof process){var _0x5c1165=this['endpoint']['protocol'];if(_0x5c1165){var _0x4becf3,_0x279435,_0x513abf=_0x5c1165['replace'](/:$/,'')['toLowerCas'+'e']()+'_proxy',_0x4877d1=_0x513abf['toUpperCas'+'e'](),_0x3d7e58=process['env'];return'http_proxy'===_0x513abf&&_0x3d7e58['REQUEST_ME'+'THOD']?(0xb77*0x1+0x20b3+-0x85*0x55===(_0x4becf3=Object['keys'](_0x3d7e58)['filter'](function(_0x239e80){return/^http_proxy$/i['test'](_0x239e80);}))['length']?_0x4becf3[0x4e6+0x17ce+-0x1cb4]===_0x513abf&&void(-0x23e5+0x1ead+0x538)===_0x3d7e58[_0x4877d1]&&(_0x279435=_0x3d7e58[_0x513abf]):_0x4becf3['length']>0x23de+0x2*-0x824+-0x1395&&(_0x279435=_0x3d7e58[_0x513abf]),_0x279435=_0x279435||_0x3d7e58['CGI_'+_0x4877d1]):(_0x279435=_0x3d7e58[_0x513abf]||_0x3d7e58[_0x4877d1])&&!_0x3d7e58[_0x513abf]&&console['warn']('The\x20enviro'+'nment\x20vari'+'able\x20'+_0x4877d1+('\x20is\x20discou'+'raged.\x20Use'+'\x20')+_0x513abf+'.'),_0x279435;}}}}),{'get':function(_0x2ba3ea,_0x3fa3ba,_0x47aa16,_0x30308a,_0x12d8e5){var _0x51ca34=_0x2ba3ea['endpoint'];_0x270971['asyncEach'](this['_transport'+'s'],function(_0x22c645,_0x2496a2){var _0x48c69d=_0x22c645[0x1*0x1a9+0xb9c+-0xd45],_0x252423=_0x22c645[0x1125+0x1041+-0x1*0x2165],_0x4f33d7=_0x2ba3ea['endpointFo'+'r'](_0x48c69d);return _0x270971['indexOf'](_0x47aa16,_0x48c69d)>=0x1f*0x112+-0x1b59*0x1+-0x1*0x5d5?_0x2496a2():_0x270971['indexOf'](_0x3fa3ba,_0x48c69d)<0x1eae+-0x57*-0x2b+-0x5*0x90f?(_0x252423['isUsable'](_0x2ba3ea,_0x4f33d7,function(){}),_0x2496a2()):void _0x252423['isUsable'](_0x2ba3ea,_0x4f33d7,function(_0x240a67){if(!_0x240a67)return _0x2496a2();var _0x4a62eb=_0x252423['hasOwnProp'+'erty']('create')?_0x252423['create'](_0x2ba3ea,_0x4f33d7):new _0x252423(_0x2ba3ea,_0x4f33d7);_0x30308a['call'](_0x12d8e5,_0x4a62eb);});},function(){throw new Error('Could\x20not\x20'+'find\x20a\x20usa'+'ble\x20connec'+'tion\x20type\x20'+'for\x20'+_0x51ca34['href']);});},'register':function(_0x1f7993,_0x54a643){this['_transport'+'s']['push']([_0x1f7993,_0x54a643]),_0x54a643['prototype']['connection'+'Type']=_0x1f7993;},'getConnectionTypes':function(){return _0x270971['map'](this['_transport'+'s'],function(_0x315556){return _0x315556[0x2*-0xb8b+0x5b6+0x1160];});},'disable':function(_0x5ccacc){if('autodiscon'+'nect'===_0x5ccacc){for(var _0x406925=0x35*0x31+-0x1cc0+0x129b;_0x406925<this['_transport'+'s']['length'];_0x406925++)this['_transport'+'s'][_0x406925][-0x419*0x7+0x2d*0xb1+0x1b*-0x17]['_unloaded']=!(0x1d7a+-0x59d+-0x17dc);}},'_transports':[]});_0x1e230f(_0x29a6e3['prototype'],_0x25495d),_0x1e230f(_0x29a6e3['prototype'],_0x493f2e),_0x2270d1['exports']=_0x29a6e3;},0xb07:(_0x12bcb8,_0x561c80,_0x512828)=>{'use strict';var _0x3a328f=_0x512828(0xffd*-0x1+-0x1e*-0x65+-0x1433*-0x1),_0x2aba4d=_0x512828(-0xe6b+0x68+-0x198*-0x9),_0x2490c6=_0x512828(0x1130+0xa7b+-0x80b),_0x50759c=_0x512828(-0xea7+0x2231+0x1*-0xbcc),_0x3b07d0=_0x512828(-0x1592+0x262a+-0x15),_0x33bc4d=_0x512828(0x3c3+-0x65*0x22+0x1740),_0x358c42=_0x512828(-0x9c5+0x18c3+-0x1bb),_0x4e8c68=_0x512828(0x30ed+0x119e+0x22f*-0x11),_0x940a0d=_0x512828(-0x2260+0x2ba*0xd+0x198),_0x5bff63=_0x512828(0x516*-0x8+-0x11*0xbd+0x4d47),_0x4f1955=_0x358c42(_0x3a328f(_0x512828(-0x4a9+-0x3*-0x245+0x17fe),{'UNCONNECTED':0x1,'CONNECTING':0x2,'CONNECTED':0x3,'batching':!(-0x15bd+0x979+0xc45),'isUsable':function(_0x465477,_0x38651b){this['callback'](function(){_0x465477['call'](_0x38651b,!(0x200c*-0x1+0x2350+-0x344));}),this['errback'](function(){_0x465477['call'](_0x38651b,!(0xd0a+0x2fe+0x1007*-0x1));}),this['connect']();},'request':function(_0x2d0ce5){this['_pending']=this['_pending']||new _0x2490c6();for(var _0x582f66=0x89*-0x3d+-0x1c41*-0x1+0x2*0x232,_0x2593ad=_0x2d0ce5['length'];_0x582f66<_0x2593ad;_0x582f66++)this['_pending']['add'](_0x2d0ce5[_0x582f66]);var _0x36b54d=this,_0xf04b2a=new _0x2aba4d(function(_0x2027e3,_0xc06089){_0x36b54d['callback'](function(_0x58740f){_0x58740f&&0x11*-0x84+-0xaaf+0x1374===_0x58740f['readyState']&&(_0x58740f['send'](_0x4e8c68(_0x2d0ce5)),_0x2027e3(_0x58740f));}),_0x36b54d['connect']();});return{'abort':function(){_0xf04b2a['then'](function(_0x5d4ffc){_0x5d4ffc['close']();});}};},'connect':function(){if(!_0x4f1955['_unloaded']&&(this['_state']=this['_state']||this['UNCONNECTE'+'D'],this['_state']===this['UNCONNECTE'+'D'])){this['_state']=this['CONNECTING'];var _0x5dc1b0=this['_createSoc'+'ket']();if(!_0x5dc1b0)return this['setDeferre'+'dStatus']('failed');var _0x38bcb6=this;_0x5dc1b0['onopen']=function(){_0x5dc1b0['headers']&&_0x38bcb6['_storeCook'+'ies'](_0x5dc1b0['headers']['set-cookie']),_0x38bcb6['_socket']=_0x5dc1b0,_0x38bcb6['_state']=_0x38bcb6['CONNECTED'],_0x38bcb6['_everConne'+'cted']=!(-0x198e+-0x1783*0x1+0x3111),_0x38bcb6['setDeferre'+'dStatus']('succeeded',_0x5dc1b0);};var _0x1e1316=!(0x2518+0x8*-0xed+0x33*-0x95);_0x5dc1b0['onclose']=_0x5dc1b0['onerror']=function(){if(!_0x1e1316){_0x1e1316=!(0x22ab+-0x5a0+-0x1d0b*0x1);var _0xb4c3ac=_0x38bcb6['_state']===_0x38bcb6['CONNECTED'];_0x5dc1b0['onopen']=_0x5dc1b0['onclose']=_0x5dc1b0['onerror']=_0x5dc1b0['onmessage']=null,delete _0x38bcb6['_socket'],_0x38bcb6['_state']=_0x38bcb6['UNCONNECTE'+'D'];var _0x2dd379=_0x38bcb6['_pending']?_0x38bcb6['_pending']['toArray']():[];delete _0x38bcb6['_pending'],_0xb4c3ac||_0x38bcb6['_everConne'+'cted']?(_0x38bcb6['setDeferre'+'dStatus']('unknown'),_0x38bcb6['_handleErr'+'or'](_0x2dd379,_0xb4c3ac)):_0x38bcb6['setDeferre'+'dStatus']('failed');}},_0x5dc1b0['onmessage']=function(_0x681e01){var _0x45554a;try{_0x45554a=JSON['parse'](_0x681e01['data']);}catch(_0x155d7c){}if(_0x45554a){for(var _0x521c16=0x2*-0xc4c+-0xf*-0x283+-0xd15,_0x2dbf2f=(_0x45554a=[]['concat'](_0x45554a))['length'];_0x521c16<_0x2dbf2f;_0x521c16++)void(-0xf*0x4d+0x133*0xa+-0x17f*0x5)!==_0x45554a[_0x521c16]['successful']&&_0x38bcb6['_pending']['remove'](_0x45554a[_0x521c16]);_0x38bcb6['_receive'](_0x45554a);}};}},'close':function(){this['_socket']&&this['_socket']['close']();},'_createSocket':function(){var _0x11a140=_0x4f1955['getSocketU'+'rl'](this['endpoint']),_0x333c33=this['_dispatche'+'r']['headers'],_0x4e0174=this['_dispatche'+'r']['wsExtensio'+'ns'],_0x3af08a=this['_getCookie'+'s'](),_0x146c5d=this['_dispatche'+'r']['tls'],_0x58dad4={'extensions':_0x4e0174,'headers':_0x333c33,'proxy':this['_proxy'],'tls':_0x146c5d};''!==_0x3af08a&&(_0x58dad4['headers']['Cookie']=_0x3af08a);try{return _0x940a0d['create'](_0x11a140,[],_0x58dad4);}catch(_0x36e097){}}}),{'PROTOCOLS':{'http:':'ws:','https:':'wss:'},'create':function(_0x151a4a,_0x36db2c){var _0x42047a=_0x151a4a['transports']['websocket']=_0x151a4a['transports']['websocket']||{};return _0x42047a[_0x36db2c['href']]=_0x42047a[_0x36db2c['href']]||new this(_0x151a4a,_0x36db2c),_0x42047a[_0x36db2c['href']];},'getSocketUrl':function(_0x28a2c4){return(_0x28a2c4=_0x33bc4d(_0x28a2c4))['protocol']=this['PROTOCOLS'][_0x28a2c4['protocol']],_0x50759c['stringify'](_0x28a2c4);},'isUsable':function(_0x15a80a,_0x8d04ab,_0x1cc092,_0x36aaf1){this['create'](_0x15a80a,_0x8d04ab)['isUsable'](_0x1cc092,_0x36aaf1);}});_0x358c42(_0x4f1955['prototype'],_0x5bff63),_0x3b07d0['Event']&&void(-0x18*-0x17c+-0xc56*0x3+0x162)!==global['onbeforeun'+'load']&&_0x3b07d0['Event']['on'](global,'beforeunlo'+'ad',function(){void(-0x2688+-0xba3+0x322b)===_0x4f1955['_unloaded']&&(_0x4f1955['_unloaded']=!(0x208f+-0x1*0x2239+-0x6*-0x47));}),_0x12bcb8['exports']=_0x4f1955;},0x149:_0x6f2f6e=>{'use strict';_0x6f2f6e['exports']={'commonElement':function(_0x2f7c3f,_0x2510ad){for(var _0xdd71e=0x381+0x6*0x482+-0x4f*0x63,_0x354826=_0x2f7c3f['length'];_0xdd71e<_0x354826;_0xdd71e++)if(-(-0x2da+-0xcf3+-0x2*-0x7e7)!==this['indexOf'](_0x2510ad,_0x2f7c3f[_0xdd71e]))return _0x2f7c3f[_0xdd71e];return null;},'indexOf':function(_0xfffaa3,_0x368d68){if(_0xfffaa3['indexOf'])return _0xfffaa3['indexOf'](_0x368d68);for(var _0x4eb932=0x1aa1+0x1*0x1cec+-0x378d,_0x2f2722=_0xfffaa3['length'];_0x4eb932<_0x2f2722;_0x4eb932++)if(_0xfffaa3[_0x4eb932]===_0x368d68)return _0x4eb932;return-(-0x55*0x2f+-0x1096+-0x13d*-0x1a);},'map':function(_0x23d126,_0x2f7ee2,_0x3d4ffb){if(_0x23d126['map'])return _0x23d126['map'](_0x2f7ee2,_0x3d4ffb);var _0xe0a0f2=[];if(_0x23d126 instanceof Array){for(var _0xf03530=-0x5bf*0x3+-0x6f*-0x4+-0x1*-0xf81,_0x4595af=_0x23d126['length'];_0xf03530<_0x4595af;_0xf03530++)_0xe0a0f2['push'](_0x2f7ee2['call'](_0x3d4ffb||null,_0x23d126[_0xf03530],_0xf03530));}else{for(var _0x37a06c in _0x23d126)_0x23d126['hasOwnProp'+'erty'](_0x37a06c)&&_0xe0a0f2['push'](_0x2f7ee2['call'](_0x3d4ffb||null,_0x37a06c,_0x23d126[_0x37a06c]));}return _0xe0a0f2;},'filter':function(_0x358397,_0x1c5c9c,_0x119f4d){if(_0x358397['filter'])return _0x358397['filter'](_0x1c5c9c,_0x119f4d);for(var _0xd4f1a4=[],_0x1b813e=0x24d8+-0x771+-0x27*0xc1,_0x148f03=_0x358397['length'];_0x1b813e<_0x148f03;_0x1b813e++)_0x1c5c9c['call'](_0x119f4d||null,_0x358397[_0x1b813e],_0x1b813e)&&_0xd4f1a4['push'](_0x358397[_0x1b813e]);return _0xd4f1a4;},'asyncEach':function(_0x42ec3e,_0x50564d,_0x2d287e,_0x305b6a){var _0xbfaa55=_0x42ec3e['length'],_0x454c52=-(0x1687+-0xa74+0x26a*-0x5),_0x4fa0f0=-0x1a23+0x646+-0xf*-0x153,_0x274c2f=!(0x26*0xb9+-0x371+-0x1804),_0x22a385=function(){if(_0x4fa0f0-=0xbf0*-0x1+-0x5cb+0x4*0x46f,(_0x454c52+=-0x1*0x337+-0x12c1*0x1+-0x1*-0x15f9)===_0xbfaa55)return _0x2d287e&&_0x2d287e['call'](_0x305b6a);_0x50564d(_0x42ec3e[_0x454c52],_0x2f15c5);},_0x2f15c5=function(){_0x4fa0f0+=-0x22e7+-0x669+0x7*0x5e7,(function(){if(!_0x274c2f){for(_0x274c2f=!(-0x185f+0x16e+0x16f1);_0x4fa0f0>0xa90*0x2+0x263c+-0x3b5c;)_0x22a385();_0x274c2f=!(-0x4*-0x84a+-0x420+-0x1d07);}}());};_0x2f15c5();}};},0xd43:_0x3691d6=>{'use strict';var _0x3924da=Array['prototype']['forEach'],_0x54d5c7=Object['prototype']['hasOwnProp'+'erty'];_0x3691d6['exports']=function(_0x2c1a10){return _0x3924da['call'](arguments,function(_0x26bcca,_0x294a9f){if(-0x15*-0x162+-0x101*-0x19+-0x1*0x3623!==_0x294a9f){for(var _0x214e52 in _0x26bcca)_0x54d5c7['call'](_0x26bcca,_0x214e52)&&(_0x2c1a10[_0x214e52]=_0x26bcca[_0x214e52]);}}),_0x2c1a10;};},0x1083:_0x30a9d6=>{'use strict';_0x30a9d6['exports']={};},0x100c:(_0x46ce01,_0x10e40c,_0xa58d91)=>{'use strict';var _0xdf2df3=_0xa58d91(0x1*-0x1288+0x1*-0x26b+0x2236*0x1);_0x46ce01['exports']=function(_0x6162a7,_0x192065){'function'!=typeof _0x6162a7&&(_0x192065=_0x6162a7,_0x6162a7=Object);var _0x593618=function(){return this['initialize']&&this['initialize']['apply'](this,arguments)||this;},_0x57a15b=function(){};return _0x57a15b['prototype']=_0x6162a7['prototype'],_0x593618['prototype']=new _0x57a15b(),_0xdf2df3(_0x593618['prototype'],_0x192065),_0x593618;};},0x845:_0x1bd1ac=>{_0x1bd1ac['exports']={'VERSION':'1.4.0','BAYEUX_VERSION':'1.0','ID_LENGTH':0xa0,'JSONP_CALLBACK':'jsonpcallb'+'ack','CONNECTION_TYPES':['long-polli'+'ng','cross-orig'+'in-long-po'+'lling','callback-p'+'olling','websocket','eventsourc'+'e','in-process'],'MANDATORY_CONNECTION_TYPES':['long-polli'+'ng','callback-p'+'olling','in-process']};},0x1ba2:(_0x41ff5e,_0x1f6d57,_0x3da1ec)=>{'use strict';_0x41ff5e['exports']=_0x3da1ec(0x1aff+-0x139f+0x40b);},0xd99:_0x3a091d=>{'use strict';var _0x3d44ca=function(_0x29d68d){var _0x26fbd4,_0x4f1ddf,_0x14ef15;if(_0x29d68d instanceof Array){for(_0x26fbd4=[],_0x4f1ddf=_0x29d68d['length'];_0x4f1ddf--;)_0x26fbd4[_0x4f1ddf]=_0x3d44ca(_0x29d68d[_0x4f1ddf]);return _0x26fbd4;}if('object'==typeof _0x29d68d){for(_0x14ef15 in(_0x26fbd4=null===_0x29d68d?null:{},_0x29d68d))_0x26fbd4[_0x14ef15]=_0x3d44ca(_0x29d68d[_0x14ef15]);return _0x26fbd4;}return _0x29d68d;};_0x3a091d['exports']=_0x3d44ca;},0x289:_0x19dc76=>{var _0x9476f9='function'==typeof Array['isArray']?Array['isArray']:function(_0x5e0800){return'[object\x20Ar'+'ray]'===Object['prototype']['toString']['call'](_0x5e0800);};function _0x28f5c5(){}_0x19dc76['exports']=_0x28f5c5,_0x28f5c5['prototype']['emit']=function(_0x25e418){if('error'===_0x25e418&&(!this['_events']||!this['_events']['error']||_0x9476f9(this['_events']['error'])&&!this['_events']['error']['length']))throw arguments[0x131*0x1+-0x1d71*-0x1+0x1*-0x1ea1]instanceof Error?arguments[0x1285+-0x199f+0x11*0x6b]:new Error('Uncaught,\x20'+'unspecifie'+'d\x20\x27error\x27\x20'+'event.');if(!this['_events'])return!(-0x529+0x26c7+-0x219d);var _0x4f0f9e=this['_events'][_0x25e418];if(!_0x4f0f9e)return!(0x14b+0x2065+0x21af*-0x1);if('function'==typeof _0x4f0f9e){switch(arguments['length']){case 0x1eae+-0x1*0xc8f+0x3*-0x60a:_0x4f0f9e['call'](this);break;case-0x381*-0xb+-0x1*-0xe55+-0x34de:_0x4f0f9e['call'](this,arguments[0x1b1+0x1930+-0x4*0x6b8]);break;case 0x18e9+-0x142c+-0x4ba:_0x4f0f9e['call'](this,arguments[-0x2202+-0x12e9*0x2+0x47d5*0x1],arguments[-0x2119*0x1+-0x28e+-0x219*-0x11]);break;default:var _0x4a1760=Array['prototype']['slice']['call'](arguments,-0x117d+-0x1*0x2ce+0x4*0x513);_0x4f0f9e['apply'](this,_0x4a1760);}return!(-0x1*0x95c+-0x211*0x3+-0x7*-0x239);}if(_0x9476f9(_0x4f0f9e)){_0x4a1760=Array['prototype']['slice']['call'](arguments,0x106e+0x1*0x2159+-0x31c6);for(var _0xa088c0=_0x4f0f9e['slice'](),_0x430976=-0x97b*0x3+-0x2*0x1323+-0x42b7*-0x1,_0x5bda14=_0xa088c0['length'];_0x430976<_0x5bda14;_0x430976++)_0xa088c0[_0x430976]['apply'](this,_0x4a1760);return!(0x146*0x1b+0xc2d*-0x1+0x471*-0x5);}return!(0x5*-0x23b+0x11a8+-0x680);},_0x28f5c5['prototype']['addListene'+'r']=function(_0x27fdea,_0x4a3d96){if('function'!=typeof _0x4a3d96)throw new Error('addListene'+'r\x20only\x20tak'+'es\x20instanc'+'es\x20of\x20Func'+'tion');return this['_events']||(this['_events']={}),this['emit']('newListene'+'r',_0x27fdea,_0x4a3d96),this['_events'][_0x27fdea]?_0x9476f9(this['_events'][_0x27fdea])?this['_events'][_0x27fdea]['push'](_0x4a3d96):this['_events'][_0x27fdea]=[this['_events'][_0x27fdea],_0x4a3d96]:this['_events'][_0x27fdea]=_0x4a3d96,this;},_0x28f5c5['prototype']['on']=_0x28f5c5['prototype']['addListene'+'r'],_0x28f5c5['prototype']['once']=function(_0x2d175c,_0x5edebf){var _0x1b2864=this;return _0x1b2864['on'](_0x2d175c,function _0x5348f5(){_0x1b2864['removeList'+'ener'](_0x2d175c,_0x5348f5),_0x5edebf['apply'](this,arguments);}),this;},_0x28f5c5['prototype']['removeList'+'ener']=function(_0x53b3e8,_0x538bed){if('function'!=typeof _0x538bed)throw new Error('removeList'+'ener\x20only\x20'+'takes\x20inst'+'ances\x20of\x20F'+'unction');if(!this['_events']||!this['_events'][_0x53b3e8])return this;var _0x40aac7=this['_events'][_0x53b3e8];if(_0x9476f9(_0x40aac7)){var _0x4aaeb3=function(_0x3bd676,_0x19ff41){if(_0x3bd676['indexOf'])return _0x3bd676['indexOf'](_0x19ff41);for(var _0x36d994=-0x10f8+0x24b*0x11+-0x1603;_0x36d994<_0x3bd676['length'];_0x36d994++)if(_0x19ff41===_0x3bd676[_0x36d994])return _0x36d994;return-(0x3*0x96b+-0x3*0x5e1+-0xa9d);}(_0x40aac7,_0x538bed);if(_0x4aaeb3<-0x18e5+0x18d3+-0x9*-0x2)return this;_0x40aac7['splice'](_0x4aaeb3,0x22*0x110+-0x1*-0x147d+-0x389c),0x13b2+0x680+-0x1a32==_0x40aac7['length']&&delete this['_events'][_0x53b3e8];}else this['_events'][_0x53b3e8]===_0x538bed&&delete this['_events'][_0x53b3e8];return this;},_0x28f5c5['prototype']['removeAllL'+'isteners']=function(_0x2b339f){return-0x2*0x130d+-0x18*-0x40+-0x7*-0x496===arguments['length']?(this['_events']={},this):(_0x2b339f&&this['_events']&&this['_events'][_0x2b339f]&&(this['_events'][_0x2b339f]=null),this);},_0x28f5c5['prototype']['listeners']=function(_0x157051){return this['_events']||(this['_events']={}),this['_events'][_0x157051]||(this['_events'][_0x157051]=[]),_0x9476f9(this['_events'][_0x157051])||(this['_events'][_0x157051]=[this['_events'][_0x157051]]),this['_events'][_0x157051];};},0x1d75:(_0x40fd23,_0x41b789,_0x21a5bf)=>{'use strict';var _0xcfa35e=_0x21a5bf(-0xd7*-0x1d+-0x383*-0x2+-0x1e18);_0x40fd23['exports']=function(_0x20006f){var _0x550851=_0xcfa35e['filter']([]['concat'](_0x20006f),function(_0x489a60){return'/meta/conn'+'ect'===_0x489a60['channel'];});return _0x550851[-0xdc1+0x98d+0x434]&&_0x550851[0x1*0x9b9+-0x17ce+0x203*0x7]['clientId'];};},0x10d7:(_0x5b2856,_0x121829,_0x5c73f6)=>{'use strict';var _0x2df78d=_0x5c73f6(0x99b+-0x2472+0x2ae3),_0x59a35b=_0x5c73f6(-0xa*0x367+0x5*-0x2ad+-0xc*-0x4c9);_0x5b2856['exports']=_0x2df78d({'initialize':function(){this['_used']={};},'exists':function(_0x53de72){return this['_used']['hasOwnProp'+'erty'](_0x53de72);},'generate':function(){for(var _0x48c5d2=_0x59a35b();this['_used']['hasOwnProp'+'erty'](_0x48c5d2);)_0x48c5d2=_0x59a35b();return this['_used'][_0x48c5d2]=_0x48c5d2;},'release':function(_0x499d65){delete this['_used'][_0x499d65];}});},0x55:(_0xf21d47,_0x5edb63,_0x3647e7)=>{'use strict';var _0x483f9e=_0x3647e7(-0x11c4+0x224*-0x8+0x1*0x26bb),_0x282273=function(_0x144fee){this['_state']=-(0x17ee*0x1+-0x1*-0xa77+-0x2264),this['_value']=null,this['_defer']=[],_0x2b402d(this,_0x144fee);};_0x282273['prototype']['then']=function(_0x2d7135,_0x39385a){var _0x112359=new _0x282273(),_0x3fd4dc={'promise':_0x112359,'onFulfilled':_0x2d7135,'onRejected':_0x39385a};return-(0x2671+0x25dd*-0x1+-0x93)===this['_state']?this['_defer']['push'](_0x3fd4dc):_0x5440e0(this,_0x3fd4dc),_0x112359;},_0x282273['prototype']['catch']=function(_0x15d6b0){return this['then'](null,_0x15d6b0);};var _0x2b402d=function(_0x520d3b,_0x4da7fe){if('function'==typeof _0x4da7fe){var _0x2a2733=0x1d73+-0x41*0x1+0x25*-0xca,_0x2b9d63=function(_0xe59272){0x20b+-0x24f9*0x1+0x22ee==_0x2a2733++&&_0x2847a6(_0x520d3b,_0xe59272);};try{_0x4da7fe(function(_0x2ba90d){-0x9*0x169+-0x1358+0x2009==_0x2a2733++&&_0x8c42b3(_0x520d3b,_0x2ba90d);},_0x2b9d63);}catch(_0x36455e){_0x2b9d63(_0x36455e);}}},_0x5440e0=function(_0x2fc7ea,_0x3e296e){var _0x34e420=_0x2fc7ea['_state'],_0x214527=_0x2fc7ea['_value'],_0x245f3d=_0x3e296e['promise'],_0x1d5a45=[_0x3e296e['onFulfille'+'d'],_0x3e296e['onRejected']][_0x34e420];if('function'!=typeof _0x1d5a45)return(0x1e04*0x1+0x1177*0x2+-0x40f2,[_0x8c42b3,_0x2847a6][_0x34e420])(_0x245f3d,_0x214527);_0x483f9e(function(){try{_0x8c42b3(_0x245f3d,_0x1d5a45(_0x214527));}catch(_0x2b7b5d){_0x2847a6(_0x245f3d,_0x2b7b5d);}});},_0x8c42b3=function(_0x3adf1d,_0x1a4885){if(_0x3adf1d===_0x1a4885)return _0x2847a6(_0x3adf1d,new TypeError('Recursive\x20'+'promise\x20ch'+'ain\x20detect'+'ed'));var _0x4a6d43;try{_0x4a6d43=_0x40a03f(_0x1a4885);}catch(_0x16ddcd){return _0x2847a6(_0x3adf1d,_0x16ddcd);}if(!_0x4a6d43)return _0x2d5c4e(_0x3adf1d,_0x1a4885);_0x2b402d(_0x3adf1d,function(_0xe1863e,_0x1beb54){_0x4a6d43['call'](_0x1a4885,_0xe1863e,_0x1beb54);});},_0x40a03f=function(_0x280d2e){var _0x4d09b5=typeof _0x280d2e,_0x4f39cb=('object'===_0x4d09b5||'function'===_0x4d09b5)&&_0x280d2e&&_0x280d2e['then'];return'function'==typeof _0x4f39cb?_0x4f39cb:null;},_0x2d5c4e=function(_0x13e8ce,_0x525343){_0x3f7655(_0x13e8ce,0x16c5+0x1*0x1099+0x13af*-0x2,_0x525343);},_0x2847a6=function(_0xf8c468,_0x16e26e){_0x3f7655(_0xf8c468,0xb22*-0x1+-0x1*-0x3+0x164*0x8,_0x16e26e);},_0x3f7655=function(_0x1ae43f,_0x5ceb35,_0x3e6763){var _0x405882=_0x1ae43f['_defer'],_0x34e1df=-0x2*0x611+0x1*0x531+0x6f1;if(_0x1ae43f['_state']=_0x5ceb35,_0x1ae43f['_value']=_0x3e6763,_0x1ae43f['_defer']=null,0x182f+0x1f0*0x14+-0x3eef!==_0x405882['length']){for(;_0x34e1df<_0x405882['length'];)_0x5440e0(_0x1ae43f,_0x405882[_0x34e1df++]);}};_0x282273['resolve']=function(_0x378cc7){try{if(_0x40a03f(_0x378cc7))return _0x378cc7;}catch(_0x167a7f){return _0x282273['reject'](_0x167a7f);}return new _0x282273(function(_0x473e9a,_0x4d5f97){_0x473e9a(_0x378cc7);});},_0x282273['reject']=function(_0x1739a5){return new _0x282273(function(_0x4963e2,_0x2f04bc){_0x2f04bc(_0x1739a5);});},_0x282273['all']=function(_0x35d6f4){return new _0x282273(function(_0xce0ffe,_0x37b293){var _0x38c61b,_0x47c9ea=[],_0x2ea217=_0x35d6f4['length'];if(-0x5*0x2fc+0x1*-0x196e+0x285a===_0x2ea217)return _0xce0ffe(_0x47c9ea);var _0x1056a0=function(_0xcba686,_0x17ff8b){_0x282273['resolve'](_0xcba686)['then'](function(_0x2312c9){_0x47c9ea[_0x17ff8b]=_0x2312c9,0x18ec+0x830+-0x211c==--_0x2ea217&&_0xce0ffe(_0x47c9ea);},_0x37b293);};for(_0x38c61b=-0x1575+-0x17bf+0x2d34;_0x38c61b<_0x2ea217;_0x38c61b++)_0x1056a0(_0x35d6f4[_0x38c61b],_0x38c61b);});},_0x282273['race']=function(_0x764507){return new _0x282273(function(_0xc35944,_0x4dffd2){for(var _0x1c5246=-0x2646+-0x1*0x211f+-0x4765*-0x1,_0x37cb19=_0x764507['length'];_0x1c5246<_0x37cb19;_0x1c5246++)_0x282273['resolve'](_0x764507[_0x1c5246])['then'](_0xc35944,_0x4dffd2);});},_0x282273['deferred']=function(){var _0x1e8576={};return _0x1e8576['promise']=new _0x282273(function(_0x1b15b2,_0xe34d14){_0x1e8576['resolve']=_0x1b15b2,_0x1e8576['reject']=_0xe34d14;}),_0x1e8576;},_0xf21d47['exports']=_0x282273;},0xa05:(_0xe58ae3,_0x56205e,_0x33c078)=>{'use strict';var _0x40b7a9=_0x33c078(-0x202*0x11+0x1*0x1ed+0xc*0x372),_0x43c4e8=_0x33c078(-0x1da*0x10+-0x1*0x22cd+0x1*0x48b2);_0xe58ae3['exports']=function(_0x4364e6){_0x4364e6=_0x4364e6||_0x43c4e8['ID_LENGTH'];for(var _0x513ccb=Math['ceil'](_0x4364e6*Math['log'](0x1*0xd61+0x1c41+-0x29a0)/Math['log'](0x5c2+0x3ec*-0x7+-0x2b*-0x82)),_0x51a567=_0x40b7a9(_0x4364e6,-0xbc4*0x2+-0xbf3+0x33d*0xb);_0x51a567['length']<_0x513ccb;)_0x51a567='0'+_0x51a567;return _0x51a567;};},0x13a0:(_0x3d587f,_0x16a65e,_0x257aa3)=>{'use strict';var _0x7d0407=_0x257aa3(0x2203+-0x8d7+-0x920);_0x3d587f['exports']=_0x7d0407({'initialize':function(){this['_index']={};},'add':function(_0x3e187b){var _0x2d0a57=void(0xa8*0xb+0x18ad+-0x1fe5)!==_0x3e187b['id']?_0x3e187b['id']:_0x3e187b;return!this['_index']['hasOwnProp'+'erty'](_0x2d0a57)&&(this['_index'][_0x2d0a57]=_0x3e187b,!(-0x1240+-0x6*0x4bd+0x4ab*0xa));},'forEach':function(_0x3d9ad,_0x465db8){for(var _0xda561f in this['_index'])this['_index']['hasOwnProp'+'erty'](_0xda561f)&&_0x3d9ad['call'](_0x465db8,this['_index'][_0xda561f]);},'isEmpty':function(){for(var _0x773644 in this['_index'])if(this['_index']['hasOwnProp'+'erty'](_0x773644))return!(0x109d+-0x44+-0x4*0x416);return!(-0x973*0x2+-0x257c+0x1*0x3862);},'member':function(_0x1095b2){for(var _0x370b4e in this['_index'])if(this['_index'][_0x370b4e]===_0x1095b2)return!(0x6da+0x42e+-0x8*0x161);return!(0x3*-0xbb+-0x1*0x1fbb+0x21ed);},'remove':function(_0x1b6313){var _0x2f32a2=void(0xe1c+-0x2a1*-0x1+-0x359*0x5)!==_0x1b6313['id']?_0x1b6313['id']:_0x1b6313,_0x52169=this['_index'][_0x2f32a2];return delete this['_index'][_0x2f32a2],_0x52169;},'toArray':function(){var _0x14ecff=[];return this['forEach'](function(_0x1e8b64){_0x14ecff['push'](_0x1e8b64);}),_0x14ecff;}});},0x1d6c:_0x2f7438=>{'use strict';_0x2f7438['exports']=function(_0x5c1d54){return JSON['stringify'](_0x5c1d54,function(_0xc7bb5b,_0x109914){return this[_0xc7bb5b]instanceof Array?this[_0xc7bb5b]:_0x109914;});};},0x7be:_0x1ae9bd=>{'use strict';_0x1ae9bd['exports']={'isURI':function(_0x3d482d){return _0x3d482d&&_0x3d482d['protocol']&&_0x3d482d['host']&&_0x3d482d['path'];},'isSameOrigin':function(_0x4a221e){return _0x4a221e['protocol']===location['protocol']&&_0x4a221e['hostname']===location['hostname']&&_0x4a221e['port']===location['port'];},'parse':function(_0x5411e0){if('string'!=typeof _0x5411e0)return _0x5411e0;var _0x7e3920,_0x39e665,_0x48e870,_0x245f05,_0x16b1f4,_0x311d06,_0x3f612a={},_0x30fffa=function(_0x125999,_0x45d9e4){_0x5411e0=_0x5411e0['replace'](_0x45d9e4,function(_0x9b60b8){return _0x3f612a[_0x125999]=_0x9b60b8,'';}),_0x3f612a[_0x125999]=_0x3f612a[_0x125999]||'';};for(_0x30fffa('protocol',/^[a-z]+\:/i),_0x30fffa('host',/^\/\/[^\/\?#]+/),/^\//['test'](_0x5411e0)||_0x3f612a['host']||(_0x5411e0=location['pathname']['replace'](/[^\/]*$/,'')+_0x5411e0),_0x30fffa('pathname',/^[^\?#]*/),_0x30fffa('search',/^\?[^#]*/),_0x30fffa('hash',/^#.*/),_0x3f612a['protocol']=_0x3f612a['protocol']||location['protocol'],_0x3f612a['host']?(_0x3f612a['host']=_0x3f612a['host']['substr'](-0x189+-0x6a9+0x1*0x834),/@/['test'](_0x3f612a['host'])&&(_0x3f612a['auth']=_0x3f612a['host']['split']('@')[-0x104f+0xbb7+0x498],_0x3f612a['host']=_0x3f612a['host']['split']('@')[0x1b44+-0x1930+-0x9*0x3b]),_0x7e3920=_0x3f612a['host']['match'](/^\[([^\]]+)\]|^[^:]+/),_0x3f612a['hostname']=_0x7e3920[-0x171a+0xb5f+0xbbc]||_0x7e3920[-0x345*0x1+-0x7db*0x2+-0x71*-0x2b],_0x3f612a['port']=(_0x3f612a['host']['match'](/:(\d+)$/)||[])[0x1cb7+0x2e3*0xc+-0x3f5a]||''):(_0x3f612a['host']=location['host'],_0x3f612a['hostname']=location['hostname'],_0x3f612a['port']=location['port']),_0x3f612a['pathname']=_0x3f612a['pathname']||'/',_0x3f612a['path']=_0x3f612a['pathname']+_0x3f612a['search'],_0x311d06={},_0x245f05=0x2031+0x1d*0xae+-0x33e7,_0x16b1f4=(_0x48e870=(_0x39e665=_0x3f612a['search']['replace'](/^\?/,''))?_0x39e665['split']('&'):[])['length'];_0x245f05<_0x16b1f4;_0x245f05++)_0x7e3920=_0x48e870[_0x245f05]['split']('='),_0x311d06[decodeURIComponent(_0x7e3920[-0x1549+-0x3f1*-0x5+0x194]||'')]=decodeURIComponent(_0x7e3920[0x15*-0x171+-0x2*0x664+0x2b0e]||'');return _0x3f612a['query']=_0x311d06,_0x3f612a['href']=this['stringify'](_0x3f612a),_0x3f612a;},'stringify':function(_0x1e2df7){var _0x5e0dda=_0x1e2df7['auth']?_0x1e2df7['auth']+'@':'';return _0x1e2df7['protocol']+'//'+_0x5e0dda+_0x1e2df7['host']+(_0x1e2df7['pathname']+this['queryStrin'+'g'](_0x1e2df7['query'])+(_0x1e2df7['hash']||''));},'queryString':function(_0x2ba640){var _0x57589=[];for(var _0x3f54eb in _0x2ba640)_0x2ba640['hasOwnProp'+'erty'](_0x3f54eb)&&_0x57589['push'](encodeURIComponent(_0x3f54eb)+'='+encodeURIComponent(_0x2ba640[_0x3f54eb]));return 0x1*-0x19c6+-0x953*0x1+-0x1*-0x2319===_0x57589['length']?'':'?'+_0x57589['join']('&');}};},0xf65:(_0x4c3747,_0x331346,_0x484f32)=>{'use strict';var _0x1eb878=_0x484f32(-0x14*0x64+0x104e+-0x171*0x5);_0x4c3747['exports']=function(_0x5be06f,_0x2a388e){for(var _0x25310c in _0x5be06f)if(_0x1eb878['indexOf'](_0x2a388e,_0x25310c)<-0x1234+0x101*0x17+0x1*-0x4e3)throw new Error('Unrecogniz'+'ed\x20option:'+'\x20'+_0x25310c);};},0x2aa:(_0x545699,_0x5cbb09,_0x176082)=>{'use strict';var _0x16a6f6=_0x176082(0x2*-0x6a6+-0x509*0x1+0x1582*0x1)['Client'];_0x545699['exports']={'create':function(_0x30c2fa,_0x252e79,_0x539f8c){return new _0x16a6f6(_0x30c2fa,_0x252e79,_0x539f8c);}};},0x1711:(_0x5a8137,_0x39afb5,_0x2f0d76)=>{var _0x27da33=_0x2f0d76(0x1984+-0x6*0x3b+-0xded);function _0x322713(_0x3d81a4){_0x27da33['ok'](_0x3d81a4===_0x322713['REQUEST']||_0x3d81a4===_0x322713['RESPONSE']||void(-0x2cd+-0x1e2f*-0x1+-0xdb1*0x2)===_0x3d81a4),void(-0x492+0x1776+0x3*-0x64c)===_0x3d81a4||this['initialize'](_0x3d81a4);}_0x39afb5['e']=_0x322713,_0x322713['prototype']['initialize']=function(_0x2b48a7,_0x5c5091){_0x27da33['ok'](_0x2b48a7===_0x322713['REQUEST']||_0x2b48a7===_0x322713['RESPONSE']),this['type']=_0x2b48a7,this['state']=_0x2b48a7+'_LINE',this['info']={'headers':[],'upgrade':!(0x1*0x1107+-0x1d9c+0xc96)},this['trailers']=[],this['line']='',this['isChunked']=!(-0x4*0x21+-0x206+0x28b),this['connection']='',this['headerSize']=-0x9d*0x2e+-0x270a+-0x434*-0x10,this['body_bytes']=null,this['isUserCall']=!(-0x185*-0x18+0xa19+0x2e90*-0x1),this['hadError']=!(0x16d7*-0x1+0x19cd*0x1+-0x2f5*0x1);},_0x322713['encoding']='ascii',_0x322713['maxHeaderS'+'ize']=0xb2ae+-0x17d4d*-0x1+-0xeffb,_0x322713['REQUEST']='REQUEST',_0x322713['RESPONSE']='RESPONSE';var _0x41569c=_0x322713['kOnHeaders']=0x1ad2+0x1964+-0x3435,_0x31c633=_0x322713['kOnHeaders'+'Complete']=0x15b*0x4+-0xb4*-0x9+-0xbbe,_0x3fce7e=_0x322713['kOnBody']=-0x2c*-0x22+-0x477+-0x15e,_0x2c99b2=_0x322713['kOnMessage'+'Complete']=-0x863*0x1+-0x452+0xcb9;_0x322713['prototype'][_0x41569c]=_0x322713['prototype'][_0x31c633]=_0x322713['prototype'][_0x3fce7e]=_0x322713['prototype'][_0x2c99b2]=function(){};var _0x40b643=!(-0x633*0x1+0x27*-0x5+-0xc6*-0x9);Object['defineProp'+'erty'](_0x322713,'kOnExecute',{'get':function(){return _0x40b643=!(0xb47*-0x3+0xc45+0x1591),-0xa6c*-0x1+0xed+-0x57b*0x2;}});var _0x21ff61=_0x322713['methods']=['DELETE','GET','HEAD','POST','PUT','CONNECT','OPTIONS','TRACE','COPY','LOCK','MKCOL','MOVE','PROPFIND','PROPPATCH','SEARCH','UNLOCK','BIND','REBIND','UNBIND','ACL','REPORT','MKACTIVITY','CHECKOUT','MERGE','M-SEARCH','NOTIFY','SUBSCRIBE','UNSUBSCRIB'+'E','PATCH','PURGE','MKCALENDAR','LINK','UNLINK'],_0x42f70a=_0x21ff61['indexOf']('CONNECT');_0x322713['prototype']['reinitiali'+'ze']=_0x322713,_0x322713['prototype']['close']=_0x322713['prototype']['pause']=_0x322713['prototype']['resume']=_0x322713['prototype']['free']=function(){},_0x322713['prototype']['_compatMod'+'e0_11']=!(0x4ba+0xc6+-0x57f),_0x322713['prototype']['getAsyncId']=function(){return 0x2400+0xa79+0x1*-0x2e79;};var _0x439b62={'REQUEST_LINE':!(0x10fc+-0x14b8+0x3bc),'RESPONSE_LINE':!(0x1b2a+0x879+-0x23a3),'HEADER':!(-0x20a7*-0x1+-0x2*-0xa5c+-0x355f)};_0x322713['prototype']['execute']=function(_0x3fe442,_0xf2b18,_0x20ef48){if(!(this instanceof _0x322713))throw new TypeError('not\x20a\x20HTTP'+'Parser');_0xf2b18=_0xf2b18||-0x21+0x176a+-0x1749,_0x20ef48='number'==typeof _0x20ef48?_0x20ef48:_0x3fe442['length'],this['chunk']=_0x3fe442,this['offset']=_0xf2b18;var _0x4e224b=this['end']=_0xf2b18+_0x20ef48;try{for(;this['offset']<_0x4e224b&&!this[this['state']](););}catch(_0x4479d8){if(this['isUserCall'])throw _0x4479d8;return this['hadError']=!(-0x2659*0x1+0x1f2f+0x72a),_0x4479d8;}return this['chunk']=null,_0x20ef48=this['offset']-_0xf2b18,_0x439b62[this['state']]&&(this['headerSize']+=_0x20ef48,this['headerSize']>_0x322713['maxHeaderS'+'ize'])?new Error('max\x20header'+'\x20size\x20exce'+'eded'):_0x20ef48;};var _0xdea851={'REQUEST_LINE':!(0x15a0+-0x1b62+0x5c2*0x1),'RESPONSE_LINE':!(0x684+0x1f1d+-0x25a1),'BODY_RAW':!(0x161e+0x3a+0x28*-0x8f)};_0x322713['prototype']['finish']=function(){if(!this['hadError'])return _0xdea851[this['state']]?void('BODY_RAW'===this['state']&&this['userCall']()(this[_0x2c99b2]())):new Error('invalid\x20st'+'ate\x20for\x20EO'+'F');},_0x322713['prototype']['consume']=_0x322713['prototype']['unconsume']=_0x322713['prototype']['getCurrent'+'Buffer']=function(){},_0x322713['prototype']['userCall']=function(){this['isUserCall']=!(0x7*0x3d9+-0x131*-0x19+-0x38b8);var _0x4d5004=this;return function(_0x3b2be2){return _0x4d5004['isUserCall']=!(0x1*-0x16b5+0x1bed+-0x59*0xf),_0x3b2be2;};},_0x322713['prototype']['nextReques'+'t']=function(){this['userCall']()(this[_0x2c99b2]()),this['reinitiali'+'ze'](this['type']);},_0x322713['prototype']['consumeLin'+'e']=function(){for(var _0x1bdea4=this['end'],_0x45f8cc=this['chunk'],_0x5d02b3=this['offset'];_0x5d02b3<_0x1bdea4;_0x5d02b3++)if(0x21a3+-0x12ff+-0xe9a===_0x45f8cc[_0x5d02b3]){var _0x40893e=this['line']+_0x45f8cc['toString'](_0x322713['encoding'],this['offset'],_0x5d02b3);return'\x0d'===_0x40893e['charAt'](_0x40893e['length']-(0x1c09+0x1e4+-0x1dec))&&(_0x40893e=_0x40893e['substr'](0x16*-0x70+-0xb91+0x1531,_0x40893e['length']-(-0x819+0x1c0*-0x1+0x1a*0x61))),this['line']='',this['offset']=_0x5d02b3+(-0x3*-0xaed+0x11e+-0x21e4*0x1),_0x40893e;}this['line']+=_0x45f8cc['toString'](_0x322713['encoding'],this['offset'],this['end']),this['offset']=this['end'];};var _0x523e4b=/^([^: \t]+):[ \t]*((?:.*[^ \t])|)/,_0x2037d2=/^[ \t]+(.*[^ \t])/;_0x322713['prototype']['parseHeade'+'r']=function(_0x4d550b,_0x2818be){if(-(0x1034+0xe*0x133+0x20fd*-0x1)!==_0x4d550b['indexOf']('\x0d'))throw _0x3fae4b('HPE_LF_EXP'+'ECTED');var _0x2f989f=_0x523e4b['exec'](_0x4d550b),_0x2570eb=_0x2f989f&&_0x2f989f[-0xd37*-0x1+-0x1*-0x13ea+-0x2120];if(_0x2570eb)_0x2818be['push'](_0x2570eb),_0x2818be['push'](_0x2f989f[-0x12*-0x122+0x1*0x1823+-0xed7*0x3]);else{var _0x4a0da9=_0x2037d2['exec'](_0x4d550b);_0x4a0da9&&_0x2818be['length']&&(_0x2818be[_0x2818be['length']-(0x140+0xe33+0x1*-0xf72)]&&(_0x2818be[_0x2818be['length']-(-0x1d2c*0x1+-0x5c*-0x38+0x90d)]+='\x20'),_0x2818be[_0x2818be['length']-(0x13aa+-0xf05+-0x4a4)]+=_0x4a0da9[0x15e*0x15+-0x1942+-0x373]);}};var _0x162e9a=/^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;_0x322713['prototype']['REQUEST_LI'+'NE']=function(){var _0x5ce717=this['consumeLin'+'e']();if(_0x5ce717){var _0xeb00bf=_0x162e9a['exec'](_0x5ce717);if(null===_0xeb00bf)throw _0x3fae4b('HPE_INVALI'+'D_CONSTANT');if(this['info']['method']=this['_compatMod'+'e0_11']?_0xeb00bf[-0xc20+0x7*-0x265+0x1ce4]:_0x21ff61['indexOf'](_0xeb00bf[0x1*-0x15d8+0x14ae*-0x1+0x2a87]),-(-0x95e+-0x1*-0x539+0x213*0x2)===this['info']['method'])throw new Error('invalid\x20re'+'quest\x20meth'+'od');this['info']['url']=_0xeb00bf[0x1*-0x226+0x2f6*-0x1+-0x1*-0x51e],this['info']['versionMaj'+'or']=+_0xeb00bf[-0x1f0c+-0xcc1+0x2bd0],this['info']['versionMin'+'or']=+_0xeb00bf[-0x5*-0x39f+-0x10a0*0x1+-0x177],this['body_bytes']=0x31*-0xa+-0x984+-0xb*-0x10a,this['state']='HEADER';}};var _0x4907fb=/^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;function _0x3fae4b(_0x346f53){var _0x2c0de3=new Error('Parse\x20Erro'+'r');return _0x2c0de3['code']=_0x346f53,_0x2c0de3;}_0x322713['prototype']['RESPONSE_L'+'INE']=function(){var _0x560917=this['consumeLin'+'e']();if(_0x560917){var _0x6ccd54=_0x4907fb['exec'](_0x560917);if(null===_0x6ccd54)throw _0x3fae4b('HPE_INVALI'+'D_CONSTANT');this['info']['versionMaj'+'or']=+_0x6ccd54[-0x254d+-0xfa+0x2648],this['info']['versionMin'+'or']=+_0x6ccd54[-0x59*-0x9+0x1456+-0x1775];var _0x342d1d=this['info']['statusCode']=+_0x6ccd54[-0xb87+0x1*-0x15db+0x2165];this['info']['statusMess'+'age']=_0x6ccd54[0xa7b+0x6e3+0x1*-0x115a],-0x404*0x1+-0x9b*0x5+0x2c*0x29!=(_0x342d1d/(-0x2332+0x2263+0x133*0x1)|0x26f3+-0x1345+-0x13ae)&&-0x83*0x1+-0x3b*0x7e+0x1e59!==_0x342d1d&&0x1517+0x22d3+-0x36ba!==_0x342d1d||(this['body_bytes']=0xd5a+0x250e+-0xc9a*0x4),this['state']='HEADER';}},_0x322713['prototype']['shouldKeep'+'Alive']=function(){if(this['info']['versionMaj'+'or']>-0xd66*0x2+0x6*-0x565+0x3b2a&&this['info']['versionMin'+'or']>-0x1*-0x25f1+0x1f0d*0x1+-0x44fe){if(-(0x22*0x83+-0x1215+0xb0)!==this['connection']['indexOf']('close'))return!(0x592*0x7+0x5cb+-0x2cc8);}else{if(-(-0x31*-0xbc+0x1*0x1e0b+-0x3*0x1602)===this['connection']['indexOf']('keep-alive'))return!(0x575+-0x4*0x209+-0x158*-0x2);}return!(null===this['body_bytes']&&!this['isChunked']);},_0x322713['prototype']['HEADER']=function(){var _0x738c07=this['consumeLin'+'e']();if(void(-0x799+-0x1eef+0xcd8*0x3)!==_0x738c07){var _0x1f2772=this['info'];if(_0x738c07)this['parseHeade'+'r'](_0x738c07,_0x1f2772['headers']);else{for(var _0xa2836,_0x12ac0a,_0x1f583f=_0x1f2772['headers'],_0x25c5e3=!(-0x3*-0x11d+-0x903*-0x3+-0x1e5f),_0x36debb=!(0x2587+0x2050+-0x45d6),_0x59beca=0x22f*-0x6+-0xb7f+0x1899;_0x59beca<_0x1f583f['length'];_0x59beca+=-0x1*0x14ae+0x15d+-0x671*-0x3)switch(_0x1f583f[_0x59beca]['toLowerCas'+'e']()){case'transfer-e'+'ncoding':this['isChunked']='chunked'===_0x1f583f[_0x59beca+(0x11b5+0x1*-0xd0d+-0x4a7)]['toLowerCas'+'e']();break;case'content-le'+'ngth':if(_0xa2836=+_0x1f583f[_0x59beca+(-0x3e9+-0x14ea*0x1+0x18d4)],_0x25c5e3){if(_0xa2836!==this['body_bytes'])throw _0x3fae4b('HPE_UNEXPE'+'CTED_CONTE'+'NT_LENGTH');}else _0x25c5e3=!(0xfd5+-0x170*0xb+-0x5),this['body_bytes']=_0xa2836;break;case'connection':this['connection']+=_0x1f583f[_0x59beca+(0x1*0x1f88+0xfa9+-0x5*0x970)]['toLowerCas'+'e']();break;case'upgrade':_0x36debb=!(-0xa16*0x3+0x24*0x71+0xe5e);}if(this['isChunked']&&_0x25c5e3&&(_0x25c5e3=!(-0x55b*0x1+0x133*-0x1a+0x2*0x1245),this['body_bytes']=null),_0x36debb&&-(-0x2*-0xbc2+-0x1*-0x1467+0x2*-0x15f5)!=this['connection']['indexOf']('upgrade')?_0x1f2772['upgrade']=this['type']===_0x322713['REQUEST']||-0x1849*0x1+-0x75*0x9+-0xbd*-0x27===_0x1f2772['statusCode']:_0x1f2772['upgrade']=_0x1f2772['method']===_0x42f70a,this['isChunked']&&_0x1f2772['upgrade']&&(this['isChunked']=!(-0x88d+0x4*-0x32f+0x154a)),_0x1f2772['shouldKeep'+'Alive']=this['shouldKeep'+'Alive'](),0x2553+-0x1*0x1ae1+-0xa70===(_0x12ac0a=_0x40b643?this['userCall']()(this[_0x31c633](_0x1f2772)):this['userCall']()(this[_0x31c633](_0x1f2772['versionMaj'+'or'],_0x1f2772['versionMin'+'or'],_0x1f2772['headers'],_0x1f2772['method'],_0x1f2772['url'],_0x1f2772['statusCode'],_0x1f2772['statusMess'+'age'],_0x1f2772['upgrade'],_0x1f2772['shouldKeep'+'Alive']))))return this['nextReques'+'t'](),!(-0x3cf+-0x2*0x4db+0xd85);if(this['isChunked']&&!_0x12ac0a)this['state']='BODY_CHUNK'+'HEAD';else{if(_0x12ac0a||-0x3*-0xbab+-0xa55+0x1*-0x18ac===this['body_bytes'])return this['nextReques'+'t'](),_0x1f2772['upgrade'];null===this['body_bytes']?this['state']='BODY_RAW':this['state']='BODY_SIZED';}}}},_0x322713['prototype']['BODY_CHUNK'+'HEAD']=function(){var _0x19312e=this['consumeLin'+'e']();void(-0xc92+-0x1*-0x6ff+0x593)!==_0x19312e&&(this['body_bytes']=parseInt(_0x19312e,0xef3+0x4*-0x52+0x1*-0xd9b),this['body_bytes']?this['state']='BODY_CHUNK':this['state']='BODY_CHUNK'+'TRAILERS');},_0x322713['prototype']['BODY_CHUNK']=function(){var _0x52eac0=Math['min'](this['end']-this['offset'],this['body_bytes']);this['userCall']()(this[_0x3fce7e](this['chunk'],this['offset'],_0x52eac0)),this['offset']+=_0x52eac0,this['body_bytes']-=_0x52eac0,this['body_bytes']||(this['state']='BODY_CHUNK'+'EMPTYLINE');},_0x322713['prototype']['BODY_CHUNK'+'EMPTYLINE']=function(){var _0x4aae0a=this['consumeLin'+'e']();void(0x62f*-0x6+-0x2137+0x4651)!==_0x4aae0a&&(_0x27da33['equal'](_0x4aae0a,''),this['state']='BODY_CHUNK'+'HEAD');},_0x322713['prototype']['BODY_CHUNK'+'TRAILERS']=function(){var _0x115010=this['consumeLin'+'e']();void(-0xfd3*0x2+-0x1fa4+0x1fa5*0x2)!==_0x115010&&(_0x115010?this['parseHeade'+'r'](_0x115010,this['trailers']):(this['trailers']['length']&&this['userCall']()(this[_0x41569c](this['trailers'],'')),this['nextReques'+'t']()));},_0x322713['prototype']['BODY_RAW']=function(){var _0x38f141=this['end']-this['offset'];this['userCall']()(this[_0x3fce7e](this['chunk'],this['offset'],_0x38f141)),this['offset']=this['end'];},_0x322713['prototype']['BODY_SIZED']=function(){var _0x16f718=Math['min'](this['end']-this['offset'],this['body_bytes']);this['userCall']()(this[_0x3fce7e](this['chunk'],this['offset'],_0x16f718)),this['offset']+=_0x16f718,this['body_bytes']-=_0x16f718,this['body_bytes']||this['nextReques'+'t']();},['Headers','HeadersCom'+'plete','Body','MessageCom'+'plete']['forEach'](function(_0x5641d5){var _0x2c3968=_0x322713['kOn'+_0x5641d5];Object['defineProp'+'erty'](_0x322713['prototype'],'on'+_0x5641d5,{'get':function(){return this[_0x2c3968];},'set':function(_0x3e75af){return this['_compatMod'+'e0_11']=!(-0x2008+-0xb63+-0x5*-0x8af),_0x42f70a='CONNECT',this[_0x2c3968]=_0x3e75af;}});});},0x7e8:(_0x4d8a0c,_0xc76811,_0x36961d)=>{'use strict';var _0xc7f4a8=_0x36961d(-0xb5*-0x32+0x9d2+-0x1a20),_0x538c72={};_0x538c72['rules']=_0x36961d(-0x6ca*-0x5+-0x1*0x171d+-0x2c0)['map'](function(_0x3e5e41){return{'rule':_0x3e5e41,'suffix':_0x3e5e41['replace'](/^(\*\.|\!)/,''),'punySuffix':-(-0xbe4+-0x537*-0x2+0x177),'wildcard':'*'===_0x3e5e41['charAt'](-0x45*0x59+-0x1c61+-0x2*-0x1a2f),'exception':'!'===_0x3e5e41['charAt'](0x1d5f*0x1+0x25c6+-0x4325)};}),_0x538c72['endsWith']=function(_0x51ae00,_0x3f3926){return-(-0x2fb*-0x5+-0x1e0b+0xf25)!==_0x51ae00['indexOf'](_0x3f3926,_0x51ae00['length']-_0x3f3926['length']);},_0x538c72['findRule']=function(_0x369fbb){var _0x149ba3=_0xc7f4a8['toASCII'](_0x369fbb);return _0x538c72['rules']['reduce'](function(_0x4fc442,_0x27bb68){return-(0x1075+0x6bc+-0x1730)===_0x27bb68['punySuffix']&&(_0x27bb68['punySuffix']=_0xc7f4a8['toASCII'](_0x27bb68['suffix'])),_0x538c72['endsWith'](_0x149ba3,'.'+_0x27bb68['punySuffix'])||_0x149ba3===_0x27bb68['punySuffix']?_0x27bb68:_0x4fc442;},null);},_0xc76811['errorCodes']={'DOMAIN_TOO_SHORT':'Domain\x20nam'+'e\x20too\x20shor'+'t.','DOMAIN_TOO_LONG':'Domain\x20nam'+'e\x20too\x20long'+'.\x20It\x20shoul'+'d\x20be\x20no\x20mo'+'re\x20than\x2025'+'5\x20chars.','LABEL_STARTS_WITH_DASH':'Domain\x20nam'+'e\x20label\x20ca'+'n\x20not\x20star'+'t\x20with\x20a\x20d'+'ash.','LABEL_ENDS_WITH_DASH':'Domain\x20nam'+'e\x20label\x20ca'+'n\x20not\x20end\x20'+'with\x20a\x20das'+'h.','LABEL_TOO_LONG':'Domain\x20nam'+'e\x20label\x20sh'+'ould\x20be\x20at'+'\x20most\x2063\x20c'+'hars\x20long.','LABEL_TOO_SHORT':'Domain\x20nam'+'e\x20label\x20sh'+'ould\x20be\x20at'+'\x20least\x201\x20c'+'haracter\x20l'+'ong.','LABEL_INVALID_CHARS':'Domain\x20nam'+'e\x20label\x20ca'+'n\x20only\x20con'+'tain\x20alpha'+'numeric\x20ch'+'aracters\x20o'+'r\x20dashes.'},_0x538c72['validate']=function(_0x11b0f6){var _0x3a9a7f=_0xc7f4a8['toASCII'](_0x11b0f6);if(_0x3a9a7f['length']<0x20a+0x1588+0x7db*-0x3)return'DOMAIN_TOO'+'_SHORT';if(_0x3a9a7f['length']>0x1145*-0x1+-0x809+0x1*0x1a4d)return'DOMAIN_TOO'+'_LONG';for(var _0x2bcb9d,_0x59a2fa=_0x3a9a7f['split']('.'),_0x2a8b3e=-0x628+-0xc02+-0x1e*-0x9b;_0x2a8b3e<_0x59a2fa['length'];++_0x2a8b3e){if(!(_0x2bcb9d=_0x59a2fa[_0x2a8b3e])['length'])return'LABEL_TOO_'+'SHORT';if(_0x2bcb9d['length']>0x49*-0x3e+0x16ee+-0x501)return'LABEL_TOO_'+'LONG';if('-'===_0x2bcb9d['charAt'](0x15a5+0xd9b+0xc0*-0x2f))return'LABEL_STAR'+'TS_WITH_DA'+'SH';if('-'===_0x2bcb9d['charAt'](_0x2bcb9d['length']-(0x15c2+-0x4d3+-0x10ee)))return'LABEL_ENDS'+'_WITH_DASH';if(!/^[a-z0-9\-]+$/['test'](_0x2bcb9d))return'LABEL_INVA'+'LID_CHARS';}},_0xc76811['parse']=function(_0x461f9e){if('string'!=typeof _0x461f9e)throw new TypeError('Domain\x20nam'+'e\x20must\x20be\x20'+'a\x20string.');var _0x1055c4=_0x461f9e['slice'](-0x67+0x259+-0x1f2)['toLowerCas'+'e']();'.'===_0x1055c4['charAt'](_0x1055c4['length']-(0x1*-0xc77+-0x276+0x111*0xe))&&(_0x1055c4=_0x1055c4['slice'](0x46a*-0x1+-0x2486+0x28f0,_0x1055c4['length']-(0x1*0x703+0xa6f*-0x1+0x1*0x36d)));var _0x17d96f=_0x538c72['validate'](_0x1055c4);if(_0x17d96f)return{'input':_0x461f9e,'error':{'message':_0xc76811['errorCodes'][_0x17d96f],'code':_0x17d96f}};var _0x249b53={'input':_0x461f9e,'tld':null,'sld':null,'domain':null,'subdomain':null,'listed':!(0x117f+-0xdca+-0x1da*0x2)},_0x4c2e14=_0x1055c4['split']('.');if('local'===_0x4c2e14[_0x4c2e14['length']-(-0x12b6+0x10ae+-0x1*-0x209)])return _0x249b53;var _0x54d59e=function(){return/xn--/['test'](_0x1055c4)?(_0x249b53['domain']&&(_0x249b53['domain']=_0xc7f4a8['toASCII'](_0x249b53['domain'])),_0x249b53['subdomain']&&(_0x249b53['subdomain']=_0xc7f4a8['toASCII'](_0x249b53['subdomain'])),_0x249b53):_0x249b53;},_0xa9cd15=_0x538c72['findRule'](_0x1055c4);if(!_0xa9cd15)return _0x4c2e14['length']<0x7b*-0x4d+0x1bb6*0x1+0x94b?_0x249b53:(_0x249b53['tld']=_0x4c2e14['pop'](),_0x249b53['sld']=_0x4c2e14['pop'](),_0x249b53['domain']=[_0x249b53['sld'],_0x249b53['tld']]['join']('.'),_0x4c2e14['length']&&(_0x249b53['subdomain']=_0x4c2e14['pop']()),_0x54d59e());_0x249b53['listed']=!(-0x403+-0x2*0x9dc+0x4bf*0x5);var _0x371e1b=_0xa9cd15['suffix']['split']('.'),_0x1a2fa3=_0x4c2e14['slice'](-0x2c1*-0xa+-0x1*0x123b+-0x94f,_0x4c2e14['length']-_0x371e1b['length']);return _0xa9cd15['exception']&&_0x1a2fa3['push'](_0x371e1b['shift']()),_0x249b53['tld']=_0x371e1b['join']('.'),_0x1a2fa3['length']?(_0xa9cd15['wildcard']&&(_0x371e1b['unshift'](_0x1a2fa3['pop']()),_0x249b53['tld']=_0x371e1b['join']('.')),_0x1a2fa3['length']?(_0x249b53['sld']=_0x1a2fa3['pop'](),_0x249b53['domain']=[_0x249b53['sld'],_0x249b53['tld']]['join']('.'),_0x1a2fa3['length']&&(_0x249b53['subdomain']=_0x1a2fa3['join']('.')),_0x54d59e()):_0x54d59e()):_0x54d59e();},_0xc76811['get']=function(_0x4e2abe){return _0x4e2abe&&_0xc76811['parse'](_0x4e2abe)['domain']||null;},_0xc76811['isValid']=function(_0x5696e3){var _0x2c687f=_0xc76811['parse'](_0x5696e3);return Boolean(_0x2c687f['domain']&&_0x2c687f['listed']);};},0x20bb:(_0x562848,_0x21d789,_0x2e8241)=>{'use strict';_0x2e8241['r'](_0x21d789),_0x2e8241['d'](_0x21d789,{'decode':()=>_0x2688f6,'default':()=>_0x873adf,'encode':()=>_0x55a488,'toASCII':()=>_0x2fb458,'toUnicode':()=>_0x446950,'ucs2decode':()=>_0x227f09,'ucs2encode':()=>_0x3e268f});const _0x312262=-0x53082aee+0x6ef9a7ed+0x640e8300,_0xab7fda=0x5e*0x47+0xd7+-0x1ac5,_0x30511e=/^xn--/,_0x34aee3=/[^\0-\x7E]/,_0x2401cf=/[\x2E\u3002\uFF0E\uFF61]/g,_0x58d23e={'overflow':'Overflow:\x20'+'input\x20need'+'s\x20wider\x20in'+'tegers\x20to\x20'+'process','not-basic':'Illegal\x20in'+'put\x20>=\x200x8'+'0\x20(not\x20a\x20b'+'asic\x20code\x20'+'point)','invalid-input':'Invalid\x20in'+'put'},_0x964746=Math['floor'],_0x54335f=String['fromCharCo'+'de'];function _0x2398a4(_0x565ffc){throw new RangeError(_0x58d23e[_0x565ffc]);}function _0x50704c(_0x1769b9,_0x22e283){const _0x5a1ec7=_0x1769b9['split']('@');let _0x4a902a='';_0x5a1ec7['length']>0x26*-0xc5+-0x11be+0x2efd&&(_0x4a902a=_0x5a1ec7[-0x1*-0xc0c+0x2111+0x2d1d*-0x1]+'@',_0x1769b9=_0x5a1ec7[-0x2094+-0x18ee+0x3983*0x1]);const _0x4439e0=function(_0x8c63fe,_0x42bb20){const _0x43aae1=[];let _0x14d50c=_0x8c63fe['length'];for(;_0x14d50c--;)_0x43aae1[_0x14d50c]=_0x42bb20(_0x8c63fe[_0x14d50c]);return _0x43aae1;}((_0x1769b9=_0x1769b9['replace'](_0x2401cf,'.'))['split']('.'),_0x22e283)['join']('.');return _0x4a902a+_0x4439e0;}function _0x227f09(_0x40f632){const _0x329043=[];let _0x18e7b0=0x16ff+0x23b4+-0x3ab3;const _0x2fe78f=_0x40f632['length'];for(;_0x18e7b0<_0x2fe78f;){const _0x5c3cd6=_0x40f632['charCodeAt'](_0x18e7b0++);if(_0x5c3cd6>=0x3dc3+-0x99ce+0x1340b&&_0x5c3cd6<=0x36e*-0x76+-0x10f*0x9+0x27a3a*0x1&&_0x18e7b0<_0x2fe78f){const _0x5082c7=_0x40f632['charCodeAt'](_0x18e7b0++);0x8bab+-0x2a5d+0x12*0x6d1==(-0x7a48+0x175*-0x2+0x17932&_0x5082c7)?_0x329043['push'](((-0xa3b+-0x3a*-0x63+-0xd2*0xa&_0x5c3cd6)<<-0xdf5+-0x1f1d+0x2d1c)+(-0x4*0x66+0x230a+-0x9d1*0x3&_0x5082c7)+(-0x1661d+-0xceb6+-0x334d3*-0x1)):(_0x329043['push'](_0x5c3cd6),_0x18e7b0--);}else _0x329043['push'](_0x5c3cd6);}return _0x329043;}const _0x3e268f=_0x39e57a=>String['fromCodePo'+'int'](..._0x39e57a),_0x85e0e4=function(_0x445ed1,_0x307e83){return _0x445ed1+(0x1b0d+0x1b3e+-0x3635*0x1)+(0x2380+-0x17*0x144+-0x619)*(_0x445ed1<-0x1*0x1f2a+0x1*0x1093+-0xeb1*-0x1)-((-0xa44+-0xbb*-0x15+0x1*-0x513!=_0x307e83)<<0x18f6+0x119d+-0x2a8e);},_0x48fe00=function(_0x15744a,_0x26a4cc,_0x54bb35){let _0x6d0507=0x24f*0x1+0x13*0x20b+-0x8*0x524;for(_0x15744a=_0x54bb35?_0x964746(_0x15744a/(0x1*0x8cc+0x26e*-0x5+0x616*0x1)):_0x15744a>>0x14ab+-0x11b7+-0x2f3,_0x15744a+=_0x964746(_0x15744a/_0x26a4cc);_0x15744a>-0x9b9*-0x4+0x20d*0x9+-0x943*0x6;_0x6d0507+=_0xab7fda)_0x15744a=_0x964746(_0x15744a/(-0xc74+0x1568+0x25*-0x3d));return _0x964746(_0x6d0507+(0x1fa*-0x7+0x15a+0xca0)*_0x15744a/(_0x15744a+(-0x261f+0x7e1*-0x1+-0x166*-0x21)));},_0x2688f6=function(_0x4dbf63){const _0x377b01=[],_0x220129=_0x4dbf63['length'];let _0xab6417=0x2a*0x54+0xf*0x278+-0x32d0,_0x3ad329=0x1*-0x15d1+0xc67+-0x8d*-0x12,_0x2b1404=0x1ccd+-0x1d13*-0x1+-0x3998,_0x237e01=_0x4dbf63['lastIndexO'+'f']('-');_0x237e01<-0x2*-0x665+-0x1f5f+0x1295&&(_0x237e01=0x2a*-0x14+-0x1d74+0x5*0x68c);for(let _0x18ef41=0x26db+-0x16fd+-0xfde;_0x18ef41<_0x237e01;++_0x18ef41)_0x4dbf63['charCodeAt'](_0x18ef41)>=0x1c98+-0x787+-0x1491&&_0x2398a4('not-basic'),_0x377b01['push'](_0x4dbf63['charCodeAt'](_0x18ef41));for(let _0x1d3250=_0x237e01>0x268d+-0x57e*0x2+0x1b91*-0x1?_0x237e01+(-0x12f1*0x1+0x110b+0x1e7):-0x1abb+-0xdcd*-0x2+-0xdf;_0x1d3250<_0x220129;){let _0x516fc9=_0xab6417;for(let _0x546ce4=0xa*0x73+-0x2569+0x1076*0x2,_0x39db12=_0xab7fda;;_0x39db12+=_0xab7fda){_0x1d3250>=_0x220129&&_0x2398a4('invalid-in'+'put');const _0x33439b=(_0x542f27=_0x4dbf63['charCodeAt'](_0x1d3250++))-(0x43d+-0x1*0x1a11+0x1604)<0xa7*0x32+-0x1*-0x18c6+-0x395a?_0x542f27-(-0x1*-0x529+0xa71*0x3+-0x2466):_0x542f27-(0xa63+0x253d+-0x2f5f)<0x747+0x3d2+-0xaff?_0x542f27-(-0x2362+0x3*0x595+-0x1f*-0x9c):_0x542f27-(-0x1776+-0x1*0x177+0x194e)<-0x1c69+-0x118d*-0x2+-0x697?_0x542f27-(-0x1f0c*-0x1+0x4*-0x68b+0x47f*-0x1):_0xab7fda;(_0x33439b>=_0xab7fda||_0x33439b>_0x964746((_0x312262-_0xab6417)/_0x546ce4))&&_0x2398a4('overflow'),_0xab6417+=_0x33439b*_0x546ce4;const _0x371647=_0x39db12<=_0x2b1404?-0xb*-0x99+-0x247f*-0x1+0x4c9*-0x9:_0x39db12>=_0x2b1404+(0x126*-0x1f+0x1120+0x1294)?-0x2*0x100e+-0x3be*0x2+0x27b2:_0x39db12-_0x2b1404;if(_0x33439b<_0x371647)break;const _0xb18c25=_0xab7fda-_0x371647;_0x546ce4>_0x964746(_0x312262/_0xb18c25)&&_0x2398a4('overflow'),_0x546ce4*=_0xb18c25;}const _0xcd39c2=_0x377b01['length']+(-0x1aed*0x1+0x116f*-0x2+0x3dcc);_0x2b1404=_0x48fe00(_0xab6417-_0x516fc9,_0xcd39c2,-0x1*0x643+-0x1*-0x11a5+-0xb62==_0x516fc9),_0x964746(_0xab6417/_0xcd39c2)>_0x312262-_0x3ad329&&_0x2398a4('overflow'),_0x3ad329+=_0x964746(_0xab6417/_0xcd39c2),_0xab6417%=_0xcd39c2,_0x377b01['splice'](_0xab6417++,-0xa98+0x252e+-0x1a96,_0x3ad329);}var _0x542f27;return String['fromCodePo'+'int'](..._0x377b01);},_0x55a488=function(_0x5703eb){const _0x5c5828=[];let _0x5773d2=(_0x5703eb=_0x227f09(_0x5703eb))['length'],_0x2c7440=-0x1c37*-0x1+-0x11b*0x1f+0x1*0x68e,_0x2b2f10=0x2e*-0x7c+-0x1776+0x2*0x16df,_0x1ded53=0x215e+0x12d4+-0x33ea;for(const _0x1a7c98 of _0x5703eb)_0x1a7c98<-0x493+-0x1a43+0x1f56&&_0x5c5828['push'](_0x54335f(_0x1a7c98));let _0x1d4419=_0x5c5828['length'],_0x16cf92=_0x1d4419;for(_0x1d4419&&_0x5c5828['push']('-');_0x16cf92<_0x5773d2;){let _0x9697d6=_0x312262;for(const _0x339b6d of _0x5703eb)_0x339b6d>=_0x2c7440&&_0x339b6d<_0x9697d6&&(_0x9697d6=_0x339b6d);const _0xac3d6b=_0x16cf92+(0x2702*0x1+0xce0*0x1+-0xe9*0x39);_0x9697d6-_0x2c7440>_0x964746((_0x312262-_0x2b2f10)/_0xac3d6b)&&_0x2398a4('overflow'),_0x2b2f10+=(_0x9697d6-_0x2c7440)*_0xac3d6b,_0x2c7440=_0x9697d6;for(const _0x2c948b of _0x5703eb)if(_0x2c948b<_0x2c7440&&++_0x2b2f10>_0x312262&&_0x2398a4('overflow'),_0x2c948b==_0x2c7440){let _0x59371e=_0x2b2f10;for(let _0x31e457=_0xab7fda;;_0x31e457+=_0xab7fda){const _0x59a947=_0x31e457<=_0x1ded53?-0x1215*0x1+0x27*-0x4b+0x1d83:_0x31e457>=_0x1ded53+(-0xde*0x2b+-0x6b1+0xb9*0x3d)?0xa56+0x1851+0x5*-0x6e9:_0x31e457-_0x1ded53;if(_0x59371e<_0x59a947)break;const _0x15e8eb=_0x59371e-_0x59a947,_0x290c1b=_0xab7fda-_0x59a947;_0x5c5828['push'](_0x54335f(_0x85e0e4(_0x59a947+_0x15e8eb%_0x290c1b,-0x6f1*0x5+-0x1408+0x36bd))),_0x59371e=_0x964746(_0x15e8eb/_0x290c1b);}_0x5c5828['push'](_0x54335f(_0x85e0e4(_0x59371e,0x7*0x211+-0x7b4+-0x6c3))),_0x1ded53=_0x48fe00(_0x2b2f10,_0xac3d6b,_0x16cf92==_0x1d4419),_0x2b2f10=-0x4bc*0x4+-0x1388+-0x8*-0x4cf,++_0x16cf92;}++_0x2b2f10,++_0x2c7440;}return _0x5c5828['join']('');},_0x446950=function(_0x29527f){return _0x50704c(_0x29527f,function(_0x4a252e){return _0x30511e['test'](_0x4a252e)?_0x2688f6(_0x4a252e['slice'](0x1*0x621+0x18c6+-0x1ee3)['toLowerCas'+'e']()):_0x4a252e;});},_0x2fb458=function(_0x3ce660){return _0x50704c(_0x3ce660,function(_0x909aea){return _0x34aee3['test'](_0x909aea)?'xn--'+_0x55a488(_0x909aea):_0x909aea;});},_0x873adf={'version':'2.1.0','ucs2':{'decode':_0x227f09,'encode':_0x3e268f},'decode':_0x2688f6,'encode':_0x55a488,'toASCII':_0x2fb458,'toUnicode':_0x446950};},0xf98:(_0x28e746,_0xe083)=>{'use strict';var _0x170a60=Object['prototype']['hasOwnProp'+'erty'];function _0x2ee06c(_0xc7d396){try{return decodeURIComponent(_0xc7d396['replace'](/\+/g,'\x20'));}catch(_0x23a388){return null;}}function _0x5baebe(_0x24d72a){try{return encodeURIComponent(_0x24d72a);}catch(_0x4cf86b){return null;}}_0xe083['stringify']=function(_0x9f53ed,_0x1c45e2){_0x1c45e2=_0x1c45e2||'';var _0x2beae9,_0x157d23,_0x26155e=[];for(_0x157d23 in('string'!=typeof _0x1c45e2&&(_0x1c45e2='?'),_0x9f53ed))if(_0x170a60['call'](_0x9f53ed,_0x157d23)){if((_0x2beae9=_0x9f53ed[_0x157d23])||null!=_0x2beae9&&!isNaN(_0x2beae9)||(_0x2beae9=''),_0x157d23=_0x5baebe(_0x157d23),_0x2beae9=_0x5baebe(_0x2beae9),null===_0x157d23||null===_0x2beae9)continue;_0x26155e['push'](_0x157d23+'='+_0x2beae9);}return _0x26155e['length']?_0x1c45e2+_0x26155e['join']('&'):'';},_0xe083['parse']=function(_0x5e7733){for(var _0x7bb8b7,_0x495030=/([^=?#&]+)=?([^&]*)/g,_0x5ef694={};_0x7bb8b7=_0x495030['exec'](_0x5e7733);){var _0x129b7a=_0x2ee06c(_0x7bb8b7[0x1423+0x1*0x1f3e+0x19b*-0x20]),_0x4a4e96=_0x2ee06c(_0x7bb8b7[-0xf63+-0x1*0xd55+0x1cba]);null===_0x129b7a||null===_0x4a4e96||_0x129b7a in _0x5ef694||(_0x5ef694[_0x129b7a]=_0x4a4e96);}return _0x5ef694;};},0x80f:_0x39eab3=>{'use strict';_0x39eab3['exports']=function(_0x2a8ad6,_0xa8e812){if(_0xa8e812=_0xa8e812['split'](':')[-0x13b6+0x1633+-0x1*0x27d],!(_0x2a8ad6=+_0x2a8ad6))return!(-0x1*-0xbdd+-0x2b*0x67+-0x1*-0x571);switch(_0xa8e812){case'http':case'ws':return 0x2260+-0x1a3*-0x15+-0x446f*0x1!==_0x2a8ad6;case'https':case'wss':return-0x756+-0xa80+0x1391!==_0x2a8ad6;case'ftp':return-0x15d*0x1+-0x6a7+0x819!==_0x2a8ad6;case'gopher':return 0x21c8+-0x11*-0x1a3+-0x3d55!==_0x2a8ad6;case'file':return!(-0x2bd+-0xf*-0x197+0x709*-0x3);}return-0xeab*0x2+0x2d*0x9+0x1bc1!==_0x2a8ad6;};},0xb2d:(_0x2d21eb,_0x545aa3,_0x35b361)=>{var _0x48f334=_0x35b361(0x3*-0x107+-0x1466+0x1830),_0x57ad32=_0x48f334['Buffer'];function _0x28cbd0(_0x3f7d60,_0x2525c5){for(var _0x32debc in _0x3f7d60)_0x2525c5[_0x32debc]=_0x3f7d60[_0x32debc];}function _0x1c64d1(_0x412ebe,_0xacb071,_0x3100c3){return _0x57ad32(_0x412ebe,_0xacb071,_0x3100c3);}_0x57ad32['from']&&_0x57ad32['alloc']&&_0x57ad32['allocUnsaf'+'e']&&_0x57ad32['allocUnsaf'+'eSlow']?_0x2d21eb['exports']=_0x48f334:(_0x28cbd0(_0x48f334,_0x545aa3),_0x545aa3['Buffer']=_0x1c64d1),_0x1c64d1['prototype']=Object['create'](_0x57ad32['prototype']),_0x28cbd0(_0x57ad32,_0x1c64d1),_0x1c64d1['from']=function(_0x1b3d45,_0x3e6504,_0x185b12){if('number'==typeof _0x1b3d45)throw new TypeError('Argument\x20m'+'ust\x20not\x20be'+'\x20a\x20number');return _0x57ad32(_0x1b3d45,_0x3e6504,_0x185b12);},_0x1c64d1['alloc']=function(_0x35c6da,_0x3ff8ad,_0x9686d){if('number'!=typeof _0x35c6da)throw new TypeError('Argument\x20m'+'ust\x20be\x20a\x20n'+'umber');var _0x2766f2=_0x57ad32(_0x35c6da);return void(0x904+-0x3c*0x65+0x1d5*0x8)!==_0x3ff8ad?'string'==typeof _0x9686d?_0x2766f2['fill'](_0x3ff8ad,_0x9686d):_0x2766f2['fill'](_0x3ff8ad):_0x2766f2['fill'](-0x37*0xad+-0x3*-0x887+0xb96),_0x2766f2;},_0x1c64d1['allocUnsaf'+'e']=function(_0x24eddd){if('number'!=typeof _0x24eddd)throw new TypeError('Argument\x20m'+'ust\x20be\x20a\x20n'+'umber');return _0x57ad32(_0x24eddd);},_0x1c64d1['allocUnsaf'+'eSlow']=function(_0x18550e){if('number'!=typeof _0x18550e)throw new TypeError('Argument\x20m'+'ust\x20be\x20a\x20n'+'umber');return _0x48f334['SlowBuffer'](_0x18550e);};},0x25d3:_0x500ba9=>{'use strict';var _0x902aeb=function(_0x2d591b,_0x1cb6db){_0x1cb6db=_0x1cb6db||(_0x2d591b instanceof Buffer?-0x2*-0x11eb+0x26b5+-0x4a83:-0x500+0x1e4f+-0x194e);var _0x51fb42,_0xf5e8a6,_0x18d178,_0x87de94='';for(_0xf5e8a6=-0x2246+0x4ab+0x35*0x8f,_0x18d178=_0x2d591b['length'];_0xf5e8a6<_0x18d178;_0xf5e8a6++){for(_0x51fb42=this['_get'](_0x2d591b,_0xf5e8a6)['toString'](0xb5*-0x2b+-0x479+-0x2f*-0xbe);_0x51fb42['length']<_0x1cb6db;)_0x51fb42='0'+_0x51fb42;_0x87de94+=_0x51fb42;}_0x87de94=_0x87de94['split']('')['map'](function(_0x47cced){return parseInt(_0x47cced,0x112*0xf+0x129+-0x1135);}),this['_bases']={0x2:_0x87de94};};_0x902aeb['prototype']['generate']=function(_0x3d04fa,_0xdb83af,_0x57d33d){_0xdb83af=_0xdb83af||-0x1ffc+-0xd*0x3e+0x2324;var _0x2ec17b,_0x54025e=_0x3d04fa,_0x30265c=Math['ceil'](Math['log'](_0x3d04fa)/Math['log'](_0xdb83af)),_0x26a2bd=Math['pow'](_0xdb83af,_0x30265c)-_0x3d04fa;_0xdfec4:for(;_0x54025e>=_0x3d04fa;){if(!(_0x2ec17b=this['_shift'](_0xdb83af,_0x30265c)))return _0x57d33d?_0x3d04fa:null;if((_0x54025e=this['_evaluate'](_0x2ec17b,_0xdb83af))>=_0x3d04fa){if(-0xefc+0x1135+-0x238===_0x26a2bd)continue _0xdfec4;this['_push'](_0x26a2bd,_0x54025e-_0x3d04fa),_0x54025e=this['generate'](_0x3d04fa,_0x26a2bd,!(0x1*0x411+-0xcc3+0x7*0x13e));}}return _0x54025e;},_0x902aeb['prototype']['_get']=function(_0x593fe0,_0x4f7a46){return _0x593fe0['readUInt8']?_0x593fe0['readUInt8'](_0x4f7a46):_0x593fe0[_0x4f7a46];},_0x902aeb['prototype']['_evaluate']=function(_0x145ff6,_0x453f09){for(var _0x125b70=-0x13d*-0x1f+0x13d7+0x1d1d*-0x2,_0x26b59e=_0x145ff6['length'];_0x26b59e--;)_0x125b70+=_0x145ff6[_0x26b59e]*Math['pow'](_0x453f09,_0x145ff6['length']-(_0x26b59e+(-0x25a9*-0x1+-0x20cc+-0x2*0x26e)));return _0x125b70;},_0x902aeb['prototype']['_push']=function(_0x40bc5b,_0x4c6592){this['_bases'][_0x40bc5b]=this['_bases'][_0x40bc5b]||[],this['_bases'][_0x40bc5b]['push'](_0x4c6592);},_0x902aeb['prototype']['_shift']=function(_0x3bac50,_0x5bf25a){var _0x2469d0=this['_bases'][_0x3bac50];return!_0x2469d0||_0x2469d0['length']<_0x5bf25a?null:_0x2469d0['splice'](-0x1084*0x1+-0x20*0x94+-0x1182*-0x2,_0x5bf25a);},_0x500ba9['exports']=_0x902aeb;},0xb6b:(_0x2a5011,_0x35b077,_0x445269)=>{'use strict';const _0x247701=_0x445269(0x586*0x2+-0x41f*0xa+0x3ee5),_0x299baa=_0x445269(0x1882*-0x1+-0x1a*0xd+0x1e5c),_0x51e235=_0x445269(-0x1cf4+-0x13e9*0x1+0x3576),_0x3a7e38=_0x445269(-0x1*-0x1433+0x12c5+0x14*-0x101)['i'],_0x3b0bf6=_0x445269(-0x1*-0x2702+0x1af8*-0x1+-0x187)['n'],_0x5d305a=_0x445269(-0xaac+0x2600+-0x68b)['z'],_0x3581b4=_0x445269(0x6*-0x89+-0x22ee+-0x31ca*-0x1),_0xfb42a6=_0x445269(-0xcf9+-0x1*-0x2d6+0x13c*0x12),{fromCallback:_0x40593}=_0x445269(0x6b*0x2f+0x1e76+0x43*-0xad),{getCustomInspectSymbol:_0x457826}=_0x445269(0x5*-0x5bf+-0x145c+0x15f6*0x4),_0x400fe1=/^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/,_0x327ddd=/[\x00-\x1F]/,_0x25f5aa=['\x0a','\x0d','\x00'],_0x5b058c=/[\x20-\x3A\x3C-\x7E]+/,_0x190469=/[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/,_0x114f3d={'jan':0x0,'feb':0x1,'mar':0x2,'apr':0x3,'may':0x4,'jun':0x5,'jul':0x6,'aug':0x7,'sep':0x8,'oct':0x9,'nov':0xa,'dec':0xb},_0x5714f8=0xba06dea52c+0x3*-0x9947442eb3+0x305ceede305,_0x2adea3='Invalid\x20sa'+'meSiteCont'+'ext\x20option'+'\x20for\x20getCo'+'okies();\x20e'+'xpected\x20on'+'e\x20of\x20\x22stri'+'ct\x22,\x20\x22lax\x22'+',\x20or\x20\x22none'+'\x22';function _0x231857(_0x3c7edd){_0x3581b4['validate'](_0x3581b4['isNonEmpty'+'String'](_0x3c7edd),_0x3c7edd);const _0x825039=String(_0x3c7edd)['toLowerCas'+'e']();return'none'===_0x825039||'lax'===_0x825039||'strict'===_0x825039?_0x825039:null;}const _0x5a88ad=Object['freeze']({'SILENT':'silent','STRICT':'strict','DISABLED':'unsafe-dis'+'abled'}),_0x27e173=/(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/,_0x1f005a=('\x0a\x5c[?(?:\x0a(?'+':[a-fA-F\x5cd'+']{1,4}:){7'+'}(?:[a-fA-'+'F\x5cd]{1,4}|'+':)|\x0a(?:[a-'+'fA-F\x5cd]{1,'+'4}:){6}(?:'+'(?:25[0-5]'+'|2[0-4]\x5cd|'+'1\x5cd\x5cd|[1-9'+']\x5cd|\x5cd)(?:'+'\x5c.(?:25[0-'+'5]|2[0-4]\x5c'+'d|1\x5cd\x5cd|[1'+'-9]\x5cd|\x5cd))'+'{3}|:[a-fA'+'-F\x5cd]{1,4}'+'|:)|\x0a(?:[a'+'-fA-F\x5cd]{1'+',4}:){5}(?'+'::(?:25[0-'+'5]|2[0-4]\x5c'+'d|1\x5cd\x5cd|[1'+'-9]\x5cd|\x5cd)('+'?:\x5c.(?:25['+'0-5]|2[0-4'+']\x5cd|1\x5cd\x5cd|'+'[1-9]\x5cd|\x5cd'+')){3}|(?::'+'[a-fA-F\x5cd]'+'{1,4}){1,2'+'}|:)|\x0a(?:['+'a-fA-F\x5cd]{'+'1,4}:){4}('+'?:(?::[a-f'+'A-F\x5cd]{1,4'+'}){0,1}:(?'+':25[0-5]|2'+'[0-4]\x5cd|1\x5c'+'d\x5cd|[1-9]\x5c'+'d|\x5cd)(?:\x5c.'+'(?:25[0-5]'+'|2[0-4]\x5cd|'+'1\x5cd\x5cd|[1-9'+']\x5cd|\x5cd)){3'+'}|(?::[a-f'+'A-F\x5cd]{1,4'+'}){1,3}|:)'+'|\x0a(?:[a-fA'+'-F\x5cd]{1,4}'+':){3}(?:(?'+'::[a-fA-F\x5c'+'d]{1,4}){0'+',2}:(?:25['+'0-5]|2[0-4'+']\x5cd|1\x5cd\x5cd|'+'[1-9]\x5cd|\x5cd'+')(?:\x5c.(?:2'+'5[0-5]|2[0'+'-4]\x5cd|1\x5cd\x5c'+'d|[1-9]\x5cd|'+'\x5cd)){3}|(?'+'::[a-fA-F\x5c'+'d]{1,4}){1'+',4}|:)|\x0a(?'+':[a-fA-F\x5cd'+']{1,4}:){2'+'}(?:(?::[a'+'-fA-F\x5cd]{1'+',4}){0,3}:'+'(?:25[0-5]'+'|2[0-4]\x5cd|'+'1\x5cd\x5cd|[1-9'+']\x5cd|\x5cd)(?:'+'\x5c.(?:25[0-'+'5]|2[0-4]\x5c'+'d|1\x5cd\x5cd|[1'+'-9]\x5cd|\x5cd))'+'{3}|(?::[a'+'-fA-F\x5cd]{1'+',4}){1,5}|'+':)|\x0a(?:[a-'+'fA-F\x5cd]{1,'+'4}:){1}(?:'+'(?::[a-fA-'+'F\x5cd]{1,4})'+'{0,4}:(?:2'+'5[0-5]|2[0'+'-4]\x5cd|1\x5cd\x5c'+'d|[1-9]\x5cd|'+'\x5cd)(?:\x5c.(?'+':25[0-5]|2'+'[0-4]\x5cd|1\x5c'+'d\x5cd|[1-9]\x5c'+'d|\x5cd)){3}|'+'(?::[a-fA-'+'F\x5cd]{1,4})'+'{1,6}|:)|\x0a'+'(?::(?:(?:'+(':[a-fA-F\x5cd'+']{1,4}){0,'+'5}:(?:25[0'+'-5]|2[0-4]'+'\x5cd|1\x5cd\x5cd|['+'1-9]\x5cd|\x5cd)'+'(?:\x5c.(?:25'+'[0-5]|2[0-'+'4]\x5cd|1\x5cd\x5cd'+'|[1-9]\x5cd|\x5c'+'d)){3}|(?:'+':[a-fA-F\x5cd'+']{1,4}){1,'+'7}|:))\x0a)(?'+':%[0-9a-zA'+'-Z]{1,})?\x5c'+']?\x0a'))['replace'](/\s*\/\/.*$/gm,'')['replace'](/\n/g,'')['trim'](),_0x5bdebd=new RegExp('^'+_0x1f005a+'$');function _0x59731c(_0x4a8b23,_0x373fda,_0x465f83,_0x51f818){let _0x30eefc=0x902+-0x1794+0xe92;for(;_0x30eefc<_0x4a8b23['length'];){const _0x5a4002=_0x4a8b23['charCodeAt'](_0x30eefc);if(_0x5a4002<=0x13ed+0x27d+-0x3*0x769||_0x5a4002>=-0x1b98+-0x20e+-0x3bc*-0x8)break;_0x30eefc++;}return _0x30eefc<_0x373fda||_0x30eefc>_0x465f83?null:_0x51f818||_0x30eefc==_0x4a8b23['length']?parseInt(_0x4a8b23['substr'](-0xd1d+-0x1dcc+0x2ae9,_0x30eefc),-0x19c2+-0x827*0x2+0x11*0x27a):null;}function _0xc106e9(_0x3c3f6a){const _0x7190f1=_0x3c3f6a['split'](':'),_0xcb2067=[0x297*-0xe+0x57*-0xb+0x27ff,-0x1da4+0x1284+-0x8*-0x164,-0x63*0x38+0x1f9c*0x1+0xb6*-0xe];if(-0x5d9*-0x5+-0x15ce+-0x14*0x5f!==_0x7190f1['length'])return null;for(let _0x2c5341=0x1*0x40a+0x2462+-0x286c;_0x2c5341<0x63*-0x3+0x12d*-0xd+-0x1075*-0x1;_0x2c5341++){const _0x4e2a9f=0x105+-0xf52+0x4c5*0x3==_0x2c5341,_0x154ac0=_0x59731c(_0x7190f1[_0x2c5341],-0x4f7*-0x1+0x16f1+-0x1be7,0xb06+-0x3*0x3ad+0x1*0x3,_0x4e2a9f);if(null===_0x154ac0)return null;_0xcb2067[_0x2c5341]=_0x154ac0;}return _0xcb2067;}function _0x5d2c15(_0x434f9a){_0x434f9a=String(_0x434f9a)['substr'](0x1996+-0xf08+-0xa8e,-0x350*0xb+-0x5*0x6f3+-0x2399*-0x2)['toLowerCas'+'e']();const _0xbb3f14=_0x114f3d[_0x434f9a];return _0xbb3f14>=-0x29*0x31+0x10*-0xb7+-0x1349*-0x1?_0xbb3f14:null;}function _0x419afd(_0x663c0f){if(!_0x663c0f)return;const _0x36aa18=_0x663c0f['split'](_0x190469);if(!_0x36aa18)return;let _0x190e17=null,_0x5a6c06=null,_0x596238=null,_0x2a7979=null,_0x557059=null,_0x974dac=null;for(let _0x2b87a4=-0x1*-0x1283+0x2*-0x30a+0x1*-0xc6f;_0x2b87a4<_0x36aa18['length'];_0x2b87a4++){const _0x1335f0=_0x36aa18[_0x2b87a4]['trim']();if(!_0x1335f0['length'])continue;let _0x57fe74;null===_0x596238&&(_0x57fe74=_0xc106e9(_0x1335f0),_0x57fe74)?(_0x190e17=_0x57fe74[0xe*-0x27a+0x26d5+-0x429],_0x5a6c06=_0x57fe74[-0x622*-0x3+0x1fa6+-0x320b],_0x596238=_0x57fe74[0x208*-0x10+-0x3e*0x14+0x255a]):null!==_0x2a7979||(_0x57fe74=_0x59731c(_0x1335f0,0x1a4b+-0x4*-0x6fb+0x12*-0x303,0x1afd*-0x1+0x72d+-0x2*-0x9e9,!(-0x1f*0x54+0x2b8+0x774)),null===_0x57fe74)?null!==_0x557059||(_0x57fe74=_0x5d2c15(_0x1335f0),null===_0x57fe74)?null===_0x974dac&&(_0x57fe74=_0x59731c(_0x1335f0,-0x18f4+0x250e+-0xc18,0xc19+0x133*0x1f+-0x3142,!(-0x643+-0x1*0xc77+0x95d*0x2)),null!==_0x57fe74&&(_0x974dac=_0x57fe74,_0x974dac>=0x449*0x2+0x5*-0x175+-0x103&&_0x974dac<=-0x2*0x2a6+0x2c0+-0x2ef*-0x1?_0x974dac+=0x1e92+0x1*-0xbcf+-0xb57*0x1:_0x974dac>=-0x21b9*-0x1+0x1*-0x7b+-0x73*0x4a&&_0x974dac<=0x4a3+0x1ebc+-0x231a&&(_0x974dac+=0x1c9d+-0x215*0xd+-0x191*-0x4))):_0x557059=_0x57fe74:_0x2a7979=_0x57fe74;}return null===_0x2a7979||null===_0x557059||null===_0x974dac||null===_0x596238||_0x2a7979<-0x1*0x35d+0xbc*0x18+-0xe42||_0x2a7979>0x75*0x2f+-0x99c+-0xbc0||_0x974dac<0x17*0x129+-0x149e+0x30||_0x190e17>0x2b*-0xb3+0x17*-0x6f+-0x1*-0x2821||_0x5a6c06>0x2179+-0x1947+-0x1*0x7f7||_0x596238>-0x242c*-0x1+-0xef9*0x1+0xb*-0x1e8?void(-0x29*0xc5+0x43*-0x14+-0xc43*-0x3):new Date(Date['UTC'](_0x974dac,_0x557059,_0x2a7979,_0x190e17,_0x5a6c06,_0x596238));}function _0x5c276e(_0x487db9){return _0x3581b4['validate'](_0x3581b4['isDate'](_0x487db9),_0x487db9),_0x487db9['toUTCStrin'+'g']();}function _0xb10c53(_0x410ec2){return null==_0x410ec2?null:(_0x410ec2=_0x410ec2['trim']()['replace'](/^\./,''),_0x5bdebd['test'](_0x410ec2)&&(_0x410ec2=_0x410ec2['replace']('[','')['replace'](']','')),_0x247701&&/[^\u0001-\u007f]/['test'](_0x410ec2)&&(_0x410ec2=_0x247701['toASCII'](_0x410ec2)),_0x410ec2['toLowerCas'+'e']());}function _0x2532c7(_0x6d7643,_0x103756,_0x55ba6a){if(null==_0x6d7643||null==_0x103756)return null;if(!(0x1*0x2299+-0x395+-0x1f03)!==_0x55ba6a&&(_0x6d7643=_0xb10c53(_0x6d7643),_0x103756=_0xb10c53(_0x103756)),_0x6d7643==_0x103756)return!(-0x9*0x399+0x1e30+0x231);const _0x51a1b2=_0x6d7643['lastIndexO'+'f'](_0x103756);return!(_0x51a1b2<=0x13db+-0x7*0x51a+0xfdb||_0x6d7643['length']!==_0x103756['length']+_0x51a1b2||'.'!==_0x6d7643['substr'](_0x51a1b2-(-0x5f*0x26+-0x7ff*0x1+0x161a),-0x22c7+0x4*0x743+-0x4*-0x16f)||_0x27e173['test'](_0x6d7643));}function _0x4cf497(_0x448de6){if(!_0x448de6||'/'!==_0x448de6['substr'](-0xece+0x7*-0x155+-0x1d*-0xd5,0x9*0xe5+-0x647*0x3+0xfb*0xb))return'/';if('/'===_0x448de6)return _0x448de6;const _0x104474=_0x448de6['lastIndexO'+'f']('/');return 0x60d*0x1+-0x65d*-0x5+-0x25de===_0x104474?'/':_0x448de6['slice'](0x4*-0x235+0x2*-0x20d+0x677*0x2,_0x104474);}function _0xea2f9f(_0xbde833,_0xfca15e){if(_0xfca15e&&'object'==typeof _0xfca15e||(_0xfca15e={}),_0x3581b4['isEmptyStr'+'ing'](_0xbde833)||!_0x3581b4['isString'](_0xbde833))return null;const _0x47053c=(_0xbde833=_0xbde833['trim']())['indexOf'](';'),_0x57f5d9=function(_0x30f9a9,_0x5df3c8){_0x30f9a9=function(_0x1512a2){if(_0x3581b4['isEmptyStr'+'ing'](_0x1512a2))return _0x1512a2;for(let _0x48f1ff=0x1*0x2215+0x12b6+-0x34cb;_0x48f1ff<_0x25f5aa['length'];_0x48f1ff++){const _0xa33958=_0x1512a2['indexOf'](_0x25f5aa[_0x48f1ff]);-(0x207b*0x1+0x509*0x7+-0x43b9)!==_0xa33958&&(_0x1512a2=_0x1512a2['substr'](0x19*-0x123+0x6cf*0x1+0x159c,_0xa33958));}return _0x1512a2;}(_0x30f9a9),_0x3581b4['validate'](_0x3581b4['isString'](_0x30f9a9),_0x30f9a9);let _0xc4c572,_0x4b8030,_0x45181f=_0x30f9a9['indexOf']('=');if(_0x5df3c8)0xafd*-0x1+0x26e*0xd+-0x1499===_0x45181f&&(_0x45181f=(_0x30f9a9=_0x30f9a9['substr'](-0x3cd+0x1*0x1f6+0x76*0x4))['indexOf']('='));else{if(_0x45181f<=0xc*-0x2e0+0x1189+0x10f7)return;}if(_0x45181f<=-0x1*-0xcaf+-0x22f5+0x1646?(_0xc4c572='',_0x4b8030=_0x30f9a9['trim']()):(_0xc4c572=_0x30f9a9['substr'](-0x1f*0xe9+-0xa64+-0x1*-0x269b,_0x45181f)['trim'](),_0x4b8030=_0x30f9a9['substr'](_0x45181f+(0x1*-0xda6+-0x85a+0x1601))['trim']()),_0x327ddd['test'](_0xc4c572)||_0x327ddd['test'](_0x4b8030))return;const _0x5815e6=new _0x357988();return _0x5815e6['key']=_0xc4c572,_0x5815e6['value']=_0x4b8030,_0x5815e6;}(-(0x1bdc+0x265+-0x1e40)===_0x47053c?_0xbde833:_0xbde833['substr'](-0xc2d*-0x3+0x608+0x883*-0x5,_0x47053c),!!_0xfca15e['loose']);if(!_0x57f5d9)return;if(-(0x1a38+-0x14f+-0x2*0xc74)===_0x47053c)return _0x57f5d9;const _0x4ffa6a=_0xbde833['slice'](_0x47053c+(-0x1f2a*-0x1+-0x1*-0x1a35+-0x395e))['trim']();if(-0x1*-0x1ae6+0x1185+-0x2c6b===_0x4ffa6a['length'])return _0x57f5d9;const _0x18874d=_0x4ffa6a['split'](';');for(;_0x18874d['length'];){const _0x16c097=_0x18874d['shift']()['trim']();if(-0x1450+-0x2651+-0x1*-0x3aa1===_0x16c097['length'])continue;const _0x57881d=_0x16c097['indexOf']('=');let _0xccca6c,_0x3b8b96;switch(-(-0x99a*0x1+-0x199c+0x70b*0x5)===_0x57881d?(_0xccca6c=_0x16c097,_0x3b8b96=null):(_0xccca6c=_0x16c097['substr'](0x1*0x621+-0x1*0xee3+0x8c2,_0x57881d),_0x3b8b96=_0x16c097['substr'](_0x57881d+(-0x2146+-0xc33*0x2+0x39ad))),_0xccca6c=_0xccca6c['trim']()['toLowerCas'+'e'](),_0x3b8b96&&(_0x3b8b96=_0x3b8b96['trim']()),_0xccca6c){case'expires':if(_0x3b8b96){const _0x1c5f8b=_0x419afd(_0x3b8b96);_0x1c5f8b&&(_0x57f5d9['expires']=_0x1c5f8b);}break;case'max-age':if(_0x3b8b96&&/^-?[0-9]+$/['test'](_0x3b8b96)){const _0x368b7c=parseInt(_0x3b8b96,0x1b1*-0xe+0x2e*0xa1+-0x17*0x3a);_0x57f5d9['setMaxAge'](_0x368b7c);}break;case'domain':if(_0x3b8b96){const _0x5d2760=_0x3b8b96['trim']()['replace'](/^\./,'');_0x5d2760&&(_0x57f5d9['domain']=_0x5d2760['toLowerCas'+'e']());}break;case'path':_0x57f5d9['path']=_0x3b8b96&&'/'===_0x3b8b96[-0x1e8b*0x1+0xb*-0x28c+0x3a8f]?_0x3b8b96:null;break;case'secure':_0x57f5d9['secure']=!(-0x7ff*0x1+-0x2*-0x155+0x555);break;case'httponly':_0x57f5d9['httpOnly']=!(0x367*-0x3+-0x35*0x1+0x535*0x2);break;case'samesite':switch(_0x3b8b96?_0x3b8b96['toLowerCas'+'e']():''){case'strict':_0x57f5d9['sameSite']='strict';break;case'lax':_0x57f5d9['sameSite']='lax';break;case'none':_0x57f5d9['sameSite']='none';break;default:_0x57f5d9['sameSite']=void(-0x2bd*0x2+0x1*0x98f+0x37*-0x13);}break;default:_0x57f5d9['extensions']=_0x57f5d9['extensions']||[],_0x57f5d9['extensions']['push'](_0x16c097);}}return _0x57f5d9;}function _0x87b90a(_0xff394){let _0x4df35b;try{_0x4df35b=JSON['parse'](_0xff394);}catch(_0x16abe5){return _0x16abe5;}return _0x4df35b;}function _0x1a34f1(_0x260c47){if(!_0x260c47||_0x3581b4['isEmptyStr'+'ing'](_0x260c47))return null;let _0x4384aa;if('string'==typeof _0x260c47){if(_0x4384aa=_0x87b90a(_0x260c47),_0x4384aa instanceof Error)return null;}else _0x4384aa=_0x260c47;const _0x2129c4=new _0x357988();for(let _0x2be291=0x1690+-0xc*0x94+-0x50*0x32;_0x2be291<_0x357988['serializab'+'leProperti'+'es']['length'];_0x2be291++){const _0x268010=_0x357988['serializab'+'leProperti'+'es'][_0x2be291];void(-0xc5b+0x474*0x2+0x373)!==_0x4384aa[_0x268010]&&_0x4384aa[_0x268010]!==_0x3d719b[_0x268010]&&('expires'===_0x268010||'creation'===_0x268010||'lastAccess'+'ed'===_0x268010?null===_0x4384aa[_0x268010]?_0x2129c4[_0x268010]=null:_0x2129c4[_0x268010]='Infinity'==_0x4384aa[_0x268010]?'Infinity':new Date(_0x4384aa[_0x268010]):_0x2129c4[_0x268010]=_0x4384aa[_0x268010]);}return _0x2129c4;}function _0x23371a(_0x2efd5c,_0x53d7ba){_0x3581b4['validate'](_0x3581b4['isObject'](_0x2efd5c),_0x2efd5c),_0x3581b4['validate'](_0x3581b4['isObject'](_0x53d7ba),_0x53d7ba);let _0xf141d=-0x6c1*0x2+0x10d1+-0x1*0x34f;const _0x38aa06=_0x2efd5c['path']?_0x2efd5c['path']['length']:-0x65a+0x241b+0x1dc1*-0x1;return _0xf141d=(_0x53d7ba['path']?_0x53d7ba['path']['length']:0x11*0xb9+-0xedb+0x292)-_0x38aa06,0x11bd+0x2253+-0x77*0x70!==_0xf141d||(_0xf141d=(_0x2efd5c['creation']?_0x2efd5c['creation']['getTime']():_0x5714f8)-(_0x53d7ba['creation']?_0x53d7ba['creation']['getTime']():_0x5714f8),-0x14d8+-0xeee+0x23c6!==_0xf141d||(_0xf141d=_0x2efd5c['creationIn'+'dex']-_0x53d7ba['creationIn'+'dex'])),_0xf141d;}function _0x4aa06e(_0x5af53f){if(_0x5af53f instanceof Object)return _0x5af53f;try{_0x5af53f=decodeURI(_0x5af53f);}catch(_0x2aea83){}return _0x299baa(_0x5af53f);}const _0x3d719b={'key':'','value':'','expires':'Infinity','maxAge':null,'domain':null,'path':null,'secure':!(-0x162e+-0x8dd*0x1+0x4*0x7c3),'httpOnly':!(0x1af*-0xd+-0x220a+0x2*0x1bf7),'extensions':null,'hostOnly':null,'pathIsDefault':null,'creation':null,'lastAccessed':null,'sameSite':void(0x63f+0xb*0x58+-0xa07)};class _0x357988{constructor(_0xddc7ce={}){const _0x164d0f=_0x457826();_0x164d0f&&(this[_0x164d0f]=this['inspect']),Object['assign'](this,_0x3d719b,_0xddc7ce),this['creation']=this['creation']||new Date(),Object['defineProp'+'erty'](this,'creationIn'+'dex',{'configurable':!(0xa*0x224+0x2*0x958+0x3a5*-0xb),'enumerable':!(0x1a6e+0x2293+-0x3d00),'writable':!(0x66d+0x213e+0x2a5*-0xf),'value':++_0x357988['cookiesCre'+'ated']});}['inspect'](){const _0xeae84=Date['now'](),_0x29f30a=null!=this['hostOnly']?this['hostOnly']:'?',_0x5e222f=this['creation']?_0xeae84-this['creation']['getTime']()+'ms':'?',_0x2b502e=this['lastAccess'+'ed']?_0xeae84-this['lastAccess'+'ed']['getTime']()+'ms':'?';return'Cookie=\x22'+this['toString']()+(';\x20hostOnly'+'=')+_0x29f30a+';\x20aAge='+_0x2b502e+';\x20cAge='+_0x5e222f+'\x22';}['toJSON'](){const _0x1b81aa={};for(const _0x33d0db of _0x357988['serializab'+'leProperti'+'es'])this[_0x33d0db]!==_0x3d719b[_0x33d0db]&&('expires'===_0x33d0db||'creation'===_0x33d0db||'lastAccess'+'ed'===_0x33d0db?null===this[_0x33d0db]?_0x1b81aa[_0x33d0db]=null:_0x1b81aa[_0x33d0db]='Infinity'==this[_0x33d0db]?'Infinity':this[_0x33d0db]['toISOStrin'+'g']():'maxAge'===_0x33d0db?null!==this[_0x33d0db]&&(_0x1b81aa[_0x33d0db]=this[_0x33d0db]==(-0x265*0xb+0x2*-0x617+-0x2686*-0x1)/(-0x1c38+-0x189d*-0x1+0x1*0x39b)||this[_0x33d0db]==-(-0x11ec+-0x124a+-0x7f*-0x49)/(-0x1*-0x18a2+-0x150+0x1752*-0x1)?this[_0x33d0db]['toString']():this[_0x33d0db]):this[_0x33d0db]!==_0x3d719b[_0x33d0db]&&(_0x1b81aa[_0x33d0db]=this[_0x33d0db]));return _0x1b81aa;}['clone'](){return _0x1a34f1(this['toJSON']());}['validate'](){if(!_0x400fe1['test'](this['value']))return!(0x7*-0x35f+0x35*0xb3+-0xd75);if(!(this['expires']==(-0x60e*0x2+-0x194c+0x1*0x2569)/(-0xd8a*0x2+-0x26c+-0x1d8*-0x10)||this['expires']instanceof Date||_0x419afd(this['expires'])))return!(-0x92a+0xc9f+-0x1ba*0x2);if(null!=this['maxAge']&&this['maxAge']<=-0xbe8+-0x1f96+0x2b7e)return!(0x13cb+-0x22df+0x1b*0x8f);if(null!=this['path']&&!_0x5b058c['test'](this['path']))return!(0xc*0xc5+0x95*0x5+-0xc24);const _0x4f92d8=this['cdomain']();if(_0x4f92d8){if(_0x4f92d8['match'](/\.$/))return!(-0x2593+-0x7*0x1aa+0x313a);if(null==_0x51e235['getPublicS'+'uffix'](_0x4f92d8))return!(0x224+0x47*-0x79+0x1f6c);}return!(0x3e0*0x9+-0x2583+0x2a3);}['setExpires'](_0x238f19){_0x238f19 instanceof Date?this['expires']=_0x238f19:this['expires']=_0x419afd(_0x238f19)||'Infinity';}['setMaxAge'](_0x4931fe){this['maxAge']=_0x4931fe===(-0x6e3*-0x1+0x1a2a+0xc*-0x2c1)/(-0x225e*-0x1+0x67b*0x2+-0x1a*0x1d2)||_0x4931fe===-(0x685*0x3+-0x1*-0x191f+-0x2cad)/(-0x8a5*-0x1+0x258d+-0x2e32)?_0x4931fe['toString']():_0x4931fe;}['cookieStri'+'ng'](){let _0x8c29f8=this['value'];return null==_0x8c29f8&&(_0x8c29f8=''),''===this['key']?_0x8c29f8:this['key']+'='+_0x8c29f8;}['toString'](){let _0x37409f=this['cookieStri'+'ng']();if(this['expires']!=(0xb*-0x103+-0x93*0x23+-0x1f3b*-0x1)/(0x44*0x58+-0x139*-0x6+-0x1eb6)&&(this['expires']instanceof Date?_0x37409f+=';\x20Expires='+_0x5c276e(this['expires']):_0x37409f+=';\x20Expires='+this['expires']),null!=this['maxAge']&&this['maxAge']!=(0xab7*0x2+-0x6f7+-0xe76)/(0xb43+-0x51b*-0x3+-0x1a94)&&(_0x37409f+=';\x20Max-Age='+this['maxAge']),this['domain']&&!this['hostOnly']&&(_0x37409f+=';\x20Domain='+this['domain']),this['path']&&(_0x37409f+=';\x20Path='+this['path']),this['secure']&&(_0x37409f+=';\x20Secure'),this['httpOnly']&&(_0x37409f+=';\x20HttpOnly'),this['sameSite']&&'none'!==this['sameSite']){const _0x19b813=_0x357988['sameSiteCa'+'nonical'][this['sameSite']['toLowerCas'+'e']()];_0x37409f+=';\x20SameSite'+'='+(_0x19b813||this['sameSite']);}return this['extensions']&&this['extensions']['forEach'](_0x49ac2e=>{_0x37409f+=';\x20'+_0x49ac2e;}),_0x37409f;}['TTL'](_0x20b8cf){if(null!=this['maxAge'])return this['maxAge']<=0xacd*-0x1+-0x1*-0x628+0x4a5?0x190b+0x1e94+-0x379f:(0x103b+-0x7*-0x6d+0x3*-0x51a)*this['maxAge'];let _0x2c82f4=this['expires'];return _0x2c82f4!=(-0x82e+-0x6*-0x487+0x12fb*-0x1)/(0x989*0x4+-0x3*0x5+-0x1*0x2615)?(_0x2c82f4 instanceof Date||(_0x2c82f4=_0x419afd(_0x2c82f4)||(-0xe68+0x1*0xe3+0xd86)/(0x836*0x3+-0x7d5+-0x10cd)),_0x2c82f4==(-0x2*0x2c5+0xcb+0x4c0*0x1)/(0x55c+-0x1df*0xb+-0x3*-0x513)?(-0x5f5+-0x5*0x55+0x79f)/(0x1a21+-0x857*-0x1+-0x2278):_0x2c82f4['getTime']()-(_0x20b8cf||Date['now']())):(0x1530+0x1d5f+-0x328e*0x1)/(0x2e*0x4b+-0x1bb7+-0x51*-0x2d);}['expiryTime'](_0x35e11b){if(null!=this['maxAge']){const _0x38e053=_0x35e11b||this['creation']||new Date(),_0x1a3c43=this['maxAge']<=-0x19*-0x190+0x42f+-0x2b3f?-(-0x101a+-0x1893+0x52*0x7f)/(0x2463+-0xa7d+-0x19e6):(0x259f*-0x1+0x1*0x10e1+0x18a6)*this['maxAge'];return _0x38e053['getTime']()+_0x1a3c43;}return this['expires']==(-0x175d*-0x1+-0x1764+0x1*0x8)/(0x56*-0x3+0x1f17+-0x1e15)?(-0x675*-0x3+0x6b*0x1+-0x13c9)/(0xaa6*0x3+-0x19ff+-0x5f3):this['expires']['getTime']();}['expiryDate'](_0x3bc22c){const _0x4576a0=this['expiryTime'](_0x3bc22c);return _0x4576a0==(0xc7*0xb+-0x17e5+0x1*0xf59)/(0x223*-0x11+-0x18af*-0x1+0xba4)?new Date(_0x5714f8):_0x4576a0==-(0x1c8b+0x1*-0x934+-0x1356)/(-0x1a1d+-0x1*-0x671+0x13ac)?new Date(-0x1*0x1709+0x13cb+0x33e):new Date(_0x4576a0);}['isPersiste'+'nt'](){return null!=this['maxAge']||this['expires']!=(0x97*0x16+0x9*-0x297+0xa56)/(0x1555+-0x1767+0x212);}['canonicali'+'zedDomain'](){return null==this['domain']?null:_0xb10c53(this['domain']);}['cdomain'](){return this['canonicali'+'zedDomain']();}}function _0x24e0e1(_0x10482b){if(null!=_0x10482b){const _0x4593f3=_0x10482b['toLowerCas'+'e']();switch(_0x4593f3){case _0x5a88ad['STRICT']:case _0x5a88ad['SILENT']:case _0x5a88ad['DISABLED']:return _0x4593f3;}}return _0x5a88ad['SILENT'];}_0x357988['cookiesCre'+'ated']=0x7fd*-0x3+-0x1*0x1b55+0x334c,_0x357988['parse']=_0xea2f9f,_0x357988['fromJSON']=_0x1a34f1,_0x357988['serializab'+'leProperti'+'es']=Object['keys'](_0x3d719b),_0x357988['sameSiteLe'+'vel']={'strict':0x3,'lax':0x2,'none':0x1},_0x357988['sameSiteCa'+'nonical']={'strict':'Strict','lax':'Lax'};class _0x50b2fe{constructor(_0x3a30f1,_0x23f6d3={'rejectPublicSuffixes':!(0x1*0x229d+0x1a61+0x4a*-0xd3)}){'boolean'==typeof _0x23f6d3&&(_0x23f6d3={'rejectPublicSuffixes':_0x23f6d3}),_0x3581b4['validate'](_0x3581b4['isObject'](_0x23f6d3),_0x23f6d3),this['rejectPubl'+'icSuffixes']=_0x23f6d3['rejectPubl'+'icSuffixes'],this['enableLoos'+'eMode']=!!_0x23f6d3['looseMode'],this['allowSpeci'+'alUseDomai'+'n']='boolean'!=typeof _0x23f6d3['allowSpeci'+'alUseDomai'+'n']||_0x23f6d3['allowSpeci'+'alUseDomai'+'n'],this['store']=_0x3a30f1||new _0x3b0bf6(),this['prefixSecu'+'rity']=_0x24e0e1(_0x23f6d3['prefixSecu'+'rity']),this['_cloneSync']=_0x37f64e('clone'),this['_importCoo'+'kiesSync']=_0x37f64e('_importCoo'+'kies'),this['getCookies'+'Sync']=_0x37f64e('getCookies'),this['getCookieS'+'tringSync']=_0x37f64e('getCookieS'+'tring'),this['getSetCook'+'ieStringsS'+'ync']=_0x37f64e('getSetCook'+'ieStrings'),this['removeAllC'+'ookiesSync']=_0x37f64e('removeAllC'+'ookies'),this['setCookieS'+'ync']=_0x37f64e('setCookie'),this['serializeS'+'ync']=_0x37f64e('serialize');}['setCookie'](_0x1ac2dc,_0x4c8bed,_0xd9a600,_0x15ca0d){let _0xfa782a;if(_0x3581b4['validate'](_0x3581b4['isNonEmpty'+'String'](_0x4c8bed),_0x15ca0d,_0xd9a600),_0x3581b4['isFunction'](_0x4c8bed))return(_0x15ca0d=_0x4c8bed)(new Error('No\x20URL\x20was'+'\x20specified'));const _0x3078b4=_0x4aa06e(_0x4c8bed);if(_0x3581b4['isFunction'](_0xd9a600)&&(_0x15ca0d=_0xd9a600,_0xd9a600={}),_0x3581b4['validate'](_0x3581b4['isFunction'](_0x15ca0d),_0x15ca0d),!_0x3581b4['isNonEmpty'+'String'](_0x1ac2dc)&&!_0x3581b4['isObject'](_0x1ac2dc)&&_0x1ac2dc instanceof String&&0x48d*-0x1+0x34d*-0x3+0xe74==_0x1ac2dc['length'])return _0x15ca0d(null);const _0x408176=_0xb10c53(_0x3078b4['hostname']),_0x175832=_0xd9a600['loose']||this['enableLoos'+'eMode'];let _0x1d7f7b=null;if(_0xd9a600['sameSiteCo'+'ntext']&&(_0x1d7f7b=_0x231857(_0xd9a600['sameSiteCo'+'ntext']),!_0x1d7f7b))return _0x15ca0d(new Error(_0x2adea3));if('string'==typeof _0x1ac2dc||_0x1ac2dc instanceof String){if(!(_0x1ac2dc=_0x357988['parse'](_0x1ac2dc,{'loose':_0x175832})))return _0xfa782a=new Error('Cookie\x20fai'+'led\x20to\x20par'+'se'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);}else{if(!(_0x1ac2dc instanceof _0x357988))return _0xfa782a=new Error('First\x20argu'+'ment\x20to\x20se'+'tCookie\x20mu'+'st\x20be\x20a\x20Co'+'okie\x20objec'+'t\x20or\x20strin'+'g'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);}const _0x895572=_0xd9a600['now']||new Date();if(this['rejectPubl'+'icSuffixes']&&_0x1ac2dc['domain']&&null==_0x51e235['getPublicS'+'uffix'](_0x1ac2dc['cdomain'](),{'allowSpecialUseDomain':this['allowSpeci'+'alUseDomai'+'n'],'ignoreError':_0xd9a600['ignoreErro'+'r']})&&!_0x5bdebd['test'](_0x1ac2dc['domain']))return _0xfa782a=new Error('Cookie\x20has'+'\x20domain\x20se'+'t\x20to\x20a\x20pub'+'lic\x20suffix'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);if(_0x1ac2dc['domain']){if(!_0x2532c7(_0x408176,_0x1ac2dc['cdomain'](),!(-0x39*0x6d+-0x2532*0x1+0x3d78*0x1)))return _0xfa782a=new Error('Cookie\x20not'+'\x20in\x20this\x20h'+'ost\x27s\x20doma'+'in.\x20Cookie'+':'+_0x1ac2dc['cdomain']()+'\x20Request:'+_0x408176),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);null==_0x1ac2dc['hostOnly']&&(_0x1ac2dc['hostOnly']=!(0x12e7+-0x1a29+-0x743*-0x1));}else _0x1ac2dc['hostOnly']=!(-0x4*0x99f+0xf34+0x1748),_0x1ac2dc['domain']=_0x408176;if(_0x1ac2dc['path']&&'/'===_0x1ac2dc['path'][-0x218f+0x2107+0x88]||(_0x1ac2dc['path']=_0x4cf497(_0x3078b4['pathname']),_0x1ac2dc['pathIsDefa'+'ult']=!(-0xb1f+0x1*-0x5a9+0x10c8)),!(0x1*0xe2f+-0x5*-0x769+-0x333b)===_0xd9a600['http']&&_0x1ac2dc['httpOnly'])return _0xfa782a=new Error('Cookie\x20is\x20'+'HttpOnly\x20a'+'nd\x20this\x20is'+'n\x27t\x20an\x20HTT'+'P\x20API'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);if('none'!==_0x1ac2dc['sameSite']&&void(-0x101f+-0x175f+-0xd2a*-0x3)!==_0x1ac2dc['sameSite']&&_0x1d7f7b&&'none'===_0x1d7f7b)return _0xfa782a=new Error('Cookie\x20is\x20'+'SameSite\x20b'+'ut\x20this\x20is'+'\x20a\x20cross-o'+'rigin\x20requ'+'est'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0xfa782a);const _0x3aae64=this['prefixSecu'+'rity']===_0x5a88ad['SILENT'];if(this['prefixSecu'+'rity']!==_0x5a88ad['DISABLED']){let _0x22cacb,_0x53f4e0=!(-0x3e4+0x397*0x1+0x3*0x1a);if(function(_0x20fb35){return _0x3581b4['validate'](_0x3581b4['isObject'](_0x20fb35),_0x20fb35),!_0x20fb35['key']['startsWith']('__Secure-')||_0x20fb35['secure'];}(_0x1ac2dc)?function(_0x5b2c9b){return _0x3581b4['validate'](_0x3581b4['isObject'](_0x5b2c9b)),!_0x5b2c9b['key']['startsWith']('__Host-')||_0x5b2c9b['secure']&&_0x5b2c9b['hostOnly']&&null!=_0x5b2c9b['path']&&'/'===_0x5b2c9b['path'];}(_0x1ac2dc)||(_0x53f4e0=!(-0x1*0x2532+-0xd6a+0x329c),_0x22cacb='Cookie\x20has'+'\x20__Host\x20pr'+'efix\x20but\x20e'+'ither\x20Secu'+'re\x20or\x20Host'+'Only\x20attri'+'bute\x20is\x20no'+'t\x20set\x20or\x20P'+'ath\x20is\x20not'+'\x20\x27/\x27'):(_0x53f4e0=!(-0x76d*0x2+-0xe04+0x5*0x5c6),_0x22cacb='Cookie\x20has'+'\x20__Secure\x20'+'prefix\x20but'+'\x20Secure\x20at'+'tribute\x20is'+'\x20not\x20set'),_0x53f4e0)return _0x15ca0d(_0xd9a600['ignoreErro'+'r']||_0x3aae64?null:new Error(_0x22cacb));}const _0x44445a=this['store'];_0x44445a['updateCook'+'ie']||(_0x44445a['updateCook'+'ie']=function(_0x27ee25,_0x2f5b6a,_0x3a74fc){this['putCookie'](_0x2f5b6a,_0x3a74fc);}),_0x44445a['findCookie'](_0x1ac2dc['domain'],_0x1ac2dc['path'],_0x1ac2dc['key'],function(_0x93a367,_0x2f5214){if(_0x93a367)return _0x15ca0d(_0x93a367);const _0xfd7f46=function(_0x76eefa){if(_0x76eefa)return _0x15ca0d(_0x76eefa);_0x15ca0d(null,_0x1ac2dc);};if(_0x2f5214){if(!(-0x53c+-0xe*-0x1d0+0x1423*-0x1)===_0xd9a600['http']&&_0x2f5214['httpOnly'])return _0x93a367=new Error('old\x20Cookie'+'\x20is\x20HttpOn'+'ly\x20and\x20thi'+'s\x20isn\x27t\x20an'+'\x20HTTP\x20API'),_0x15ca0d(_0xd9a600['ignoreErro'+'r']?null:_0x93a367);_0x1ac2dc['creation']=_0x2f5214['creation'],_0x1ac2dc['creationIn'+'dex']=_0x2f5214['creationIn'+'dex'],_0x1ac2dc['lastAccess'+'ed']=_0x895572,_0x44445a['updateCook'+'ie'](_0x2f5214,_0x1ac2dc,_0xfd7f46);}else _0x1ac2dc['creation']=_0x1ac2dc['lastAccess'+'ed']=_0x895572,_0x44445a['putCookie'](_0x1ac2dc,_0xfd7f46);});}['getCookies'](_0x58fcba,_0x426f32,_0x4121a3){_0x3581b4['validate'](_0x3581b4['isNonEmpty'+'String'](_0x58fcba),_0x4121a3,_0x58fcba);const _0x3fb8bb=_0x4aa06e(_0x58fcba);_0x3581b4['isFunction'](_0x426f32)&&(_0x4121a3=_0x426f32,_0x426f32={}),_0x3581b4['validate'](_0x3581b4['isObject'](_0x426f32),_0x4121a3,_0x426f32),_0x3581b4['validate'](_0x3581b4['isFunction'](_0x4121a3),_0x4121a3);const _0x1692e1=_0xb10c53(_0x3fb8bb['hostname']),_0x3febea=_0x3fb8bb['pathname']||'/';let _0x16f9d1=_0x426f32['secure'];null!=_0x16f9d1||!_0x3fb8bb['protocol']||'https:'!=_0x3fb8bb['protocol']&&'wss:'!=_0x3fb8bb['protocol']||(_0x16f9d1=!(-0x11ef+0x1e9a+-0x439*0x3));let _0x523bf5=0x229f+0x1aa*0x16+-0x473b;if(_0x426f32['sameSiteCo'+'ntext']){const _0x8f20db=_0x231857(_0x426f32['sameSiteCo'+'ntext']);if(_0x523bf5=_0x357988['sameSiteLe'+'vel'][_0x8f20db],!_0x523bf5)return _0x4121a3(new Error(_0x2adea3));}let _0x4727dc=_0x426f32['http'];null==_0x4727dc&&(_0x4727dc=!(-0x1*0x1d26+-0x22ce+-0xffd*-0x4));const _0x2ce78e=_0x426f32['now']||Date['now'](),_0x43825b=!(-0xe63+0xc2+0xda2)!==_0x426f32['expire'],_0x5496d8=!!_0x426f32['allPaths'],_0x3a049a=this['store'];function _0x480e69(_0x381c16){if(_0x381c16['hostOnly']){if(_0x381c16['domain']!=_0x1692e1)return!(-0x9af+-0x263+0xc13);}else{if(!_0x2532c7(_0x1692e1,_0x381c16['domain'],!(-0x90f+-0x1*-0x8b+0x885)))return!(-0x20ae+-0x12cb+-0xb*-0x4ae);}return!(!_0x5496d8&&!_0x5d305a(_0x3febea,_0x381c16['path']))&&(!(_0x381c16['secure']&&!_0x16f9d1)&&(!(_0x381c16['httpOnly']&&!_0x4727dc)&&(!(_0x523bf5&&_0x357988['sameSiteLe'+'vel'][_0x381c16['sameSite']||'none']>_0x523bf5)&&!(_0x43825b&&_0x381c16['expiryTime']()<=_0x2ce78e&&(_0x3a049a['removeCook'+'ie'](_0x381c16['domain'],_0x381c16['path'],_0x381c16['key'],()=>{}),0x280+-0x66b+0x3ec)))));}_0x3a049a['findCookie'+'s'](_0x1692e1,_0x5496d8?null:_0x3febea,this['allowSpeci'+'alUseDomai'+'n'],(_0x3027d4,_0x19dada)=>{if(_0x3027d4)return _0x4121a3(_0x3027d4);_0x19dada=_0x19dada['filter'](_0x480e69),!(-0x240a+-0x32*0x3a+0x2f5f)!==_0x426f32['sort']&&(_0x19dada=_0x19dada['sort'](_0x23371a));const _0x4806eb=new Date();for(const _0x5129cc of _0x19dada)_0x5129cc['lastAccess'+'ed']=_0x4806eb;_0x4121a3(null,_0x19dada);});}['getCookieS'+'tring'](..._0x2daac8){const _0x57571=_0x2daac8['pop']();_0x3581b4['validate'](_0x3581b4['isFunction'](_0x57571),_0x57571),_0x2daac8['push'](function(_0x2bcf21,_0xd00056){_0x2bcf21?_0x57571(_0x2bcf21):_0x57571(null,_0xd00056['sort'](_0x23371a)['map'](_0x1e34aa=>_0x1e34aa['cookieStri'+'ng']())['join'](';\x20'));}),this['getCookies']['apply'](this,_0x2daac8);}['getSetCook'+'ieStrings'](..._0x13385d){const _0x212242=_0x13385d['pop']();_0x3581b4['validate'](_0x3581b4['isFunction'](_0x212242),_0x212242),_0x13385d['push'](function(_0x1e293f,_0x426c8c){_0x1e293f?_0x212242(_0x1e293f):_0x212242(null,_0x426c8c['map'](_0x22a5de=>_0x22a5de['toString']()));}),this['getCookies']['apply'](this,_0x13385d);}['serialize'](_0x16d8d7){_0x3581b4['validate'](_0x3581b4['isFunction'](_0x16d8d7),_0x16d8d7);let _0x640f05=this['store']['constructo'+'r']['name'];_0x3581b4['isObject'](_0x640f05)&&(_0x640f05=null);const _0x36c678={'version':'tough-cook'+'ie@'+_0xfb42a6,'storeType':_0x640f05,'rejectPublicSuffixes':!!this['rejectPubl'+'icSuffixes'],'enableLooseMode':!!this['enableLoos'+'eMode'],'allowSpecialUseDomain':!!this['allowSpeci'+'alUseDomai'+'n'],'prefixSecurity':_0x24e0e1(this['prefixSecu'+'rity']),'cookies':[]};if(!this['store']['getAllCook'+'ies']||'function'!=typeof this['store']['getAllCook'+'ies'])return _0x16d8d7(new Error('store\x20does'+'\x20not\x20suppo'+'rt\x20getAllC'+'ookies\x20and'+'\x20cannot\x20be'+'\x20serialize'+'d'));this['store']['getAllCook'+'ies']((_0x165326,_0x42f76b)=>_0x165326?_0x16d8d7(_0x165326):(_0x36c678['cookies']=_0x42f76b['map'](_0x3eff11=>(delete(_0x3eff11=_0x3eff11 instanceof _0x357988?_0x3eff11['toJSON']():_0x3eff11)['creationIn'+'dex'],_0x3eff11)),_0x16d8d7(null,_0x36c678)));}['toJSON'](){return this['serializeS'+'ync']();}['_importCoo'+'kies'](_0x5e2bfc,_0x2b28d9){let _0xa1145a=_0x5e2bfc['cookies'];if(!_0xa1145a||!Array['isArray'](_0xa1145a))return _0x2b28d9(new Error('serialized'+'\x20jar\x20has\x20n'+'o\x20cookies\x20'+'array'));_0xa1145a=_0xa1145a['slice']();const _0x254902=_0x5a121e=>{if(_0x5a121e)return _0x2b28d9(_0x5a121e);if(!_0xa1145a['length'])return _0x2b28d9(_0x5a121e,this);let _0x31c688;try{_0x31c688=_0x1a34f1(_0xa1145a['shift']());}catch(_0x1fe69a){return _0x2b28d9(_0x1fe69a);}if(null===_0x31c688)return _0x254902(null);this['store']['putCookie'](_0x31c688,_0x254902);};_0x254902();}['clone'](_0x59459f,_0x23c580){-0x14f*-0x4+-0x1d0*-0x8+-0x13bb===arguments['length']&&(_0x23c580=_0x59459f,_0x59459f=null),this['serialize']((_0x33f872,_0x399b24)=>{if(_0x33f872)return _0x23c580(_0x33f872);_0x50b2fe['deserializ'+'e'](_0x399b24,_0x59459f,_0x23c580);});}['cloneSync'](_0x23cd4f){if(-0x24f5*0x1+0x1517*0x1+0xfde===arguments['length'])return this['_cloneSync']();if(!_0x23cd4f['synchronou'+'s'])throw new Error('CookieJar\x20'+'clone\x20dest'+'ination\x20st'+'ore\x20is\x20not'+'\x20synchrono'+'us;\x20use\x20as'+'ync\x20API\x20in'+'stead.');return this['_cloneSync'](_0x23cd4f);}['removeAllC'+'ookies'](_0x311d47){_0x3581b4['validate'](_0x3581b4['isFunction'](_0x311d47),_0x311d47);const _0x2ea864=this['store'];if('function'==typeof _0x2ea864['removeAllC'+'ookies']&&_0x2ea864['removeAllC'+'ookies']!==_0x3a7e38['prototype']['removeAllC'+'ookies'])return _0x2ea864['removeAllC'+'ookies'](_0x311d47);_0x2ea864['getAllCook'+'ies']((_0x37f5a1,_0x97d148)=>{if(_0x37f5a1)return _0x311d47(_0x37f5a1);if(-0x16*-0x110+-0x28d*0xd+0xf*0xa7===_0x97d148['length'])return _0x311d47(null);let _0xe179f1=-0x1dd2+0x422*0x1+-0x3*-0x890;const _0x1878d3=[];function _0x2ffd58(_0x79c448){if(_0x79c448&&_0x1878d3['push'](_0x79c448),_0xe179f1++,_0xe179f1===_0x97d148['length'])return _0x311d47(_0x1878d3['length']?_0x1878d3[0x874+-0x2043*0x1+0x17*0x109]:null);}_0x97d148['forEach'](_0x195cef=>{_0x2ea864['removeCook'+'ie'](_0x195cef['domain'],_0x195cef['path'],_0x195cef['key'],_0x2ffd58);});});}static['deserializ'+'e'](_0x43f495,_0x3023b6,_0x4a7cc9){let _0x597a3a;if(-0x1f66*-0x1+0x295*-0x9+0x826*-0x1!==arguments['length']&&(_0x4a7cc9=_0x3023b6,_0x3023b6=null),_0x3581b4['validate'](_0x3581b4['isFunction'](_0x4a7cc9),_0x4a7cc9),'string'==typeof _0x43f495){if(_0x597a3a=_0x87b90a(_0x43f495),_0x597a3a instanceof Error)return _0x4a7cc9(_0x597a3a);}else _0x597a3a=_0x43f495;const _0x442c84=new _0x50b2fe(_0x3023b6,{'rejectPublicSuffixes':_0x597a3a['rejectPubl'+'icSuffixes'],'looseMode':_0x597a3a['enableLoos'+'eMode'],'allowSpecialUseDomain':_0x597a3a['allowSpeci'+'alUseDomai'+'n'],'prefixSecurity':_0x597a3a['prefixSecu'+'rity']});_0x442c84['_importCoo'+'kies'](_0x597a3a,_0x3c3830=>{if(_0x3c3830)return _0x4a7cc9(_0x3c3830);_0x4a7cc9(null,_0x442c84);});}static['deserializ'+'eSync'](_0x24db4b,_0x31e5d7){const _0x480d59='string'==typeof _0x24db4b?JSON['parse'](_0x24db4b):_0x24db4b,_0x49918a=new _0x50b2fe(_0x31e5d7,{'rejectPublicSuffixes':_0x480d59['rejectPubl'+'icSuffixes'],'looseMode':_0x480d59['enableLoos'+'eMode']});if(!_0x49918a['store']['synchronou'+'s'])throw new Error('CookieJar\x20'+'store\x20is\x20n'+'ot\x20synchro'+'nous;\x20use\x20'+'async\x20API\x20'+'instead.');return _0x49918a['_importCoo'+'kiesSync'](_0x480d59),_0x49918a;}}function _0x37f64e(_0xff3525){return function(..._0x557867){if(!this['store']['synchronou'+'s'])throw new Error('CookieJar\x20'+'store\x20is\x20n'+'ot\x20synchro'+'nous;\x20use\x20'+'async\x20API\x20'+'instead.');let _0x2e70f7,_0x171578;if(this[_0xff3525](..._0x557867,(_0x4468b0,_0x5f2720)=>{_0x2e70f7=_0x4468b0,_0x171578=_0x5f2720;}),_0x2e70f7)throw _0x2e70f7;return _0x171578;};}_0x50b2fe['fromJSON']=_0x50b2fe['deserializ'+'eSync'],['_importCoo'+'kies','clone','getCookies','getCookieS'+'tring','getSetCook'+'ieStrings','removeAllC'+'ookies','serialize','setCookie']['forEach'](_0x27cfe0=>{_0x50b2fe['prototype'][_0x27cfe0]=_0x40593(_0x50b2fe['prototype'][_0x27cfe0]);}),_0x50b2fe['deserializ'+'e']=_0x40593(_0x50b2fe['deserializ'+'e']),_0x35b077['version']=_0xfb42a6,_0x35b077['CookieJar']=_0x50b2fe,_0x35b077['Cookie']=_0x357988,_0x35b077['Store']=_0x3a7e38,_0x35b077['MemoryCook'+'ieStore']=_0x3b0bf6,_0x35b077['parseDate']=_0x419afd,_0x35b077['formatDate']=_0x5c276e,_0x35b077['parse']=_0xea2f9f,_0x35b077['fromJSON']=_0x1a34f1,_0x35b077['domainMatc'+'h']=_0x2532c7,_0x35b077['defaultPat'+'h']=_0x4cf497,_0x35b077['pathMatch']=_0x5d305a,_0x35b077['getPublicS'+'uffix']=_0x51e235['getPublicS'+'uffix'],_0x35b077['cookieComp'+'are']=_0x23371a,_0x35b077['permuteDom'+'ain']=_0x445269(0x175c+-0x12b*0x27+0x34a0)['permuteDom'+'ain'],_0x35b077['permutePat'+'h']=function(_0xcbba46){if(_0x3581b4['validate'](_0x3581b4['isString'](_0xcbba46)),'/'===_0xcbba46)return['/'];const _0x2a7311=[_0xcbba46];for(;_0xcbba46['length']>-0x165c+-0x1c9a+0x32f7;){const _0x205005=_0xcbba46['lastIndexO'+'f']('/');if(-0x5a7+0xe81+-0x8da===_0x205005)break;_0xcbba46=_0xcbba46['substr'](-0x3*0x917+0x7f5*0x2+0x1*0xb5b,_0x205005),_0x2a7311['push'](_0xcbba46);}return _0x2a7311['push']('/'),_0x2a7311;},_0x35b077['canonicalD'+'omain']=_0xb10c53,_0x35b077['PrefixSecu'+'rityEnum']=_0x5a88ad,_0x35b077['ParameterE'+'rror']=_0x3581b4['ParameterE'+'rror'];},0xa83:(_0x1c6022,_0x1b1f83,_0x5edb07)=>{'use strict';const {fromCallback:_0x13d57e}=_0x5edb07(0x291*0x2+-0x1eed+-0x75*-0x43),_0x19a87e=_0x5edb07(0xdc9*-0x1+-0x741+0x27ee)['i'],_0xb7e3b7=_0x5edb07(-0x649*0x5+-0x297a*0x1+0x6756)['permuteDom'+'ain'],_0x96e31a=_0x5edb07(-0xe91+0xc6f+0x16eb)['z'],{getCustomInspectSymbol:_0xd166aa,getUtilInspect:_0x3ce4c5}=_0x5edb07(-0x1*-0xbcf+-0x43*-0xd2+-0x1c04);class _0x5414f6 extends _0x19a87e{constructor(){super(),this['synchronou'+'s']=!(0x4*0x2f9+0xb*-0x1cf+0x3*0x2ab),this['idx']=Object['create'](null);const _0x1a7529=_0xd166aa();_0x1a7529&&(this[_0x1a7529]=this['inspect']);}['inspect'](){return'{\x20idx:\x20'+_0x3ce4c5(_0x5bd01d)(this['idx'],!(0x253d+0x1026+-0x2*0x1ab1),0x513+-0x1c*-0xb2+-0x1889)+'\x20}';}['findCookie'](_0x49c67f,_0x545073,_0xa637c2,_0x30e7f9){return this['idx'][_0x49c67f]&&this['idx'][_0x49c67f][_0x545073]?_0x30e7f9(null,this['idx'][_0x49c67f][_0x545073][_0xa637c2]||null):_0x30e7f9(null,void(-0x3*0x9ad+-0x3bd+0x20c4*0x1));}['findCookie'+'s'](_0x286346,_0x3bbbc5,_0x500102,_0x3b705c){const _0x43d0ad=[];if('function'==typeof _0x500102&&(_0x3b705c=_0x500102,_0x500102=!(-0xcd3*0x1+-0xe*-0x55+0x82d*0x1)),!_0x286346)return _0x3b705c(null,[]);let _0x4b78d3;_0x4b78d3=_0x3bbbc5?function(_0x41ef8d){Object['keys'](_0x41ef8d)['forEach'](_0x348780=>{if(_0x96e31a(_0x3bbbc5,_0x348780)){const _0xf1979a=_0x41ef8d[_0x348780];for(const _0x3229e6 in _0xf1979a)_0x43d0ad['push'](_0xf1979a[_0x3229e6]);}});}:function(_0x3bb31e){for(const _0x653fc0 in _0x3bb31e){const _0x558118=_0x3bb31e[_0x653fc0];for(const _0x2df82c in _0x558118)_0x43d0ad['push'](_0x558118[_0x2df82c]);}};const _0x4ffa09=_0xb7e3b7(_0x286346,_0x500102)||[_0x286346],_0xdc15d0=this['idx'];_0x4ffa09['forEach'](_0x378a0a=>{const _0x3df890=_0xdc15d0[_0x378a0a];_0x3df890&&_0x4b78d3(_0x3df890);}),_0x3b705c(null,_0x43d0ad);}['putCookie'](_0x68249d,_0x31160e){this['idx'][_0x68249d['domain']]||(this['idx'][_0x68249d['domain']]=Object['create'](null)),this['idx'][_0x68249d['domain']][_0x68249d['path']]||(this['idx'][_0x68249d['domain']][_0x68249d['path']]=Object['create'](null)),this['idx'][_0x68249d['domain']][_0x68249d['path']][_0x68249d['key']]=_0x68249d,_0x31160e(null);}['updateCook'+'ie'](_0x313934,_0x2bf0ea,_0x2b1a98){this['putCookie'](_0x2bf0ea,_0x2b1a98);}['removeCook'+'ie'](_0x29e37f,_0x534fa7,_0x5ea8bc,_0x25d812){this['idx'][_0x29e37f]&&this['idx'][_0x29e37f][_0x534fa7]&&this['idx'][_0x29e37f][_0x534fa7][_0x5ea8bc]&&delete this['idx'][_0x29e37f][_0x534fa7][_0x5ea8bc],_0x25d812(null);}['removeCook'+'ies'](_0x3313ae,_0x5b706e,_0x9e5cb){return this['idx'][_0x3313ae]&&(_0x5b706e?delete this['idx'][_0x3313ae][_0x5b706e]:delete this['idx'][_0x3313ae]),_0x9e5cb(null);}['removeAllC'+'ookies'](_0x5f32fa){return this['idx']=Object['create'](null),_0x5f32fa(null);}['getAllCook'+'ies'](_0x2bee9d){const _0xdf2944=[],_0x290477=this['idx'];Object['keys'](_0x290477)['forEach'](_0x39746e=>{Object['keys'](_0x290477[_0x39746e])['forEach'](_0x5d101=>{Object['keys'](_0x290477[_0x39746e][_0x5d101])['forEach'](_0x186ad9=>{null!==_0x186ad9&&_0xdf2944['push'](_0x290477[_0x39746e][_0x5d101][_0x186ad9]);});});}),_0xdf2944['sort']((_0x3aa734,_0x8c9e08)=>(_0x3aa734['creationIn'+'dex']||-0x1a3d+0xf*-0x1ca+0x3513)-(_0x8c9e08['creationIn'+'dex']||-0x10fe*-0x2+-0x16*0x12+-0x2070)),_0x2bee9d(null,_0xdf2944);}}function _0x5bd01d(_0x4267d9){const _0x3f0cf4=Object['keys'](_0x4267d9);if(-0x17d6+0x1b16+0x68*-0x8===_0x3f0cf4['length'])return'[Object:\x20n'+'ull\x20protot'+'ype]\x20{}';let _0x379b7a='[Object:\x20n'+'ull\x20protot'+'ype]\x20{\x0a';return Object['keys'](_0x4267d9)['forEach']((_0x553e3d,_0x4084ee)=>{_0x379b7a+=function(_0x394f5a,_0x18e0b6){let _0x15f379='\x20\x20\x27'+_0x394f5a+('\x27:\x20[Object'+':\x20null\x20pro'+'totype]\x20{\x0a');return Object['keys'](_0x18e0b6)['forEach']((_0x53ea00,_0x2f034d,_0x568689)=>{_0x15f379+=function(_0x4e1b68,_0x3ff617){const _0x28f44c='\x20\x20\x20\x20';let _0x335414=_0x28f44c+'\x27'+_0x4e1b68+('\x27:\x20[Object'+':\x20null\x20pro'+'totype]\x20{\x0a');return Object['keys'](_0x3ff617)['forEach']((_0x37cf2a,_0x324e13,_0xf0f112)=>{const _0x8229f8=_0x3ff617[_0x37cf2a];_0x335414+='\x20\x20\x20\x20\x20\x20'+_0x37cf2a+':\x20'+_0x8229f8['inspect'](),_0x324e13<_0xf0f112['length']-(0x3*0x50d+0xc*-0x4e+0x2*-0x5bf)&&(_0x335414+=','),_0x335414+='\x0a';}),_0x335414+=_0x28f44c+'}',_0x335414;}(_0x53ea00,_0x18e0b6[_0x53ea00]),_0x2f034d<_0x568689['length']-(0x1d27+0x191e+0x17*-0x25c)&&(_0x15f379+=','),_0x15f379+='\x0a';}),_0x15f379+='\x20\x20}',_0x15f379;}(_0x553e3d,_0x4267d9[_0x553e3d]),_0x4084ee<_0x3f0cf4['length']-(0x158f*-0x1+0x25*0x1d+0x115f*0x1)&&(_0x379b7a+=','),_0x379b7a+='\x0a';}),_0x379b7a+='}',_0x379b7a;}['findCookie','findCookie'+'s','putCookie','updateCook'+'ie','removeCook'+'ie','removeCook'+'ies','removeAllC'+'ookies','getAllCook'+'ies']['forEach'](_0x2a38ba=>{_0x5414f6['prototype'][_0x2a38ba]=_0x13d57e(_0x5414f6['prototype'][_0x2a38ba]);}),_0x1b1f83['n']=_0x5414f6;},0x14c9:(_0x2a3648,_0x3b2ccf)=>{'use strict';_0x3b2ccf['z']=function(_0x2d88b0,_0x3be5ac){if(_0x3be5ac===_0x2d88b0)return!(-0x1db6+0x2341+-0x58b);if(-0x2341+-0x1*0x1da7+0x40e8===_0x2d88b0['indexOf'](_0x3be5ac)){if('/'===_0x3be5ac['substr'](-(0x2455+-0x1879+-0x5*0x25f)))return!(-0x6de*-0x2+0xdd5+0x1b91*-0x1);if('/'===_0x2d88b0['substr'](_0x3be5ac['length'],-0x25c2+-0x1c21+0x41e4))return!(-0x81f+-0x268b+-0x6*-0x7c7);}return!(-0x1c33*0x1+-0x1014+0x2c48);};},0x1e6f:(_0x316f46,_0x1602d8,_0x4fe109)=>{'use strict';const _0x231092=_0x4fe109(0x1cc6+-0x23cf+0xba2);_0x1602d8['permuteDom'+'ain']=function(_0x2aed3d,_0x27eb82){const _0x2fd959=_0x231092['getPublicS'+'uffix'](_0x2aed3d,{'allowSpecialUseDomain':_0x27eb82});if(!_0x2fd959)return null;if(_0x2fd959==_0x2aed3d)return[_0x2aed3d];'.'==_0x2aed3d['slice'](-(0x223f+-0x1282+-0x4c*0x35))&&(_0x2aed3d=_0x2aed3d['slice'](-0xe*0x233+-0x24fe*-0x1+0x634*-0x1,-(0x67*0x3+0xd3*-0x1b+0x150d)));const _0x4251b7=_0x2aed3d['slice'](-0x581*-0x2+-0x11f9+0x6f7,-(_0x2fd959['length']+(0x2*0x10ff+-0x1846+-0x9b7)))['split']('.')['reverse']();let _0x3ef2ae=_0x2fd959;const _0x54d21c=[_0x3ef2ae];for(;_0x4251b7['length'];)_0x3ef2ae=_0x4251b7['shift']()+'.'+_0x3ef2ae,_0x54d21c['push'](_0x3ef2ae);return _0x54d21c;};},0x499:(_0x3dd4c3,_0xf17c1e,_0x48b729)=>{'use strict';const _0x412ce1=_0x48b729(0xe*-0xe9+-0x1*-0x61f+0xe87),_0x2910ca=['local','example','invalid','localhost','test'],_0x101291=['localhost','invalid'];_0xf17c1e['getPublicS'+'uffix']=function(_0x9b5249,_0x3f5b6d={}){const _0x5a1bc7=_0x9b5249['split']('.'),_0x549a08=_0x5a1bc7[_0x5a1bc7['length']-(-0x2708*-0x1+-0x1f2e+0x1*-0x7d9)],_0x7d689d=!!_0x3f5b6d['allowSpeci'+'alUseDomai'+'n'],_0x32b5a2=!!_0x3f5b6d['ignoreErro'+'r'];if(_0x7d689d&&_0x2910ca['includes'](_0x549a08)){if(_0x5a1bc7['length']>0x26d1+-0x1*0xae5+-0x3fd*0x7)return _0x5a1bc7[_0x5a1bc7['length']-(0x14e4+0x10f1*-0x1+-0x3f1)]+'.'+_0x549a08;if(_0x101291['includes'](_0x549a08))return''+_0x549a08;}if(!_0x32b5a2&&_0x2910ca['includes'](_0x549a08))throw new Error('Cookie\x20has'+'\x20domain\x20se'+'t\x20to\x20the\x20p'+'ublic\x20suff'+'ix\x20\x22'+_0x549a08+('\x22\x20which\x20is'+'\x20a\x20special'+'\x20use\x20domai'+'n.\x20To\x20allo'+'w\x20this,\x20co'+'nfigure\x20yo'+'ur\x20CookieJ'+'ar\x20with\x20{a'+'llowSpecia'+'lUseDomain'+':true,\x20rej'+'ectPublicS'+'uffixes:\x20f'+'alse}.'));return _0x412ce1['get'](_0x9b5249);};},0x12e4:(_0x11d5d4,_0x3b1947)=>{'use strict';_0x3b1947['i']=class{constructor(){this['synchronou'+'s']=!(-0x8f*-0x1d+0x15+-0x1047);}['findCookie'](_0x231f50,_0x59f55c,_0x1d7db0,_0x15d276){throw new Error('findCookie'+'\x20is\x20not\x20im'+'plemented');}['findCookie'+'s'](_0x2dcd24,_0x498b69,_0x252317,_0x3163df){throw new Error('findCookie'+'s\x20is\x20not\x20i'+'mplemented');}['putCookie'](_0x353de5,_0x4bd459){throw new Error('putCookie\x20'+'is\x20not\x20imp'+'lemented');}['updateCook'+'ie'](_0x43222f,_0x4adfb1,_0x22c84f){throw new Error('updateCook'+'ie\x20is\x20not\x20'+'implemente'+'d');}['removeCook'+'ie'](_0x5cc730,_0x5b7752,_0x5f333a,_0x5d90f6){throw new Error('removeCook'+'ie\x20is\x20not\x20'+'implemente'+'d');}['removeCook'+'ies'](_0x195ee2,_0x5cae59,_0x1a5a0a){throw new Error('removeCook'+'ies\x20is\x20not'+'\x20implement'+'ed');}['removeAllC'+'ookies'](_0x1c5222){throw new Error('removeAllC'+'ookies\x20is\x20'+'not\x20implem'+'ented');}['getAllCook'+'ies'](_0x3c3287){throw new Error('getAllCook'+'ies\x20is\x20not'+'\x20implement'+'ed\x20(theref'+'ore\x20jar\x20ca'+'nnot\x20be\x20se'+'rialized)');}};},0x26c1:(_0x5fd032,_0x4c2aa2,_0x4beb19)=>{function _0x443be1(){try{return _0x4beb19(-0xb*-0x619+-0x3b3+-0x1c21*0x1);}catch(_0x3d3e12){return null;}}function _0x1c87ec(){return Symbol['for']('nodejs.uti'+'l.inspect.'+'custom');}_0x4c2aa2['getUtilIns'+'pect']=function(_0x5aaee3,_0x41675f={}){const _0x3188f4=(_0x41675f['requireUti'+'l']||_0x443be1)();return function(_0x55c5c6,_0x52abb8,_0x4cfd08){return _0x3188f4?_0x3188f4['inspect'](_0x55c5c6,_0x52abb8,_0x4cfd08):_0x5aaee3(_0x55c5c6);};},_0x4c2aa2['getCustomI'+'nspectSymb'+'ol']=function(_0x12b28e={}){return(_0x12b28e['lookupCust'+'omInspectS'+'ymbol']||_0x1c87ec)()||function(_0x42e091){const _0x5985ec=(_0x42e091['requireUti'+'l']||_0x443be1)();return _0x5985ec?_0x5985ec['inspect']['custom']:null;}(_0x12b28e);};},0xba6:(_0x18bfdb,_0xffeba4)=>{'use strict';function _0x138df7(_0x13586c){return'function'==typeof _0x13586c;}function _0x5105c8(_0x515169){return'string'==typeof _0x515169||_0x515169 instanceof String;}function _0xc7310d(_0xbe1024){return'[object\x20Ob'+'ject]'===toString['call'](_0xbe1024);}class _0x449dd7 extends Error{constructor(..._0x451a18){super(..._0x451a18);}}_0xffeba4['ParameterE'+'rror']=_0x449dd7,_0xffeba4['isFunction']=_0x138df7,_0xffeba4['isNonEmpty'+'String']=function(_0x101899){return _0x5105c8(_0x101899)&&''!==_0x101899;},_0xffeba4['isDate']=function(_0x61180e){return function(_0x5a7a26,_0x2cfe44){try{return _0x5a7a26 instanceof _0x2cfe44;}catch(_0x55f72c){return!(0x317+-0x1a2c+-0x1e*-0xc5);}}(_0x61180e,Date)&&function(_0x42982f){return'number'==typeof _0x42982f&&_0x42982f%(-0xc60+-0x2172+-0x1*-0x2dd3)==-0x16c6+-0x117a+0x2840;}(_0x61180e['getTime']());},_0xffeba4['isEmptyStr'+'ing']=function(_0x147917){return''===_0x147917||_0x147917 instanceof String&&''===_0x147917['toString']();},_0xffeba4['isString']=_0x5105c8,_0xffeba4['isObject']=_0xc7310d,_0xffeba4['validate']=function(_0x5171aa,_0x2d081c,_0x11af37){if(_0x138df7(_0x2d081c)||(_0x11af37=_0x2d081c,_0x2d081c=null),_0xc7310d(_0x11af37)||(_0x11af37={'Error':'Failed\x20Che'+'ck'}),!_0x5171aa){if(!_0x2d081c)throw new _0x449dd7(_0x11af37);_0x2d081c(new _0x449dd7(_0x11af37));}};},0xc15:_0x430664=>{_0x430664['exports']='4.1.3';},0x2708:function(_0x3693ea,_0x16e3ac,_0x4853a4){'use strict';var _0x173927,_0x3b600c,_0x2c2045,_0x33885a=this&&this['__createBi'+'nding']||(Object['create']?function(_0x11185b,_0x30cfe5,_0x30c236,_0x5641b2){void(-0x23ef+-0x5d*0x2+0x24a9)===_0x5641b2&&(_0x5641b2=_0x30c236);var _0x318d11=Object['getOwnProp'+'ertyDescri'+'ptor'](_0x30cfe5,_0x30c236);_0x318d11&&!('get'in _0x318d11?!_0x30cfe5['__esModule']:_0x318d11['writable']||_0x318d11['configurab'+'le'])||(_0x318d11={'enumerable':!(-0x479*-0x1+0x1448+-0x18c1),'get':function(){return _0x30cfe5[_0x30c236];}}),Object['defineProp'+'erty'](_0x11185b,_0x5641b2,_0x318d11);}:function(_0x4cf57b,_0x1a3f16,_0x3ee4a7,_0x281bfe){void(0x19*0x4c+-0x107*-0x18+0x1*-0x2014)===_0x281bfe&&(_0x281bfe=_0x3ee4a7),_0x4cf57b[_0x281bfe]=_0x1a3f16[_0x3ee4a7];}),_0x20bf34=this&&this['__setModul'+'eDefault']||(Object['create']?function(_0x5f5c51,_0x16396b){Object['defineProp'+'erty'](_0x5f5c51,'default',{'enumerable':!(-0x1*-0x20cf+0x4b1+-0x4b0*0x8),'value':_0x16396b});}:function(_0x2f8289,_0x2765e0){_0x2f8289['default']=_0x2765e0;}),_0x1f1201=this&&this['__importSt'+'ar']||function(_0x36e42b){if(_0x36e42b&&_0x36e42b['__esModule'])return _0x36e42b;var _0x333d86={};if(null!=_0x36e42b){for(var _0xa24a17 in _0x36e42b)'default'!==_0xa24a17&&Object['prototype']['hasOwnProp'+'erty']['call'](_0x36e42b,_0xa24a17)&&_0x33885a(_0x333d86,_0x36e42b,_0xa24a17);}return _0x20bf34(_0x333d86,_0x36e42b),_0x333d86;},_0x47b476=this&&this['__awaiter']||function(_0x4659aa,_0x42481b,_0x352017,_0x9be5ef){return new(_0x352017||(_0x352017=Promise))(function(_0x3cb238,_0x101740){function _0x456359(_0x538f6d){try{_0x191d2a(_0x9be5ef['next'](_0x538f6d));}catch(_0x53b8a5){_0x101740(_0x53b8a5);}}function _0x4d985d(_0x48c48f){try{_0x191d2a(_0x9be5ef['throw'](_0x48c48f));}catch(_0xae3f81){_0x101740(_0xae3f81);}}function _0x191d2a(_0x44b7a5){var _0x5e4e13;_0x44b7a5['done']?_0x3cb238(_0x44b7a5['value']):(_0x5e4e13=_0x44b7a5['value'],_0x5e4e13 instanceof _0x352017?_0x5e4e13:new _0x352017(function(_0x1f4c90){_0x1f4c90(_0x5e4e13);}))['then'](_0x456359,_0x4d985d);}_0x191d2a((_0x9be5ef=_0x9be5ef['apply'](_0x4659aa,_0x42481b||[]))['next']());});};Object['defineProp'+'erty'](_0x16e3ac,'__esModule',{'value':!(0x1429+0x447+-0x5c*0x44)}),_0x16e3ac['MatlabConn'+'ection']=_0x16e3ac['LifecycleE'+'ventType']=void(-0x51*-0x2e+-0x145+-0x1*0xd49);const _0x17f2f3=_0x4853a4(-0x3c*0x95+-0x16f0+0x4ea1),_0x2b738a=_0x4853a4(0x18dd*-0x1+0x11c2*0x3+-0x123),_0x821af8=_0x1f1201(_0x4853a4(-0x2*-0x313+0x1*-0xbf6+0x4de*0x3)),_0x39f71a=_0x1f1201(_0x4853a4(-0x1832+0x639*-0x6+-0x5*-0xdd3)),_0x430546=_0x1f1201(_0x4853a4(0xd3a+-0x1eef+0x150e)),_0x3949ac=_0x1f1201(_0x4853a4(0x5*-0x6ce+-0x4*0x7d4+0x5c66)),_0xb3b7eb=_0x4853a4(0x1b*-0x2+-0x257*0xd+-0x8*-0x51b);var _0x1e7e49;!function(_0x5e5cbf){_0x5e5cbf[_0x5e5cbf['CONNECTED']=-0xe72+0x7f*0x1+0xdf3]='CONNECTED',_0x5e5cbf[_0x5e5cbf['DISCONNECT'+'ED']=-0x23b+-0x3a*0xa7+0x2812*0x1]='DISCONNECT'+'ED';}(_0x1e7e49=_0x16e3ac['LifecycleE'+'ventType']||(_0x16e3ac['LifecycleE'+'ventType']={}));const _0xd9749=null!==(_0x173927=process['env']['HTTP_PROXY'])&&void(-0x1127+-0x158e+0x26b5)!==_0x173927?_0x173927:process['env']['http_proxy'],_0x3163d8=null!==(_0x3b600c=process['env']['HTTPS_PROX'+'Y'])&&void(-0x55*-0x11+-0x4*0x8b7+0x1d37)!==_0x3b600c?_0x3b600c:process['env']['https_prox'+'y'],_0x352569=null!==(_0x2c2045=process['env']['NO_PROXY'])&&void(0x3*-0x123+0xd54+-0x9eb)!==_0x2c2045?_0x2c2045:process['env']['no_proxy'];delete process['env']['HTTP_PROXY'],delete process['env']['http_proxy'],delete process['env']['HTTPS_PROX'+'Y'],delete process['env']['https_prox'+'y'],delete process['env']['NO_PROXY'],delete process['env']['no_proxy'];class _0x327292{constructor(){this['_lifecycle'+'Callback']=null,this['_channelId'+'Ct']=0x14c*0x1d+-0x743+0x1c9*-0x11;}['close'](){var _0x4b1772;null===(_0x4b1772=this['_client'])||void(-0x2159*-0x1+0x1*0x143b+-0xc*0x477)===_0x4b1772||_0x4b1772['disconnect'](),this['_lifecycle'+'Callback']=null;}['getChannel'+'Id'](){return(this['_channelId'+'Ct']++)['toString']();}['publish'](_0x377513,_0x1b335b){this['_client']['publish'](this['_prependCh'+'annel'](_0x377513),_0x1b335b);}['subscribe'](_0x4b3d81,_0x200c61){return this['_client']['subscribe'](this['_prependCh'+'annel'](_0x4b3d81),_0x200c61);}['unsubscrib'+'e'](_0x170908){_0x170908['cancel']();}['setLifecyc'+'leListener'](_0x5a2b93){this['_lifecycle'+'Callback']=_0x5a2b93;}['onConnecti'+'onSuccess'](){var _0x2f2cfd;null===(_0x2f2cfd=this['_lifecycle'+'Callback'])||void(0x8d+0x10d1+-0x115e)===_0x2f2cfd||_0x2f2cfd['call'](this,_0x1e7e49['CONNECTED']);}['onConnecti'+'onFailure'](){var _0x518bb7;null===(_0x518bb7=this['_lifecycle'+'Callback'])||void(-0x2569+0xd8+0x2491*0x1)===_0x518bb7||_0x518bb7['call'](this,_0x1e7e49['DISCONNECT'+'ED']);}['setupConne'+'ctionCallb'+'acks'](){this['_client']['on']('transport:'+'up',this['onConnecti'+'onSuccess']['bind'](this)),this['_client']['on']('transport:'+'down',this['onConnecti'+'onFailure']['bind'](this));}['_prependCh'+'annel'](_0x19b84b){return'/matlab'+_0x19b84b;}}_0x16e3ac['MatlabConn'+'ection']=_0x327292;class _0x301d0d extends _0x327292{constructor(_0x2cb23d){super(),this['_apiKey']=_0x2cb23d;}['initialize'](_0x208dcb,_0x576d6c){return _0x47b476(this,void(-0x1*-0xc11+-0x85e+-0x3b3),void(0xa6+-0x788+0x6e2),function*(){const _0x5872f9=yield _0x39f71a['readFile'](_0x576d6c);_0x821af8['setDefault'+'ResultOrde'+'r']('ipv4first');const _0xe1097b='https://lo'+'calhost:'+_0x208dcb+('/messagese'+'rvice/asyn'+'c');this['_client']=new _0xb3b7eb['Client'](_0xe1097b,{'tls':{'ca':_0x5872f9}}),this['_client']['setHeader']('mwapikey',this['_apiKey']),this['setupConne'+'ctionCallb'+'acks']();});}}class _0x3e155e extends _0x327292{constructor(_0x1c9ce8){super(),this['_url']=_0x1c9ce8;}['initialize'](){return _0x47b476(this,void(-0x25dd+0x3*-0x2dc+0x2e71),void(0xdb7+0x1*0x49+0x1*-0xe00),function*(){this['_client']=new _0xb3b7eb['Client'](this['_url']),this['setupConne'+'ctionCallb'+'acks'](),this['publish']('matlabls/c'+'onnection/'+'startup',{});});}}_0x16e3ac['default']=new class{['launchNewM'+'atlab'](_0x38e2da,_0x218ae1,_0x14a55d,_0x4c3cbd={}){const _0x2c1bdd=(function(){const _0x192f6f='abcdefghij'+'klmnopqrst'+'uvwxyzABCD'+'EFGHIJKLMN'+'OPQRSTUVWX'+'YZ01234567'+'89-._~';let _0x2716fc='';for(let _0x43d673=0x5e9*0x3+-0x2*-0x42d+0x1*-0x1a15;_0x43d673<0x22d*0x3+0x847*-0x1+0x10*0x5c;_0x43d673++)_0x2716fc+=_0x192f6f['charAt']((-0x1b58+-0x2*0x80f+0x2b76,_0x2b738a['randomInt'])(-0x2126+-0x3d*-0x25+0x1897));return _0x2716fc;}());let _0x4624e5;try{const _0x114600=Object['assign'](Object['assign'](Object['assign']({},process['env']),_0x4c3cbd),{'MATLAB_LOG_DIR':_0x14a55d,'MWAPIKEY':_0x2c1bdd});null==_0xd9749&&null==_0x3163d8&&null==_0x352569||(_0x114600['HTTP_PROXY']=_0xd9749,_0x114600['HTTPS_PROX'+'Y']=_0x3163d8,_0x114600['NO_PROXY']=_0x352569);let _0x442770=process['env']['HOME'];if('darwin'===_0x430546['platform']()&&'arm64'===_0x430546['arch']()&&'matlab'!==_0x38e2da){const _0x4e9e2b=_0x38e2da['split'](_0x3949ac['sep']);_0x442770=_0x4e9e2b['slice'](-0x24c7+0xe*0x288+0x157,_0x4e9e2b['length']-(0x87*0xb+-0x24c7+0x1efc))['join'](_0x3949ac['sep']);}_0x4624e5=(0x397*0x1+-0x19f0+0x1659,_0x17f2f3['spawn'])(_0x38e2da,_0x218ae1,{'cwd':_0x442770,'env':_0x114600});}catch(_0x4b4ffd){return null;}return{'matlabProcess':_0x4624e5,'matlabConnection':new _0x301d0d(_0x2c1bdd)};}['connectToE'+'xistingMat'+'lab'](_0x5a6a2f){return _0x47b476(this,void(-0x5*-0x3cb+-0x18d8+-0x5*-0x12d),void(0x5*0x6fb+-0x1600+-0xce7),function*(){return new _0x3e155e(_0x5a6a2f);});}}();},0xf57:(_0x1d90b5,_0x3600be,_0x46b839)=>{'use strict';_0x46b839(0x234d+0x64b*0x9+-0x37b2*0x1);var _0x5c5b95,_0x51dfbe=_0x46b839(0x2197+-0x61b*-0x5+-0x2d8a),_0xd1e47b=_0x46b839(-0x3a20+-0xf2*0x1b+-0x1775*-0x5),_0x597bba=_0x46b839(0x1*-0x10d7+-0x135e+-0x1*-0x3a71),_0x40f7f8=_0x46b839(0x1*-0x24b6+-0xf1*0x5+0x3abd),_0x1f177f=_0x46b839(-0x1cd*-0xd+-0xd59+0x25*0x1),_0x32c069=_0x46b839(0x3135+-0x14e3*-0x3+0x5*-0xf53),_0x1675f7=_0x46b839(0x1655*0x1+0x1*-0x1177+0x64f)['Buffer'];function _0x1f2c67(_0x3720ba){var _0x4ab508=this;_0x4ab508['options']=_0x3720ba||{},_0x4ab508['proxyOptio'+'ns']=_0x4ab508['options']['proxy']||{},_0x4ab508['maxSockets']=_0x4ab508['options']['maxSockets']||_0xd1e47b['Agent']['defaultMax'+'Sockets'],_0x4ab508['requests']=[],_0x4ab508['sockets']=[],_0x4ab508['on']('free',function(_0x2d110c,_0x55970d,_0x2a69c){for(var _0x858b85=0x747+0xb5*-0xb+0x80,_0xae0df6=_0x4ab508['requests']['length'];_0x858b85<_0xae0df6;++_0x858b85){var _0x72bc8f=_0x4ab508['requests'][_0x858b85];if(_0x72bc8f['host']===_0x55970d&&_0x72bc8f['port']===_0x2a69c)return _0x4ab508['requests']['splice'](_0x858b85,0x18d2+0x19*0xc+0x19fd*-0x1),void _0x72bc8f['request']['onSocket'](_0x2d110c);}_0x2d110c['destroy'](),_0x4ab508['removeSock'+'et'](_0x2d110c);});}function _0x3d3b89(_0x3c0fe6,_0x25fbe2){var _0x2f3904=this;_0x1f2c67['prototype']['createSock'+'et']['call'](_0x2f3904,_0x3c0fe6,function(_0x31f41c){var _0x48d289=_0x51dfbe['connect'](0xfd4+-0xb*-0x221+-0xd15*0x3,_0x1afef9({},_0x2f3904['options'],{'servername':_0x3c0fe6['host'],'socket':_0x31f41c}));_0x2f3904['sockets'][_0x2f3904['sockets']['indexOf'](_0x31f41c)]=_0x48d289,_0x25fbe2(_0x48d289);});}function _0x1afef9(_0x91443a){for(var _0x212de6=-0x10a1+0x1eee+-0x393*0x4,_0x456cb6=arguments['length'];_0x212de6<_0x456cb6;++_0x212de6){var _0x3f83d3=arguments[_0x212de6];if('object'==typeof _0x3f83d3)for(var _0xd116d6=Object['keys'](_0x3f83d3),_0x2225a1=-0x1*-0x197b+-0x40*-0x7b+0xb3f*-0x5,_0x441894=_0xd116d6['length'];_0x2225a1<_0x441894;++_0x2225a1){var _0x1a8ec8=_0xd116d6[_0x2225a1];void(-0xa36+0x1ee9+-0x14b3)!==_0x3f83d3[_0x1a8ec8]&&(_0x91443a[_0x1a8ec8]=_0x3f83d3[_0x1a8ec8]);}}return _0x91443a;}_0x3600be['httpOverHt'+'tp']=function(_0x30a0ef){var _0x398505=new _0x1f2c67(_0x30a0ef);return _0x398505['request']=_0xd1e47b['request'],_0x398505;},_0x3600be['httpsOverH'+'ttp']=function(_0x2acf35){var _0xc16d79=new _0x1f2c67(_0x2acf35);return _0xc16d79['request']=_0xd1e47b['request'],_0xc16d79['createSock'+'et']=_0x3d3b89,_0xc16d79['defaultPor'+'t']=0x809*0x4+-0xa*0x3ad+0x659,_0xc16d79;},_0x3600be['httpOverHt'+'tps']=function(_0x5f3514){var _0x31cbe2=new _0x1f2c67(_0x5f3514);return _0x31cbe2['request']=_0x597bba['request'],_0x31cbe2;},_0x3600be['httpsOverH'+'ttps']=function(_0x3b8360){var _0x34df22=new _0x1f2c67(_0x3b8360);return _0x34df22['request']=_0x597bba['request'],_0x34df22['createSock'+'et']=_0x3d3b89,_0x34df22['defaultPor'+'t']=-0x1d1f+0xa49+0x1491,_0x34df22;},_0x32c069['inherits'](_0x1f2c67,_0x40f7f8['EventEmitt'+'er']),_0x1f2c67['prototype']['addRequest']=function(_0x168f1f,_0x396bc5){var _0x30a3fb=this;'string'==typeof _0x396bc5&&(_0x396bc5={'host':_0x396bc5,'port':arguments[0xa*-0x9d+0xc34+-0x610],'path':arguments[-0x2437*-0x1+-0x1307*0x1+-0x112d]}),_0x30a3fb['sockets']['length']>=this['maxSockets']?_0x30a3fb['requests']['push']({'host':_0x396bc5['host'],'port':_0x396bc5['port'],'request':_0x168f1f}):_0x30a3fb['createConn'+'ection']({'host':_0x396bc5['host'],'port':_0x396bc5['port'],'request':_0x168f1f});},_0x1f2c67['prototype']['createConn'+'ection']=function(_0x5a8669){var _0xa5dbaa=this;_0xa5dbaa['createSock'+'et'](_0x5a8669,function(_0x2a2b04){function _0x183510(){_0xa5dbaa['emit']('free',_0x2a2b04,_0x5a8669['host'],_0x5a8669['port']);}function _0x5458d5(_0x264b0d){_0xa5dbaa['removeSock'+'et'](_0x2a2b04),_0x2a2b04['removeList'+'ener']('free',_0x183510),_0x2a2b04['removeList'+'ener']('close',_0x5458d5),_0x2a2b04['removeList'+'ener']('agentRemov'+'e',_0x5458d5);}_0x2a2b04['on']('free',_0x183510),_0x2a2b04['on']('close',_0x5458d5),_0x2a2b04['on']('agentRemov'+'e',_0x5458d5),_0x5a8669['request']['onSocket'](_0x2a2b04);});},_0x1f2c67['prototype']['createSock'+'et']=function(_0x476861,_0x49a492){var _0x4fbc37=this,_0x55e74f={};_0x4fbc37['sockets']['push'](_0x55e74f);var _0x392279=_0x1afef9({},_0x4fbc37['proxyOptio'+'ns'],{'method':'CONNECT','path':_0x476861['host']+':'+_0x476861['port'],'agent':!(-0xfeb+0x40f+0xbdd*0x1)});_0x392279['proxyAuth']&&(_0x392279['headers']=_0x392279['headers']||{},_0x392279['headers']['Proxy-Auth'+'orization']='Basic\x20'+_0x1675f7['from'](_0x392279['proxyAuth'])['toString']('base64')),_0x5c5b95('making\x20CON'+'NECT\x20reque'+'st');var _0x17387d=_0x4fbc37['request'](_0x392279);function _0x49008f(_0x5056f8,_0x4d7645,_0x40399f){if(_0x17387d['removeAllL'+'isteners'](),_0x4d7645['removeAllL'+'isteners'](),0x5f9+-0x79d*-0x4+-0x23a5===_0x5056f8['statusCode'])_0x1f177f['equal'](_0x40399f['length'],0x1ad0+0x9*0x97+0x1*-0x201f),_0x5c5b95('tunneling\x20'+'connection'+'\x20has\x20estab'+'lished'),_0x4fbc37['sockets'][_0x4fbc37['sockets']['indexOf'](_0x55e74f)]=_0x4d7645,_0x49a492(_0x4d7645);else{_0x5c5b95('tunneling\x20'+'socket\x20cou'+'ld\x20not\x20be\x20'+'establishe'+'d,\x20statusC'+'ode=%d',_0x5056f8['statusCode']);var _0x74fad5=new Error('tunneling\x20'+'socket\x20cou'+'ld\x20not\x20be\x20'+'establishe'+'d,\x20statusC'+'ode='+_0x5056f8['statusCode']);_0x74fad5['code']='ECONNRESET',_0x476861['request']['emit']('error',_0x74fad5),_0x4fbc37['removeSock'+'et'](_0x55e74f);}}_0x17387d['useChunked'+'EncodingBy'+'Default']=!(0xb00*0x2+0x2380+-0x397f),_0x17387d['once']('response',function(_0x26e06b){_0x26e06b['upgrade']=!(0x8ee+-0x17d3+-0x7b*-0x1f);}),_0x17387d['once']('upgrade',function(_0x5dca4c,_0x23665a,_0x595b75){process['nextTick'](function(){_0x49008f(_0x5dca4c,_0x23665a,_0x595b75);});}),_0x17387d['once']('connect',_0x49008f),_0x17387d['once']('error',function(_0xca6c51){_0x17387d['removeAllL'+'isteners'](),_0x5c5b95('tunneling\x20'+'socket\x20cou'+'ld\x20not\x20be\x20'+'establishe'+'d,\x20cause=%'+'s\x0a',_0xca6c51['message'],_0xca6c51['stack']);var _0x57d826=new Error('tunneling\x20'+'socket\x20cou'+'ld\x20not\x20be\x20'+'establishe'+'d,\x20cause='+_0xca6c51['message']);_0x57d826['code']='ECONNRESET',_0x476861['request']['emit']('error',_0x57d826),_0x4fbc37['removeSock'+'et'](_0x55e74f);}),_0x17387d['end']();},_0x1f2c67['prototype']['removeSock'+'et']=function(_0x465e24){var _0x376d29=this['sockets']['indexOf'](_0x465e24);if(-(-0x79d+-0xf72+0x1710)!==_0x376d29){this['sockets']['splice'](_0x376d29,-0xf6a*-0x2+-0x25ec+0x719);var _0x868d15=this['requests']['shift']();_0x868d15&&this['createConn'+'ection'](_0x868d15);}},_0x5c5b95=process['env']['NODE_DEBUG']&&/\btunnel\b/['test'](process['env']['NODE_DEBUG'])?function(){var _0x3cae1d=Array['prototype']['slice']['call'](arguments);'string'==typeof _0x3cae1d[-0x418*-0x5+0x2*0xa51+-0x291a*0x1]?_0x3cae1d[-0x4f0+-0x4f0+0x9e0]='TUNNEL:\x20'+_0x3cae1d[-0x59c*-0x6+0x1f91+-0x4139]:_0x3cae1d['unshift']('TUNNEL:'),console['error']['apply'](console,_0x3cae1d);}:function(){},_0x3600be['debug']=_0x5c5b95;},0x4d4:(_0x28498b,_0xc20aa8)=>{'use strict';_0xc20aa8['fromCallba'+'ck']=function(_0x3e2ec8){return Object['defineProp'+'erty'](function(){if('function'!=typeof arguments[arguments['length']-(0x1c9e+-0x1*0x16de+0x5bf*-0x1)])return new Promise((_0x3ede2e,_0x5d2128)=>{arguments[arguments['length']]=(_0x221016,_0x271c1e)=>{if(_0x221016)return _0x5d2128(_0x221016);_0x3ede2e(_0x271c1e);},arguments['length']++,_0x3e2ec8['apply'](this,arguments);});_0x3e2ec8['apply'](this,arguments);},'name',{'value':_0x3e2ec8['name']});},_0xc20aa8['fromPromis'+'e']=function(_0x3f13c7){return Object['defineProp'+'erty'](function(){const _0x2ae904=arguments[arguments['length']-(-0x740*-0x2+-0xcbd*0x1+-0x1c2)];if('function'!=typeof _0x2ae904)return _0x3f13c7['apply'](this,arguments);delete arguments[arguments['length']-(-0x190e*0x1+-0x37*0xa7+0x3cf0)],arguments['length']--,_0x3f13c7['apply'](this,arguments)['then'](_0xfebcb3=>_0x2ae904(null,_0xfebcb3),_0x2ae904);},'name',{'value':_0x3f13c7['name']});};},0x488:(_0x41d975,_0x53f2f0,_0x33044b)=>{'use strict';var _0x565fe9=_0x33044b(-0x6*0x47b+0x1*-0x2205+-0xb6*-0x61),_0x846d65=_0x33044b(0x3f3+-0x13c2+-0x1f67*-0x1),_0x49ba23=/^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,_0xd1caa8=/[\n\r\t]/g,_0x303c48=/^[A-Za-z][A-Za-z0-9+-.]*:\/\//,_0x4396de=/:\d+$/,_0x2db2b7=/^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,_0x4f321b=/^[a-zA-Z]:/;function _0x3b9998(_0x510b2b){return(_0x510b2b||'')['toString']()['replace'](_0x49ba23,'');}var _0x513f08=[['#','hash'],['?','query'],function(_0x2b7b8d,_0x52b757){return _0x3c6783(_0x52b757['protocol'])?_0x2b7b8d['replace'](/\\/g,'/'):_0x2b7b8d;},['/','pathname'],['@','auth',0x13d*-0x7+-0x14ca+0x1d76],[NaN,'host',void(-0x1bc+0x7*-0x38c+0x1a90),-0x18d*-0x4+-0x490+-0x1a3*0x1,-0x1599+0x117a+-0x21*-0x20],[/:(\d*)$/,'port',void(0x1b6f*0x1+-0x15ab+-0x9*0xa4),0x3*0x9df+-0x14fd+0x89f*-0x1],[NaN,'hostname',void(0x1*0x815+0x207c+0x5*-0x81d),-0x3*0xc64+-0x25a+-0x3*-0xd2d,-0x1c95*0x1+-0x186c*0x1+-0x1a81*-0x2]],_0x153542={'hash':0x1,'query':0x1};function _0x5091f8(_0x5dfbd2){var _0x233a00,_0x510ac5=('undefined'!=typeof window?window:'undefined'!=typeof global?global:'undefined'!=typeof self?self:{})['location']||{},_0x56637f={},_0x3cb336=typeof(_0x5dfbd2=_0x5dfbd2||_0x510ac5);if('blob:'===_0x5dfbd2['protocol'])_0x56637f=new _0x2c0a74(unescape(_0x5dfbd2['pathname']),{});else{if('string'===_0x3cb336){for(_0x233a00 in(_0x56637f=new _0x2c0a74(_0x5dfbd2,{}),_0x153542))delete _0x56637f[_0x233a00];}else{if('object'===_0x3cb336){for(_0x233a00 in _0x5dfbd2)_0x233a00 in _0x153542||(_0x56637f[_0x233a00]=_0x5dfbd2[_0x233a00]);void(-0xbc0+0x1c53+-0x1093)===_0x56637f['slashes']&&(_0x56637f['slashes']=_0x303c48['test'](_0x5dfbd2['href']));}}}return _0x56637f;}function _0x3c6783(_0x3de995){return'file:'===_0x3de995||'ftp:'===_0x3de995||'http:'===_0x3de995||'https:'===_0x3de995||'ws:'===_0x3de995||'wss:'===_0x3de995;}function _0x56daf8(_0x10b974,_0x6a6278){_0x10b974=(_0x10b974=_0x3b9998(_0x10b974))['replace'](_0xd1caa8,''),_0x6a6278=_0x6a6278||{};var _0x1061b5,_0x180bae=_0x2db2b7['exec'](_0x10b974),_0x43a13b=_0x180bae[0x1*-0x212f+0x205*0xb+-0xaf9*-0x1]?_0x180bae[-0x1e84+-0x1f0*0x1+0x7*0x4a3]['toLowerCas'+'e']():'',_0x304199=!!_0x180bae[-0x7ee+0xf0a+-0x12*0x65],_0x297cfd=!!_0x180bae[0x3*0x4e9+-0xff9+0x141],_0x5b077b=-0x4*-0x211+0x8a*0x29+-0x1e5e;return _0x304199?_0x297cfd?(_0x1061b5=_0x180bae[-0xac8+-0xc30+-0x15a*-0x11]+_0x180bae[-0x1*-0x389+-0x2289+0x1f03*0x1]+_0x180bae[0x1542*0x1+0x2*-0xa7b+-0x48],_0x5b077b=_0x180bae[-0x10e3+-0x43*0x92+0x371b*0x1]['length']+_0x180bae[-0xa3a+0x1682+0x417*-0x3]['length']):(_0x1061b5=_0x180bae[0xa22*0x3+0x127b+0x30df*-0x1]+_0x180bae[-0x1*-0x8ad+0x293*0xa+-0x2267],_0x5b077b=_0x180bae[0xf6*-0xf+-0x14*-0xce+-0x1ac]['length']):_0x297cfd?(_0x1061b5=_0x180bae[-0x1c0f+-0x2238+0x3e4a]+_0x180bae[-0x38b*-0x6+-0xbf*-0x33+0x1*-0x3b4b],_0x5b077b=_0x180bae[0xb*0x16f+0x171d+-0x1*0x26df]['length']):_0x1061b5=_0x180bae[-0x1*0x935+-0x1f9f+0x1*0x28d8],'file:'===_0x43a13b?_0x5b077b>=0x17ac+-0x121*-0x10+-0x2fb*0xe&&(_0x1061b5=_0x1061b5['slice'](-0xd26+0x7e8+0x540)):_0x3c6783(_0x43a13b)?_0x1061b5=_0x180bae[-0x1*-0x1c7c+0x2*0x8cf+0x11*-0x2b6]:_0x43a13b?_0x304199&&(_0x1061b5=_0x1061b5['slice'](-0x4b1*-0x1+-0xfe9+-0x6*-0x1df)):_0x5b077b>=0x1d01+-0x974+0x1*-0x138b&&_0x3c6783(_0x6a6278['protocol'])&&(_0x1061b5=_0x180bae[0x2d6+0x1d3d*-0x1+0x1a6b]),{'protocol':_0x43a13b,'slashes':_0x304199||_0x3c6783(_0x43a13b),'slashesCount':_0x5b077b,'rest':_0x1061b5};}function _0x2c0a74(_0x44842c,_0x482c44,_0xc6f580){if(_0x44842c=(_0x44842c=_0x3b9998(_0x44842c))['replace'](_0xd1caa8,''),!(this instanceof _0x2c0a74))return new _0x2c0a74(_0x44842c,_0x482c44,_0xc6f580);var _0x2611f2,_0x313539,_0x1feab6,_0x1033b9,_0x5ee13f,_0x35b7af,_0x4e588c=_0x513f08['slice'](),_0x922e4a=typeof _0x482c44,_0x53d74c=this,_0x36a92a=0x8e0+0x1137+-0x1a17;for('object'!==_0x922e4a&&'string'!==_0x922e4a&&(_0xc6f580=_0x482c44,_0x482c44=null),_0xc6f580&&'function'!=typeof _0xc6f580&&(_0xc6f580=_0x846d65['parse']),_0x2611f2=!(_0x313539=_0x56daf8(_0x44842c||'',_0x482c44=_0x5091f8(_0x482c44)))['protocol']&&!_0x313539['slashes'],_0x53d74c['slashes']=_0x313539['slashes']||_0x2611f2&&_0x482c44['slashes'],_0x53d74c['protocol']=_0x313539['protocol']||_0x482c44['protocol']||'',_0x44842c=_0x313539['rest'],('file:'===_0x313539['protocol']&&(-0x3*-0x3d1+-0x3*-0x397+-0x1636!==_0x313539['slashesCou'+'nt']||_0x4f321b['test'](_0x44842c))||!_0x313539['slashes']&&(_0x313539['protocol']||_0x313539['slashesCou'+'nt']<-0xd9*-0x2b+-0xe*-0xda+0x1*-0x305d||!_0x3c6783(_0x53d74c['protocol'])))&&(_0x4e588c[0x25fe*0x1+0x559*-0x1+0x20a2*-0x1]=[/(.*)/,'pathname']);_0x36a92a<_0x4e588c['length'];_0x36a92a++)'function'!=typeof(_0x1033b9=_0x4e588c[_0x36a92a])?(_0x1feab6=_0x1033b9[-0x3*-0xabd+0x1*0xd63+-0x2d9a],_0x35b7af=_0x1033b9[0x3*-0x41+0x1ce4+0x20*-0xe1],_0x1feab6!=_0x1feab6?_0x53d74c[_0x35b7af]=_0x44842c:'string'==typeof _0x1feab6?~(_0x5ee13f='@'===_0x1feab6?_0x44842c['lastIndexO'+'f'](_0x1feab6):_0x44842c['indexOf'](_0x1feab6))&&('number'==typeof _0x1033b9[0x2042*-0x1+-0x787+-0x3d*-0xa7]?(_0x53d74c[_0x35b7af]=_0x44842c['slice'](0x204*-0x7+-0x2f0+-0x443*-0x4,_0x5ee13f),_0x44842c=_0x44842c['slice'](_0x5ee13f+_0x1033b9[-0x6*-0xe+-0x824+0x7d2])):(_0x53d74c[_0x35b7af]=_0x44842c['slice'](_0x5ee13f),_0x44842c=_0x44842c['slice'](0x1bf7+0x33f+-0x1f36,_0x5ee13f))):(_0x5ee13f=_0x1feab6['exec'](_0x44842c))&&(_0x53d74c[_0x35b7af]=_0x5ee13f[-0x15a7+-0x5cb*0x5+-0x329f*-0x1],_0x44842c=_0x44842c['slice'](-0x872+-0x227d+0x2aef,_0x5ee13f['index'])),_0x53d74c[_0x35b7af]=_0x53d74c[_0x35b7af]||_0x2611f2&&_0x1033b9[0x1658+-0x802+-0xe53]&&_0x482c44[_0x35b7af]||'',_0x1033b9[0xd*-0x68+-0xc03+-0xd3*-0x15]&&(_0x53d74c[_0x35b7af]=_0x53d74c[_0x35b7af]['toLowerCas'+'e']())):_0x44842c=_0x1033b9(_0x44842c,_0x53d74c);_0xc6f580&&(_0x53d74c['query']=_0xc6f580(_0x53d74c['query'])),_0x2611f2&&_0x482c44['slashes']&&'/'!==_0x53d74c['pathname']['charAt'](0x1*-0xf86+0x191*-0x1+0x1117)&&(''!==_0x53d74c['pathname']||''!==_0x482c44['pathname'])&&(_0x53d74c['pathname']=function(_0x16b0f3,_0xb75f40){if(''===_0x16b0f3)return _0xb75f40;for(var _0x52e85c=(_0xb75f40||'/')['split']('/')['slice'](0x945+-0xd*0x27a+0x16ed,-(0x148a+-0x19eb+0x562*0x1))['concat'](_0x16b0f3['split']('/')),_0x56a867=_0x52e85c['length'],_0x32fce2=_0x52e85c[_0x56a867-(0x14de*0x1+0x1*0x20a1+0x14e*-0x29)],_0x4cb1f6=!(0x4*0x178+-0x14c3+0x772*0x2),_0x10c210=0x5*-0x40c+-0xa9c+-0x54*-0x5e;_0x56a867--;)'.'===_0x52e85c[_0x56a867]?_0x52e85c['splice'](_0x56a867,-0x7b2+-0x243+0x9f6):'..'===_0x52e85c[_0x56a867]?(_0x52e85c['splice'](_0x56a867,0x13*0xf5+0x11a2+0x23d0*-0x1),_0x10c210++):_0x10c210&&(-0x18d*0xb+0x1*-0x1fa1+0x30b0===_0x56a867&&(_0x4cb1f6=!(0x3f2*-0x8+0x1e32+-0x7*-0x32)),_0x52e85c['splice'](_0x56a867,0x2408+0x14a0+-0x38a7),_0x10c210--);return _0x4cb1f6&&_0x52e85c['unshift'](''),'.'!==_0x32fce2&&'..'!==_0x32fce2||_0x52e85c['push'](''),_0x52e85c['join']('/');}(_0x53d74c['pathname'],_0x482c44['pathname'])),'/'!==_0x53d74c['pathname']['charAt'](0x553*-0x4+-0x3d*0x71+-0x1013*-0x3)&&_0x3c6783(_0x53d74c['protocol'])&&(_0x53d74c['pathname']='/'+_0x53d74c['pathname']),_0x565fe9(_0x53d74c['port'],_0x53d74c['protocol'])||(_0x53d74c['host']=_0x53d74c['hostname'],_0x53d74c['port']=''),_0x53d74c['username']=_0x53d74c['password']='',_0x53d74c['auth']&&(~(_0x5ee13f=_0x53d74c['auth']['indexOf'](':'))?(_0x53d74c['username']=_0x53d74c['auth']['slice'](0x5*0x2b3+-0x8b7+-0x4c8,_0x5ee13f),_0x53d74c['username']=encodeURIComponent(decodeURIComponent(_0x53d74c['username'])),_0x53d74c['password']=_0x53d74c['auth']['slice'](_0x5ee13f+(0x1fe6+0x1664*0x1+-0x3649)),_0x53d74c['password']=encodeURIComponent(decodeURIComponent(_0x53d74c['password']))):_0x53d74c['username']=encodeURIComponent(decodeURIComponent(_0x53d74c['auth'])),_0x53d74c['auth']=_0x53d74c['password']?_0x53d74c['username']+':'+_0x53d74c['password']:_0x53d74c['username']),_0x53d74c['origin']='file:'!==_0x53d74c['protocol']&&_0x3c6783(_0x53d74c['protocol'])&&_0x53d74c['host']?_0x53d74c['protocol']+'//'+_0x53d74c['host']:'null',_0x53d74c['href']=_0x53d74c['toString']();}_0x2c0a74['prototype']={'set':function(_0x236959,_0x3de3ac,_0x45780c){var _0x5956f7=this;switch(_0x236959){case'query':'string'==typeof _0x3de3ac&&_0x3de3ac['length']&&(_0x3de3ac=(_0x45780c||_0x846d65['parse'])(_0x3de3ac)),_0x5956f7[_0x236959]=_0x3de3ac;break;case'port':_0x5956f7[_0x236959]=_0x3de3ac,_0x565fe9(_0x3de3ac,_0x5956f7['protocol'])?_0x3de3ac&&(_0x5956f7['host']=_0x5956f7['hostname']+':'+_0x3de3ac):(_0x5956f7['host']=_0x5956f7['hostname'],_0x5956f7[_0x236959]='');break;case'hostname':_0x5956f7[_0x236959]=_0x3de3ac,_0x5956f7['port']&&(_0x3de3ac+=':'+_0x5956f7['port']),_0x5956f7['host']=_0x3de3ac;break;case'host':_0x5956f7[_0x236959]=_0x3de3ac,_0x4396de['test'](_0x3de3ac)?(_0x3de3ac=_0x3de3ac['split'](':'),_0x5956f7['port']=_0x3de3ac['pop'](),_0x5956f7['hostname']=_0x3de3ac['join'](':')):(_0x5956f7['hostname']=_0x3de3ac,_0x5956f7['port']='');break;case'protocol':_0x5956f7['protocol']=_0x3de3ac['toLowerCas'+'e'](),_0x5956f7['slashes']=!_0x45780c;break;case'pathname':case'hash':if(_0x3de3ac){var _0x5dc317='pathname'===_0x236959?'/':'#';_0x5956f7[_0x236959]=_0x3de3ac['charAt'](-0x20f2+-0x2323*-0x1+-0xbb*0x3)!==_0x5dc317?_0x5dc317+_0x3de3ac:_0x3de3ac;}else _0x5956f7[_0x236959]=_0x3de3ac;break;case'username':case'password':_0x5956f7[_0x236959]=encodeURIComponent(_0x3de3ac);break;case'auth':var _0x2032a3=_0x3de3ac['indexOf'](':');~_0x2032a3?(_0x5956f7['username']=_0x3de3ac['slice'](-0x1*0x397+-0x2567+-0x6d5*-0x6,_0x2032a3),_0x5956f7['username']=encodeURIComponent(decodeURIComponent(_0x5956f7['username'])),_0x5956f7['password']=_0x3de3ac['slice'](_0x2032a3+(-0x1e5f+-0x2199*-0x1+-0x339)),_0x5956f7['password']=encodeURIComponent(decodeURIComponent(_0x5956f7['password']))):_0x5956f7['username']=encodeURIComponent(decodeURIComponent(_0x3de3ac));}for(var _0x3ddce6=0x1*0xe9+-0x4*0x849+-0xdf*-0x25;_0x3ddce6<_0x513f08['length'];_0x3ddce6++){var _0x37141d=_0x513f08[_0x3ddce6];_0x37141d[0xf3*-0x28+0x26c9+-0xcd]&&(_0x5956f7[_0x37141d[0x2*-0xca6+-0xbe2+0x252f]]=_0x5956f7[_0x37141d[-0x1*0x1c8d+0x2408+-0x6*0x13f]]['toLowerCas'+'e']());}return _0x5956f7['auth']=_0x5956f7['password']?_0x5956f7['username']+':'+_0x5956f7['password']:_0x5956f7['username'],_0x5956f7['origin']='file:'!==_0x5956f7['protocol']&&_0x3c6783(_0x5956f7['protocol'])&&_0x5956f7['host']?_0x5956f7['protocol']+'//'+_0x5956f7['host']:'null',_0x5956f7['href']=_0x5956f7['toString'](),_0x5956f7;},'toString':function(_0x411dc8){_0x411dc8&&'function'==typeof _0x411dc8||(_0x411dc8=_0x846d65['stringify']);var _0x4cce54,_0x3f893b=this,_0x2f5845=_0x3f893b['host'],_0x273d38=_0x3f893b['protocol'];_0x273d38&&':'!==_0x273d38['charAt'](_0x273d38['length']-(0xb*-0xb5+-0x17*0xdf+0x1*0x1bd1))&&(_0x273d38+=':');var _0x26c5c8=_0x273d38+(_0x3f893b['protocol']&&_0x3f893b['slashes']||_0x3c6783(_0x3f893b['protocol'])?'//':'');return _0x3f893b['username']?(_0x26c5c8+=_0x3f893b['username'],_0x3f893b['password']&&(_0x26c5c8+=':'+_0x3f893b['password']),_0x26c5c8+='@'):_0x3f893b['password']?(_0x26c5c8+=':'+_0x3f893b['password'],_0x26c5c8+='@'):'file:'!==_0x3f893b['protocol']&&_0x3c6783(_0x3f893b['protocol'])&&!_0x2f5845&&'/'!==_0x3f893b['pathname']&&(_0x26c5c8+='@'),(':'===_0x2f5845[_0x2f5845['length']-(-0x77d+0x13a2+-0x103*0xc)]||_0x4396de['test'](_0x3f893b['hostname'])&&!_0x3f893b['port'])&&(_0x2f5845+=':'),_0x26c5c8+=_0x2f5845+_0x3f893b['pathname'],(_0x4cce54='object'==typeof _0x3f893b['query']?_0x411dc8(_0x3f893b['query']):_0x3f893b['query'])&&(_0x26c5c8+='?'!==_0x4cce54['charAt'](-0x1ed5+-0x128f*0x1+0x3164)?'?'+_0x4cce54:_0x4cce54),_0x3f893b['hash']&&(_0x26c5c8+=_0x3f893b['hash']),_0x26c5c8;}},_0x2c0a74['extractPro'+'tocol']=_0x56daf8,_0x2c0a74['location']=_0x5091f8,_0x2c0a74['trimLeft']=_0x3b9998,_0x2c0a74['qs']=_0x846d65,_0x41d975['exports']=_0x2c0a74;},0x863:(_0x4c08a9,_0x2beb65,_0x184f27)=>{'use strict';var _0x398d16=_0x184f27(-0x677+0x1375*-0x1+0x210f),_0x3fc6e8=_0x184f27(0x2345+-0x1b*0x13e+0x93a),_0x58ad9f=_0x184f27(-0x995*-0x3+-0xe27*-0x1+-0x1e35),_0x149da1={'client':function(_0x30a7aa,_0x580088){return void(-0x814+-0xd3*-0xe+-0x376)===(_0x580088=_0x580088||{})['masking']&&(_0x580088['masking']=!(-0x25a7+0xd93*0x1+0x1814)),new _0x3fc6e8(_0x30a7aa,_0x580088);},'server':function(_0xb3667b){return void(0x2cf+-0x1d*0x158+0x2429)===(_0xb3667b=_0xb3667b||{})['requireMas'+'king']&&(_0xb3667b['requireMas'+'king']=!(-0x51b*0x2+-0x18d7+0x230d)),new _0x58ad9f(_0xb3667b);},'http':function(){return _0x58ad9f['http']['apply'](_0x58ad9f,arguments);},'isSecureRequest':function(_0x51aa6b){return _0x58ad9f['isSecureRe'+'quest'](_0x51aa6b);},'isWebSocket':function(_0x4da2e3){return _0x398d16['isWebSocke'+'t'](_0x4da2e3);},'validateOptions':function(_0x45aea1,_0x4f0dad){_0x398d16['validateOp'+'tions'](_0x45aea1,_0x4f0dad);}};_0x4c08a9['exports']=_0x149da1;},0x723:(_0x1cebfa,_0x11e319,_0x12a022)=>{'use strict';var _0x6618a0=_0x12a022(-0x1be2+-0x1154+0x3863)['Buffer'],_0x704eb9=_0x12a022(-0x5*0x9b+-0x5ac+0x1a05)['EventEmitt'+'er'],_0x3786f6=_0x12a022(-0x9f7+0x1*-0x1a5c+0x1*0x4792),_0x5a8fc3=_0x12a022(0x1c75+-0x8f*0xc+-0x3f9),_0x579907=_0x12a022(-0x1f7d+-0x736*0x5+0x4e59),_0x1f497d=_0x12a022(0x3e77*-0x1+0x2496+0x3c67),_0x33a429=function(_0x44c050,_0x1dc427,_0x35ff94){_0x704eb9['call'](this),_0x33a429['validateOp'+'tions'](_0x35ff94||{},['maxLength','masking','requireMas'+'king','protocols']),this['_request']=_0x44c050,this['_reader']=new _0x1f497d(),this['_options']=_0x35ff94||{},this['_maxLength']=this['_options']['maxLength']||this['MAX_LENGTH'],this['_headers']=new _0x579907(),this['__queue']=[],this['readyState']=0x16d*-0x7+-0x19*-0x89+-0x366,this['url']=_0x1dc427,this['io']=new _0x5a8fc3['IO'](this),this['messages']=new _0x5a8fc3['Messages'](this),this['_bindEvent'+'Listeners']();};_0x3786f6['inherits'](_0x33a429,_0x704eb9),_0x33a429['isWebSocke'+'t']=function(_0x1e0a59){var _0x4c4112=_0x1e0a59['headers']['connection']||'',_0x32bf2e=_0x1e0a59['headers']['upgrade']||'';return'GET'===_0x1e0a59['method']&&_0x4c4112['toLowerCas'+'e']()['split'](/ *, */)['indexOf']('upgrade')>=-0xe4a+0xcf1*-0x3+-0x1*-0x351d&&'websocket'===_0x32bf2e['toLowerCas'+'e']();},_0x33a429['validateOp'+'tions']=function(_0x2fdd1d,_0x4d2a7f){for(var _0x1da048 in _0x2fdd1d)if(_0x4d2a7f['indexOf'](_0x1da048)<-0xc0c+-0x3*-0x260+0x4ec)throw new Error('Unrecogniz'+'ed\x20option:'+'\x20'+_0x1da048);};var _0x4efeae={'MAX_LENGTH':0x3ffffff,'STATES':['connecting','open','closing','closed'],'_bindEventListeners':function(){var _0x4a8324=this;this['messages']['on']('error',function(){}),this['on']('message',function(_0x2f9dbd){var _0xae7543=_0x4a8324['messages'];_0xae7543['readable']&&_0xae7543['emit']('data',_0x2f9dbd['data']);}),this['on']('error',function(_0x3a22f9){var _0x277664=_0x4a8324['messages'];_0x277664['readable']&&_0x277664['emit']('error',_0x3a22f9);}),this['on']('close',function(){var _0x5fe7bb=_0x4a8324['messages'];_0x5fe7bb['readable']&&(_0x5fe7bb['readable']=_0x5fe7bb['writable']=!(-0x2c*-0x27+-0x940+0x28d),_0x5fe7bb['emit']('end'));});},'getState':function(){return this['STATES'][this['readyState']]||null;},'addExtension':function(_0x5cf0b4){return!(-0xa36+-0x197*0xb+0x1bb4);},'setHeader':function(_0x4fb1f1,_0x284a16){return!(this['readyState']>0x25f4+-0x292+-0x7*0x50e||(this['_headers']['set'](_0x4fb1f1,_0x284a16),0x1e5+0x1a12+0x1*-0x1bf7));},'start':function(){if(-0xb66+0xe*0x40+0x7e6!==this['readyState'])return!(0xe5f*0x1+-0x1f*-0xd3+-0x3a1*0xb);if(!_0x33a429['isWebSocke'+'t'](this['_request']))return this['_failHands'+'hake'](new Error('Not\x20a\x20WebS'+'ocket\x20requ'+'est'));var _0x165306;try{_0x165306=this['_handshake'+'Response']();}catch(_0x5d4b4b){return this['_failHands'+'hake'](_0x5d4b4b);}return this['_write'](_0x165306),-(0xf20+-0x1*-0x1517+-0x2436)!==this['_stage']&&this['_open'](),!(0xa0e+-0x3c9+-0x645);},'_failHandshake':function(_0x3aedc1){var _0x5cea43=new _0x579907();return _0x5cea43['set']('Content-Ty'+'pe','text/plain'),_0x5cea43['set']('Content-Le'+'ngth',_0x6618a0['byteLength'](_0x3aedc1['message'],'utf8')),_0x5cea43=['HTTP/1.1\x204'+'00\x20Bad\x20Req'+'uest',_0x5cea43['toString'](),_0x3aedc1['message']],this['_write'](_0x6618a0['from'](_0x5cea43['join']('\x0d\x0a'),'utf8')),this['_fail']('protocol_e'+'rror',_0x3aedc1['message']),!(0x6f*0x15+0x8b6+0x5f0*-0x3);},'text':function(_0x2a7e33){return this['frame'](_0x2a7e33);},'binary':function(_0x9d56c9){return!(0x4ae*0x4+-0x4*-0x5c5+-0x29cb);},'ping':function(){return!(-0x141b*0x1+-0x2ee+0x170a);},'pong':function(){return!(0x21e*0x6+-0x261c*0x1+-0x5*-0x515);},'close':function(_0xfbb355,_0x259613){return-0x160a+0xb6c+0xa9f*0x1===this['readyState']&&(this['readyState']=-0x1*0x2639+0x1a0b+0xc31*0x1,this['emit']('close',new _0x33a429['CloseEvent'](null,null)),!(-0xa2*0x14+0x15*-0xd9+0x1e75));},'_open':function(){this['readyState']=0x1023+-0x1b4a+0xb28,this['__queue']['forEach'](function(_0x2a3116){this['frame']['apply'](this,_0x2a3116);},this),this['__queue']=[],this['emit']('open',new _0x33a429['OpenEvent']());},'_queue':function(_0x14651b){return this['__queue']['push'](_0x14651b),!(0x2426+0x1*0x1e5d+-0x4283);},'_write':function(_0x244b8f){var _0x38bf2d=this['io'];_0x38bf2d['readable']&&_0x38bf2d['emit']('data',_0x244b8f);},'_fail':function(_0x3fb9c4,_0x269b4b){this['readyState']=0x852+0x1a*-0x9b+0x76e*0x1,this['emit']('error',new Error(_0x269b4b)),this['close']();}};for(var _0x5b96d5 in _0x4efeae)_0x33a429['prototype'][_0x5b96d5]=_0x4efeae[_0x5b96d5];_0x33a429['ConnectEve'+'nt']=function(){},_0x33a429['OpenEvent']=function(){},_0x33a429['CloseEvent']=function(_0x32daa9,_0x449e9d){this['code']=_0x32daa9,this['reason']=_0x449e9d;},_0x33a429['MessageEve'+'nt']=function(_0x5b5817){this['data']=_0x5b5817;},_0x33a429['PingEvent']=function(_0x37a9dc){this['data']=_0x37a9dc;},_0x33a429['PongEvent']=function(_0x578cfc){this['data']=_0x578cfc;},_0x1cebfa['exports']=_0x33a429;},0xaf5:(_0x7c990,_0x27fb59,_0x374433)=>{'use strict';var _0x3fa83c=_0x374433(-0x1*-0xb9b+-0x1*0x1d63+-0x3*-0x9a7)['Buffer'],_0x3498c5=_0x374433(0x17c7+0x68*0x41+0x187*-0xf),_0x108fbc=_0x374433(-0xf44+-0x1a17+-0x1d*-0x25f),_0x2d5930=_0x374433(0x17bc+-0x37b1+0xbb*0x5c),_0x7ab253=_0x374433(0x112+0x1977+0xc6),_0x1cc3bc=_0x374433(-0x8e*0x30+0x2f5*-0xd+0x2*0x241a),_0x55b902=_0x374433(-0x1eb5+0xa41+0x3568),_0x4151f3=_0x374433(0x3*-0x83+0xb*0x189+-0x2*-0x21),_0xc59d79=function(_0x27f967,_0x477ea7){this['version']='hybi-'+_0x55b902['VERSION'],_0x55b902['call'](this,null,_0x27f967,_0x477ea7),this['readyState']=-(-0x1211+-0x7*-0x1c9+0x593),this['_key']=_0xc59d79['generateKe'+'y'](),this['_accept']=_0x55b902['generateAc'+'cept'](this['_key']),this['_http']=new _0x7ab253('response');var _0x48e5e7=_0x108fbc['parse'](this['url']),_0x860d42=_0x48e5e7['auth']&&_0x3fa83c['from'](_0x48e5e7['auth'],'utf8')['toString']('base64');if(this['VALID_PROT'+'OCOLS']['indexOf'](_0x48e5e7['protocol'])<-0xb74+0x212c+0x14*-0x116)throw new Error(this['url']+('\x20is\x20not\x20a\x20'+'valid\x20WebS'+'ocket\x20URL'));this['_pathname']=(_0x48e5e7['pathname']||'/')+(_0x48e5e7['search']||''),this['_headers']['set']('Host',_0x48e5e7['host']),this['_headers']['set']('Upgrade','websocket'),this['_headers']['set']('Connection','Upgrade'),this['_headers']['set']('Sec-WebSoc'+'ket-Key',this['_key']),this['_headers']['set']('Sec-WebSoc'+'ket-Versio'+'n',_0x55b902['VERSION']),this['_protocols']['length']>0x16*-0xa4+-0xb03+-0x1*-0x191b&&this['_headers']['set']('Sec-WebSoc'+'ket-Protoc'+'ol',this['_protocols']['join'](',\x20')),_0x860d42&&this['_headers']['set']('Authorizat'+'ion','Basic\x20'+_0x860d42);};_0x2d5930['inherits'](_0xc59d79,_0x55b902),_0xc59d79['generateKe'+'y']=function(){return _0x3498c5['randomByte'+'s'](0x1463+0x4*0xfb+0x183f*-0x1)['toString']('base64');};var _0x318403={'VALID_PROTOCOLS':['ws:','wss:'],'proxy':function(_0x3313ef,_0x1c6ba1){return new _0x4151f3(this,_0x3313ef,_0x1c6ba1);},'start':function(){return-(-0x1d0+-0x1a43+0x1c14)===this['readyState']&&(this['_write'](this['_handshake'+'Request']()),this['readyState']=-0x1*-0x293+-0x4*0x6c9+0x1891,!(0x2a5*-0x1+-0x17e+0x423));},'parse':function(_0x1c484c){if(0x236f+-0x1ab2*0x1+-0x8ba!==this['readyState']){if(this['readyState']>0x4*0x23+0x3f2*-0x6+-0x1720*-0x1)return _0x55b902['prototype']['parse']['call'](this,_0x1c484c);this['_http']['parse'](_0x1c484c),this['_http']['isComplete']()&&(this['_validateH'+'andshake'](),-0x186c+-0x1*0x1325+-0x2*-0x15ca!==this['readyState']&&(this['_open'](),this['parse'](this['_http']['body'])));}},'_handshakeRequest':function(){var _0x3c3508=this['_extension'+'s']['generateOf'+'fer']();_0x3c3508&&this['_headers']['set']('Sec-WebSoc'+'ket-Extens'+'ions',_0x3c3508);var _0x9d839c=['GET\x20'+this['_pathname']+'\x20HTTP/1.1',this['_headers']['toString'](),''];return _0x3fa83c['from'](_0x9d839c['join']('\x0d\x0a'),'utf8');},'_failHandshake':function(_0x51e3bc){_0x51e3bc='Error\x20duri'+'ng\x20WebSock'+'et\x20handsha'+'ke:\x20'+_0x51e3bc,this['readyState']=0x18d2+-0x1e63+0x2*0x2ca,this['emit']('error',new Error(_0x51e3bc)),this['emit']('close',new _0x1cc3bc['CloseEvent'](this['ERRORS']['protocol_e'+'rror'],_0x51e3bc));},'_validateHandshake':function(){if(this['statusCode']=this['_http']['statusCode'],this['headers']=this['_http']['headers'],this['_http']['error'])return this['_failHands'+'hake'](this['_http']['error']['message']);if(0x13d3+0x8*0x49+0x15b6*-0x1!==this['_http']['statusCode'])return this['_failHands'+'hake']('Unexpected'+'\x20response\x20'+'code:\x20'+this['_http']['statusCode']);var _0x12b859=this['_http']['headers'],_0x387e39=_0x12b859['upgrade']||'',_0x2a900f=_0x12b859['connection']||'',_0x449ea4=_0x12b859['sec-websoc'+'ket-accept']||'',_0x4205e1=_0x12b859['sec-websoc'+'ket-protoc'+'ol']||'';if(''===_0x387e39)return this['_failHands'+'hake']('\x27Upgrade\x27\x20'+'header\x20is\x20'+'missing');if('websocket'!==_0x387e39['toLowerCas'+'e']())return this['_failHands'+'hake']('\x27Upgrade\x27\x20'+'header\x20val'+'ue\x20is\x20not\x20'+'\x27WebSocket'+'\x27');if(''===_0x2a900f)return this['_failHands'+'hake']('\x27Connectio'+'n\x27\x20header\x20'+'is\x20missing');if('upgrade'!==_0x2a900f['toLowerCas'+'e']())return this['_failHands'+'hake']('\x27Connectio'+'n\x27\x20header\x20'+'value\x20is\x20n'+'ot\x20\x27Upgrad'+'e\x27');if(_0x449ea4!==this['_accept'])return this['_failHands'+'hake']('Sec-WebSoc'+'ket-Accept'+'\x20mismatch');if(this['protocol']=null,''!==_0x4205e1){if(this['_protocols']['indexOf'](_0x4205e1)<0x1289*-0x1+0x2675+0xff*-0x14)return this['_failHands'+'hake']('Sec-WebSoc'+'ket-Protoc'+'ol\x20mismatc'+'h');this['protocol']=_0x4205e1;}try{this['_extension'+'s']['activate'](this['headers']['sec-websoc'+'ket-extens'+'ions']);}catch(_0x18cc90){return this['_failHands'+'hake'](_0x18cc90['message']);}}};for(var _0x36b339 in _0x318403)_0xc59d79['prototype'][_0x36b339]=_0x318403[_0x36b339];_0x7c990['exports']=_0xc59d79;},0xc9f:(_0x59860a,_0x1faf93,_0x427ce5)=>{'use strict';var _0x478c67=_0x427ce5(-0x5*0x71e+0x1*-0x1763+0x1b6*0x29)['Buffer'],_0x308415=_0x427ce5(0x11e5+0x2*-0x1087+0x164c),_0x3e2e8f=function(_0x3d302f,_0x18d78b,_0x43e8cd){_0x308415['apply'](this,arguments),this['_stage']=-0x1cf0+-0x12*-0x1db+0x2*-0x23b,this['version']='hixie-75',this['_headers']['set']('Upgrade','WebSocket'),this['_headers']['set']('Connection','Upgrade'),this['_headers']['set']('WebSocket-'+'Origin',this['_request']['headers']['origin']),this['_headers']['set']('WebSocket-'+'Location',this['url']);};_0x427ce5(-0x41f2+-0x4*-0x491+0x52ed)['inherits'](_0x3e2e8f,_0x308415);var _0x3fde7f={'close':function(){return 0x17ad+0x7b0+0xfad*-0x2!==this['readyState']&&(this['readyState']=0x3a1*0x5+-0x1*0xd50+-0x2*0x269,this['emit']('close',new _0x308415['CloseEvent'](null,null)),!(-0x338*0x1+0x14bb+-0x1183*0x1));},'parse':function(_0x450d63){this['readyState']>-0x1cbe+0xce9+0xfd6||(this['_reader']['put'](_0x450d63),this['_reader']['eachByte'](function(_0x299fac){var _0x5d9ecc;switch(this['_stage']){case-(0x227f+0x1*-0x15a5+-0xcd9*0x1):this['_body']['push'](_0x299fac),this['_sendHands'+'hakeBody']();break;case 0x21c1+0x452+-0x169*0x1b:this['_parseLead'+'ingByte'](_0x299fac);break;case-0x3a5+0x227d+-0x1ed7:if(this['_length']=(-0x859*0x4+0x1219+0x56*0x2f&_0x299fac)+(-0x1*0x185e+0x1033+-0x7*-0x13d)*this['_length'],this['_closing']&&0x91d*0x4+0x63b*0x2+0x104e*-0x3===this['_length'])return this['close']();-0x10ce+-0x6a0+0x17ee&~_0x299fac&&(-0x1*-0x1406+-0x95*0x32+-0x48a*-0x2===this['_length']?this['_stage']=0x73*0x2+-0x252*0x2+-0x2*-0x1df:(this['_skipped']=0x1b5a+0x7b2+-0x230c,this['_stage']=0x75*-0x7+0x2*0xc07+0x251*-0x9));break;case 0xf*0x1e7+0x1a79*0x1+-0x3700:if(0x147d+-0x129c+-0x1*0xe2===_0x299fac)this['_stage']=-0x1*-0x919+-0x169e+-0xd85*-0x1,_0x5d9ecc=_0x478c67['from'](this['_buffer'])['toString']('utf8',-0x33a+0x273*-0x3+0xa93,this['_buffer']['length']),this['emit']('message',new _0x308415['MessageEve'+'nt'](_0x5d9ecc));else{if(this['_length'])this['_skipped']+=0x3*-0x1fd+-0x9*-0x3b+0x3e5,this['_skipped']===this['_length']&&(this['_stage']=0x1ba6+0x1944+-0xd*0x412);else{if(this['_buffer']['push'](_0x299fac),this['_buffer']['length']>this['_maxLength'])return this['close']();}}}},this));},'frame':function(_0x222089){if(0xb*-0x1ed+0x2461+-0xf32*0x1===this['readyState'])return this['_queue']([_0x222089]);if(this['readyState']>-0x1a77+0x184a*0x1+0x22e)return!(-0x759+-0xf*0x1dd+-0x234d*-0x1);'string'!=typeof _0x222089&&(_0x222089=_0x222089['toString']());var _0x139b4f=_0x478c67['byteLength'](_0x222089),_0x8e1cc4=_0x478c67['allocUnsaf'+'e'](_0x139b4f+(-0x1e5c+-0x53c+0x239a));return _0x8e1cc4[-0x3*-0x3f6+-0x4fe+-0x6e4]=0x3a2*-0x1+-0xd*0x1a+0x4f4,_0x8e1cc4['write'](_0x222089,-0x1252*0x1+0x96+-0x13*-0xef),_0x8e1cc4[_0x8e1cc4['length']-(-0x5eb+0x215e*0x1+-0x1b72)]=-0x5dc+0x1f87+-0x2*0xc56,this['_write'](_0x8e1cc4),!(-0x1*0x14cc+-0x1c*-0x56+0xb64);},'_handshakeResponse':function(){var _0x5a57e4=['HTTP/1.1\x201'+'01\x20Web\x20Soc'+'ket\x20Protoc'+'ol\x20Handsha'+'ke',this['_headers']['toString'](),''];return _0x478c67['from'](_0x5a57e4['join']('\x0d\x0a'),'utf8');},'_parseLeadingByte':function(_0x188b6d){-0x14d6+-0x1b9d+0x30f3&~_0x188b6d?(delete this['_length'],delete this['_skipped'],this['_buffer']=[],this['_stage']=-0x2554+-0x15+-0x256b*-0x1):(this['_length']=0x6da*0x2+0x177a+-0x252e,this['_stage']=0x1*0x2135+-0x5*-0x73+-0x2373);}};for(var _0x468503 in _0x3fde7f)_0x3e2e8f['prototype'][_0x468503]=_0x3fde7f[_0x468503];_0x59860a['exports']=_0x3e2e8f;},0x1922:(_0x531dd5,_0x34a4f9,_0x5eb04d)=>{'use strict';var _0x41b92e=_0x5eb04d(-0x132e+0x1*0x1df+0x2*0xe3e)['Buffer'],_0x1518eb=_0x5eb04d(0x17a0+0x19db+-0x14*0x21e),_0xb24c07=_0x5eb04d(-0x19b5*0x1+-0x23*0xdf+0x44d1),_0x2d3274=_0x5eb04d(0x385+-0x1*-0x2c4a+-0x1489),_0x456ff0=_0x5eb04d(0x103f+0x3059*0x1+-0x1d59),_0x2df36b=function(_0x16aaf9){return parseInt((_0x16aaf9['match'](/[0-9]/g)||[])['join'](''),0x8c0+-0x13bc+0xb06);},_0x1a1dd9=function(_0x5bc44a){return(_0x5bc44a['match'](/ /g)||[])['length'];},_0xdf8554=function(_0x4200bf,_0x286da2,_0x4dbcbd){_0xb24c07['apply'](this,arguments),this['_stage']=-(-0xa91+0x128e+0x2*-0x3fe),this['_body']=[],this['version']='hixie-76',this['_headers']['clear'](),this['_headers']['set']('Upgrade','WebSocket'),this['_headers']['set']('Connection','Upgrade'),this['_headers']['set']('Sec-WebSoc'+'ket-Origin',this['_request']['headers']['origin']),this['_headers']['set']('Sec-WebSoc'+'ket-Locati'+'on',this['url']);};_0x456ff0['inherits'](_0xdf8554,_0xb24c07);var _0x19d4a8={'BODY_SIZE':0x8,'start':function(){return!!_0xb24c07['prototype']['start']['call'](this)&&(this['_started']=!(-0x10b1+0x3*0x84c+-0x833),this['_sendHands'+'hakeBody'](),!(0x857+-0x1c02+-0x3ef*-0x5));},'close':function(){return-0x1596*-0x1+0xece+0x1*-0x2461!==this['readyState']&&(0xa1f*-0x3+0x185c+0x602===this['readyState']&&this['_write'](_0x41b92e['from']([-0xd9f+-0x1dc*0x12+0x3016,-0xd6e+-0xe*0x51+-0x6*-0x2fa])),this['readyState']=-0x1baa+0x1ee8+-0x33b,this['emit']('close',new _0x1518eb['CloseEvent'](null,null)),!(0x1421*0x1+0x34e*-0xa+0xceb));},'_handshakeResponse':function(){var _0x36a6b5=(_0x5e87ba=this['_request']['headers'])['sec-websoc'+'ket-key1'],_0xd8aa5c=_0x5e87ba['sec-websoc'+'ket-key2'];if(!_0x36a6b5)throw new Error('Missing\x20re'+'quired\x20hea'+'der:\x20Sec-W'+'ebSocket-K'+'ey1');if(!_0xd8aa5c)throw new Error('Missing\x20re'+'quired\x20hea'+'der:\x20Sec-W'+'ebSocket-K'+'ey2');var _0x82e802=_0x2df36b(_0x36a6b5),_0x8c383b=_0x1a1dd9(_0x36a6b5),_0x10433d=_0x2df36b(_0xd8aa5c),_0x190d6f=_0x1a1dd9(_0xd8aa5c);if(_0x82e802%_0x8c383b!=0x181*0xd+0x9*-0x346+0x9e9||_0x10433d%_0x190d6f!=-0x1d7*-0x7+0x13eb+-0x20cc)throw new Error('Client\x20sen'+'t\x20invalid\x20'+'Sec-WebSoc'+'ket-Key\x20he'+'aders');this['_keyValues']=[_0x82e802/_0x8c383b,_0x10433d/_0x190d6f];var _0x5e87ba=['HTTP/1.1\x201'+'01\x20WebSock'+'et\x20Protoco'+'l\x20Handshak'+'e',this['_headers']['toString'](),''];return _0x41b92e['from'](_0x5e87ba['join']('\x0d\x0a'),'binary');},'_handshakeSignature':function(){if(this['_body']['length']<this['BODY_SIZE'])return null;var _0x21ddb2=_0x2d3274['createHash']('md5'),_0x32af04=_0x41b92e['allocUnsaf'+'e'](-0x1213+0x1*-0x1c1f+0x2e3a+this['BODY_SIZE']);return _0x32af04['writeUInt3'+'2BE'](this['_keyValues'][-0x119d+-0x16*0xc6+0x22a1],-0x1*-0x1121+0x115b+-0x227c),_0x32af04['writeUInt3'+'2BE'](this['_keyValues'][0x1711+-0x5d7+-0x1*0x1139],-0x5*-0x277+0x59*0x6a+-0x3129),_0x41b92e['from'](this['_body'])['copy'](_0x32af04,-0x901+0xa*0xac+0x251,-0x13c+-0x1*0x123f+0x137b,this['BODY_SIZE']),_0x21ddb2['update'](_0x32af04),_0x41b92e['from'](_0x21ddb2['digest']('binary'),'binary');},'_sendHandshakeBody':function(){if(this['_started']){var _0x2ce060=this['_handshake'+'Signature']();_0x2ce060&&(this['_write'](_0x2ce060),this['_stage']=-0x2bd+-0x105e+-0x43*-0x49,this['_open'](),this['_body']['length']>this['BODY_SIZE']&&this['parse'](this['_body']['slice'](this['BODY_SIZE'])));}},'_parseLeadingByte':function(_0x523f52){if(-0x1*0x421+-0x1d*0x85+0x1431!==_0x523f52)return _0xb24c07['prototype']['_parseLead'+'ingByte']['call'](this,_0x523f52);this['_closing']=!(-0x154f+-0x1b*0x146+0x37b1),this['_length']=-0x241*-0x1+0x1f46*-0x1+0x1d05,this['_stage']=-0x219c+-0x65*0x3a+0x387f;}};for(var _0x17115d in _0x19d4a8)_0xdf8554['prototype'][_0x17115d]=_0x19d4a8[_0x17115d];_0x531dd5['exports']=_0xdf8554;},0xace:_0x124131=>{'use strict';var _0x5deb5b=function(){this['clear']();};_0x5deb5b['prototype']['ALLOWED_DU'+'PLICATES']=['set-cookie','set-cookie'+'2','warning','www-authen'+'ticate'],_0x5deb5b['prototype']['clear']=function(){this['_sent']={},this['_lines']=[];},_0x5deb5b['prototype']['set']=function(_0x55c79f,_0x3085a3){if(void(0x1*-0x15f7+0x1711*0x1+-0x11a)!==_0x3085a3){_0x55c79f=this['_strip'](_0x55c79f),_0x3085a3=this['_strip'](_0x3085a3);var _0x5f7af=_0x55c79f['toLowerCas'+'e']();(!this['_sent']['hasOwnProp'+'erty'](_0x5f7af)||this['ALLOWED_DU'+'PLICATES']['indexOf'](_0x5f7af)>=-0x35+-0x24a7+-0x544*-0x7)&&(this['_sent'][_0x5f7af]=!(-0x1*-0x146+0x2175+-0x20b*0x11),this['_lines']['push'](_0x55c79f+':\x20'+_0x3085a3+'\x0d\x0a'));}},_0x5deb5b['prototype']['toString']=function(){return this['_lines']['join']('');},_0x5deb5b['prototype']['_strip']=function(_0x2b7269){return _0x2b7269['toString']()['replace'](/^ */,'')['replace'](/ *$/,'');},_0x124131['exports']=_0x5deb5b;},0x20f4:(_0x689f79,_0x1a07a8,_0x528a47)=>{'use strict';var _0x47f79c=_0x528a47(0x66*-0x3b+0xbc7+0x16e8)['Buffer'],_0x4050ad=_0x528a47(-0xb47*0x2+0x2950+0x884),_0x14b8ec=_0x528a47(0x543*-0x5+0x3f8+0x3996),_0x3ee74d=_0x528a47(-0x24*0xb1+-0xa*0x323+0xf31*0x5),_0x1b7628=_0x528a47(0x1*0x18c7+0x1d9+-0x3*0x67f),_0x51b6e2=_0x528a47(0x9d*0x26+0x2e3*0x5+-0x1*0x1807),_0x4bc871=_0x528a47(-0x18e4+0x1b26+-0x7f1*-0x2),_0x3117b4=function(_0x17dc89,_0x34f518,_0x1c1a0b){if(_0x1b7628['apply'](this,arguments),this['_extension'+'s']=new _0x3ee74d(),this['_stage']=-0x35*-0x6d+0x7*-0x215+-0x1f*0x42,this['_masking']=this['_options']['masking'],this['_protocols']=this['_options']['protocols']||[],this['_requireMa'+'sking']=this['_options']['requireMas'+'king'],this['_pingCallb'+'acks']={},'string'==typeof this['_protocols']&&(this['_protocols']=this['_protocols']['split'](/ *, */)),this['_request']){var _0x218a72=this['_request']['headers']['sec-websoc'+'ket-protoc'+'ol'],_0x5b64b7=this['_protocols'];void(0xa5*-0x15+-0x104b+-0x1dd4*-0x1)!==_0x218a72&&('string'==typeof _0x218a72&&(_0x218a72=_0x218a72['split'](/ *, */)),this['protocol']=_0x218a72['filter'](function(_0x1478ed){return _0x5b64b7['indexOf'](_0x1478ed)>=0x14*0x71+-0x85d*-0x1+-0x9*0x1e9;})[0x189b+-0x2*0xa51+-0x3f9]),this['version']='hybi-'+_0x3117b4['VERSION'];}};_0x14b8ec['inherits'](_0x3117b4,_0x1b7628),_0x3117b4['VERSION']='13',_0x3117b4['mask']=function(_0x471ac6,_0x4d2058,_0x22b55e){if(!_0x4d2058||-0xe0b*-0x1+0x8ea+-0x16f5*0x1===_0x4d2058['length'])return _0x471ac6;_0x22b55e=_0x22b55e||-0x2e*0xbf+-0x4*0x62b+0x3afe;for(var _0x311f95=0x1*0x1a69+-0x1dca*0x1+0x361,_0x2d6850=_0x471ac6['length']-_0x22b55e;_0x311f95<_0x2d6850;_0x311f95++)_0x471ac6[_0x22b55e+_0x311f95]=_0x471ac6[_0x22b55e+_0x311f95]^_0x4d2058[_0x311f95%(0x1*-0x221f+0x1*-0x99f+-0x1*-0x2bc2)];return _0x471ac6;},_0x3117b4['generateAc'+'cept']=function(_0x45dc79){var _0x4f9fb5=_0x4050ad['createHash']('sha1');return _0x4f9fb5['update'](_0x45dc79+_0x3117b4['GUID']),_0x4f9fb5['digest']('base64');},_0x3117b4['GUID']='258EAFA5-E'+'914-47DA-9'+'5CA-C5AB0D'+'C85B11';var _0x5d5957={'FIN':0x80,'MASK':0x80,'RSV1':0x40,'RSV2':0x20,'RSV3':0x10,'OPCODE':0xf,'LENGTH':0x7f,'OPCODES':{'continuation':0x0,'text':0x1,'binary':0x2,'close':0x8,'ping':0x9,'pong':0xa},'OPCODE_CODES':[-0x9fc+0x25*-0x109+0x3049,-0x3*0x479+-0x1*0xb6a+-0xbb*-0x22,-0x53d+0xcb*-0x3+0x7a0,-0xcd5+0xd16+-0x39,-0x2564+0x69b*0x5+0x466,0x7b2+-0x1ec3+0x1*0x171b],'MESSAGE_OPCODES':[-0x1a5*0x1+-0xeed*0x1+-0x25e*-0x7,-0x1135*-0x1+-0x145a+0x326,0x161*-0x1a+0x1a0a+-0x9d2*-0x1],'OPENING_OPCODES':[0x1*0x56b+-0x3*0xa11+0x18c9,0x4*-0x742+-0x7*-0x3e5+0x7*0x41],'ERRORS':{'normal_closure':0x3e8,'going_away':0x3e9,'protocol_error':0x3ea,'unacceptable':0x3eb,'encoding_error':0x3ef,'policy_violation':0x3f0,'too_large':0x3f1,'extension_error':0x3f2,'unexpected_condition':0x3f3},'ERROR_CODES':[0x73c+-0x164e+0x12fa,0x6be*0x2+-0x219+0x16*-0x57,0x1de*0xa+0xb*0x6d+-0x1371,-0x84b*-0x1+0x209a+-0x24fa*0x1,-0x7de+-0x1f40+0x2b0d,-0x22eb+-0xc97+0x3372,0x2*0x1163+-0x4*0x2d1+-0x1391*0x1,0x313+0x24*0x8d+-0x12f5,0x94*0x17+0x16aa*0x1+-0x2003],'DEFAULT_ERROR_CODE':0x3e8,'MIN_RESERVED_ERROR':0xbb8,'MAX_RESERVED_ERROR':0x1387,'UTF8_MATCH':/^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,'addExtension':function(_0x282cc2){return this['_extension'+'s']['add'](_0x282cc2),!(0xac*-0x34+-0x2679+0x4969);},'parse':function(_0x1889ee){this['_reader']['put'](_0x1889ee);for(var _0x57b63c=!(0x2*-0xaaf+0x624+0xf3a);_0x57b63c;)switch(this['_stage']){case 0x19f7+-0x117d+-0x43d*0x2:(_0x57b63c=this['_reader']['read'](0x15f+-0x11*-0x11f+-0x6cf*0x3))&&this['_parseOpco'+'de'](_0x57b63c[-0x6cd+-0x35f*0x2+-0xd8b*-0x1]);break;case-0x192c*-0x1+-0x264a+0xd1f*0x1:(_0x57b63c=this['_reader']['read'](-0x1*-0x176c+0x1487+-0x2bf2))&&this['_parseLeng'+'th'](_0x57b63c[-0x7*-0x3cd+0x995*0x3+-0x375a]);break;case-0x2301+-0x648+0x294b:(_0x57b63c=this['_reader']['read'](this['_frame']['lengthByte'+'s']))&&this['_parseExte'+'ndedLength'](_0x57b63c);break;case 0x60b+0x1f35+-0x1*0x253d:(_0x57b63c=this['_reader']['read'](-0x2*0x382+-0xfd9+-0x1*-0x16e1))&&(this['_stage']=-0x3*0x53b+-0x90a+0x18bf,this['_frame']['maskingKey']=_0x57b63c);break;case-0x7*0x32f+0x4d4*-0x6+0x1*0x3345:(_0x57b63c=this['_reader']['read'](this['_frame']['length']))&&(this['_stage']=-0x46d+0x1884+-0x1417,this['_emitFrame'](_0x57b63c));break;default:_0x57b63c=null;}},'text':function(_0x5bdf63){return!(this['readyState']>0x12e4+-0x1cd*-0x12+-0x334d*0x1)&&this['frame'](_0x5bdf63,'text');},'binary':function(_0x10e3e5){return!(this['readyState']>-0xe17*0x1+0x1a3f*0x1+-0xc27)&&this['frame'](_0x10e3e5,'binary');},'ping':function(_0x99ccb5,_0x6a6a88){return!(this['readyState']>0x37*-0x70+0x4*-0x1ee+0x1fc9)&&(_0x99ccb5=_0x99ccb5||'',_0x6a6a88&&(this['_pingCallb'+'acks'][_0x99ccb5]=_0x6a6a88),this['frame'](_0x99ccb5,'ping'));},'pong':function(_0x478a6e){return!(this['readyState']>-0x639+0xd*0x1e7+-0x1281)&&(_0x478a6e=_0x478a6e||'',this['frame'](_0x478a6e,'pong'));},'close':function(_0x52d1ae,_0x361136){return _0x52d1ae=_0x52d1ae||'',_0x361136=_0x361136||this['ERRORS']['normal_clo'+'sure'],this['readyState']<=0x1a82+-0x21*-0x3d+-0x225f?(this['readyState']=0x1621+0x1*0xf25+-0x2543,this['emit']('close',new _0x1b7628['CloseEvent'](_0x361136,_0x52d1ae)),!(0x9*-0x323+0xa7*-0x16+-0x2a95*-0x1)):0x1*0x20e3+0x7*-0x4a3+-0x1*0x6d===this['readyState']&&(this['readyState']=0x163*-0x18+-0xe5*-0x13+0x104b,this['_extension'+'s']['close'](function(){this['frame'](_0x52d1ae,'close',_0x361136);},this),!(-0x96a+-0xbb*-0x1d+-0xbc5));},'frame':function(_0x743702,_0x5b0576,_0x180d1f){if(this['readyState']<=0x31*-0x35+-0x205f+0x2a84)return this['_queue']([_0x743702,_0x5b0576,_0x180d1f]);if(this['readyState']>-0x1*-0x26ff+-0x2666*0x1+-0x97)return!(-0x17c+0xe2e+-0xcb1);_0x743702 instanceof Array&&(_0x743702=_0x47f79c['from'](_0x743702)),'number'==typeof _0x743702&&(_0x743702=_0x743702['toString']());var _0x541fcf,_0x397ac8,_0x2cad51=new _0x4bc871(),_0x291173='string'==typeof _0x743702;_0x2cad51['rsv1']=_0x2cad51['rsv2']=_0x2cad51['rsv3']=!(-0x5d1*0x5+0x5df*0x6+-0x189*0x4),_0x2cad51['opcode']=this['OPCODES'][_0x5b0576||(_0x291173?'text':'binary')],_0x541fcf=_0x291173?_0x47f79c['from'](_0x743702,'utf8'):_0x743702,_0x180d1f&&(_0x397ac8=_0x541fcf,(_0x541fcf=_0x47f79c['allocUnsaf'+'e'](0x1*-0x1e8f+-0x5*-0x432+0x997+_0x397ac8['length']))['writeUInt1'+'6BE'](_0x180d1f,0x869+0x83c+-0x1*0x10a5),_0x397ac8['copy'](_0x541fcf,0x23c7+-0x33c*0x8+-0x9e5)),_0x2cad51['data']=_0x541fcf;var _0x114efc=function(_0x45e8f7){var _0x588661=new _0x51b6e2();_0x588661['final']=!(0xcb8+-0x1*0xd19+0x61*0x1),_0x588661['rsv1']=_0x45e8f7['rsv1'],_0x588661['rsv2']=_0x45e8f7['rsv2'],_0x588661['rsv3']=_0x45e8f7['rsv3'],_0x588661['opcode']=_0x45e8f7['opcode'],_0x588661['masked']=!!this['_masking'],_0x588661['length']=_0x45e8f7['data']['length'],_0x588661['payload']=_0x45e8f7['data'],_0x588661['masked']&&(_0x588661['maskingKey']=_0x4050ad['randomByte'+'s'](-0x13*-0x89+0xe*-0x119+0xf*0x59)),this['_sendFrame'](_0x588661);};return this['MESSAGE_OP'+'CODES']['indexOf'](_0x2cad51['opcode'])>=-0xa4e*0x1+0x1f*-0x5a+0x2*0xa9a?this['_extension'+'s']['processOut'+'goingMessa'+'ge'](_0x2cad51,function(_0x4411a5,_0x362a00){if(_0x4411a5)return this['_fail']('extension_'+'error',_0x4411a5['message']);_0x114efc['call'](this,_0x362a00);},this):_0x114efc['call'](this,_0x2cad51),!(0x1429+0xf*-0x118+-0x3c1);},'_sendFrame':function(_0x1495f0){var _0x2d4ca1=_0x1495f0['length'],_0xae8e55=_0x2d4ca1<=-0x1a52+-0x2*0x46+0x1b5b?-0x2436+0x221*0x6+0x1772:_0x2d4ca1<=-0x3628+0x1df58+-0xa931?-0x13*-0x5+-0x12c8*0x2+0x2535:-0x82*-0xb+-0x77b*-0x2+-0x1482,_0x4f7917=_0xae8e55+(_0x1495f0['masked']?-0x24+0x749*-0x3+0x31*0x73:0x3*0xc6e+-0x2b7*-0x7+-0x1*0x384b),_0x406bdf=_0x47f79c['allocUnsaf'+'e'](_0x4f7917+_0x2d4ca1),_0x500b7c=_0x1495f0['masked']?this['MASK']:-0x250b+0x266d+-0x162;_0x406bdf[-0x1367*-0x1+-0x2313+0xfac]=(_0x1495f0['final']?this['FIN']:-0x10f4+0x2454+-0x4*0x4d8)|(_0x1495f0['rsv1']?this['RSV1']:-0x19aa+0x18c0+0x27*0x6)|(_0x1495f0['rsv2']?this['RSV2']:-0xc05+-0x1ca5*0x1+0x28aa)|(_0x1495f0['rsv3']?this['RSV3']:-0x1b12+-0x1*-0x1349+-0x1*-0x7c9)|_0x1495f0['opcode'],_0x2d4ca1<=0x173b*-0x1+0x1*0x10f1+0x6c7?_0x406bdf[0x212e+0x132f+-0x345c]=_0x500b7c|_0x2d4ca1:_0x2d4ca1<=0x1d132*-0x1+0x760f+0x25b22?(_0x406bdf[0x116a+-0x2*-0x103d+-0x31e3]=0x642+-0x24f5+-0x1*-0x1f31|_0x500b7c,_0x406bdf['writeUInt1'+'6BE'](_0x2d4ca1,-0xa*-0x313+-0x205+0x1*-0x1cb7)):(_0x406bdf[0x8*0x32+-0x1*-0xc77+-0xe06]=-0x310+0x15a*-0x4+0x8f7|_0x500b7c,_0x406bdf['writeUInt3'+'2BE'](Math['floor'](_0x2d4ca1/(-0x34782b10+-0xfdc608d0*0x2+0x330043cb0)),0x1*0x1a1d+-0x1f5e+0x543),_0x406bdf['writeUInt3'+'2BE'](_0x2d4ca1%(-0x619824cb*-0x4+-0x1cdb3c*-0x1e2+0x96*-0x1420ff6),0x1164+0x5f4+-0x1752)),_0x1495f0['payload']['copy'](_0x406bdf,_0x4f7917),_0x1495f0['masked']&&(_0x1495f0['maskingKey']['copy'](_0x406bdf,_0xae8e55),_0x3117b4['mask'](_0x406bdf,_0x1495f0['maskingKey'],_0x4f7917)),this['_write'](_0x406bdf);},'_handshakeResponse':function(){var _0x10d4af=this['_request']['headers']['sec-websoc'+'ket-key'],_0x491e32=this['_request']['headers']['sec-websoc'+'ket-versio'+'n'];if(_0x491e32!==_0x3117b4['VERSION'])throw new Error('Unsupporte'+'d\x20WebSocke'+'t\x20version:'+'\x20'+_0x491e32);if('string'!=typeof _0x10d4af)throw new Error('Missing\x20ha'+'ndshake\x20re'+'quest\x20head'+'er:\x20Sec-We'+'bSocket-Ke'+'y');this['_headers']['set']('Upgrade','websocket'),this['_headers']['set']('Connection','Upgrade'),this['_headers']['set']('Sec-WebSoc'+'ket-Accept',_0x3117b4['generateAc'+'cept'](_0x10d4af)),this['protocol']&&this['_headers']['set']('Sec-WebSoc'+'ket-Protoc'+'ol',this['protocol']);var _0x549b75=this['_extension'+'s']['generateRe'+'sponse'](this['_request']['headers']['sec-websoc'+'ket-extens'+'ions']);_0x549b75&&this['_headers']['set']('Sec-WebSoc'+'ket-Extens'+'ions',_0x549b75);var _0xb4ef60=['HTTP/1.1\x201'+'01\x20Switchi'+'ng\x20Protoco'+'ls',this['_headers']['toString'](),''];return _0x47f79c['from'](_0xb4ef60['join']('\x0d\x0a'),'utf8');},'_shutdown':function(_0x58705c,_0x4a1e60,_0x544756){delete this['_frame'],delete this['_message'],this['_stage']=-0x22b4+-0x2ee+0x25a7;var _0x329075=-0x1*-0xd1+-0xca1+0xbd1===this['readyState'];this['readyState']=0xc*0x284+-0x2*0x11c5+0x55c,this['_extension'+'s']['close'](function(){_0x329075&&this['frame'](_0x4a1e60,'close',_0x58705c),this['readyState']=-0x1d*-0xa9+0x285+-0x17*0xf1,_0x544756&&this['emit']('error',new Error(_0x4a1e60)),this['emit']('close',new _0x1b7628['CloseEvent'](_0x58705c,_0x4a1e60));},this);},'_fail':function(_0x5dd758,_0x5cea37){this['readyState']>-0x266f+-0x1*-0xf6e+-0x24d*-0xa||this['_shutdown'](this['ERRORS'][_0x5dd758],_0x5cea37,!(0x1166+0xc95+-0x1dfb*0x1));},'_parseOpcode':function(_0x755302){var _0x2530a4=[this['RSV1'],this['RSV2'],this['RSV3']]['map'](function(_0x56b0f1){return(_0x755302&_0x56b0f1)===_0x56b0f1;}),_0x5f27db=this['_frame']=new _0x51b6e2();return _0x5f27db['final']=(_0x755302&this['FIN'])===this['FIN'],_0x5f27db['rsv1']=_0x2530a4[0x14b7+0x195b*-0x1+0x3*0x18c],_0x5f27db['rsv2']=_0x2530a4[0xe51*-0x1+-0x116b+0x19*0x145],_0x5f27db['rsv3']=_0x2530a4[0x22ab+-0xd7a+-0x152f],_0x5f27db['opcode']=_0x755302&this['OPCODE'],this['_stage']=-0x3*-0x9a5+0x8*0x3d7+-0x3ba6,this['_extension'+'s']['validFrame'+'Rsv'](_0x5f27db)?this['OPCODE_COD'+'ES']['indexOf'](_0x5f27db['opcode'])<0x538*-0x6+-0x15c9*-0x1+0x987*0x1?this['_fail']('protocol_e'+'rror','Unrecogniz'+'ed\x20frame\x20o'+'pcode:\x20'+_0x5f27db['opcode']):this['MESSAGE_OP'+'CODES']['indexOf'](_0x5f27db['opcode'])<0x11b+0x1313+-0x142e&&!_0x5f27db['final']?this['_fail']('protocol_e'+'rror','Received\x20f'+'ragmented\x20'+'control\x20fr'+'ame:\x20opcod'+'e\x20=\x20'+_0x5f27db['opcode']):this['_message']&&this['OPENING_OP'+'CODES']['indexOf'](_0x5f27db['opcode'])>=0x2bd*-0xb+0x1*-0x191d+-0x7e4*-0x7?this['_fail']('protocol_e'+'rror','Received\x20n'+'ew\x20data\x20fr'+'ame\x20but\x20pr'+'evious\x20con'+'tinuous\x20fr'+'ame\x20is\x20unf'+'inished'):void(0x21cc+-0x2*0x301+0xde5*-0x2):this['_fail']('protocol_e'+'rror','One\x20or\x20mor'+'e\x20reserved'+'\x20bits\x20are\x20'+'on:\x20reserv'+'ed1\x20=\x20'+(_0x5f27db['rsv1']?0xf2b+0x1*0xef+0x1*-0x1019:0x8*-0x100+0x791+-0x6f*-0x1)+(',\x20reserved'+'2\x20=\x20')+(_0x5f27db['rsv2']?0x1d46+0xd33+0x3*-0xe28:-0x1b*-0x163+-0x71*0x48+-0x5a9)+(',\x20reserved'+'3\x20=\x20')+(_0x5f27db['rsv3']?0x3*0x4fd+-0x14c5+-0x1*-0x5cf:-0x543*-0x7+-0x1311*-0x1+-0x10e*0x35));},'_parseLength':function(_0x2539f7){var _0x42fb38=this['_frame'];if(_0x42fb38['masked']=(_0x2539f7&this['MASK'])===this['MASK'],_0x42fb38['length']=_0x2539f7&this['LENGTH'],_0x42fb38['length']>=0x38*-0x43+-0x1*0x88a+0x1732&&_0x42fb38['length']<=-0x1622+0x343*-0x3+0x2068){if(this['_stage']=_0x42fb38['masked']?-0x1143*-0x1+-0x167*0x2+0x1*-0xe72:-0x125b+-0x24e7+0x3746,!this['_checkFram'+'eLength']())return;}else this['_stage']=-0x12*0x83+-0x9cc+0x1*0x1304,_0x42fb38['lengthByte'+'s']=-0x1159+0x5*0x16+-0x1*-0x1169===_0x42fb38['length']?0x11d*0x13+0xaf0+0x2b*-0xbf:0xfdf*-0x1+-0x2*0x1297+-0x6b*-0x7f;if(this['_requireMa'+'sking']&&!_0x42fb38['masked'])return this['_fail']('unacceptab'+'le','Received\x20u'+'nmasked\x20fr'+'ame\x20but\x20ma'+'sking\x20is\x20r'+'equired');},'_parseExtendedLength':function(_0x2c84db){var _0x1ba734=this['_frame'];if(_0x1ba734['length']=this['_readUInt'](_0x2c84db),this['_stage']=_0x1ba734['masked']?-0x230d+-0x1caa+0x3fba:-0x1*-0x2287+0x26c5+0x24a4*-0x2,this['MESSAGE_OP'+'CODES']['indexOf'](_0x1ba734['opcode'])<0x154d+-0x1d67+0x81a&&_0x1ba734['length']>-0x2538+-0x19*0x9d+0x350a)return this['_fail']('protocol_e'+'rror','Received\x20c'+'ontrol\x20fra'+'me\x20having\x20'+'too\x20long\x20p'+'ayload:\x20'+_0x1ba734['length']);this['_checkFram'+'eLength']();},'_checkFrameLength':function(){return!((this['_message']?this['_message']['length']:-0x1c68+-0xda*-0x17+0x1*0x8d2)+this['_frame']['length']>this['_maxLength']&&(this['_fail']('too_large','WebSocket\x20'+'frame\x20leng'+'th\x20too\x20lar'+'ge'),0xf12+0x161d+-0x252e));},'_emitFrame':function(_0x95f8b0){var _0x598746,_0x23eed4,_0x1c9808,_0x17521c,_0x4df8b3,_0x169d75=this['_frame'],_0x1759a6=_0x169d75['payload']=_0x3117b4['mask'](_0x95f8b0,_0x169d75['maskingKey']),_0x2aacb2=_0x169d75['opcode'];if(delete this['_frame'],_0x2aacb2===this['OPCODES']['continuati'+'on']){if(!this['_message'])return this['_fail']('protocol_e'+'rror','Received\x20u'+'nexpected\x20'+'continuati'+'on\x20frame');this['_message']['pushFrame'](_0x169d75);}if(_0x2aacb2!==this['OPCODES']['text']&&_0x2aacb2!==this['OPCODES']['binary']||(this['_message']=new _0x4bc871(),this['_message']['pushFrame'](_0x169d75)),_0x169d75['final']&&this['MESSAGE_OP'+'CODES']['indexOf'](_0x2aacb2)>=0x1081+-0x1485+0x404)return this['_emitMessa'+'ge'](this['_message']);_0x2aacb2===this['OPCODES']['close']&&(_0x23eed4=_0x1759a6['length']>=0x1f4f+0x280+0x1*-0x21cd?_0x1759a6['readUInt16'+'BE'](0x1*0x17b9+0x1011+-0x27ca):null,_0x1c9808=_0x1759a6['length']>0x3e8+-0x1*-0x1d8d+0x2173*-0x1?this['_encode'](_0x1759a6['slice'](-0x1337+-0x1ef*-0x13+-0x4*0x461)):null,-0x43b+-0x1*0x1e4a+-0x1*-0x2285!==_0x1759a6['length']&&!(null!==_0x23eed4&&_0x23eed4>=this['MIN_RESERV'+'ED_ERROR']&&_0x23eed4<=this['MAX_RESERV'+'ED_ERROR'])&&this['ERROR_CODE'+'S']['indexOf'](_0x23eed4)<0xe8*0x19+-0x3*0x76d+-0x61&&(_0x23eed4=this['ERRORS']['protocol_e'+'rror']),(_0x1759a6['length']>-0x8c2+0xd03+-0x3c4||_0x1759a6['length']>0x3*-0x2b6+-0x1cf1+0x35f*0xb&&!_0x1c9808)&&(_0x23eed4=this['ERRORS']['protocol_e'+'rror']),this['_shutdown'](_0x23eed4||this['DEFAULT_ER'+'ROR_CODE'],_0x1c9808||'')),_0x2aacb2===this['OPCODES']['ping']&&(this['frame'](_0x1759a6,'pong'),this['emit']('ping',new _0x1b7628['PingEvent'](_0x1759a6['toString']()))),_0x2aacb2===this['OPCODES']['pong']&&(_0x4df8b3=(_0x17521c=this['_pingCallb'+'acks'])[_0x598746=this['_encode'](_0x1759a6)],delete _0x17521c[_0x598746],_0x4df8b3&&_0x4df8b3(),this['emit']('pong',new _0x1b7628['PongEvent'](_0x1759a6['toString']())));},'_emitMessage':function(_0x3376a3){(_0x3376a3=this['_message'])['read'](),delete this['_message'],this['_extension'+'s']['processInc'+'omingMessa'+'ge'](_0x3376a3,function(_0x56d1c8,_0x343273){if(_0x56d1c8)return this['_fail']('extension_'+'error',_0x56d1c8['message']);var _0x49e759=_0x343273['data'];if(_0x343273['opcode']===this['OPCODES']['text']&&(_0x49e759=this['_encode'](_0x49e759)),null===_0x49e759)return this['_fail']('encoding_e'+'rror','Could\x20not\x20'+'decode\x20a\x20t'+'ext\x20frame\x20'+'as\x20UTF-8');this['emit']('message',new _0x1b7628['MessageEve'+'nt'](_0x49e759));},this);},'_encode':function(_0x5afe5a){try{var _0x2eff64=_0x5afe5a['toString']('binary',-0x144b+-0x131a+-0x2765*-0x1,_0x5afe5a['length']);if(!this['UTF8_MATCH']['test'](_0x2eff64))return null;}catch(_0x1b4ed6){}return _0x5afe5a['toString']('utf8',-0x1*0x189e+-0xe01+0x269f,_0x5afe5a['length']);},'_readUInt':function(_0x2df179){return-0x270a+0xc09+0x1b03===_0x2df179['length']?_0x2df179['readUInt16'+'BE'](0x1bb3+0x84e*-0x1+-0x1365):(0x8*0x3ab1a3f+-0x9c2ee308+0x17ed61110)*_0x2df179['readUInt32'+'BE'](0x1*0x2113+-0x6d9*-0x2+-0x3*0xf97)+_0x2df179['readUInt32'+'BE'](-0x9b*-0x18+-0x13cd+-0x3*-0x1c3);}};for(var _0xc1f3a9 in _0x5d5957)_0x3117b4['prototype'][_0xc1f3a9]=_0x5d5957[_0xc1f3a9];_0x689f79['exports']=_0x3117b4;},0xdb6:_0x295391=>{'use strict';var _0x5ac948=function(){},_0x1c7d35={'final':!(0xe7a+-0x2a2*0x1+-0xbd7),'rsv1':!(-0x1be3+-0x1*-0x227a+0x2*-0x34b),'rsv2':!(0x210f+-0x1*-0xe43+-0x2f51),'rsv3':!(-0xd*-0x2c5+-0x2153+-0x2ad),'opcode':null,'masked':!(0x1e8c+0xe41+0x3d*-0xbc),'maskingKey':null,'lengthBytes':0x1,'length':0x0,'payload':null};for(var _0x27e584 in _0x1c7d35)_0x5ac948['prototype'][_0x27e584]=_0x1c7d35[_0x27e584];_0x295391['exports']=_0x5ac948;},0x1224:(_0x31b811,_0x34b5fa,_0x171beb)=>{'use strict';var _0x554bbc=_0x171beb(0x1*-0xfb4+-0xdd4+0x11*0x265)['Buffer'],_0x4545d9=function(){this['rsv1']=!(-0x21*0x3e+-0x1597+0x1d96),this['rsv2']=!(-0x1b1b+0x16*-0x8c+-0x686*-0x6),this['rsv3']=!(-0xd46+-0x24aa+-0x1*-0x31f1),this['opcode']=null,this['length']=-0x13a4+0x1c*-0xcb+0x29d8,this['_chunks']=[];},_0x257e0c={'read':function(){return this['data']=this['data']||_0x554bbc['concat'](this['_chunks'],this['length']);},'pushFrame':function(_0x3789ef){this['rsv1']=this['rsv1']||_0x3789ef['rsv1'],this['rsv2']=this['rsv2']||_0x3789ef['rsv2'],this['rsv3']=this['rsv3']||_0x3789ef['rsv3'],null===this['opcode']&&(this['opcode']=_0x3789ef['opcode']),this['_chunks']['push'](_0x3789ef['payload']),this['length']+=_0x3789ef['length'];}};for(var _0x74a1e in _0x257e0c)_0x4545d9['prototype'][_0x74a1e]=_0x257e0c[_0x74a1e];_0x31b811['exports']=_0x4545d9;},0xf9c:(_0x5b0c78,_0x2025de,_0x5c5d68)=>{'use strict';var _0x91034f=_0x5c5d68(0x152a+-0x2b*-0x18+-0xe05*0x1)['Buffer'],_0x324adb=_0x5c5d68(0x1*-0xbd3+0x11*0x3a+0x1094)['Stream'],_0x32236d=_0x5c5d68(-0x1*0x357d+-0x1300+0x63e5),_0x4a8d4c=_0x5c5d68(-0x238f+-0x5*0x51e+-0x1*-0x6064),_0x1a392a=_0x5c5d68(0x1*-0xeae+0x17*0x7+-0x10*-0x153),_0x2714aa=_0x5c5d68(-0x1*-0x1967+-0x17*0x6f+0x94*-0x8),_0x231b9f=_0x5c5d68(-0x1e0e+-0x1a5*-0x1e+0x807),_0x307d20={'ws:':0x50,'wss:':0x1bb},_0x35e1fe=function(_0x5d7f93,_0x58e89b,_0x20cec2){this['_client']=_0x5d7f93,this['_http']=new _0x231b9f('response'),this['_origin']='object'==typeof _0x5d7f93['url']?_0x5d7f93['url']:_0x32236d['parse'](_0x5d7f93['url']),this['_url']='object'==typeof _0x58e89b?_0x58e89b:_0x32236d['parse'](_0x58e89b),this['_options']=_0x20cec2||{},this['_state']=0x20d9+-0x167*-0x10+-0x3749,this['readable']=this['writable']=!(0x25a1+0x109*0x2+-0x27b3*0x1),this['_paused']=!(-0x89f*0x3+0x427*0x9+-0xb81),this['_headers']=new _0x2714aa(),this['_headers']['set']('Host',this['_origin']['host']),this['_headers']['set']('Connection','keep-alive'),this['_headers']['set']('Proxy-Conn'+'ection','keep-alive');var _0x5cc7f9=this['_url']['auth']&&_0x91034f['from'](this['_url']['auth'],'utf8')['toString']('base64');_0x5cc7f9&&this['_headers']['set']('Proxy-Auth'+'orization','Basic\x20'+_0x5cc7f9);};_0x4a8d4c['inherits'](_0x35e1fe,_0x324adb);var _0x34c916={'setHeader':function(_0xc2b882,_0x3cdcae){return-0xf4a+-0xc7*0x27+0x1*0x2d9b===this['_state']&&(this['_headers']['set'](_0xc2b882,_0x3cdcae),!(0x586+0x2649+-0x8c3*0x5));},'start':function(){if(0x566*0x5+-0x32*0xbe+0xa1e!==this['_state'])return!(0x1454+-0x1206*0x1+-0x24d);this['_state']=-0x1cd9+-0x2696*-0x1+0x164*-0x7;var _0x38f763=this['_origin'],_0x4afe53=_0x38f763['port']||_0x307d20[_0x38f763['protocol']],_0x519069=['CONNECT\x20'+_0x38f763['hostname']+':'+_0x4afe53+'\x20HTTP/1.1',this['_headers']['toString'](),''];return this['emit']('data',_0x91034f['from'](_0x519069['join']('\x0d\x0a'),'utf8')),!(-0x2309+-0x10b*0x19+0x3d1c);},'pause':function(){this['_paused']=!(0x132c+-0x224f*-0x1+-0x357b);},'resume':function(){this['_paused']=!(-0x3*0x21b+-0x401*0x3+-0x1255*-0x1),this['emit']('drain');},'write':function(_0x4d33ab){if(!this['writable'])return!(-0x1*-0x26df+0x14ec+-0x1de5*0x2);if(this['_http']['parse'](_0x4d33ab),!this['_http']['isComplete']())return!this['_paused'];if(this['statusCode']=this['_http']['statusCode'],this['headers']=this['_http']['headers'],0x6cc*0x1+0x1b*0x95+-0x15bb===this['statusCode'])this['emit']('connect',new _0x1a392a['ConnectEve'+'nt']());else{var _0x20b9d6='Can\x27t\x20esta'+'blish\x20a\x20co'+'nnection\x20t'+'o\x20the\x20serv'+'er\x20at\x20'+this['_origin']['href'];this['emit']('error',new Error(_0x20b9d6));}return this['end'](),!this['_paused'];},'end':function(_0x279b8b){this['writable']&&(void(-0x2471+-0x13bf+0xe8*0x3e)!==_0x279b8b&&this['write'](_0x279b8b),this['readable']=this['writable']=!(-0x21ae+0xe46+0x1369),this['emit']('close'),this['emit']('end'));},'destroy':function(){this['end']();}};for(var _0x52604c in _0x34c916)_0x35e1fe['prototype'][_0x52604c]=_0x34c916[_0x52604c];_0x5b0c78['exports']=_0x35e1fe;},0xcb1:(_0x3a8f0e,_0x35c1fc,_0xa5c3c7)=>{'use strict';var _0x581a1c=_0xa5c3c7(-0x1d3d+0x21ff*-0x1+0x627b),_0x1c182d=_0xa5c3c7(0x3*0x4af+0x1b61+-0xf*0xf1),_0x21d60e=_0xa5c3c7(-0x1*-0x1544+0x2*-0xe7f+-0x5*-0x2f9),_0x42c208=_0xa5c3c7(-0xe75+-0x8a2+0x23b6*0x1),_0x4965dd=_0xa5c3c7(0x7*-0x1c3+-0x1b59+0x40d0),_0x1ab27f=_0xa5c3c7(-0xd6*0x17+0x184d+0x3d*0x75),_0x516fb2=function(_0x36ca54){_0x21d60e['call'](this,null,null,_0x36ca54),this['_http']=new _0x1c182d('request');};_0x581a1c['inherits'](_0x516fb2,_0x21d60e);var _0x467b3c={'EVENTS':['open','message','error','close','ping','pong'],'_bindEventListeners':function(){this['messages']['on']('error',function(){}),this['on']('error',function(){});},'parse':function(_0x3e0e58){if(this['_delegate'])return this['_delegate']['parse'](_0x3e0e58);if(this['_http']['parse'](_0x3e0e58),this['_http']['isComplete']()){this['method']=this['_http']['method'],this['url']=this['_http']['url'],this['headers']=this['_http']['headers'],this['body']=this['_http']['body'];var _0x3a126a=this;this['_delegate']=_0x516fb2['http'](this,this['_options']),this['_delegate']['messages']=this['messages'],this['_delegate']['io']=this['io'],this['_open'](),this['EVENTS']['forEach'](function(_0x6cd6eb){this['_delegate']['on'](_0x6cd6eb,function(_0x36ed1e){_0x3a126a['emit'](_0x6cd6eb,_0x36ed1e);});},this),this['protocol']=this['_delegate']['protocol'],this['version']=this['_delegate']['version'],this['parse'](this['_http']['body']),this['emit']('connect',new _0x21d60e['ConnectEve'+'nt']());}},'_open':function(){this['__queue']['forEach'](function(_0x3af6d1){this['_delegate'][_0x3af6d1[-0x1c6*-0x6+-0x291*-0x3+0x5*-0x3ab]]['apply'](this['_delegate'],_0x3af6d1[-0xc54+0x2*-0x8f9+0x17*0x151]);},this),this['__queue']=[];}};for(var _0x2098b5 in(['addExtensi'+'on','setHeader','start','frame','text','binary','ping','close']['forEach'](function(_0x345edf){_0x467b3c[_0x345edf]=function(){return this['_delegate']?this['_delegate'][_0x345edf]['apply'](this['_delegate'],arguments):(this['__queue']['push']([_0x345edf,arguments]),!(-0x2f*-0x16+0x4d*0x53+0x339*-0x9));};}),_0x467b3c))_0x516fb2['prototype'][_0x2098b5]=_0x467b3c[_0x2098b5];_0x516fb2['isSecureRe'+'quest']=function(_0x548fc4){if(_0x548fc4['connection']&&void(0x4*0x7d+0x25b+-0x44f)!==_0x548fc4['connection']['authorized'])return!(-0x1caf+0x748+0x1567);if(_0x548fc4['socket']&&_0x548fc4['socket']['secure'])return!(-0x1aaf+0x20b7+-0x608);var _0x95bd04=_0x548fc4['headers'];return!!_0x95bd04&&('on'===_0x95bd04['https']||'on'===_0x95bd04['x-forwarde'+'d-ssl']||'https'===_0x95bd04['x-forwarde'+'d-scheme']||'https'===_0x95bd04['x-forwarde'+'d-proto']);},_0x516fb2['determineU'+'rl']=function(_0x50ddd9){return(this['isSecureRe'+'quest'](_0x50ddd9)?'wss:':'ws:')+'//'+_0x50ddd9['headers']['host']+_0x50ddd9['url'];},_0x516fb2['http']=function(_0x1e0f3b,_0x42ca5d){void(0x1b*-0x9+-0x2509+0x97f*0x4)===(_0x42ca5d=_0x42ca5d||{})['requireMas'+'king']&&(_0x42ca5d['requireMas'+'king']=!(0x869+0x769+0x32*-0x51));var _0x370dac=_0x1e0f3b['headers'],_0x5399e7=_0x370dac['sec-websoc'+'ket-versio'+'n'],_0xed118f=_0x370dac['sec-websoc'+'ket-key'],_0x3a502d=_0x370dac['sec-websoc'+'ket-key1'],_0x528cb3=_0x370dac['sec-websoc'+'ket-key2'],_0x252dc5=this['determineU'+'rl'](_0x1e0f3b);return _0x5399e7||_0xed118f?new _0x1ab27f(_0x1e0f3b,_0x252dc5,_0x42ca5d):_0x3a502d||_0x528cb3?new _0x4965dd(_0x1e0f3b,_0x252dc5,_0x42ca5d):new _0x42c208(_0x1e0f3b,_0x252dc5,_0x42ca5d);},_0x3a8f0e['exports']=_0x516fb2;},0x2286:(_0x2bae19,_0x569481,_0x410f7e)=>{'use strict';var _0x37fb88=_0x410f7e(-0x4*-0x91d+0x2416+0x1*-0x3d5d)['Buffer'],_0x668a6e=function(){this['_queue']=[],this['_queueSize']=0x1*0x11fb+0x751*-0x2+-0x359,this['_offset']=-0x13fe+-0x3*-0xbd4+0x295*-0x6;};_0x668a6e['prototype']['put']=function(_0x3d7416){_0x3d7416&&-0x21fd+0x1a48+0x1*0x7b5!==_0x3d7416['length']&&(_0x37fb88['isBuffer'](_0x3d7416)||(_0x3d7416=_0x37fb88['from'](_0x3d7416)),this['_queue']['push'](_0x3d7416),this['_queueSize']+=_0x3d7416['length']);},_0x668a6e['prototype']['read']=function(_0x5c6b0b){if(_0x5c6b0b>this['_queueSize'])return null;if(-0x16f8+-0x1230+-0xdb8*-0x3===_0x5c6b0b)return _0x37fb88['alloc'](0x45f*-0x2+-0x949+0x47*0x41);this['_queueSize']-=_0x5c6b0b;var _0xdbc946,_0x4901fe,_0xdd3643=this['_queue'],_0x4567fb=_0x5c6b0b,_0x450c8b=_0xdd3643[-0x27*0x93+-0x25a0+-0xc01*-0x5];if(_0x450c8b['length']>=_0x5c6b0b)return _0x450c8b['length']===_0x5c6b0b?_0xdd3643['shift']():(_0x4901fe=_0x450c8b['slice'](0x202c+-0x97*0x17+-0x129b,_0x5c6b0b),_0xdd3643[-0x2303*0x1+0x3fb*-0x7+0x7dc*0x8]=_0x450c8b['slice'](_0x5c6b0b),_0x4901fe);for(var _0x32b0dc=0x1b2c+-0x1c*0x148+0x8b4,_0x169140=_0xdd3643['length'];_0x32b0dc<_0x169140&&!(_0x4567fb<_0xdd3643[_0x32b0dc]['length']);_0x32b0dc++)_0x4567fb-=_0xdd3643[_0x32b0dc]['length'];return _0xdbc946=_0xdd3643['splice'](0x2378+0x18d0+-0x3c48,_0x32b0dc),_0x4567fb>0x1819+-0x343+-0x14d6&&_0xdd3643['length']>-0x2074+0x2207+0x1*-0x193&&(_0xdbc946['push'](_0xdd3643[0x3ca+-0xe81+0xab7]['slice'](0x1*-0x6b2+-0x1f5+0x8a7,_0x4567fb)),_0xdd3643[-0x33*-0x45+0xaa4+-0x1863*0x1]=_0xdd3643[-0x1a6f+-0x2*-0x127f+-0xa8f]['slice'](_0x4567fb)),_0x37fb88['concat'](_0xdbc946,_0x5c6b0b);},_0x668a6e['prototype']['eachByte']=function(_0x57a900,_0x32d90e){for(var _0x4f2e33,_0x223cfd,_0x2d125f;this['_queue']['length']>-0xd9*-0x13+-0x2149+0x112e;){for(_0x223cfd=(_0x4f2e33=this['_queue'][0x2*0xfef+0x1d*-0x65+-0x146d])['length'];this['_offset']<_0x223cfd;)_0x2d125f=this['_offset'],this['_offset']+=-0x1c4d+0x1a67*0x1+0x1*0x1e7,_0x57a900['call'](_0x32d90e,_0x4f2e33[_0x2d125f]);this['_offset']=0xd*0x68+-0x2332+0x7*0x446,this['_queue']['shift']();}},_0x2bae19['exports']=_0x668a6e;},0x1b4f:(_0x28807d,_0x186575,_0x157626)=>{'use strict';var _0x286bc7=_0x157626(-0x1969+-0x86c+0x38e6)['e'],_0x479462=_0x157626(0xf1b+-0x8*0x242+0x12*0xc9)['Buffer'],_0x2cf650={'request':_0x286bc7['REQUEST']||'request','response':_0x286bc7['RESPONSE']||'response'},_0x2275f1=function(_0x402c1b){this['_type']=_0x402c1b,this['_parser']=new _0x286bc7(_0x2cf650[_0x402c1b]),this['_complete']=!(-0x103a*-0x2+0x4*0x994+0x1*-0x46c3),this['headers']={};var _0x1133b3=null,_0x3cbd6a=this;this['_parser']['onHeaderFi'+'eld']=function(_0x5dfef1,_0x528d75,_0x25421f){_0x1133b3=_0x5dfef1['toString']('utf8',_0x528d75,_0x528d75+_0x25421f)['toLowerCas'+'e']();},this['_parser']['onHeaderVa'+'lue']=function(_0x4d12b9,_0x9ae9e,_0x12ee21){var _0x57b203=_0x4d12b9['toString']('utf8',_0x9ae9e,_0x9ae9e+_0x12ee21);_0x3cbd6a['headers']['hasOwnProp'+'erty'](_0x1133b3)?_0x3cbd6a['headers'][_0x1133b3]+=',\x20'+_0x57b203:_0x3cbd6a['headers'][_0x1133b3]=_0x57b203;},this['_parser']['onHeadersC'+'omplete']=this['_parser'][_0x286bc7['kOnHeaders'+'Complete']]=function(_0x504e75,_0x33a2dc,_0x281a35,_0x42dc5d,_0x4bf83f,_0x4d8725){var _0x440d18=arguments[-0x1c70+0x147b+0x2a7*0x3];if('object'==typeof _0x440d18&&(_0x42dc5d=_0x440d18['method'],_0x4bf83f=_0x440d18['url'],_0x4d8725=_0x440d18['statusCode'],_0x281a35=_0x440d18['headers']),_0x3cbd6a['method']='number'==typeof _0x42dc5d?_0x2275f1['METHODS'][_0x42dc5d]:_0x42dc5d,_0x3cbd6a['statusCode']=_0x4d8725,_0x3cbd6a['url']=_0x4bf83f,_0x281a35){for(var _0x2d420d,_0x5e3118,_0x22eeff=0x618*-0x1+-0x738+0x2*0x6a8,_0x50b9fd=_0x281a35['length'];_0x22eeff<_0x50b9fd;_0x22eeff+=-0xf6f+-0x6cb+-0x58f*-0x4)_0x2d420d=_0x281a35[_0x22eeff]['toLowerCas'+'e'](),_0x5e3118=_0x281a35[_0x22eeff+(0x1f56*-0x1+-0x91a+0x2871)],_0x3cbd6a['headers']['hasOwnProp'+'erty'](_0x2d420d)?_0x3cbd6a['headers'][_0x2d420d]+=',\x20'+_0x5e3118:_0x3cbd6a['headers'][_0x2d420d]=_0x5e3118;_0x3cbd6a['_complete']=!(0x201+0x1*-0xbf5+0x9f4);}};};_0x2275f1['METHODS']={0x0:'DELETE',0x1:'GET',0x2:'HEAD',0x3:'POST',0x4:'PUT',0x5:'CONNECT',0x6:'OPTIONS',0x7:'TRACE',0x8:'COPY',0x9:'LOCK',0xa:'MKCOL',0xb:'MOVE',0xc:'PROPFIND',0xd:'PROPPATCH',0xe:'SEARCH',0xf:'UNLOCK',0x10:'BIND',0x11:'REBIND',0x12:'UNBIND',0x13:'ACL',0x14:'REPORT',0x15:'MKACTIVITY',0x16:'CHECKOUT',0x17:'MERGE',0x18:'M-SEARCH',0x19:'NOTIFY',0x1a:'SUBSCRIBE',0x1b:'UNSUBSCRIB'+'E',0x1c:'PATCH',0x1d:'PURGE',0x1e:'MKCALENDAR',0x1f:'LINK',0x20:'UNLINK'};var _0x18c46b=process['version']?process['version']['match'](/[0-9]+/g)['map'](function(_0x151b0e){return parseInt(_0x151b0e,0x6d*-0x17+0x1253*-0x2+0x2e7b);}):[];-0xb*0x219+-0x2cd*0x7+0x2aae===_0x18c46b[0xe12*0x1+0x239d+-0x17*0x229]&&0x231f+-0x1676+0x1*-0xc9d===_0x18c46b[-0x22b0+-0x527*-0x6+0x1*0x3c7]&&(_0x2275f1['METHODS'][-0x2480+-0xd77+-0x10ad*-0x3]='REPORT',_0x2275f1['METHODS'][0x35+0x657+0x229*-0x3]='MKACTIVITY',_0x2275f1['METHODS'][-0x1bad+-0x6cb+0x228a]='CHECKOUT',_0x2275f1['METHODS'][0x2*0xb4b+0x3*0x175+-0x1ae2]='MERGE',_0x2275f1['METHODS'][-0x1671+0x1*0xebb+0x7ca]='M-SEARCH',_0x2275f1['METHODS'][0xe55*-0x2+-0x1*0x1d25+0x39e4*0x1]='NOTIFY',_0x2275f1['METHODS'][-0x127+0xd6+0x67]='SUBSCRIBE',_0x2275f1['METHODS'][-0x5ac+-0x8a7+-0x1e*-0x7b]='UNSUBSCRIB'+'E',_0x2275f1['METHODS'][0x4*0x8a8+-0x1b3*0x2+-0x1f22]='PATCH',_0x2275f1['METHODS'][-0x1ab9*0x1+0x1f*0x16+0x1828]='PURGE'),_0x2275f1['prototype']['isComplete']=function(){return this['_complete'];},_0x2275f1['prototype']['parse']=function(_0x6c215b){var _0x381e55=this['_parser']['execute'](_0x6c215b,-0x2*0x543+-0xef*-0x25+-0xd*0x1d9,_0x6c215b['length']);if('number'!=typeof _0x381e55)return this['error']=_0x381e55,void(this['_complete']=!(0x1*-0x1e1f+0xda2+0x9*0x1d5));this['_complete']&&(this['body']=_0x381e55<_0x6c215b['length']?_0x6c215b['slice'](_0x381e55):_0x479462['alloc'](0x145e+-0x1366+-0xf8));},_0x28807d['exports']=_0x2275f1;},0x11c8:(_0x31b1b6,_0x4b078e,_0x5f1123)=>{'use strict';var _0x1588b2=_0x5f1123(0x14c3+-0x1*-0x24d7+-0x30ff)['Stream'],_0x53c382=_0x5f1123(0x2762+0xb5f+-0x31a*0x5),_0x3f087a=function(_0xcb542c){this['readable']=this['writable']=!(0x1d*-0x12d+-0x9*0x2b3+-0x65*-0x94),this['_paused']=!(-0x83c*0x3+0x8ce+-0xfe7*-0x1),this['_driver']=_0xcb542c;};_0x53c382['inherits'](_0x3f087a,_0x1588b2),_0x3f087a['prototype']['pause']=function(){this['_paused']=!(0x1dc9+0x701+-0x24ca),this['_driver']['messages']['_paused']=!(-0x1*0x1fdd+-0x1*-0x399+-0x9*-0x324);},_0x3f087a['prototype']['resume']=function(){this['_paused']=!(0x167*0x4+-0xc*0xfe+0x64d),this['emit']('drain');var _0x2d9705=this['_driver']['messages'];_0x2d9705['_paused']=!(-0x26d1+0x529*0x5+0x12f*0xb),_0x2d9705['emit']('drain');},_0x3f087a['prototype']['write']=function(_0x3ae076){return!!this['writable']&&(this['_driver']['parse'](_0x3ae076),!this['_paused']);},_0x3f087a['prototype']['end']=function(_0xecf08a){if(this['writable']){void(0xa6*-0x2+0x1b02+-0x3*0x892)!==_0xecf08a&&this['write'](_0xecf08a),this['writable']=!(-0x3*0x2d1+-0x71c+0xf90);var _0x55cc3f=this['_driver']['messages'];_0x55cc3f['readable']&&(_0x55cc3f['readable']=_0x55cc3f['writable']=!(0xbe9*0x1+-0x1de2+-0x2*-0x8fd),_0x55cc3f['emit']('end'));}},_0x3f087a['prototype']['destroy']=function(){this['end']();};var _0x58b1ea=function(_0xf204ac){this['readable']=this['writable']=!(-0xc70+-0x1476+-0x2*-0x1073),this['_paused']=!(-0x874*0x1+-0x85*0x47+0x2d58),this['_driver']=_0xf204ac;};_0x53c382['inherits'](_0x58b1ea,_0x1588b2),_0x58b1ea['prototype']['pause']=function(){this['_driver']['io']['_paused']=!(-0xb2*-0x5+0x104f*-0x2+0x175*0x14);},_0x58b1ea['prototype']['resume']=function(){this['_driver']['io']['_paused']=!(-0xe87+-0x3ab+0x1233),this['_driver']['io']['emit']('drain');},_0x58b1ea['prototype']['write']=function(_0x149795){return!!this['writable']&&('string'==typeof _0x149795?this['_driver']['text'](_0x149795):this['_driver']['binary'](_0x149795),!this['_paused']);},_0x58b1ea['prototype']['end']=function(_0x3a7c1e){void(-0x3*-0xb96+0x1e7d+0x413f*-0x1)!==_0x3a7c1e&&this['write'](_0x3a7c1e);},_0x58b1ea['prototype']['destroy']=function(){},_0x4b078e['IO']=_0x3f087a,_0x4b078e['Messages']=_0x58b1ea;},0x93e:_0x3b5ef7=>{'use strict';var _0x44240d=/([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/,_0x191e5d=/([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g,_0xbc921d=new RegExp(_0x44240d['source']+'(?:=(?:'+_0x44240d['source']+'|'+/"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/['source']+'))?'),_0x16114a=new RegExp(_0x44240d['source']+'(?:\x20*;\x20*'+_0xbc921d['source']+')*','g'),_0xb904ac=new RegExp('^'+_0x16114a['source']+'(?:\x20*,\x20*'+_0x16114a['source']+')*$'),_0x327afe=/^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/,_0xb571ab=Object['prototype']['hasOwnProp'+'erty'],_0x44ff01={'parseHeader':function(_0x52308b){var _0x1ee54f=new _0x1cb43c();if(''===_0x52308b||void(-0x20c4+0x1*-0x12e+0x21f2)===_0x52308b)return _0x1ee54f;if(!_0xb904ac['test'](_0x52308b))throw new SyntaxError('Invalid\x20Se'+'c-WebSocke'+'t-Extensio'+'ns\x20header:'+'\x20'+_0x52308b);return _0x52308b['match'](_0x16114a)['forEach'](function(_0x428e3c){var _0x49a3a0=_0x428e3c['match'](new RegExp(_0xbc921d['source'],'g')),_0x11d9a7=_0x49a3a0['shift'](),_0x2f1006={};_0x49a3a0['forEach'](function(_0x4be8d1){var _0x1533b3,_0x122475=_0x4be8d1['match'](_0xbc921d),_0xc0bab0=_0x122475[-0x194d+-0x10f5+0x2a43];_0x1533b3=void(0x105c+0x1*0xbe4+-0x1c40)!==_0x122475[0x13f*0x4+-0x23e*0x1+-0x2bc]?_0x122475[-0x21a1+0xfbd+0x3a*0x4f]:void(-0x59*-0x29+0x255*0xb+-0x27e8)===_0x122475[-0x1c57+-0x2*0x9cb+0x3b0*0xd]||_0x122475[-0x142e+-0x19f0+0x2e21]['replace'](/\\/g,''),_0x327afe['test'](_0x1533b3)&&(_0x1533b3=parseFloat(_0x1533b3)),_0xb571ab['call'](_0x2f1006,_0xc0bab0)?(_0x2f1006[_0xc0bab0]=[]['concat'](_0x2f1006[_0xc0bab0]),_0x2f1006[_0xc0bab0]['push'](_0x1533b3)):_0x2f1006[_0xc0bab0]=_0x1533b3;},this),_0x1ee54f['push'](_0x11d9a7,_0x2f1006);},this),_0x1ee54f;},'serializeParams':function(_0x5e95f8,_0x2f5bb8){var _0x51d82e=[],_0x4d9d67=function(_0x34c90c,_0x4737a1){_0x4737a1 instanceof Array?_0x4737a1['forEach'](function(_0x3d478e){_0x4d9d67(_0x34c90c,_0x3d478e);}):!(0x8f*-0xe+-0x1*0xfe5+0x17b7*0x1)===_0x4737a1?_0x51d82e['push'](_0x34c90c):'number'==typeof _0x4737a1?_0x51d82e['push'](_0x34c90c+'='+_0x4737a1):_0x191e5d['test'](_0x4737a1)?_0x51d82e['push'](_0x34c90c+'=\x22'+_0x4737a1['replace'](/"/g,'\x5c\x22')+'\x22'):_0x51d82e['push'](_0x34c90c+'='+_0x4737a1);};for(var _0x5c58ed in _0x2f5bb8)_0x4d9d67(_0x5c58ed,_0x2f5bb8[_0x5c58ed]);return[_0x5e95f8]['concat'](_0x51d82e)['join'](';\x20');}},_0x1cb43c=function(){this['_byName']={},this['_inOrder']=[];};_0x1cb43c['prototype']['push']=function(_0x5b54d3,_0x17ef3a){_0xb571ab['call'](this['_byName'],_0x5b54d3)||(this['_byName'][_0x5b54d3]=[]),this['_byName'][_0x5b54d3]['push'](_0x17ef3a),this['_inOrder']['push']({'name':_0x5b54d3,'params':_0x17ef3a});},_0x1cb43c['prototype']['eachOffer']=function(_0x3355a0,_0x248f50){for(var _0x446fe1=this['_inOrder'],_0x27444d=-0x14d8*0x1+0x1105+-0xb*-0x59,_0x4df590=_0x446fe1['length'];_0x27444d<_0x4df590;_0x27444d++)_0x3355a0['call'](_0x248f50,_0x446fe1[_0x27444d]['name'],_0x446fe1[_0x27444d]['params']);},_0x1cb43c['prototype']['byName']=function(_0x411ec3){return this['_byName'][_0x411ec3]||[];},_0x1cb43c['prototype']['toArray']=function(){return this['_inOrder']['slice']();},_0x3b5ef7['exports']=_0x44ff01;},0x282:(_0x321288,_0x212e45,_0x362086)=>{'use strict';var _0x36378a=_0x362086(-0x1*-0x1e75+0x1719+-0x24d3),_0x4d39a0=_0x362086(-0x17bf+-0x4d2+0x30fc),_0x141848=function(_0x2b6ed5){this['_ext']=_0x2b6ed5[-0x16fd+0xb43+0x4f*0x26],this['_session']=_0x2b6ed5[-0x1801+-0x35*-0x1c+-0x25*-0x7e],this['_functors']={'incoming':new _0x36378a(this['_session'],'processInc'+'omingMessa'+'ge'),'outgoing':new _0x36378a(this['_session'],'processOut'+'goingMessa'+'ge')};};_0x141848['prototype']['pending']=function(_0x13f69c){var _0x14864f=this['_functors'][_0x13f69c];_0x14864f['_stopped']||(_0x14864f['pending']+=0x248*0xe+-0x2259+-0x3*-0xce);},_0x141848['prototype']['incoming']=function(_0x133d7a,_0x5eeffa,_0x432f58,_0x3b7194){this['_exec']('incoming',_0x133d7a,_0x5eeffa,_0x432f58,_0x3b7194);},_0x141848['prototype']['outgoing']=function(_0x555d0c,_0x483a30,_0x51a99e,_0x179363){this['_exec']('outgoing',_0x555d0c,_0x483a30,_0x51a99e,_0x179363);},_0x141848['prototype']['close']=function(){return this['_closed']=this['_closed']||new _0x4d39a0(),this['_doClose'](),this['_closed'];},_0x141848['prototype']['_exec']=function(_0x15e4f5,_0x5f138c,_0x46629e,_0x37e23e,_0x80cac9){this['_functors'][_0x15e4f5]['call'](_0x5f138c,_0x46629e,function(_0x56b341,_0x4d5dca){_0x56b341&&(_0x56b341['message']=this['_ext']['name']+':\x20'+_0x56b341['message']),_0x37e23e['call'](_0x80cac9,_0x56b341,_0x4d5dca),this['_doClose']();},this);},_0x141848['prototype']['_doClose']=function(){var _0x30cdc6=this['_functors']['incoming'],_0x479c59=this['_functors']['outgoing'];this['_closed']&&_0x30cdc6['pending']+_0x479c59['pending']===0x1*0x4e5+0x2*0xd4c+-0x1f7d*0x1&&(this['_session']&&this['_session']['close'](),this['_session']=null,this['_closed']['done']());},_0x321288['exports']=_0x141848;},0x10bb:(_0x1ba606,_0x19d87a,_0x1eb8a8)=>{'use strict';var _0x51292e=_0x1eb8a8(-0x2*0xf7e+0x2*0x472+0x2375*0x1),_0xb1cad7=function(_0x2893cc,_0x1a42bd){this['_session']=_0x2893cc,this['_method']=_0x1a42bd,this['_queue']=new _0x51292e(_0xb1cad7['QUEUE_SIZE']),this['_stopped']=!(-0x1*-0x4ef+-0x3*-0x2ad+-0xcf5),this['pending']=-0xb*-0x20+-0x2fb+0x19b;};_0xb1cad7['QUEUE_SIZE']=0x3*0x4c1+0x1aad*-0x1+0xc72,_0xb1cad7['prototype']['call']=function(_0xc36c88,_0x8c4c1e,_0x126e07,_0xd2b49){if(!this['_stopped']){var _0x5b794d={'error':_0xc36c88,'message':_0x8c4c1e,'callback':_0x126e07,'context':_0xd2b49,'done':!(-0xab*-0x39+-0x20ef+0x1*-0x523)},_0x5ae6a2=!(-0xa37*0x3+-0xbf1+0x2a97),_0x40186=this;if(this['_queue']['push'](_0x5b794d),_0x5b794d['error'])return _0x5b794d['done']=!(0x16e6+0x6b7+-0x1d9d),this['_stop'](),this['_flushQueu'+'e']();var _0x1c71e5=function(_0x39d01f,_0x35dfca){_0x5ae6a2^(_0x5ae6a2=!(-0x14a8+0x7cb+-0xcdd*-0x1))&&(_0x39d01f?(_0x40186['_stop'](),_0x5b794d['error']=_0x39d01f,_0x5b794d['message']=null):_0x5b794d['message']=_0x35dfca,_0x5b794d['done']=!(-0x7c1+0x1*-0x575+0x69b*0x2),_0x40186['_flushQueu'+'e']());};try{this['_session'][this['_method']](_0x8c4c1e,_0x1c71e5);}catch(_0xe41e36){_0x1c71e5(_0xe41e36);}}},_0xb1cad7['prototype']['_stop']=function(){this['pending']=this['_queue']['length'],this['_stopped']=!(0x7b*0x35+-0xa50+0x50d*-0x3);},_0xb1cad7['prototype']['_flushQueu'+'e']=function(){for(var _0x2fdd55,_0x5cfe96=this['_queue'];_0x5cfe96['length']>0x1cd4+-0x1*0x3b3+-0x1921&&_0x5cfe96['peek']()['done'];)(_0x2fdd55=_0x5cfe96['shift']())['error']?(this['pending']=0x3b*0x32+0x211c+0x1651*-0x2,_0x5cfe96['clear']()):this['pending']-=-0xcba+-0x1911+-0x3b*-0xa4,_0x2fdd55['callback']['call'](_0x2fdd55['context'],_0x2fdd55['error'],_0x2fdd55['message']);},_0x1ba606['exports']=_0xb1cad7;},0x147c:(_0x3e18f9,_0x4dd175,_0x4a7b0c)=>{'use strict';var _0x167c3d=_0x4a7b0c(0x713+-0x20*-0x8+-0x3*0x1db),_0x21f383=_0x4a7b0c(-0x21ca+-0x36b+0x20*0x1cd),_0x12683d=function(_0x31764a){this['_cells']=_0x31764a['map'](function(_0x4eb2e2){return new _0x167c3d(_0x4eb2e2);}),this['_stopped']={'incoming':!(0x1a39*-0x1+0x1255*0x1+0x7e5),'outgoing':!(0x1d24+-0xe*-0xcd+-0x2859)};};_0x12683d['prototype']['processInc'+'omingMessa'+'ge']=function(_0x1dbd2d,_0x4f1a36,_0x2077e0){this['_stopped']['incoming']||this['_loop']('incoming',this['_cells']['length']-(0x1ea5+0x7f7+-0x269b),-(-0x1b*-0xe5+0x5f+-0x1885),-(-0x21af+0x6f*-0x9+0x2597*0x1),_0x1dbd2d,_0x4f1a36,_0x2077e0);},_0x12683d['prototype']['processOut'+'goingMessa'+'ge']=function(_0x4dd6dc,_0xde6f96,_0x57dc7b){this['_stopped']['outgoing']||this['_loop']('outgoing',0xcc6+-0xa7c+-0x24a,this['_cells']['length'],-0x264d+-0x891*-0x2+0x1*0x152c,_0x4dd6dc,_0xde6f96,_0x57dc7b);},_0x12683d['prototype']['close']=function(_0x2ae0b3,_0x2467ed){this['_stopped']={'incoming':!(-0x23b3+-0x3cb*0x5+0x36aa),'outgoing':!(0x911+0x13b2+-0x1cc3)};var _0xd7de5b=this['_cells']['map'](function(_0x458dcb){return _0x458dcb['close']();});_0x2ae0b3&&_0x21f383['all'](_0xd7de5b)['then'](function(){_0x2ae0b3['call'](_0x2467ed);});},_0x12683d['prototype']['_loop']=function(_0x465d54,_0x3213d6,_0x4024ce,_0x3c72cc,_0x45305d,_0x16f98e,_0x1777de){for(var _0x5e5341=this['_cells'],_0x40113d=_0x5e5341['length'],_0x221338=this;_0x40113d--;)_0x5e5341[_0x40113d]['pending'](_0x465d54);var _0x49f15e=function(_0x552c36,_0x3cd060,_0x232a27){if(_0x552c36===_0x4024ce)return _0x16f98e['call'](_0x1777de,_0x3cd060,_0x232a27);_0x5e5341[_0x552c36][_0x465d54](_0x3cd060,_0x232a27,function(_0x52bbe4,_0x3f6e6e){_0x52bbe4&&(_0x221338['_stopped'][_0x465d54]=!(-0x5*-0x11f+-0x1*-0x89b+-0x71b*0x2)),_0x49f15e(_0x552c36+_0x3c72cc,_0x52bbe4,_0x3f6e6e);});};_0x49f15e(_0x3213d6,null,_0x45305d);},_0x3e18f9['exports']=_0x12683d;},0x146b:(_0x257c73,_0x5b3536,_0xef390e)=>{'use strict';var _0x3d4fb4=_0xef390e(0x9a0+0x4fc+0x13f*-0x1),_0x4b0e81=function(){this['_complete']=!(0xf55+0xca5+-0x1bf9),this['_callbacks']=new _0x3d4fb4(_0x4b0e81['QUEUE_SIZE']);};_0x4b0e81['QUEUE_SIZE']=-0x1e9c+-0x67f+-0xd*-0x2db,_0x4b0e81['all']=function(_0x1564f2){var _0x2fb253=new _0x4b0e81(),_0x1dd642=_0x1564f2['length'],_0x4632a8=_0x1dd642;for(0xd+-0x14*0x16f+-0x1c9f*-0x1===_0x1dd642&&_0x2fb253['done']();_0x4632a8--;)_0x1564f2[_0x4632a8]['then'](function(){-0x316*-0x5+-0x1*-0x17b7+0xb*-0x38f==(_0x1dd642-=0xad*-0x7+-0x10*0xd+-0x1*-0x58c)&&_0x2fb253['done']();});return _0x2fb253;},_0x4b0e81['prototype']['then']=function(_0x345f73){this['_complete']?_0x345f73():this['_callbacks']['push'](_0x345f73);},_0x4b0e81['prototype']['done']=function(){this['_complete']=!(0x1a0d+0x471*-0x6+0x11*0x9);for(var _0xc5d1f8,_0x6d56c7=this['_callbacks'];_0xc5d1f8=_0x6d56c7['shift']();)_0xc5d1f8();},_0x257c73['exports']=_0x4b0e81;},0xd5d:_0x3be9ee=>{'use strict';var _0x1af234=function(_0x4b2a18){this['_bufferSiz'+'e']=_0x4b2a18,this['clear']();};_0x1af234['prototype']['clear']=function(){this['_buffer']=new Array(this['_bufferSiz'+'e']),this['_ringOffse'+'t']=-0x727*0x1+0xa0e+-0x2e7*0x1,this['_ringSize']=this['_bufferSiz'+'e'],this['_head']=-0x2506+-0x13c8+0x38ce,this['_tail']=0x226+0xe58+-0x107e,this['length']=-0x1c*0x15b+0x2423+0x1d1;},_0x1af234['prototype']['push']=function(_0x4a6d8c){var _0x1b78ca=!(-0x2f1*-0x3+0x2*0x704+-0x16da),_0xb822a8=!(0x9a4+0x8c1+-0x1ac*0xb);this['_ringSize']<this['_bufferSiz'+'e']?_0x1b78ca=0x1*0x386+-0x9cd+0x647*0x1===this['_tail']:this['_ringOffse'+'t']===this['_ringSize']&&(_0x1b78ca=!(0x707+0x1781+-0x1e88),_0xb822a8=-0x1d30+0x1*-0x5da+0xbae*0x3===this['_tail']),_0x1b78ca&&(this['_tail']=this['_bufferSiz'+'e'],this['_buffer']=this['_buffer']['concat'](new Array(this['_bufferSiz'+'e'])),this['_bufferSiz'+'e']=this['_buffer']['length'],_0xb822a8&&(this['_ringSize']=this['_bufferSiz'+'e'])),this['_buffer'][this['_tail']]=_0x4a6d8c,this['length']+=-0x1c37+0xe3+0x1b55,this['_tail']<this['_ringSize']&&(this['_ringOffse'+'t']+=-0x1e2c+-0x140d+0x191d*0x2),this['_tail']=(this['_tail']+(0x2*0xa3b+0x2603+-0x74f*0x8))%this['_bufferSiz'+'e'];},_0x1af234['prototype']['peek']=function(){if(0xd58+-0x1611+0x1*0x8b9!==this['length'])return this['_buffer'][this['_head']];},_0x1af234['prototype']['shift']=function(){if(-0x1993+-0x1e29+-0x2*-0x1bde!==this['length']){var _0x273207=this['_buffer'][this['_head']];return this['_buffer'][this['_head']]=void(-0x3cf+0x1*0x1615+-0x1246),this['length']-=-0x23d9+0x329*0xa+0x220*0x2,this['_ringOffse'+'t']-=0x7f*-0x3e+0x19b*-0x2+0x21f9,-0x1f2b+0x176+0x1db5===this['_ringOffse'+'t']&&this['length']>-0x26f2+0x3*0x37f+0x1c75?(this['_head']=this['_ringSize'],this['_ringOffse'+'t']=this['length'],this['_ringSize']=this['_bufferSiz'+'e']):this['_head']=(this['_head']+(-0x1eb+0xd*0x4+-0x6e*-0x4))%this['_ringSize'],_0x273207;}},_0x3be9ee['exports']=_0x1af234;},0x13b3:(_0x276a11,_0x4f536f,_0xdbd629)=>{'use strict';var _0x3b9d35=_0xdbd629(0x2253+0x1*-0xaa9+-0xe6c),_0x3ac382=_0xdbd629(0x167f+-0x126+-0x1*0xdd),_0x1dac47=function(){this['_rsv1']=this['_rsv2']=this['_rsv3']=null,this['_byName']={},this['_inOrder']=[],this['_sessions']=[],this['_index']={};};_0x1dac47['MESSAGE_OP'+'CODES']=[-0x1fb4+0x24cf+0x51a*-0x1,0xc3b+0xd88*0x1+0x1*-0x19c1];var _0x2a2b32={'add':function(_0x351776){if('string'!=typeof _0x351776['name'])throw new TypeError('extension.'+'name\x20must\x20'+'be\x20a\x20strin'+'g');if('permessage'!==_0x351776['type'])throw new TypeError('extension.'+'type\x20must\x20'+'be\x20\x22permes'+'sage\x22');if('boolean'!=typeof _0x351776['rsv1'])throw new TypeError('extension.'+'rsv1\x20must\x20'+'be\x20true\x20or'+'\x20false');if('boolean'!=typeof _0x351776['rsv2'])throw new TypeError('extension.'+'rsv2\x20must\x20'+'be\x20true\x20or'+'\x20false');if('boolean'!=typeof _0x351776['rsv3'])throw new TypeError('extension.'+'rsv3\x20must\x20'+'be\x20true\x20or'+'\x20false');if(this['_byName']['hasOwnProp'+'erty'](_0x351776['name']))throw new TypeError('An\x20extensi'+'on\x20with\x20na'+'me\x20\x22'+_0x351776['name']+('\x22\x20is\x20alrea'+'dy\x20registe'+'red'));this['_byName'][_0x351776['name']]=_0x351776,this['_inOrder']['push'](_0x351776);},'generateOffer':function(){var _0x371bdd=[],_0x53c266=[],_0x9ff211={};return this['_inOrder']['forEach'](function(_0xb88de5){var _0x2e17f2=_0xb88de5['createClie'+'ntSession']();if(_0x2e17f2){var _0x443890=[_0xb88de5,_0x2e17f2];_0x371bdd['push'](_0x443890),_0x9ff211[_0xb88de5['name']]=_0x443890;var _0x5656e5=_0x2e17f2['generateOf'+'fer']();(_0x5656e5=_0x5656e5?[]['concat'](_0x5656e5):[])['forEach'](function(_0x3ecbfd){_0x53c266['push'](_0x3b9d35['serializeP'+'arams'](_0xb88de5['name'],_0x3ecbfd));},this);}},this),this['_sessions']=_0x371bdd,this['_index']=_0x9ff211,_0x53c266['length']>-0x1852*-0x1+-0x749+-0x7*0x26f?_0x53c266['join'](',\x20'):null;},'activate':function(_0x16b1af){var _0x187c80=_0x3b9d35['parseHeade'+'r'](_0x16b1af),_0x4470f5=[];_0x187c80['eachOffer'](function(_0xa90227,_0x2479b6){var _0x488b00=this['_index'][_0xa90227];if(!_0x488b00)throw new Error('Server\x20sen'+'t\x20an\x20exten'+'sion\x20respo'+'nse\x20for\x20un'+'known\x20exte'+'nsion\x20\x22'+_0xa90227+'\x22');var _0x2c8c06=_0x488b00[-0x7bd+0xa7*-0x15+0x1570],_0x511472=_0x488b00[0x1f7*0x7+0x10d*0x5+-0x1301],_0x48a1b5=this['_reserved'](_0x2c8c06);if(_0x48a1b5)throw new Error('Server\x20sen'+'t\x20two\x20exte'+'nsion\x20resp'+'onses\x20that'+'\x20use\x20the\x20R'+'SV'+_0x48a1b5[0x16a2+-0x987+-0xd1b]+'\x20bit:\x20\x22'+_0x48a1b5[0x12cf+-0x252c+0x125e]+'\x22\x20and\x20\x22'+_0x2c8c06['name']+'\x22');if(!(-0x2502+0x149*0x16+0x8bc)!==_0x511472['activate'](_0x2479b6))throw new Error('Server\x20sen'+'t\x20unaccept'+'able\x20exten'+'sion\x20param'+'eters:\x20'+_0x3b9d35['serializeP'+'arams'](_0xa90227,_0x2479b6));this['_reserve'](_0x2c8c06),_0x4470f5['push'](_0x488b00);},this),this['_sessions']=_0x4470f5,this['_pipeline']=new _0x3ac382(_0x4470f5);},'generateResponse':function(_0x368cf3){var _0x47919c=[],_0x38d4cb=[],_0x4c60bc=_0x3b9d35['parseHeade'+'r'](_0x368cf3);return this['_inOrder']['forEach'](function(_0x88496d){var _0x1e2fbe=_0x4c60bc['byName'](_0x88496d['name']);if(0x1103+-0xf85+-0x17e*0x1!==_0x1e2fbe['length']&&!this['_reserved'](_0x88496d)){var _0xbb84bc=_0x88496d['createServ'+'erSession'](_0x1e2fbe);_0xbb84bc&&(this['_reserve'](_0x88496d),_0x47919c['push']([_0x88496d,_0xbb84bc]),_0x38d4cb['push'](_0x3b9d35['serializeP'+'arams'](_0x88496d['name'],_0xbb84bc['generateRe'+'sponse']())));}},this),this['_sessions']=_0x47919c,this['_pipeline']=new _0x3ac382(_0x47919c),_0x38d4cb['length']>0x1*-0x16ff+0x8e4*-0x1+0x1fe3?_0x38d4cb['join'](',\x20'):null;},'validFrameRsv':function(_0x4b83b3){var _0x3ccdd8,_0x577718={'rsv1':!(0x2*0x30a+0x4b*-0x1+0x172*-0x4),'rsv2':!(-0x14d2+-0x1ab8+0x2f8b),'rsv3':!(0x1*-0x1693+-0x21f2+0x3886)};if(_0x1dac47['MESSAGE_OP'+'CODES']['indexOf'](_0x4b83b3['opcode'])>=0x201*-0x13+0x116+-0x24fd*-0x1){for(var _0x481247=-0x3*-0xc1b+0x664+-0x2ab5,_0x1b0457=this['_sessions']['length'];_0x481247<_0x1b0457;_0x481247++)_0x3ccdd8=this['_sessions'][_0x481247][-0x43*-0x86+0x2*-0x172+-0x1*0x202e],_0x577718['rsv1']=_0x577718['rsv1']||_0x3ccdd8['rsv1'],_0x577718['rsv2']=_0x577718['rsv2']||_0x3ccdd8['rsv2'],_0x577718['rsv3']=_0x577718['rsv3']||_0x3ccdd8['rsv3'];}return(_0x577718['rsv1']||!_0x4b83b3['rsv1'])&&(_0x577718['rsv2']||!_0x4b83b3['rsv2'])&&(_0x577718['rsv3']||!_0x4b83b3['rsv3']);},'processIncomingMessage':function(_0x2dd455,_0x521ad7,_0x7295dc){this['_pipeline']['processInc'+'omingMessa'+'ge'](_0x2dd455,_0x521ad7,_0x7295dc);},'processOutgoingMessage':function(_0x4a4cbc,_0x37d3c8,_0x37e73c){this['_pipeline']['processOut'+'goingMessa'+'ge'](_0x4a4cbc,_0x37d3c8,_0x37e73c);},'close':function(_0x16cc7e,_0x5e8101){if(!this['_pipeline'])return _0x16cc7e['call'](_0x5e8101);this['_pipeline']['close'](_0x16cc7e,_0x5e8101);},'_reserve':function(_0x5aa609){this['_rsv1']=this['_rsv1']||_0x5aa609['rsv1']&&_0x5aa609['name'],this['_rsv2']=this['_rsv2']||_0x5aa609['rsv2']&&_0x5aa609['name'],this['_rsv3']=this['_rsv3']||_0x5aa609['rsv3']&&_0x5aa609['name'];},'_reserved':function(_0x580997){return this['_rsv1']&&_0x580997['rsv1']?[-0x3*-0xb85+0x24e1+-0x476f,this['_rsv1']]:this['_rsv2']&&_0x580997['rsv2']?[0x8fa+0x128a+0x2*-0xdc1,this['_rsv2']]:!(!this['_rsv3']||!_0x580997['rsv3'])&&[0x9a*-0x17+0x486+0x953,this['_rsv3']];}};for(var _0x542175 in _0x2a2b32)_0x1dac47['prototype'][_0x542175]=_0x2a2b32[_0x542175];_0x276a11['exports']=_0x1dac47;},0xa35:_0x5c9ebb=>{'use strict';_0x5c9ebb['exports']=__webpack_require__(/*! assert */ "assert");},0xb5:_0x3c8acd=>{'use strict';_0x3c8acd['exports']=__webpack_require__(/*! buffer */ "buffer");},0x14c5:_0x15e8ce=>{'use strict';_0x15e8ce['exports']=__webpack_require__(/*! child_process */ "child_process");},0x1b46:_0x375abc=>{'use strict';_0x375abc['exports']=__webpack_require__(/*! crypto */ "crypto");},0x8ca:_0x176e32=>{'use strict';_0x176e32['exports']=__webpack_require__(/*! dns */ "dns");},0xc5f:_0x4e3463=>{'use strict';_0x4e3463['exports']=__webpack_require__(/*! domain */ "domain");},0x1152:_0x526b44=>{'use strict';_0x526b44['exports']=__webpack_require__(/*! events */ "events");},0x26a8:_0x2e212c=>{'use strict';_0x2e212c['exports']=__webpack_require__(/*! fs */ "fs");},0x797:_0x24ba4f=>{'use strict';_0x24ba4f['exports']=__webpack_require__(/*! fs/promises */ "fs/promises");},0x21a3:_0x21b10b=>{'use strict';_0x21b10b['exports']=__webpack_require__(/*! http */ "http");},0x163c:_0x75afed=>{'use strict';_0x75afed['exports']=__webpack_require__(/*! https */ "https");},0x243e:_0x4900bb=>{'use strict';_0x4900bb['exports']=__webpack_require__(/*! net */ "net");},0x359:_0x38c905=>{'use strict';_0x38c905['exports']=__webpack_require__(/*! os */ "os");},0x1b10:_0x524984=>{'use strict';_0x524984['exports']=__webpack_require__(/*! path */ "path");},0x130c:_0x477517=>{'use strict';_0x477517['exports']=__webpack_require__(/*! punycode */ "punycode");},0xd98:_0x3759b3=>{'use strict';_0x3759b3['exports']=__webpack_require__(/*! querystring */ "querystring");},0x89b:_0x12df88=>{'use strict';_0x12df88['exports']=__webpack_require__(/*! stream */ "stream");},0x1294:_0x427c74=>{'use strict';_0x427c74['exports']=__webpack_require__(/*! tls */ "tls");},0x1b68:_0x4c2659=>{'use strict';_0x4c2659['exports']=__webpack_require__(/*! url */ "url");},0x233f:_0x25068b=>{'use strict';_0x25068b['exports']=__webpack_require__(/*! util */ "util");},0x815:_0x301213=>{'use strict';_0x301213['exports']=JSON['parse']('[\x22ac\x22,\x22com'+'.ac\x22,\x22edu.'+'ac\x22,\x22gov.a'+'c\x22,\x22net.ac'+'\x22,\x22mil.ac\x22'+',\x22org.ac\x22,'+'\x22ad\x22,\x22nom.'+'ad\x22,\x22ae\x22,\x22'+'co.ae\x22,\x22ne'+'t.ae\x22,\x22org'+'.ae\x22,\x22sch.'+'ae\x22,\x22ac.ae'+'\x22,\x22gov.ae\x22'+',\x22mil.ae\x22,'+'\x22aero\x22,\x22ac'+'cident-inv'+'estigation'+'.aero\x22,\x22ac'+'cident-pre'+'vention.ae'+'ro\x22,\x22aerob'+'atic.aero\x22'+',\x22aeroclub'+'.aero\x22,\x22ae'+'rodrome.ae'+'ro\x22,\x22agent'+'s.aero\x22,\x22a'+'ircraft.ae'+'ro\x22,\x22airli'+'ne.aero\x22,\x22'+'airport.ae'+'ro\x22,\x22air-s'+'urveillanc'+'e.aero\x22,\x22a'+'irtraffic.'+'aero\x22,\x22air'+'-traffic-c'+'ontrol.aer'+'o\x22,\x22ambula'+'nce.aero\x22,'+'\x22amusement'+'.aero\x22,\x22as'+'sociation.'+'aero\x22,\x22aut'+'hor.aero\x22,'+'\x22balloonin'+'g.aero\x22,\x22b'+'roker.aero'+'\x22,\x22caa.aer'+'o\x22,\x22cargo.'+'aero\x22,\x22cat'+'ering.aero'+'\x22,\x22certifi'+'cation.aer'+'o\x22,\x22champi'+'onship.aer'+'o\x22,\x22charte'+'r.aero\x22,\x22c'+'ivilaviati'+'on.aero\x22,\x22'+'club.aero\x22'+',\x22conferen'+'ce.aero\x22,\x22'+'consultant'+'.aero\x22,\x22co'+'nsulting.a'+'ero\x22,\x22cont'+'rol.aero\x22,'+'\x22council.a'+'ero\x22,\x22crew'+'.aero\x22,\x22de'+'sign.aero\x22'+',\x22dgca.aer'+'o\x22,\x22educat'+'or.aero\x22,\x22'+'emergency.'+'aero\x22,\x22eng'+'ine.aero\x22,'+'\x22engineer.'+'aero\x22,\x22ent'+'ertainment'+'.aero\x22,\x22eq'+'uipment.ae'+'ro\x22,\x22excha'+'nge.aero\x22,'+'\x22express.a'+'ero\x22,\x22fede'+'ration.aer'+'o\x22,\x22flight'+'.aero\x22,\x22fr'+'eight.aero'+'\x22,\x22fuel.ae'+'ro\x22,\x22glidi'+'ng.aero\x22,\x22'+'government'+'.aero\x22,\x22gr'+'oundhandli'+'ng.aero\x22,\x22'+'group.aero'+'\x22,\x22hanggli'+('ding.aero\x22'+',\x22homebuil'+'t.aero\x22,\x22i'+'nsurance.a'+'ero\x22,\x22jour'+'nal.aero\x22,'+'\x22journalis'+'t.aero\x22,\x22l'+'easing.aer'+'o\x22,\x22logist'+'ics.aero\x22,'+'\x22magazine.'+'aero\x22,\x22mai'+'ntenance.a'+'ero\x22,\x22medi'+'a.aero\x22,\x22m'+'icrolight.'+'aero\x22,\x22mod'+'elling.aer'+'o\x22,\x22naviga'+'tion.aero\x22'+',\x22parachut'+'ing.aero\x22,'+'\x22paraglidi'+'ng.aero\x22,\x22'+'passenger-'+'associatio'+'n.aero\x22,\x22p'+'ilot.aero\x22'+',\x22press.ae'+'ro\x22,\x22produ'+'ction.aero'+'\x22,\x22recreat'+'ion.aero\x22,'+'\x22repbody.a'+'ero\x22,\x22res.'+'aero\x22,\x22res'+'earch.aero'+'\x22,\x22rotorcr'+'aft.aero\x22,'+'\x22safety.ae'+'ro\x22,\x22scien'+'tist.aero\x22'+',\x22services'+'.aero\x22,\x22sh'+'ow.aero\x22,\x22'+'skydiving.'+'aero\x22,\x22sof'+'tware.aero'+'\x22,\x22student'+'.aero\x22,\x22tr'+'ader.aero\x22'+',\x22trading.'+'aero\x22,\x22tra'+'iner.aero\x22'+',\x22union.ae'+'ro\x22,\x22worki'+'nggroup.ae'+'ro\x22,\x22works'+'.aero\x22,\x22af'+'\x22,\x22gov.af\x22'+',\x22com.af\x22,'+'\x22org.af\x22,\x22'+'net.af\x22,\x22e'+'du.af\x22,\x22ag'+'\x22,\x22com.ag\x22'+',\x22org.ag\x22,'+'\x22net.ag\x22,\x22'+'co.ag\x22,\x22no'+'m.ag\x22,\x22ai\x22'+',\x22off.ai\x22,'+'\x22com.ai\x22,\x22'+'net.ai\x22,\x22o'+'rg.ai\x22,\x22al'+'\x22,\x22com.al\x22'+',\x22edu.al\x22,'+'\x22gov.al\x22,\x22'+'mil.al\x22,\x22n'+'et.al\x22,\x22or'+'g.al\x22,\x22am\x22'+',\x22co.am\x22,\x22'+'com.am\x22,\x22c'+'ommune.am\x22'+',\x22net.am\x22,'+'\x22org.am\x22,\x22'+'ao\x22,\x22ed.ao'+'\x22,\x22gv.ao\x22,'+'\x22og.ao\x22,\x22c'+'o.ao\x22,\x22pb.'+'ao\x22,\x22it.ao'+'\x22,\x22aq\x22,\x22ar'+'\x22,\x22com.ar\x22'+',\x22edu.ar\x22,'+'\x22gob.ar\x22,\x22'+'gov.ar\x22,\x22i'+'nt.ar\x22,\x22mi'+'l.ar\x22,\x22mus'+'ica.ar\x22,\x22n'+'et.ar\x22,\x22or'+'g.ar\x22,\x22tur')+('.ar\x22,\x22arpa'+'\x22,\x22e164.ar'+'pa\x22,\x22in-ad'+'dr.arpa\x22,\x22'+'ip6.arpa\x22,'+'\x22iris.arpa'+'\x22,\x22uri.arp'+'a\x22,\x22urn.ar'+'pa\x22,\x22as\x22,\x22'+'gov.as\x22,\x22a'+'sia\x22,\x22at\x22,'+'\x22ac.at\x22,\x22c'+'o.at\x22,\x22gv.'+'at\x22,\x22or.at'+'\x22,\x22au\x22,\x22co'+'m.au\x22,\x22net'+'.au\x22,\x22org.'+'au\x22,\x22edu.a'+'u\x22,\x22gov.au'+'\x22,\x22asn.au\x22'+',\x22id.au\x22,\x22'+'info.au\x22,\x22'+'conf.au\x22,\x22'+'oz.au\x22,\x22ac'+'t.au\x22,\x22nsw'+'.au\x22,\x22nt.a'+'u\x22,\x22qld.au'+'\x22,\x22sa.au\x22,'+'\x22tas.au\x22,\x22'+'vic.au\x22,\x22w'+'a.au\x22,\x22act'+'.edu.au\x22,\x22'+'catholic.e'+'du.au\x22,\x22ns'+'w.edu.au\x22,'+'\x22nt.edu.au'+'\x22,\x22qld.edu'+'.au\x22,\x22sa.e'+'du.au\x22,\x22ta'+'s.edu.au\x22,'+'\x22vic.edu.a'+'u\x22,\x22wa.edu'+'.au\x22,\x22qld.'+'gov.au\x22,\x22s'+'a.gov.au\x22,'+'\x22tas.gov.a'+'u\x22,\x22vic.go'+'v.au\x22,\x22wa.'+'gov.au\x22,\x22e'+'ducation.t'+'as.edu.au\x22'+',\x22schools.'+'nsw.edu.au'+'\x22,\x22aw\x22,\x22co'+'m.aw\x22,\x22ax\x22'+',\x22az\x22,\x22com'+'.az\x22,\x22net.'+'az\x22,\x22int.a'+'z\x22,\x22gov.az'+'\x22,\x22org.az\x22'+',\x22edu.az\x22,'+'\x22info.az\x22,'+'\x22pp.az\x22,\x22m'+'il.az\x22,\x22na'+'me.az\x22,\x22pr'+'o.az\x22,\x22biz'+'.az\x22,\x22ba\x22,'+'\x22com.ba\x22,\x22'+'edu.ba\x22,\x22g'+'ov.ba\x22,\x22mi'+'l.ba\x22,\x22net'+'.ba\x22,\x22org.'+'ba\x22,\x22bb\x22,\x22'+'biz.bb\x22,\x22c'+'o.bb\x22,\x22com'+'.bb\x22,\x22edu.'+'bb\x22,\x22gov.b'+'b\x22,\x22info.b'+'b\x22,\x22net.bb'+'\x22,\x22org.bb\x22'+',\x22store.bb'+'\x22,\x22tv.bb\x22,'+'\x22*.bd\x22,\x22be'+'\x22,\x22ac.be\x22,'+'\x22bf\x22,\x22gov.'+'bf\x22,\x22bg\x22,\x22'+'a.bg\x22,\x22b.b'+'g\x22,\x22c.bg\x22,'+'\x22d.bg\x22,\x22e.'+'bg\x22,\x22f.bg\x22'+',\x22g.bg\x22,\x22h'+'.bg\x22,\x22i.bg'+'\x22,\x22j.bg\x22,\x22'+'k.bg\x22,\x22l.b'+'g\x22,\x22m.bg\x22,'+'\x22n.bg\x22,\x22o.'+'bg\x22,\x22p.bg\x22'+',\x22q.bg\x22,\x22r'+'.bg\x22,\x22s.bg'+'\x22,\x22t.bg\x22,\x22')+('u.bg\x22,\x22v.b'+'g\x22,\x22w.bg\x22,'+'\x22x.bg\x22,\x22y.'+'bg\x22,\x22z.bg\x22'+',\x220.bg\x22,\x221'+'.bg\x22,\x222.bg'+'\x22,\x223.bg\x22,\x22'+'4.bg\x22,\x225.b'+'g\x22,\x226.bg\x22,'+'\x227.bg\x22,\x228.'+'bg\x22,\x229.bg\x22'+',\x22bh\x22,\x22com'+'.bh\x22,\x22edu.'+'bh\x22,\x22net.b'+'h\x22,\x22org.bh'+'\x22,\x22gov.bh\x22'+',\x22bi\x22,\x22co.'+'bi\x22,\x22com.b'+'i\x22,\x22edu.bi'+'\x22,\x22or.bi\x22,'+'\x22org.bi\x22,\x22'+'biz\x22,\x22bj\x22,'+'\x22asso.bj\x22,'+'\x22barreau.b'+'j\x22,\x22gouv.b'+'j\x22,\x22bm\x22,\x22c'+'om.bm\x22,\x22ed'+'u.bm\x22,\x22gov'+'.bm\x22,\x22net.'+'bm\x22,\x22org.b'+'m\x22,\x22bn\x22,\x22c'+'om.bn\x22,\x22ed'+'u.bn\x22,\x22gov'+'.bn\x22,\x22net.'+'bn\x22,\x22org.b'+'n\x22,\x22bo\x22,\x22c'+'om.bo\x22,\x22ed'+'u.bo\x22,\x22gob'+'.bo\x22,\x22int.'+'bo\x22,\x22org.b'+'o\x22,\x22net.bo'+'\x22,\x22mil.bo\x22'+',\x22tv.bo\x22,\x22'+'web.bo\x22,\x22a'+'cademia.bo'+'\x22,\x22agro.bo'+'\x22,\x22arte.bo'+'\x22,\x22blog.bo'+'\x22,\x22bolivia'+'.bo\x22,\x22cien'+'cia.bo\x22,\x22c'+'ooperativa'+'.bo\x22,\x22demo'+'cracia.bo\x22'+',\x22deporte.'+'bo\x22,\x22ecolo'+'gia.bo\x22,\x22e'+'conomia.bo'+'\x22,\x22empresa'+'.bo\x22,\x22indi'+'gena.bo\x22,\x22'+'industria.'+'bo\x22,\x22info.'+'bo\x22,\x22medic'+'ina.bo\x22,\x22m'+'ovimiento.'+'bo\x22,\x22music'+'a.bo\x22,\x22nat'+'ural.bo\x22,\x22'+'nombre.bo\x22'+',\x22noticias'+'.bo\x22,\x22patr'+'ia.bo\x22,\x22po'+'litica.bo\x22'+',\x22profesio'+'nal.bo\x22,\x22p'+'lurinacion'+'al.bo\x22,\x22pu'+'eblo.bo\x22,\x22'+'revista.bo'+'\x22,\x22salud.b'+'o\x22,\x22tecnol'+'ogia.bo\x22,\x22'+'tksat.bo\x22,'+'\x22transport'+'e.bo\x22,\x22wik'+'i.bo\x22,\x22br\x22'+',\x229guacu.b'+'r\x22,\x22abc.br'+'\x22,\x22adm.br\x22'+',\x22adv.br\x22,'+'\x22agr.br\x22,\x22'+'aju.br\x22,\x22a'+'m.br\x22,\x22ana'+'ni.br\x22,\x22ap'+'arecida.br'+'\x22,\x22arq.br\x22'+',\x22art.br\x22,'+'\x22ato.br\x22,\x22'+'b.br\x22,\x22bar')+('ueri.br\x22,\x22'+'belem.br\x22,'+'\x22bhz.br\x22,\x22'+'bio.br\x22,\x22b'+'log.br\x22,\x22b'+'md.br\x22,\x22bo'+'avista.br\x22'+',\x22bsb.br\x22,'+'\x22campinagr'+'ande.br\x22,\x22'+'campinas.b'+'r\x22,\x22caxias'+'.br\x22,\x22cim.'+'br\x22,\x22cng.b'+'r\x22,\x22cnt.br'+'\x22,\x22com.br\x22'+',\x22contagem'+'.br\x22,\x22coop'+'.br\x22,\x22cri.'+'br\x22,\x22cuiab'+'a.br\x22,\x22cur'+'itiba.br\x22,'+'\x22def.br\x22,\x22'+'ecn.br\x22,\x22e'+'co.br\x22,\x22ed'+'u.br\x22,\x22emp'+'.br\x22,\x22eng.'+'br\x22,\x22esp.b'+'r\x22,\x22etc.br'+'\x22,\x22eti.br\x22'+',\x22far.br\x22,'+'\x22feira.br\x22'+',\x22flog.br\x22'+',\x22floripa.'+'br\x22,\x22fm.br'+'\x22,\x22fnd.br\x22'+',\x22fortal.b'+'r\x22,\x22fot.br'+'\x22,\x22foz.br\x22'+',\x22fst.br\x22,'+'\x22g12.br\x22,\x22'+'ggf.br\x22,\x22g'+'oiania.br\x22'+',\x22gov.br\x22,'+'\x22ac.gov.br'+'\x22,\x22al.gov.'+'br\x22,\x22am.go'+'v.br\x22,\x22ap.'+'gov.br\x22,\x22b'+'a.gov.br\x22,'+'\x22ce.gov.br'+'\x22,\x22df.gov.'+'br\x22,\x22es.go'+'v.br\x22,\x22go.'+'gov.br\x22,\x22m'+'a.gov.br\x22,'+'\x22mg.gov.br'+'\x22,\x22ms.gov.'+'br\x22,\x22mt.go'+'v.br\x22,\x22pa.'+'gov.br\x22,\x22p'+'b.gov.br\x22,'+'\x22pe.gov.br'+'\x22,\x22pi.gov.'+'br\x22,\x22pr.go'+'v.br\x22,\x22rj.'+'gov.br\x22,\x22r'+'n.gov.br\x22,'+'\x22ro.gov.br'+'\x22,\x22rr.gov.'+'br\x22,\x22rs.go'+'v.br\x22,\x22sc.'+'gov.br\x22,\x22s'+'e.gov.br\x22,'+'\x22sp.gov.br'+'\x22,\x22to.gov.'+'br\x22,\x22gru.b'+'r\x22,\x22imb.br'+'\x22,\x22ind.br\x22'+',\x22inf.br\x22,'+'\x22jab.br\x22,\x22'+'jampa.br\x22,'+'\x22jdf.br\x22,\x22'+'joinville.'+'br\x22,\x22jor.b'+'r\x22,\x22jus.br'+'\x22,\x22leg.br\x22'+',\x22lel.br\x22,'+'\x22londrina.'+'br\x22,\x22macap'+'a.br\x22,\x22mac'+'eio.br\x22,\x22m'+'anaus.br\x22,'+'\x22maringa.b'+'r\x22,\x22mat.br'+'\x22,\x22med.br\x22'+',\x22mil.br\x22,'+'\x22morena.br'+'\x22,\x22mp.br\x22,'+'\x22mus.br\x22,\x22')+('natal.br\x22,'+'\x22net.br\x22,\x22'+'niteroi.br'+'\x22,\x22*.nom.b'+'r\x22,\x22not.br'+'\x22,\x22ntr.br\x22'+',\x22odo.br\x22,'+'\x22ong.br\x22,\x22'+'org.br\x22,\x22o'+'sasco.br\x22,'+'\x22palmas.br'+'\x22,\x22poa.br\x22'+',\x22ppg.br\x22,'+'\x22pro.br\x22,\x22'+'psc.br\x22,\x22p'+'si.br\x22,\x22pv'+'h.br\x22,\x22qsl'+'.br\x22,\x22radi'+'o.br\x22,\x22rec'+'.br\x22,\x22reci'+'fe.br\x22,\x22ri'+'beirao.br\x22'+',\x22rio.br\x22,'+'\x22riobranco'+'.br\x22,\x22riop'+'reto.br\x22,\x22'+'salvador.b'+'r\x22,\x22sampa.'+'br\x22,\x22santa'+'maria.br\x22,'+'\x22santoandr'+'e.br\x22,\x22sao'+'bernardo.b'+'r\x22,\x22saogon'+'ca.br\x22,\x22sj'+'c.br\x22,\x22slg'+'.br\x22,\x22slz.'+'br\x22,\x22soroc'+'aba.br\x22,\x22s'+'rv.br\x22,\x22ta'+'xi.br\x22,\x22tc'+'.br\x22,\x22teo.'+'br\x22,\x22the.b'+'r\x22,\x22tmp.br'+'\x22,\x22trd.br\x22'+',\x22tur.br\x22,'+'\x22tv.br\x22,\x22u'+'di.br\x22,\x22ve'+'t.br\x22,\x22vix'+'.br\x22,\x22vlog'+'.br\x22,\x22wiki'+'.br\x22,\x22zlg.'+'br\x22,\x22bs\x22,\x22'+'com.bs\x22,\x22n'+'et.bs\x22,\x22or'+'g.bs\x22,\x22edu'+'.bs\x22,\x22gov.'+'bs\x22,\x22bt\x22,\x22'+'com.bt\x22,\x22e'+'du.bt\x22,\x22go'+'v.bt\x22,\x22net'+'.bt\x22,\x22org.'+'bt\x22,\x22bv\x22,\x22'+'bw\x22,\x22co.bw'+'\x22,\x22org.bw\x22'+',\x22by\x22,\x22gov'+'.by\x22,\x22mil.'+'by\x22,\x22com.b'+'y\x22,\x22of.by\x22'+',\x22bz\x22,\x22com'+'.bz\x22,\x22net.'+'bz\x22,\x22org.b'+'z\x22,\x22edu.bz'+'\x22,\x22gov.bz\x22'+',\x22ca\x22,\x22ab.'+'ca\x22,\x22bc.ca'+'\x22,\x22mb.ca\x22,'+'\x22nb.ca\x22,\x22n'+'f.ca\x22,\x22nl.'+'ca\x22,\x22ns.ca'+'\x22,\x22nt.ca\x22,'+'\x22nu.ca\x22,\x22o'+'n.ca\x22,\x22pe.'+'ca\x22,\x22qc.ca'+'\x22,\x22sk.ca\x22,'+'\x22yk.ca\x22,\x22g'+'c.ca\x22,\x22cat'+'\x22,\x22cc\x22,\x22cd'+'\x22,\x22gov.cd\x22'+',\x22cf\x22,\x22cg\x22'+',\x22ch\x22,\x22ci\x22'+',\x22org.ci\x22,'+'\x22or.ci\x22,\x22c'+'om.ci\x22,\x22co'+'.ci\x22,\x22edu.'+'ci\x22,\x22ed.ci'+'\x22,\x22ac.ci\x22,'+'\x22net.ci\x22,\x22'+'go.ci\x22,\x22as'+'so.ci\x22,\x22a')+('roport.ci\x22'+',\x22int.ci\x22,'+'\x22presse.ci'+'\x22,\x22md.ci\x22,'+'\x22gouv.ci\x22,'+'\x22*.ck\x22,\x22!w'+'ww.ck\x22,\x22cl'+'\x22,\x22aprende'+'mas.cl\x22,\x22c'+'o.cl\x22,\x22gob'+'.cl\x22,\x22gov.'+'cl\x22,\x22mil.c'+'l\x22,\x22cm\x22,\x22c'+'o.cm\x22,\x22com'+'.cm\x22,\x22gov.'+'cm\x22,\x22net.c'+'m\x22,\x22cn\x22,\x22a'+'c.cn\x22,\x22com'+'.cn\x22,\x22edu.'+'cn\x22,\x22gov.c'+'n\x22,\x22net.cn'+'\x22,\x22org.cn\x22'+',\x22mil.cn\x22,'+'\x22.cn\x22,\x22'+'.cn\x22,\x22.'+'cn\x22,\x22ah.cn'+'\x22,\x22bj.cn\x22,'+'\x22cq.cn\x22,\x22f'+'j.cn\x22,\x22gd.'+'cn\x22,\x22gs.cn'+'\x22,\x22gz.cn\x22,'+'\x22gx.cn\x22,\x22h'+'a.cn\x22,\x22hb.'+'cn\x22,\x22he.cn'+'\x22,\x22hi.cn\x22,'+'\x22hl.cn\x22,\x22h'+'n.cn\x22,\x22jl.'+'cn\x22,\x22js.cn'+'\x22,\x22jx.cn\x22,'+'\x22ln.cn\x22,\x22n'+'m.cn\x22,\x22nx.'+'cn\x22,\x22qh.cn'+'\x22,\x22sc.cn\x22,'+'\x22sd.cn\x22,\x22s'+'h.cn\x22,\x22sn.'+'cn\x22,\x22sx.cn'+'\x22,\x22tj.cn\x22,'+'\x22xj.cn\x22,\x22x'+'z.cn\x22,\x22yn.'+'cn\x22,\x22zj.cn'+'\x22,\x22hk.cn\x22,'+'\x22mo.cn\x22,\x22t'+'w.cn\x22,\x22co\x22'+',\x22arts.co\x22'+',\x22com.co\x22,'+'\x22edu.co\x22,\x22'+'firm.co\x22,\x22'+'gov.co\x22,\x22i'+'nfo.co\x22,\x22i'+'nt.co\x22,\x22mi'+'l.co\x22,\x22net'+'.co\x22,\x22nom.'+'co\x22,\x22org.c'+'o\x22,\x22rec.co'+'\x22,\x22web.co\x22'+',\x22com\x22,\x22co'+'op\x22,\x22cr\x22,\x22'+'ac.cr\x22,\x22co'+'.cr\x22,\x22ed.c'+'r\x22,\x22fi.cr\x22'+',\x22go.cr\x22,\x22'+'or.cr\x22,\x22sa'+'.cr\x22,\x22cu\x22,'+'\x22com.cu\x22,\x22'+'edu.cu\x22,\x22o'+'rg.cu\x22,\x22ne'+'t.cu\x22,\x22gov'+'.cu\x22,\x22inf.'+'cu\x22,\x22cv\x22,\x22'+'cw\x22,\x22com.c'+'w\x22,\x22edu.cw'+'\x22,\x22net.cw\x22'+',\x22org.cw\x22,'+'\x22cx\x22,\x22gov.'+'cx\x22,\x22cy\x22,\x22'+'ac.cy\x22,\x22bi'+'z.cy\x22,\x22com'+'.cy\x22,\x22eklo'+'ges.cy\x22,\x22g'+'ov.cy\x22,\x22lt'+'d.cy\x22,\x22nam'+'e.cy\x22,\x22net'+'.cy\x22,\x22org.'+'cy\x22,\x22parli'+'ament.cy\x22,'+'\x22press.cy\x22'+',\x22pro.cy\x22,'+'\x22tm.cy\x22,\x22c'+'z\x22,\x22de\x22,\x22d'+'j\x22,\x22dk\x22,\x22d')+('m\x22,\x22com.dm'+'\x22,\x22net.dm\x22'+',\x22org.dm\x22,'+'\x22edu.dm\x22,\x22'+'gov.dm\x22,\x22d'+'o\x22,\x22art.do'+'\x22,\x22com.do\x22'+',\x22edu.do\x22,'+'\x22gob.do\x22,\x22'+'gov.do\x22,\x22m'+'il.do\x22,\x22ne'+'t.do\x22,\x22org'+'.do\x22,\x22sld.'+'do\x22,\x22web.d'+'o\x22,\x22dz\x22,\x22c'+'om.dz\x22,\x22or'+'g.dz\x22,\x22net'+'.dz\x22,\x22gov.'+'dz\x22,\x22edu.d'+'z\x22,\x22asso.d'+'z\x22,\x22pol.dz'+'\x22,\x22art.dz\x22'+',\x22ec\x22,\x22com'+'.ec\x22,\x22info'+'.ec\x22,\x22net.'+'ec\x22,\x22fin.e'+'c\x22,\x22k12.ec'+'\x22,\x22med.ec\x22'+',\x22pro.ec\x22,'+'\x22org.ec\x22,\x22'+'edu.ec\x22,\x22g'+'ov.ec\x22,\x22go'+'b.ec\x22,\x22mil'+'.ec\x22,\x22edu\x22'+',\x22ee\x22,\x22edu'+'.ee\x22,\x22gov.'+'ee\x22,\x22riik.'+'ee\x22,\x22lib.e'+'e\x22,\x22med.ee'+'\x22,\x22com.ee\x22'+',\x22pri.ee\x22,'+'\x22aip.ee\x22,\x22'+'org.ee\x22,\x22f'+'ie.ee\x22,\x22eg'+'\x22,\x22com.eg\x22'+',\x22edu.eg\x22,'+'\x22eun.eg\x22,\x22'+'gov.eg\x22,\x22m'+'il.eg\x22,\x22na'+'me.eg\x22,\x22ne'+'t.eg\x22,\x22org'+'.eg\x22,\x22sci.'+'eg\x22,\x22*.er\x22'+',\x22es\x22,\x22com'+'.es\x22,\x22nom.'+'es\x22,\x22org.e'+'s\x22,\x22gob.es'+'\x22,\x22edu.es\x22'+',\x22et\x22,\x22com'+'.et\x22,\x22gov.'+'et\x22,\x22org.e'+'t\x22,\x22edu.et'+'\x22,\x22biz.et\x22'+',\x22name.et\x22'+',\x22info.et\x22'+',\x22net.et\x22,'+'\x22eu\x22,\x22fi\x22,'+'\x22aland.fi\x22'+',\x22fj\x22,\x22ac.'+'fj\x22,\x22biz.f'+'j\x22,\x22com.fj'+'\x22,\x22gov.fj\x22'+',\x22info.fj\x22'+',\x22mil.fj\x22,'+'\x22name.fj\x22,'+'\x22net.fj\x22,\x22'+'org.fj\x22,\x22p'+'ro.fj\x22,\x22*.'+'fk\x22,\x22fm\x22,\x22'+'fo\x22,\x22fr\x22,\x22'+'asso.fr\x22,\x22'+'com.fr\x22,\x22g'+'ouv.fr\x22,\x22n'+'om.fr\x22,\x22pr'+'d.fr\x22,\x22tm.'+'fr\x22,\x22aerop'+'ort.fr\x22,\x22a'+'vocat.fr\x22,'+'\x22avoues.fr'+'\x22,\x22cci.fr\x22'+',\x22chambagr'+'i.fr\x22,\x22chi'+'rurgiens-d'+'entistes.f'+'r\x22,\x22expert'+'s-comptabl'+'es.fr\x22,\x22ge'+'ometre-exp'+'ert.fr\x22,\x22g'+'reta.fr\x22,\x22')+('huissier-j'+'ustice.fr\x22'+',\x22medecin.'+'fr\x22,\x22notai'+'res.fr\x22,\x22p'+'harmacien.'+'fr\x22,\x22port.'+'fr\x22,\x22veter'+'inaire.fr\x22'+',\x22ga\x22,\x22gb\x22'+',\x22gd\x22,\x22ge\x22'+',\x22com.ge\x22,'+'\x22edu.ge\x22,\x22'+'gov.ge\x22,\x22o'+'rg.ge\x22,\x22mi'+'l.ge\x22,\x22net'+'.ge\x22,\x22pvt.'+'ge\x22,\x22gf\x22,\x22'+'gg\x22,\x22co.gg'+'\x22,\x22net.gg\x22'+',\x22org.gg\x22,'+'\x22gh\x22,\x22com.'+'gh\x22,\x22edu.g'+'h\x22,\x22gov.gh'+'\x22,\x22org.gh\x22'+',\x22mil.gh\x22,'+'\x22gi\x22,\x22com.'+'gi\x22,\x22ltd.g'+'i\x22,\x22gov.gi'+'\x22,\x22mod.gi\x22'+',\x22edu.gi\x22,'+'\x22org.gi\x22,\x22'+'gl\x22,\x22co.gl'+'\x22,\x22com.gl\x22'+',\x22edu.gl\x22,'+'\x22net.gl\x22,\x22'+'org.gl\x22,\x22g'+'m\x22,\x22gn\x22,\x22a'+'c.gn\x22,\x22com'+'.gn\x22,\x22edu.'+'gn\x22,\x22gov.g'+'n\x22,\x22org.gn'+'\x22,\x22net.gn\x22'+',\x22gov\x22,\x22gp'+'\x22,\x22com.gp\x22'+',\x22net.gp\x22,'+'\x22mobi.gp\x22,'+'\x22edu.gp\x22,\x22'+'org.gp\x22,\x22a'+'sso.gp\x22,\x22g'+'q\x22,\x22gr\x22,\x22c'+'om.gr\x22,\x22ed'+'u.gr\x22,\x22net'+'.gr\x22,\x22org.'+'gr\x22,\x22gov.g'+'r\x22,\x22gs\x22,\x22g'+'t\x22,\x22com.gt'+'\x22,\x22edu.gt\x22'+',\x22gob.gt\x22,'+'\x22ind.gt\x22,\x22'+'mil.gt\x22,\x22n'+'et.gt\x22,\x22or'+'g.gt\x22,\x22gu\x22'+',\x22com.gu\x22,'+'\x22edu.gu\x22,\x22'+'gov.gu\x22,\x22g'+'uam.gu\x22,\x22i'+'nfo.gu\x22,\x22n'+'et.gu\x22,\x22or'+'g.gu\x22,\x22web'+'.gu\x22,\x22gw\x22,'+'\x22gy\x22,\x22co.g'+'y\x22,\x22com.gy'+'\x22,\x22edu.gy\x22'+',\x22gov.gy\x22,'+'\x22net.gy\x22,\x22'+'org.gy\x22,\x22h'+'k\x22,\x22com.hk'+'\x22,\x22edu.hk\x22'+',\x22gov.hk\x22,'+'\x22idv.hk\x22,\x22'+'net.hk\x22,\x22o'+'rg.hk\x22,\x22'+'.hk\x22,\x22.h'+'k\x22,\x22.hk\x22'+',\x22.hk\x22,\x22'+'.hk\x22,\x22'+'.hk\x22,\x22.h'+'k\x22,\x22.hk\x22'+',\x22.hk\x22,\x22'+'.hk\x22,\x22'+'.hk\x22,\x22.h'+'k\x22,\x22.hk\x22'+',\x22.hk\x22,\x22'+'.hk\x22,\x22hm'+'\x22,\x22hn\x22,\x22co'+'m.hn\x22,\x22edu'+'.hn\x22,\x22org.'+'hn\x22,\x22net.h'+'n\x22,\x22mil.hn')+('\x22,\x22gob.hn\x22'+',\x22hr\x22,\x22iz.'+'hr\x22,\x22from.'+'hr\x22,\x22name.'+'hr\x22,\x22com.h'+'r\x22,\x22ht\x22,\x22c'+'om.ht\x22,\x22sh'+'op.ht\x22,\x22fi'+'rm.ht\x22,\x22in'+'fo.ht\x22,\x22ad'+'ult.ht\x22,\x22n'+'et.ht\x22,\x22pr'+'o.ht\x22,\x22org'+'.ht\x22,\x22med.'+'ht\x22,\x22art.h'+'t\x22,\x22coop.h'+'t\x22,\x22pol.ht'+'\x22,\x22asso.ht'+'\x22,\x22edu.ht\x22'+',\x22rel.ht\x22,'+'\x22gouv.ht\x22,'+'\x22perso.ht\x22'+',\x22hu\x22,\x22co.'+'hu\x22,\x22info.'+'hu\x22,\x22org.h'+'u\x22,\x22priv.h'+'u\x22,\x22sport.'+'hu\x22,\x22tm.hu'+'\x22,\x222000.hu'+'\x22,\x22agrar.h'+'u\x22,\x22bolt.h'+'u\x22,\x22casino'+'.hu\x22,\x22city'+'.hu\x22,\x22erot'+'ica.hu\x22,\x22e'+'rotika.hu\x22'+',\x22film.hu\x22'+',\x22forum.hu'+'\x22,\x22games.h'+'u\x22,\x22hotel.'+'hu\x22,\x22ingat'+'lan.hu\x22,\x22j'+'ogasz.hu\x22,'+'\x22konyvelo.'+'hu\x22,\x22lakas'+'.hu\x22,\x22medi'+'a.hu\x22,\x22new'+'s.hu\x22,\x22rek'+'lam.hu\x22,\x22s'+'ex.hu\x22,\x22sh'+'op.hu\x22,\x22su'+'li.hu\x22,\x22sz'+'ex.hu\x22,\x22to'+'zsde.hu\x22,\x22'+'utazas.hu\x22'+',\x22video.hu'+'\x22,\x22id\x22,\x22ac'+'.id\x22,\x22biz.'+'id\x22,\x22co.id'+'\x22,\x22desa.id'+'\x22,\x22go.id\x22,'+'\x22mil.id\x22,\x22'+'my.id\x22,\x22ne'+'t.id\x22,\x22or.'+'id\x22,\x22ponpe'+'s.id\x22,\x22sch'+'.id\x22,\x22web.'+'id\x22,\x22ie\x22,\x22'+'gov.ie\x22,\x22i'+'l\x22,\x22ac.il\x22'+',\x22co.il\x22,\x22'+'gov.il\x22,\x22i'+'df.il\x22,\x22k1'+'2.il\x22,\x22mun'+'i.il\x22,\x22net'+'.il\x22,\x22org.'+'il\x22,\x22im\x22,\x22'+'ac.im\x22,\x22co'+'.im\x22,\x22com.'+'im\x22,\x22ltd.c'+'o.im\x22,\x22net'+'.im\x22,\x22org.'+'im\x22,\x22plc.c'+'o.im\x22,\x22tt.'+'im\x22,\x22tv.im'+'\x22,\x22in\x22,\x22co'+'.in\x22,\x22firm'+'.in\x22,\x22net.'+'in\x22,\x22org.i'+'n\x22,\x22gen.in'+'\x22,\x22ind.in\x22'+',\x22nic.in\x22,'+'\x22ac.in\x22,\x22e'+'du.in\x22,\x22re'+'s.in\x22,\x22gov'+'.in\x22,\x22mil.'+'in\x22,\x22info\x22'+',\x22int\x22,\x22eu'+'.int\x22,\x22io\x22'+',\x22com.io\x22,')+('\x22iq\x22,\x22gov.'+'iq\x22,\x22edu.i'+'q\x22,\x22mil.iq'+'\x22,\x22com.iq\x22'+',\x22org.iq\x22,'+'\x22net.iq\x22,\x22'+'ir\x22,\x22ac.ir'+'\x22,\x22co.ir\x22,'+'\x22gov.ir\x22,\x22'+'id.ir\x22,\x22ne'+'t.ir\x22,\x22org'+'.ir\x22,\x22sch.'+'ir\x22,\x22'+'.ir\x22,\x22'+'.ir\x22,\x22is\x22'+',\x22net.is\x22,'+'\x22com.is\x22,\x22'+'edu.is\x22,\x22g'+'ov.is\x22,\x22or'+'g.is\x22,\x22int'+'.is\x22,\x22it\x22,'+'\x22gov.it\x22,\x22'+'edu.it\x22,\x22a'+'br.it\x22,\x22ab'+'ruzzo.it\x22,'+'\x22aosta-val'+'ley.it\x22,\x22a'+'ostavalley'+'.it\x22,\x22bas.'+'it\x22,\x22basil'+'icata.it\x22,'+'\x22cal.it\x22,\x22'+'calabria.i'+'t\x22,\x22cam.it'+'\x22,\x22campani'+'a.it\x22,\x22emi'+'lia-romagn'+'a.it\x22,\x22emi'+'liaromagna'+'.it\x22,\x22emr.'+'it\x22,\x22friul'+'i-v-giulia'+'.it\x22,\x22friu'+'li-ve-giul'+'ia.it\x22,\x22fr'+'iuli-vegiu'+'lia.it\x22,\x22f'+'riuli-vene'+'zia-giulia'+'.it\x22,\x22friu'+'li-venezia'+'giulia.it\x22'+',\x22friuli-v'+'giulia.it\x22'+',\x22friuliv-'+'giulia.it\x22'+',\x22friulive'+'-giulia.it'+'\x22,\x22friuliv'+'egiulia.it'+'\x22,\x22friuliv'+'enezia-giu'+'lia.it\x22,\x22f'+'riulivenez'+'iagiulia.i'+'t\x22,\x22friuli'+'vgiulia.it'+'\x22,\x22fvg.it\x22'+',\x22laz.it\x22,'+'\x22lazio.it\x22'+',\x22lig.it\x22,'+'\x22liguria.i'+'t\x22,\x22lom.it'+'\x22,\x22lombard'+'ia.it\x22,\x22lo'+'mbardy.it\x22'+',\x22lucania.'+'it\x22,\x22mar.i'+'t\x22,\x22marche'+'.it\x22,\x22mol.'+'it\x22,\x22molis'+'e.it\x22,\x22pie'+'dmont.it\x22,'+'\x22piemonte.'+'it\x22,\x22pmn.i'+'t\x22,\x22pug.it'+'\x22,\x22puglia.'+'it\x22,\x22sar.i'+'t\x22,\x22sardeg'+'na.it\x22,\x22sa'+'rdinia.it\x22'+',\x22sic.it\x22,'+'\x22sicilia.i'+'t\x22,\x22sicily'+'.it\x22,\x22taa.'+'it\x22,\x22tos.i'+'t\x22,\x22toscan'+'a.it\x22,\x22tre'+'ntin-sud-t'+'irol.it\x22,\x22')+('trentin-s'+'d-tirol.it'+'\x22,\x22trentin'+'-sudtirol.'+'it\x22,\x22trent'+'in-sdtiro'+'l.it\x22,\x22tre'+'ntin-sued-'+'tirol.it\x22,'+'\x22trentin-s'+'uedtirol.i'+'t\x22,\x22trenti'+'no-a-adige'+'.it\x22,\x22tren'+'tino-aadig'+'e.it\x22,\x22tre'+'ntino-alto'+'-adige.it\x22'+',\x22trentino'+'-altoadige'+'.it\x22,\x22tren'+'tino-s-tir'+'ol.it\x22,\x22tr'+'entino-sti'+'rol.it\x22,\x22t'+'rentino-su'+'d-tirol.it'+'\x22,\x22trentin'+'o-sd-tiro'+'l.it\x22,\x22tre'+'ntino-sudt'+'irol.it\x22,\x22'+'trentino-s'+'dtirol.it'+'\x22,\x22trentin'+'o-sued-tir'+'ol.it\x22,\x22tr'+'entino-sue'+'dtirol.it\x22'+',\x22trentino'+'.it\x22,\x22tren'+'tinoa-adig'+'e.it\x22,\x22tre'+'ntinoaadig'+'e.it\x22,\x22tre'+'ntinoalto-'+'adige.it\x22,'+'\x22trentinoa'+'ltoadige.i'+'t\x22,\x22trenti'+'nos-tirol.'+'it\x22,\x22trent'+'inostirol.'+'it\x22,\x22trent'+'inosud-tir'+'ol.it\x22,\x22tr'+'entinosd-'+'tirol.it\x22,'+'\x22trentinos'+'udtirol.it'+'\x22,\x22trentin'+'osdtirol.'+'it\x22,\x22trent'+'inosued-ti'+'rol.it\x22,\x22t'+'rentinosue'+'dtirol.it\x22'+',\x22trentins'+'ud-tirol.i'+'t\x22,\x22trenti'+'nsd-tirol'+'.it\x22,\x22tren'+'tinsudtiro'+'l.it\x22,\x22tre'+'ntinsdtir'+'ol.it\x22,\x22tr'+'entinsued-'+'tirol.it\x22,'+'\x22trentinsu'+'edtirol.it'+'\x22,\x22tuscany'+'.it\x22,\x22umb.'+'it\x22,\x22umbri'+'a.it\x22,\x22val'+'-d-aosta.i'+'t\x22,\x22val-da'+'osta.it\x22,\x22'+'vald-aosta'+'.it\x22,\x22vald'+'aosta.it\x22,'+'\x22valle-aos'+'ta.it\x22,\x22va'+'lle-d-aost'+'a.it\x22,\x22val'+'le-daosta.'+'it\x22,\x22valle'+'aosta.it\x22,'+'\x22valled-ao'+'sta.it\x22,\x22v'+'alledaosta')+('.it\x22,\x22vall'+'ee-aoste.i'+'t\x22,\x22valle'+'-aoste.it\x22'+',\x22vallee-d'+'-aoste.it\x22'+',\x22valle-d'+'-aoste.it\x22'+',\x22valleeao'+'ste.it\x22,\x22v'+'alleaoste'+'.it\x22,\x22vall'+'eedaoste.i'+'t\x22,\x22valle'+'daoste.it\x22'+',\x22vao.it\x22,'+'\x22vda.it\x22,\x22'+'ven.it\x22,\x22v'+'eneto.it\x22,'+'\x22ag.it\x22,\x22a'+'grigento.i'+'t\x22,\x22al.it\x22'+',\x22alessand'+'ria.it\x22,\x22a'+'lto-adige.'+'it\x22,\x22altoa'+'dige.it\x22,\x22'+'an.it\x22,\x22an'+'cona.it\x22,\x22'+'andria-bar'+'letta-tran'+'i.it\x22,\x22and'+'ria-trani-'+'barletta.i'+'t\x22,\x22andria'+'barlettatr'+'ani.it\x22,\x22a'+'ndriatrani'+'barletta.i'+'t\x22,\x22ao.it\x22'+',\x22aosta.it'+'\x22,\x22aoste.i'+'t\x22,\x22ap.it\x22'+',\x22aq.it\x22,\x22'+'aquila.it\x22'+',\x22ar.it\x22,\x22'+'arezzo.it\x22'+',\x22ascoli-p'+'iceno.it\x22,'+'\x22ascolipic'+'eno.it\x22,\x22a'+'sti.it\x22,\x22a'+'t.it\x22,\x22av.'+'it\x22,\x22avell'+'ino.it\x22,\x22b'+'a.it\x22,\x22bal'+'san-sudtir'+'ol.it\x22,\x22ba'+'lsan-sdti'+'rol.it\x22,\x22b'+'alsan-sued'+'tirol.it\x22,'+'\x22balsan.it'+'\x22,\x22bari.it'+'\x22,\x22barlett'+'a-trani-an'+'dria.it\x22,\x22'+'barlettatr'+'aniandria.'+'it\x22,\x22bellu'+'no.it\x22,\x22be'+'nevento.it'+'\x22,\x22bergamo'+'.it\x22,\x22bg.i'+'t\x22,\x22bi.it\x22'+',\x22biella.i'+'t\x22,\x22bl.it\x22'+',\x22bn.it\x22,\x22'+'bo.it\x22,\x22bo'+'logna.it\x22,'+'\x22bolzano-a'+'ltoadige.i'+'t\x22,\x22bolzan'+'o.it\x22,\x22boz'+'en-sudtiro'+'l.it\x22,\x22boz'+'en-sdtiro'+'l.it\x22,\x22boz'+'en-suedtir'+'ol.it\x22,\x22bo'+'zen.it\x22,\x22b'+'r.it\x22,\x22bre'+'scia.it\x22,\x22'+'brindisi.i'+'t\x22,\x22bs.it\x22'+',\x22bt.it\x22,\x22'+'bulsan-sud'+'tirol.it\x22,'+'\x22bulsan-s'+'dtirol.it\x22')+(',\x22bulsan-s'+'uedtirol.i'+'t\x22,\x22bulsan'+'.it\x22,\x22bz.i'+'t\x22,\x22ca.it\x22'+',\x22cagliari'+'.it\x22,\x22calt'+'anissetta.'+'it\x22,\x22campi'+'dano-medio'+'.it\x22,\x22camp'+'idanomedio'+'.it\x22,\x22camp'+'obasso.it\x22'+',\x22carbonia'+'-iglesias.'+'it\x22,\x22carbo'+'niaiglesia'+'s.it\x22,\x22car'+'rara-massa'+'.it\x22,\x22carr'+'aramassa.i'+'t\x22,\x22casert'+'a.it\x22,\x22cat'+'ania.it\x22,\x22'+'catanzaro.'+'it\x22,\x22cb.it'+'\x22,\x22ce.it\x22,'+'\x22cesena-fo'+'rli.it\x22,\x22c'+'esena-forl'+'.it\x22,\x22ces'+'enaforli.i'+'t\x22,\x22cesena'+'forl.it\x22,'+'\x22ch.it\x22,\x22c'+'hieti.it\x22,'+'\x22ci.it\x22,\x22c'+'l.it\x22,\x22cn.'+'it\x22,\x22co.it'+'\x22,\x22como.it'+'\x22,\x22cosenza'+'.it\x22,\x22cr.i'+'t\x22,\x22cremon'+'a.it\x22,\x22cro'+'tone.it\x22,\x22'+'cs.it\x22,\x22ct'+'.it\x22,\x22cune'+'o.it\x22,\x22cz.'+'it\x22,\x22dell-'+'ogliastra.'+'it\x22,\x22dello'+'gliastra.i'+'t\x22,\x22en.it\x22'+',\x22enna.it\x22'+',\x22fc.it\x22,\x22'+'fe.it\x22,\x22fe'+'rmo.it\x22,\x22f'+'errara.it\x22'+',\x22fg.it\x22,\x22'+'fi.it\x22,\x22fi'+'renze.it\x22,'+'\x22florence.'+'it\x22,\x22fm.it'+'\x22,\x22foggia.'+'it\x22,\x22forli'+'-cesena.it'+'\x22,\x22forl-c'+'esena.it\x22,'+'\x22forlicese'+'na.it\x22,\x22fo'+'rlcesena.'+'it\x22,\x22fr.it'+'\x22,\x22frosino'+'ne.it\x22,\x22ge'+'.it\x22,\x22geno'+'a.it\x22,\x22gen'+'ova.it\x22,\x22g'+'o.it\x22,\x22gor'+'izia.it\x22,\x22'+'gr.it\x22,\x22gr'+'osseto.it\x22'+',\x22iglesias'+'-carbonia.'+'it\x22,\x22igles'+'iascarboni'+'a.it\x22,\x22im.'+'it\x22,\x22imper'+'ia.it\x22,\x22is'+'.it\x22,\x22iser'+'nia.it\x22,\x22k'+'r.it\x22,\x22la-'+'spezia.it\x22'+',\x22laquila.'+'it\x22,\x22laspe'+'zia.it\x22,\x22l'+'atina.it\x22,'+'\x22lc.it\x22,\x22l'+'e.it\x22,\x22lec'+'ce.it\x22,\x22le')+('cco.it\x22,\x22l'+'i.it\x22,\x22liv'+'orno.it\x22,\x22'+'lo.it\x22,\x22lo'+'di.it\x22,\x22lt'+'.it\x22,\x22lu.i'+'t\x22,\x22lucca.'+'it\x22,\x22macer'+'ata.it\x22,\x22m'+'antova.it\x22'+',\x22massa-ca'+'rrara.it\x22,'+'\x22massacarr'+'ara.it\x22,\x22m'+'atera.it\x22,'+'\x22mb.it\x22,\x22m'+'c.it\x22,\x22me.'+'it\x22,\x22medio'+'-campidano'+'.it\x22,\x22medi'+'ocampidano'+'.it\x22,\x22mess'+'ina.it\x22,\x22m'+'i.it\x22,\x22mil'+'an.it\x22,\x22mi'+'lano.it\x22,\x22'+'mn.it\x22,\x22mo'+'.it\x22,\x22mode'+'na.it\x22,\x22mo'+'nza-brianz'+'a.it\x22,\x22mon'+'za-e-della'+'-brianza.i'+'t\x22,\x22monza.'+'it\x22,\x22monza'+'brianza.it'+'\x22,\x22monzaeb'+'rianza.it\x22'+',\x22monzaede'+'llabrianza'+'.it\x22,\x22ms.i'+'t\x22,\x22mt.it\x22'+',\x22na.it\x22,\x22'+'naples.it\x22'+',\x22napoli.i'+'t\x22,\x22no.it\x22'+',\x22novara.i'+'t\x22,\x22nu.it\x22'+',\x22nuoro.it'+'\x22,\x22og.it\x22,'+'\x22ogliastra'+'.it\x22,\x22olbi'+'a-tempio.i'+'t\x22,\x22olbiat'+'empio.it\x22,'+'\x22or.it\x22,\x22o'+'ristano.it'+'\x22,\x22ot.it\x22,'+'\x22pa.it\x22,\x22p'+'adova.it\x22,'+'\x22padua.it\x22'+',\x22palermo.'+'it\x22,\x22parma'+'.it\x22,\x22pavi'+'a.it\x22,\x22pc.'+'it\x22,\x22pd.it'+'\x22,\x22pe.it\x22,'+'\x22perugia.i'+'t\x22,\x22pesaro'+'-urbino.it'+'\x22,\x22pesarou'+'rbino.it\x22,'+'\x22pescara.i'+'t\x22,\x22pg.it\x22'+',\x22pi.it\x22,\x22'+'piacenza.i'+'t\x22,\x22pisa.i'+'t\x22,\x22pistoi'+'a.it\x22,\x22pn.'+'it\x22,\x22po.it'+'\x22,\x22pordeno'+'ne.it\x22,\x22po'+'tenza.it\x22,'+'\x22pr.it\x22,\x22p'+'rato.it\x22,\x22'+'pt.it\x22,\x22pu'+'.it\x22,\x22pv.i'+'t\x22,\x22pz.it\x22'+',\x22ra.it\x22,\x22'+'ragusa.it\x22'+',\x22ravenna.'+'it\x22,\x22rc.it'+'\x22,\x22re.it\x22,'+'\x22reggio-ca'+'labria.it\x22'+',\x22reggio-e'+'milia.it\x22,'+'\x22reggiocal'+'abria.it\x22,'+'\x22reggioemi')+('lia.it\x22,\x22r'+'g.it\x22,\x22ri.'+'it\x22,\x22rieti'+'.it\x22,\x22rimi'+'ni.it\x22,\x22rm'+'.it\x22,\x22rn.i'+'t\x22,\x22ro.it\x22'+',\x22roma.it\x22'+',\x22rome.it\x22'+',\x22rovigo.i'+'t\x22,\x22sa.it\x22'+',\x22salerno.'+'it\x22,\x22sassa'+'ri.it\x22,\x22sa'+'vona.it\x22,\x22'+'si.it\x22,\x22si'+'ena.it\x22,\x22s'+'iracusa.it'+'\x22,\x22so.it\x22,'+'\x22sondrio.i'+'t\x22,\x22sp.it\x22'+',\x22sr.it\x22,\x22'+'ss.it\x22,\x22su'+'edtirol.it'+'\x22,\x22sdtiro'+'l.it\x22,\x22sv.'+'it\x22,\x22ta.it'+'\x22,\x22taranto'+'.it\x22,\x22te.i'+'t\x22,\x22tempio'+'-olbia.it\x22'+',\x22tempiool'+'bia.it\x22,\x22t'+'eramo.it\x22,'+'\x22terni.it\x22'+',\x22tn.it\x22,\x22'+'to.it\x22,\x22to'+'rino.it\x22,\x22'+'tp.it\x22,\x22tr'+'.it\x22,\x22tran'+'i-andria-b'+'arletta.it'+'\x22,\x22trani-b'+'arletta-an'+'dria.it\x22,\x22'+'traniandri'+'abarletta.'+'it\x22,\x22trani'+'barlettaan'+'dria.it\x22,\x22'+'trapani.it'+'\x22,\x22trento.'+'it\x22,\x22trevi'+'so.it\x22,\x22tr'+'ieste.it\x22,'+'\x22ts.it\x22,\x22t'+'urin.it\x22,\x22'+'tv.it\x22,\x22ud'+'.it\x22,\x22udin'+'e.it\x22,\x22urb'+'ino-pesaro'+'.it\x22,\x22urbi'+'nopesaro.i'+'t\x22,\x22va.it\x22'+',\x22varese.i'+'t\x22,\x22vb.it\x22'+',\x22vc.it\x22,\x22'+'ve.it\x22,\x22ve'+'nezia.it\x22,'+'\x22venice.it'+'\x22,\x22verbani'+'a.it\x22,\x22ver'+'celli.it\x22,'+'\x22verona.it'+'\x22,\x22vi.it\x22,'+'\x22vibo-vale'+'ntia.it\x22,\x22'+'vibovalent'+'ia.it\x22,\x22vi'+'cenza.it\x22,'+'\x22viterbo.i'+'t\x22,\x22vr.it\x22'+',\x22vs.it\x22,\x22'+'vt.it\x22,\x22vv'+'.it\x22,\x22je\x22,'+'\x22co.je\x22,\x22n'+'et.je\x22,\x22or'+'g.je\x22,\x22*.j'+'m\x22,\x22jo\x22,\x22c'+'om.jo\x22,\x22or'+'g.jo\x22,\x22net'+'.jo\x22,\x22edu.'+'jo\x22,\x22sch.j'+'o\x22,\x22gov.jo'+'\x22,\x22mil.jo\x22'+',\x22name.jo\x22'+',\x22jobs\x22,\x22j'+'p\x22,\x22ac.jp\x22'+',\x22ad.jp\x22,\x22'+'co.jp\x22,\x22ed')+('.jp\x22,\x22go.j'+'p\x22,\x22gr.jp\x22'+',\x22lg.jp\x22,\x22'+'ne.jp\x22,\x22or'+'.jp\x22,\x22aich'+'i.jp\x22,\x22aki'+'ta.jp\x22,\x22ao'+'mori.jp\x22,\x22'+'chiba.jp\x22,'+'\x22ehime.jp\x22'+',\x22fukui.jp'+'\x22,\x22fukuoka'+'.jp\x22,\x22fuku'+'shima.jp\x22,'+'\x22gifu.jp\x22,'+'\x22gunma.jp\x22'+',\x22hiroshim'+'a.jp\x22,\x22hok'+'kaido.jp\x22,'+'\x22hyogo.jp\x22'+',\x22ibaraki.'+'jp\x22,\x22ishik'+'awa.jp\x22,\x22i'+'wate.jp\x22,\x22'+'kagawa.jp\x22'+',\x22kagoshim'+'a.jp\x22,\x22kan'+'agawa.jp\x22,'+'\x22kochi.jp\x22'+',\x22kumamoto'+'.jp\x22,\x22kyot'+'o.jp\x22,\x22mie'+'.jp\x22,\x22miya'+'gi.jp\x22,\x22mi'+'yazaki.jp\x22'+',\x22nagano.j'+'p\x22,\x22nagasa'+'ki.jp\x22,\x22na'+'ra.jp\x22,\x22ni'+'igata.jp\x22,'+'\x22oita.jp\x22,'+'\x22okayama.j'+'p\x22,\x22okinaw'+'a.jp\x22,\x22osa'+'ka.jp\x22,\x22sa'+'ga.jp\x22,\x22sa'+'itama.jp\x22,'+'\x22shiga.jp\x22'+',\x22shimane.'+'jp\x22,\x22shizu'+'oka.jp\x22,\x22t'+'ochigi.jp\x22'+',\x22tokushim'+'a.jp\x22,\x22tok'+'yo.jp\x22,\x22to'+'ttori.jp\x22,'+'\x22toyama.jp'+'\x22,\x22wakayam'+'a.jp\x22,\x22yam'+'agata.jp\x22,'+'\x22yamaguchi'+'.jp\x22,\x22yama'+'nashi.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22.'+'jp\x22,\x22.jp'+'\x22,\x22.jp\x22,'+'\x22.jp\x22,\x22'+'.jp\x22,\x22'+'.jp\x22,\x22.j'+'p\x22,\x22.jp\x22'+',\x22.jp\x22,\x22'+'.jp\x22,\x22'+'.jp\x22,\x22.j'+'p\x22,\x22.jp\x22')+(',\x22.jp\x22,'+'\x22*.kawasak'+'i.jp\x22,\x22*.k'+'itakyushu.'+'jp\x22,\x22*.kob'+'e.jp\x22,\x22*.n'+'agoya.jp\x22,'+'\x22*.sapporo'+'.jp\x22,\x22*.se'+'ndai.jp\x22,\x22'+'*.yokohama'+'.jp\x22,\x22!cit'+'y.kawasaki'+'.jp\x22,\x22!cit'+'y.kitakyus'+'hu.jp\x22,\x22!c'+'ity.kobe.j'+'p\x22,\x22!city.'+'nagoya.jp\x22'+',\x22!city.sa'+'pporo.jp\x22,'+'\x22!city.sen'+'dai.jp\x22,\x22!'+'city.yokoh'+'ama.jp\x22,\x22a'+'isai.aichi'+'.jp\x22,\x22ama.'+'aichi.jp\x22,'+'\x22anjo.aich'+'i.jp\x22,\x22asu'+'ke.aichi.j'+'p\x22,\x22chiryu'+'.aichi.jp\x22'+',\x22chita.ai'+'chi.jp\x22,\x22f'+'uso.aichi.'+'jp\x22,\x22gamag'+'ori.aichi.'+'jp\x22,\x22handa'+'.aichi.jp\x22'+',\x22hazu.aic'+'hi.jp\x22,\x22he'+'kinan.aich'+'i.jp\x22,\x22hig'+'ashiura.ai'+'chi.jp\x22,\x22i'+'chinomiya.'+'aichi.jp\x22,'+'\x22inazawa.a'+'ichi.jp\x22,\x22'+'inuyama.ai'+'chi.jp\x22,\x22i'+'sshiki.aic'+'hi.jp\x22,\x22iw'+'akura.aich'+'i.jp\x22,\x22kan'+'ie.aichi.j'+'p\x22,\x22kariya'+'.aichi.jp\x22'+',\x22kasugai.'+'aichi.jp\x22,'+'\x22kira.aich'+'i.jp\x22,\x22kiy'+'osu.aichi.'+'jp\x22,\x22komak'+'i.aichi.jp'+'\x22,\x22konan.a'+'ichi.jp\x22,\x22'+'kota.aichi'+'.jp\x22,\x22miha'+'ma.aichi.j'+'p\x22,\x22miyosh'+'i.aichi.jp'+'\x22,\x22nishio.'+'aichi.jp\x22,'+'\x22nisshin.a'+'ichi.jp\x22,\x22'+'obu.aichi.'+'jp\x22,\x22oguch'+'i.aichi.jp'+'\x22,\x22oharu.a'+'ichi.jp\x22,\x22'+'okazaki.ai'+'chi.jp\x22,\x22o'+'wariasahi.'+'aichi.jp\x22,'+'\x22seto.aich'+'i.jp\x22,\x22shi'+'katsu.aich'+'i.jp\x22,\x22shi'+'nshiro.aic'+'hi.jp\x22,\x22sh'+'itara.aich'+'i.jp\x22,\x22tah'+'ara.aichi.'+'jp\x22,\x22takah'+'ama.aichi.'+'jp\x22,\x22tobis'+'hima.aichi'+'.jp\x22,\x22toei')+('.aichi.jp\x22'+',\x22togo.aic'+'hi.jp\x22,\x22to'+'kai.aichi.'+'jp\x22,\x22tokon'+'ame.aichi.'+'jp\x22,\x22toyoa'+'ke.aichi.j'+'p\x22,\x22toyoha'+'shi.aichi.'+'jp\x22,\x22toyok'+'awa.aichi.'+'jp\x22,\x22toyon'+'e.aichi.jp'+'\x22,\x22toyota.'+'aichi.jp\x22,'+'\x22tsushima.'+'aichi.jp\x22,'+'\x22yatomi.ai'+'chi.jp\x22,\x22a'+'kita.akita'+'.jp\x22,\x22dais'+'en.akita.j'+'p\x22,\x22fujisa'+'to.akita.j'+'p\x22,\x22gojome'+'.akita.jp\x22'+',\x22hachirog'+'ata.akita.'+'jp\x22,\x22happo'+'u.akita.jp'+'\x22,\x22higashi'+'naruse.aki'+'ta.jp\x22,\x22ho'+'njo.akita.'+'jp\x22,\x22honjy'+'o.akita.jp'+'\x22,\x22ikawa.a'+'kita.jp\x22,\x22'+'kamikoani.'+'akita.jp\x22,'+'\x22kamioka.a'+'kita.jp\x22,\x22'+'katagami.a'+'kita.jp\x22,\x22'+'kazuno.aki'+'ta.jp\x22,\x22ki'+'taakita.ak'+'ita.jp\x22,\x22k'+'osaka.akit'+'a.jp\x22,\x22kyo'+'wa.akita.j'+'p\x22,\x22misato'+'.akita.jp\x22'+',\x22mitane.a'+'kita.jp\x22,\x22'+'moriyoshi.'+'akita.jp\x22,'+'\x22nikaho.ak'+'ita.jp\x22,\x22n'+'oshiro.aki'+'ta.jp\x22,\x22od'+'ate.akita.'+'jp\x22,\x22oga.a'+'kita.jp\x22,\x22'+'ogata.akit'+'a.jp\x22,\x22sem'+'boku.akita'+'.jp\x22,\x22yoko'+'te.akita.j'+'p\x22,\x22yuriho'+'njo.akita.'+'jp\x22,\x22aomor'+'i.aomori.j'+'p\x22,\x22gonohe'+'.aomori.jp'+'\x22,\x22hachino'+'he.aomori.'+'jp\x22,\x22hashi'+'kami.aomor'+'i.jp\x22,\x22hir'+'anai.aomor'+'i.jp\x22,\x22hir'+'osaki.aomo'+'ri.jp\x22,\x22it'+'ayanagi.ao'+'mori.jp\x22,\x22'+'kuroishi.a'+'omori.jp\x22,'+'\x22misawa.ao'+'mori.jp\x22,\x22'+'mutsu.aomo'+'ri.jp\x22,\x22na'+'kadomari.a'+'omori.jp\x22,'+'\x22noheji.ao'+'mori.jp\x22,\x22'+'oirase.aom'+'ori.jp\x22,\x22o'+'wani.aomor')+('i.jp\x22,\x22rok'+'unohe.aomo'+'ri.jp\x22,\x22sa'+'nnohe.aomo'+'ri.jp\x22,\x22sh'+'ichinohe.a'+'omori.jp\x22,'+'\x22shingo.ao'+'mori.jp\x22,\x22'+'takko.aomo'+'ri.jp\x22,\x22to'+'wada.aomor'+'i.jp\x22,\x22tsu'+'garu.aomor'+'i.jp\x22,\x22tsu'+'ruta.aomor'+'i.jp\x22,\x22abi'+'ko.chiba.j'+'p\x22,\x22asahi.'+'chiba.jp\x22,'+'\x22chonan.ch'+'iba.jp\x22,\x22c'+'hosei.chib'+'a.jp\x22,\x22cho'+'shi.chiba.'+'jp\x22,\x22chuo.'+'chiba.jp\x22,'+'\x22funabashi'+'.chiba.jp\x22'+',\x22futtsu.c'+'hiba.jp\x22,\x22'+'hanamigawa'+'.chiba.jp\x22'+',\x22ichihara'+'.chiba.jp\x22'+',\x22ichikawa'+'.chiba.jp\x22'+',\x22ichinomi'+'ya.chiba.j'+'p\x22,\x22inzai.'+'chiba.jp\x22,'+'\x22isumi.chi'+'ba.jp\x22,\x22ka'+'magaya.chi'+'ba.jp\x22,\x22ka'+'mogawa.chi'+'ba.jp\x22,\x22ka'+'shiwa.chib'+'a.jp\x22,\x22kat'+'ori.chiba.'+'jp\x22,\x22katsu'+'ura.chiba.'+'jp\x22,\x22kimit'+'su.chiba.j'+'p\x22,\x22kisara'+'zu.chiba.j'+'p\x22,\x22kozaki'+'.chiba.jp\x22'+',\x22kujukuri'+'.chiba.jp\x22'+',\x22kyonan.c'+'hiba.jp\x22,\x22'+'matsudo.ch'+'iba.jp\x22,\x22m'+'idori.chib'+'a.jp\x22,\x22mih'+'ama.chiba.'+'jp\x22,\x22minam'+'iboso.chib'+'a.jp\x22,\x22mob'+'ara.chiba.'+'jp\x22,\x22mutsu'+'zawa.chiba'+'.jp\x22,\x22naga'+'ra.chiba.j'+'p\x22,\x22nagare'+'yama.chiba'+'.jp\x22,\x22nara'+'shino.chib'+'a.jp\x22,\x22nar'+'ita.chiba.'+'jp\x22,\x22noda.'+'chiba.jp\x22,'+'\x22oamishira'+'sato.chiba'+'.jp\x22,\x22omig'+'awa.chiba.'+'jp\x22,\x22onjuk'+'u.chiba.jp'+'\x22,\x22otaki.c'+'hiba.jp\x22,\x22'+'sakae.chib'+'a.jp\x22,\x22sak'+'ura.chiba.'+'jp\x22,\x22shimo'+'fusa.chiba'+'.jp\x22,\x22shir'+'ako.chiba.'+'jp\x22,\x22shiro'+'i.chiba.jp')+('\x22,\x22shisui.'+'chiba.jp\x22,'+'\x22sodegaura'+'.chiba.jp\x22'+',\x22sosa.chi'+'ba.jp\x22,\x22ta'+'ko.chiba.j'+'p\x22,\x22tateya'+'ma.chiba.j'+'p\x22,\x22togane'+'.chiba.jp\x22'+',\x22tohnosho'+'.chiba.jp\x22'+',\x22tomisato'+'.chiba.jp\x22'+',\x22urayasu.'+'chiba.jp\x22,'+'\x22yachimata'+'.chiba.jp\x22'+',\x22yachiyo.'+'chiba.jp\x22,'+'\x22yokaichib'+'a.chiba.jp'+'\x22,\x22yokoshi'+'bahikari.c'+'hiba.jp\x22,\x22'+'yotsukaido'+'.chiba.jp\x22'+',\x22ainan.eh'+'ime.jp\x22,\x22h'+'onai.ehime'+'.jp\x22,\x22ikat'+'a.ehime.jp'+'\x22,\x22imabari'+'.ehime.jp\x22'+',\x22iyo.ehim'+'e.jp\x22,\x22kam'+'ijima.ehim'+'e.jp\x22,\x22kih'+'oku.ehime.'+'jp\x22,\x22kumak'+'ogen.ehime'+'.jp\x22,\x22masa'+'ki.ehime.j'+'p\x22,\x22matsun'+'o.ehime.jp'+'\x22,\x22matsuya'+'ma.ehime.j'+'p\x22,\x22namika'+'ta.ehime.j'+'p\x22,\x22niiham'+'a.ehime.jp'+'\x22,\x22ozu.ehi'+'me.jp\x22,\x22sa'+'ijo.ehime.'+'jp\x22,\x22seiyo'+'.ehime.jp\x22'+',\x22shikokuc'+'huo.ehime.'+'jp\x22,\x22tobe.'+'ehime.jp\x22,'+'\x22toon.ehim'+'e.jp\x22,\x22uch'+'iko.ehime.'+'jp\x22,\x22uwaji'+'ma.ehime.j'+'p\x22,\x22yawata'+'hama.ehime'+'.jp\x22,\x22echi'+'zen.fukui.'+'jp\x22,\x22eihei'+'ji.fukui.j'+'p\x22,\x22fukui.'+'fukui.jp\x22,'+'\x22ikeda.fuk'+'ui.jp\x22,\x22ka'+'tsuyama.fu'+'kui.jp\x22,\x22m'+'ihama.fuku'+'i.jp\x22,\x22min'+'amiechizen'+'.fukui.jp\x22'+',\x22obama.fu'+'kui.jp\x22,\x22o'+'hi.fukui.j'+'p\x22,\x22ono.fu'+'kui.jp\x22,\x22s'+'abae.fukui'+'.jp\x22,\x22saka'+'i.fukui.jp'+'\x22,\x22takaham'+'a.fukui.jp'+'\x22,\x22tsuruga'+'.fukui.jp\x22'+',\x22wakasa.f'+'ukui.jp\x22,\x22'+'ashiya.fuk'+'uoka.jp\x22,\x22'+'buzen.fuku'+'oka.jp\x22,\x22c')+('hikugo.fuk'+'uoka.jp\x22,\x22'+'chikuho.fu'+'kuoka.jp\x22,'+'\x22chikujo.f'+'ukuoka.jp\x22'+',\x22chikushi'+'no.fukuoka'+'.jp\x22,\x22chik'+'uzen.fukuo'+'ka.jp\x22,\x22ch'+'uo.fukuoka'+'.jp\x22,\x22daza'+'ifu.fukuok'+'a.jp\x22,\x22fuk'+'uchi.fukuo'+'ka.jp\x22,\x22ha'+'kata.fukuo'+'ka.jp\x22,\x22hi'+'gashi.fuku'+'oka.jp\x22,\x22h'+'irokawa.fu'+'kuoka.jp\x22,'+'\x22hisayama.'+'fukuoka.jp'+'\x22,\x22iizuka.'+'fukuoka.jp'+'\x22,\x22inatsuk'+'i.fukuoka.'+'jp\x22,\x22kaho.'+'fukuoka.jp'+'\x22,\x22kasuga.'+'fukuoka.jp'+'\x22,\x22kasuya.'+'fukuoka.jp'+'\x22,\x22kawara.'+'fukuoka.jp'+'\x22,\x22keisen.'+'fukuoka.jp'+'\x22,\x22koga.fu'+'kuoka.jp\x22,'+'\x22kurate.fu'+'kuoka.jp\x22,'+'\x22kurogi.fu'+'kuoka.jp\x22,'+'\x22kurume.fu'+'kuoka.jp\x22,'+'\x22minami.fu'+'kuoka.jp\x22,'+'\x22miyako.fu'+'kuoka.jp\x22,'+'\x22miyama.fu'+'kuoka.jp\x22,'+'\x22miyawaka.'+'fukuoka.jp'+'\x22,\x22mizumak'+'i.fukuoka.'+'jp\x22,\x22munak'+'ata.fukuok'+'a.jp\x22,\x22nak'+'agawa.fuku'+'oka.jp\x22,\x22n'+'akama.fuku'+'oka.jp\x22,\x22n'+'ishi.fukuo'+'ka.jp\x22,\x22no'+'gata.fukuo'+'ka.jp\x22,\x22og'+'ori.fukuok'+'a.jp\x22,\x22oka'+'gaki.fukuo'+'ka.jp\x22,\x22ok'+'awa.fukuok'+'a.jp\x22,\x22oki'+'.fukuoka.j'+'p\x22,\x22omuta.'+'fukuoka.jp'+'\x22,\x22onga.fu'+'kuoka.jp\x22,'+'\x22onojo.fuk'+'uoka.jp\x22,\x22'+'oto.fukuok'+'a.jp\x22,\x22sai'+'gawa.fukuo'+'ka.jp\x22,\x22sa'+'saguri.fuk'+'uoka.jp\x22,\x22'+'shingu.fuk'+'uoka.jp\x22,\x22'+'shinyoshit'+'omi.fukuok'+'a.jp\x22,\x22sho'+'nai.fukuok'+'a.jp\x22,\x22soe'+'da.fukuoka'+'.jp\x22,\x22sue.'+'fukuoka.jp'+'\x22,\x22tachiar'+'ai.fukuoka'+'.jp\x22,\x22taga')+('wa.fukuoka'+'.jp\x22,\x22taka'+'ta.fukuoka'+'.jp\x22,\x22toho'+'.fukuoka.j'+'p\x22,\x22toyots'+'u.fukuoka.'+'jp\x22,\x22tsuik'+'i.fukuoka.'+'jp\x22,\x22ukiha'+'.fukuoka.j'+'p\x22,\x22umi.fu'+'kuoka.jp\x22,'+'\x22usui.fuku'+'oka.jp\x22,\x22y'+'amada.fuku'+'oka.jp\x22,\x22y'+'ame.fukuok'+'a.jp\x22,\x22yan'+'agawa.fuku'+'oka.jp\x22,\x22y'+'ukuhashi.f'+'ukuoka.jp\x22'+',\x22aizubang'+'e.fukushim'+'a.jp\x22,\x22aiz'+'umisato.fu'+'kushima.jp'+'\x22,\x22aizuwak'+'amatsu.fuk'+'ushima.jp\x22'+',\x22asakawa.'+'fukushima.'+'jp\x22,\x22banda'+'i.fukushim'+'a.jp\x22,\x22dat'+'e.fukushim'+'a.jp\x22,\x22fuk'+'ushima.fuk'+'ushima.jp\x22'+',\x22furudono'+'.fukushima'+'.jp\x22,\x22futa'+'ba.fukushi'+'ma.jp\x22,\x22ha'+'nawa.fukus'+'hima.jp\x22,\x22'+'higashi.fu'+'kushima.jp'+'\x22,\x22hirata.'+'fukushima.'+'jp\x22,\x22hiron'+'o.fukushim'+'a.jp\x22,\x22iit'+'ate.fukush'+'ima.jp\x22,\x22i'+'nawashiro.'+'fukushima.'+'jp\x22,\x22ishik'+'awa.fukush'+'ima.jp\x22,\x22i'+'waki.fukus'+'hima.jp\x22,\x22'+'izumizaki.'+'fukushima.'+'jp\x22,\x22kagam'+'iishi.fuku'+'shima.jp\x22,'+'\x22kaneyama.'+'fukushima.'+'jp\x22,\x22kawam'+'ata.fukush'+'ima.jp\x22,\x22k'+'itakata.fu'+'kushima.jp'+'\x22,\x22kitashi'+'obara.fuku'+'shima.jp\x22,'+'\x22koori.fuk'+'ushima.jp\x22'+',\x22koriyama'+'.fukushima'+'.jp\x22,\x22kuni'+'mi.fukushi'+'ma.jp\x22,\x22mi'+'haru.fukus'+'hima.jp\x22,\x22'+'mishima.fu'+'kushima.jp'+'\x22,\x22namie.f'+'ukushima.j'+'p\x22,\x22nango.'+'fukushima.'+'jp\x22,\x22nishi'+'aizu.fukus'+'hima.jp\x22,\x22'+'nishigo.fu'+'kushima.jp'+'\x22,\x22okuma.f'+'ukushima.j')+('p\x22,\x22omoteg'+'o.fukushim'+'a.jp\x22,\x22ono'+'.fukushima'+'.jp\x22,\x22otam'+'a.fukushim'+'a.jp\x22,\x22sam'+'egawa.fuku'+'shima.jp\x22,'+'\x22shimogo.f'+'ukushima.j'+'p\x22,\x22shirak'+'awa.fukush'+'ima.jp\x22,\x22s'+'howa.fukus'+'hima.jp\x22,\x22'+'soma.fukus'+'hima.jp\x22,\x22'+'sukagawa.f'+'ukushima.j'+'p\x22,\x22taishi'+'n.fukushim'+'a.jp\x22,\x22tam'+'akawa.fuku'+'shima.jp\x22,'+'\x22tanagura.'+'fukushima.'+'jp\x22,\x22tenei'+'.fukushima'+'.jp\x22,\x22yabu'+'ki.fukushi'+'ma.jp\x22,\x22ya'+'mato.fukus'+'hima.jp\x22,\x22'+'yamatsuri.'+'fukushima.'+'jp\x22,\x22yanai'+'zu.fukushi'+'ma.jp\x22,\x22yu'+'gawa.fukus'+'hima.jp\x22,\x22'+'anpachi.gi'+'fu.jp\x22,\x22en'+'a.gifu.jp\x22'+',\x22gifu.gif'+'u.jp\x22,\x22gin'+'an.gifu.jp'+'\x22,\x22godo.gi'+'fu.jp\x22,\x22gu'+'jo.gifu.jp'+'\x22,\x22hashima'+'.gifu.jp\x22,'+'\x22hichiso.g'+'ifu.jp\x22,\x22h'+'ida.gifu.j'+'p\x22,\x22higash'+'ishirakawa'+'.gifu.jp\x22,'+'\x22ibigawa.g'+'ifu.jp\x22,\x22i'+'keda.gifu.'+'jp\x22,\x22kakam'+'igahara.gi'+'fu.jp\x22,\x22ka'+'ni.gifu.jp'+'\x22,\x22kasahar'+'a.gifu.jp\x22'+',\x22kasamats'+'u.gifu.jp\x22'+',\x22kawaue.g'+'ifu.jp\x22,\x22k'+'itagata.gi'+'fu.jp\x22,\x22mi'+'no.gifu.jp'+'\x22,\x22minokam'+'o.gifu.jp\x22'+',\x22mitake.g'+'ifu.jp\x22,\x22m'+'izunami.gi'+'fu.jp\x22,\x22mo'+'tosu.gifu.'+'jp\x22,\x22nakat'+'sugawa.gif'+'u.jp\x22,\x22oga'+'ki.gifu.jp'+'\x22,\x22sakahog'+'i.gifu.jp\x22'+',\x22seki.gif'+'u.jp\x22,\x22sek'+'igahara.gi'+'fu.jp\x22,\x22sh'+'irakawa.gi'+'fu.jp\x22,\x22ta'+'jimi.gifu.'+'jp\x22,\x22takay'+'ama.gifu.j'+'p\x22,\x22tarui.'+'gifu.jp\x22,\x22'+'toki.gifu.'+'jp\x22,\x22tomik')+('a.gifu.jp\x22'+',\x22wanouchi'+'.gifu.jp\x22,'+'\x22yamagata.'+'gifu.jp\x22,\x22'+'yaotsu.gif'+'u.jp\x22,\x22yor'+'o.gifu.jp\x22'+',\x22annaka.g'+'unma.jp\x22,\x22'+'chiyoda.gu'+'nma.jp\x22,\x22f'+'ujioka.gun'+'ma.jp\x22,\x22hi'+'gashiagats'+'uma.gunma.'+'jp\x22,\x22isesa'+'ki.gunma.j'+'p\x22,\x22itakur'+'a.gunma.jp'+'\x22,\x22kanna.g'+'unma.jp\x22,\x22'+'kanra.gunm'+'a.jp\x22,\x22kat'+'ashina.gun'+'ma.jp\x22,\x22ka'+'waba.gunma'+'.jp\x22,\x22kiry'+'u.gunma.jp'+'\x22,\x22kusatsu'+'.gunma.jp\x22'+',\x22maebashi'+'.gunma.jp\x22'+',\x22meiwa.gu'+'nma.jp\x22,\x22m'+'idori.gunm'+'a.jp\x22,\x22min'+'akami.gunm'+'a.jp\x22,\x22nag'+'anohara.gu'+'nma.jp\x22,\x22n'+'akanojo.gu'+'nma.jp\x22,\x22n'+'anmoku.gun'+'ma.jp\x22,\x22nu'+'mata.gunma'+'.jp\x22,\x22oizu'+'mi.gunma.j'+'p\x22,\x22ora.gu'+'nma.jp\x22,\x22o'+'ta.gunma.j'+'p\x22,\x22shibuk'+'awa.gunma.'+'jp\x22,\x22shimo'+'nita.gunma'+'.jp\x22,\x22shin'+'to.gunma.j'+'p\x22,\x22showa.'+'gunma.jp\x22,'+'\x22takasaki.'+'gunma.jp\x22,'+'\x22takayama.'+'gunma.jp\x22,'+'\x22tamamura.'+'gunma.jp\x22,'+'\x22tatebayas'+'hi.gunma.j'+'p\x22,\x22tomiok'+'a.gunma.jp'+'\x22,\x22tsukiyo'+'no.gunma.j'+'p\x22,\x22tsumag'+'oi.gunma.j'+'p\x22,\x22ueno.g'+'unma.jp\x22,\x22'+'yoshioka.g'+'unma.jp\x22,\x22'+'asaminami.'+'hiroshima.'+'jp\x22,\x22daiwa'+'.hiroshima'+'.jp\x22,\x22etaj'+'ima.hirosh'+'ima.jp\x22,\x22f'+'uchu.hiros'+'hima.jp\x22,\x22'+'fukuyama.h'+'iroshima.j'+'p\x22,\x22hatsuk'+'aichi.hiro'+'shima.jp\x22,'+'\x22higashihi'+'roshima.hi'+'roshima.jp'+'\x22,\x22hongo.h'+'iroshima.j'+'p\x22,\x22jinsek'+'ikogen.hir'+'oshima.jp\x22'+',\x22kaita.hi')+('roshima.jp'+'\x22,\x22kui.hir'+'oshima.jp\x22'+',\x22kumano.h'+'iroshima.j'+'p\x22,\x22kure.h'+'iroshima.j'+'p\x22,\x22mihara'+'.hiroshima'+'.jp\x22,\x22miyo'+'shi.hirosh'+'ima.jp\x22,\x22n'+'aka.hirosh'+'ima.jp\x22,\x22o'+'nomichi.hi'+'roshima.jp'+'\x22,\x22osakika'+'mijima.hir'+'oshima.jp\x22'+',\x22otake.hi'+'roshima.jp'+'\x22,\x22saka.hi'+'roshima.jp'+'\x22,\x22sera.hi'+'roshima.jp'+'\x22,\x22seranis'+'hi.hiroshi'+'ma.jp\x22,\x22sh'+'inichi.hir'+'oshima.jp\x22'+',\x22shobara.'+'hiroshima.'+'jp\x22,\x22takeh'+'ara.hirosh'+'ima.jp\x22,\x22a'+'bashiri.ho'+'kkaido.jp\x22'+',\x22abira.ho'+'kkaido.jp\x22'+',\x22aibetsu.'+'hokkaido.j'+'p\x22,\x22akabir'+'a.hokkaido'+'.jp\x22,\x22akke'+'shi.hokkai'+'do.jp\x22,\x22as'+'ahikawa.ho'+'kkaido.jp\x22'+',\x22ashibets'+'u.hokkaido'+'.jp\x22,\x22asho'+'ro.hokkaid'+'o.jp\x22,\x22ass'+'abu.hokkai'+'do.jp\x22,\x22at'+'suma.hokka'+'ido.jp\x22,\x22b'+'ibai.hokka'+'ido.jp\x22,\x22b'+'iei.hokkai'+'do.jp\x22,\x22bi'+'fuka.hokka'+'ido.jp\x22,\x22b'+'ihoro.hokk'+'aido.jp\x22,\x22'+'biratori.h'+'okkaido.jp'+'\x22,\x22chippub'+'etsu.hokka'+'ido.jp\x22,\x22c'+'hitose.hok'+'kaido.jp\x22,'+'\x22date.hokk'+'aido.jp\x22,\x22'+'ebetsu.hok'+'kaido.jp\x22,'+'\x22embetsu.h'+'okkaido.jp'+'\x22,\x22eniwa.h'+'okkaido.jp'+'\x22,\x22erimo.h'+'okkaido.jp'+'\x22,\x22esan.ho'+'kkaido.jp\x22'+',\x22esashi.h'+'okkaido.jp'+'\x22,\x22fukagaw'+'a.hokkaido'+'.jp\x22,\x22fuku'+'shima.hokk'+'aido.jp\x22,\x22'+'furano.hok'+'kaido.jp\x22,'+'\x22furubira.'+'hokkaido.j'+'p\x22,\x22haboro'+'.hokkaido.'+'jp\x22,\x22hakod'+'ate.hokkai'+'do.jp\x22,\x22ha')+('matonbetsu'+'.hokkaido.'+'jp\x22,\x22hidak'+'a.hokkaido'+'.jp\x22,\x22higa'+'shikagura.'+'hokkaido.j'+'p\x22,\x22higash'+'ikawa.hokk'+'aido.jp\x22,\x22'+'hiroo.hokk'+'aido.jp\x22,\x22'+'hokuryu.ho'+'kkaido.jp\x22'+',\x22hokuto.h'+'okkaido.jp'+'\x22,\x22honbets'+'u.hokkaido'+'.jp\x22,\x22horo'+'kanai.hokk'+'aido.jp\x22,\x22'+'horonobe.h'+'okkaido.jp'+'\x22,\x22ikeda.h'+'okkaido.jp'+'\x22,\x22imakane'+'.hokkaido.'+'jp\x22,\x22ishik'+'ari.hokkai'+'do.jp\x22,\x22iw'+'amizawa.ho'+'kkaido.jp\x22'+',\x22iwanai.h'+'okkaido.jp'+'\x22,\x22kamifur'+'ano.hokkai'+'do.jp\x22,\x22ka'+'mikawa.hok'+'kaido.jp\x22,'+'\x22kamishiho'+'ro.hokkaid'+'o.jp\x22,\x22kam'+'isunagawa.'+'hokkaido.j'+'p\x22,\x22kamoen'+'ai.hokkaid'+'o.jp\x22,\x22kay'+'abe.hokkai'+'do.jp\x22,\x22ke'+'mbuchi.hok'+'kaido.jp\x22,'+'\x22kikonai.h'+'okkaido.jp'+'\x22,\x22kimobet'+'su.hokkaid'+'o.jp\x22,\x22kit'+'ahiroshima'+'.hokkaido.'+'jp\x22,\x22kitam'+'i.hokkaido'+'.jp\x22,\x22kiyo'+'sato.hokka'+'ido.jp\x22,\x22k'+'oshimizu.h'+'okkaido.jp'+'\x22,\x22kunnepp'+'u.hokkaido'+'.jp\x22,\x22kuri'+'yama.hokka'+'ido.jp\x22,\x22k'+'uromatsuna'+'i.hokkaido'+'.jp\x22,\x22kush'+'iro.hokkai'+'do.jp\x22,\x22ku'+'tchan.hokk'+'aido.jp\x22,\x22'+'kyowa.hokk'+'aido.jp\x22,\x22'+'mashike.ho'+'kkaido.jp\x22'+',\x22matsumae'+'.hokkaido.'+'jp\x22,\x22mikas'+'a.hokkaido'+'.jp\x22,\x22mina'+'mifurano.h'+'okkaido.jp'+'\x22,\x22mombets'+'u.hokkaido'+'.jp\x22,\x22mose'+'ushi.hokka'+'ido.jp\x22,\x22m'+'ukawa.hokk'+'aido.jp\x22,\x22'+'muroran.ho'+'kkaido.jp\x22'+',\x22naie.hok'+'kaido.jp\x22,'+'\x22nakagawa.')+('hokkaido.j'+'p\x22,\x22nakasa'+'tsunai.hok'+'kaido.jp\x22,'+'\x22nakatombe'+'tsu.hokkai'+'do.jp\x22,\x22na'+'nae.hokkai'+'do.jp\x22,\x22na'+'nporo.hokk'+'aido.jp\x22,\x22'+'nayoro.hok'+'kaido.jp\x22,'+'\x22nemuro.ho'+'kkaido.jp\x22'+',\x22niikappu'+'.hokkaido.'+'jp\x22,\x22niki.'+'hokkaido.j'+'p\x22,\x22nishio'+'koppe.hokk'+'aido.jp\x22,\x22'+'noboribets'+'u.hokkaido'+'.jp\x22,\x22numa'+'ta.hokkaid'+'o.jp\x22,\x22obi'+'hiro.hokka'+'ido.jp\x22,\x22o'+'bira.hokka'+'ido.jp\x22,\x22o'+'keto.hokka'+'ido.jp\x22,\x22o'+'koppe.hokk'+'aido.jp\x22,\x22'+'otaru.hokk'+'aido.jp\x22,\x22'+'otobe.hokk'+'aido.jp\x22,\x22'+'otofuke.ho'+'kkaido.jp\x22'+',\x22otoinepp'+'u.hokkaido'+'.jp\x22,\x22oumu'+'.hokkaido.'+'jp\x22,\x22ozora'+'.hokkaido.'+'jp\x22,\x22pippu'+'.hokkaido.'+'jp\x22,\x22ranko'+'shi.hokkai'+'do.jp\x22,\x22re'+'bun.hokkai'+'do.jp\x22,\x22ri'+'kubetsu.ho'+'kkaido.jp\x22'+',\x22rishiri.'+'hokkaido.j'+'p\x22,\x22rishir'+'ifuji.hokk'+'aido.jp\x22,\x22'+'saroma.hok'+'kaido.jp\x22,'+'\x22sarufutsu'+'.hokkaido.'+'jp\x22,\x22shako'+'tan.hokkai'+'do.jp\x22,\x22sh'+'ari.hokkai'+'do.jp\x22,\x22sh'+'ibecha.hok'+'kaido.jp\x22,'+'\x22shibetsu.'+'hokkaido.j'+'p\x22,\x22shikab'+'e.hokkaido'+'.jp\x22,\x22shik'+'aoi.hokkai'+'do.jp\x22,\x22sh'+'imamaki.ho'+'kkaido.jp\x22'+',\x22shimizu.'+'hokkaido.j'+'p\x22,\x22shimok'+'awa.hokkai'+'do.jp\x22,\x22sh'+'inshinotsu'+'.hokkaido.'+'jp\x22,\x22shint'+'oku.hokkai'+'do.jp\x22,\x22sh'+'iranuka.ho'+'kkaido.jp\x22'+',\x22shiraoi.'+'hokkaido.j'+'p\x22,\x22shiriu'+'chi.hokkai'+'do.jp\x22,\x22so'+'betsu.hokk'+'aido.jp\x22,\x22')+('sunagawa.h'+'okkaido.jp'+'\x22,\x22taiki.h'+'okkaido.jp'+'\x22,\x22takasu.'+'hokkaido.j'+'p\x22,\x22takika'+'wa.hokkaid'+'o.jp\x22,\x22tak'+'inoue.hokk'+'aido.jp\x22,\x22'+'teshikaga.'+'hokkaido.j'+'p\x22,\x22tobets'+'u.hokkaido'+'.jp\x22,\x22tohm'+'a.hokkaido'+'.jp\x22,\x22toma'+'komai.hokk'+'aido.jp\x22,\x22'+'tomari.hok'+'kaido.jp\x22,'+'\x22toya.hokk'+'aido.jp\x22,\x22'+'toyako.hok'+'kaido.jp\x22,'+'\x22toyotomi.'+'hokkaido.j'+'p\x22,\x22toyour'+'a.hokkaido'+'.jp\x22,\x22tsub'+'etsu.hokka'+'ido.jp\x22,\x22t'+'sukigata.h'+'okkaido.jp'+'\x22,\x22urakawa'+'.hokkaido.'+'jp\x22,\x22uraus'+'u.hokkaido'+'.jp\x22,\x22uryu'+'.hokkaido.'+'jp\x22,\x22utash'+'inai.hokka'+'ido.jp\x22,\x22w'+'akkanai.ho'+'kkaido.jp\x22'+',\x22wassamu.'+'hokkaido.j'+'p\x22,\x22yakumo'+'.hokkaido.'+'jp\x22,\x22yoich'+'i.hokkaido'+'.jp\x22,\x22aioi'+'.hyogo.jp\x22'+',\x22akashi.h'+'yogo.jp\x22,\x22'+'ako.hyogo.'+'jp\x22,\x22amaga'+'saki.hyogo'+'.jp\x22,\x22aoga'+'ki.hyogo.j'+'p\x22,\x22asago.'+'hyogo.jp\x22,'+'\x22ashiya.hy'+'ogo.jp\x22,\x22a'+'waji.hyogo'+'.jp\x22,\x22fuku'+'saki.hyogo'+'.jp\x22,\x22gosh'+'iki.hyogo.'+'jp\x22,\x22harim'+'a.hyogo.jp'+'\x22,\x22himeji.'+'hyogo.jp\x22,'+'\x22ichikawa.'+'hyogo.jp\x22,'+'\x22inagawa.h'+'yogo.jp\x22,\x22'+'itami.hyog'+'o.jp\x22,\x22kak'+'ogawa.hyog'+'o.jp\x22,\x22kam'+'igori.hyog'+'o.jp\x22,\x22kam'+'ikawa.hyog'+'o.jp\x22,\x22kas'+'ai.hyogo.j'+'p\x22,\x22kasuga'+'.hyogo.jp\x22'+',\x22kawanish'+'i.hyogo.jp'+'\x22,\x22miki.hy'+'ogo.jp\x22,\x22m'+'inamiawaji'+'.hyogo.jp\x22'+',\x22nishinom'+'iya.hyogo.'+'jp\x22,\x22nishi'+'waki.hyogo'+'.jp\x22,\x22ono.')+('hyogo.jp\x22,'+'\x22sanda.hyo'+'go.jp\x22,\x22sa'+'nnan.hyogo'+'.jp\x22,\x22sasa'+'yama.hyogo'+'.jp\x22,\x22sayo'+'.hyogo.jp\x22'+',\x22shingu.h'+'yogo.jp\x22,\x22'+'shinonsen.'+'hyogo.jp\x22,'+'\x22shiso.hyo'+'go.jp\x22,\x22su'+'moto.hyogo'+'.jp\x22,\x22tais'+'hi.hyogo.j'+'p\x22,\x22taka.h'+'yogo.jp\x22,\x22'+'takarazuka'+'.hyogo.jp\x22'+',\x22takasago'+'.hyogo.jp\x22'+',\x22takino.h'+'yogo.jp\x22,\x22'+'tamba.hyog'+'o.jp\x22,\x22tat'+'suno.hyogo'+'.jp\x22,\x22toyo'+'oka.hyogo.'+'jp\x22,\x22yabu.'+'hyogo.jp\x22,'+'\x22yashiro.h'+'yogo.jp\x22,\x22'+'yoka.hyogo'+'.jp\x22,\x22yoka'+'wa.hyogo.j'+'p\x22,\x22ami.ib'+'araki.jp\x22,'+'\x22asahi.iba'+'raki.jp\x22,\x22'+'bando.ibar'+'aki.jp\x22,\x22c'+'hikusei.ib'+'araki.jp\x22,'+'\x22daigo.iba'+'raki.jp\x22,\x22'+'fujishiro.'+'ibaraki.jp'+'\x22,\x22hitachi'+'.ibaraki.j'+'p\x22,\x22hitach'+'inaka.ibar'+'aki.jp\x22,\x22h'+'itachiomiy'+'a.ibaraki.'+'jp\x22,\x22hitac'+'hiota.ibar'+'aki.jp\x22,\x22i'+'baraki.iba'+'raki.jp\x22,\x22'+'ina.ibarak'+'i.jp\x22,\x22ina'+'shiki.ibar'+'aki.jp\x22,\x22i'+'tako.ibara'+'ki.jp\x22,\x22iw'+'ama.ibarak'+'i.jp\x22,\x22jos'+'o.ibaraki.'+'jp\x22,\x22kamis'+'u.ibaraki.'+'jp\x22,\x22kasam'+'a.ibaraki.'+'jp\x22,\x22kashi'+'ma.ibaraki'+'.jp\x22,\x22kasu'+'migaura.ib'+'araki.jp\x22,'+'\x22koga.ibar'+'aki.jp\x22,\x22m'+'iho.ibarak'+'i.jp\x22,\x22mit'+'o.ibaraki.'+'jp\x22,\x22moriy'+'a.ibaraki.'+'jp\x22,\x22naka.'+'ibaraki.jp'+'\x22,\x22namegat'+'a.ibaraki.'+'jp\x22,\x22oarai'+'.ibaraki.j'+'p\x22,\x22ogawa.'+'ibaraki.jp'+'\x22,\x22omitama'+'.ibaraki.j'+'p\x22,\x22ryugas'+'aki.ibarak'+'i.jp\x22,\x22sak'+'ai.ibaraki')+('.jp\x22,\x22saku'+'ragawa.iba'+'raki.jp\x22,\x22'+'shimodate.'+'ibaraki.jp'+'\x22,\x22shimots'+'uma.ibarak'+'i.jp\x22,\x22shi'+'rosato.iba'+'raki.jp\x22,\x22'+'sowa.ibara'+'ki.jp\x22,\x22su'+'ifu.ibarak'+'i.jp\x22,\x22tak'+'ahagi.ibar'+'aki.jp\x22,\x22t'+'amatsukuri'+'.ibaraki.j'+'p\x22,\x22tokai.'+'ibaraki.jp'+'\x22,\x22tomobe.'+'ibaraki.jp'+'\x22,\x22tone.ib'+'araki.jp\x22,'+'\x22toride.ib'+'araki.jp\x22,'+'\x22tsuchiura'+'.ibaraki.j'+'p\x22,\x22tsukub'+'a.ibaraki.'+'jp\x22,\x22uchih'+'ara.ibarak'+'i.jp\x22,\x22ush'+'iku.ibarak'+'i.jp\x22,\x22yac'+'hiyo.ibara'+'ki.jp\x22,\x22ya'+'magata.iba'+'raki.jp\x22,\x22'+'yawara.iba'+'raki.jp\x22,\x22'+'yuki.ibara'+'ki.jp\x22,\x22an'+'amizu.ishi'+'kawa.jp\x22,\x22'+'hakui.ishi'+'kawa.jp\x22,\x22'+'hakusan.is'+'hikawa.jp\x22'+',\x22kaga.ish'+'ikawa.jp\x22,'+'\x22kahoku.is'+'hikawa.jp\x22'+',\x22kanazawa'+'.ishikawa.'+'jp\x22,\x22kawak'+'ita.ishika'+'wa.jp\x22,\x22ko'+'matsu.ishi'+'kawa.jp\x22,\x22'+'nakanoto.i'+'shikawa.jp'+'\x22,\x22nanao.i'+'shikawa.jp'+'\x22,\x22nomi.is'+'hikawa.jp\x22'+',\x22nonoichi'+'.ishikawa.'+'jp\x22,\x22noto.'+'ishikawa.j'+'p\x22,\x22shika.'+'ishikawa.j'+'p\x22,\x22suzu.i'+'shikawa.jp'+'\x22,\x22tsubata'+'.ishikawa.'+'jp\x22,\x22tsuru'+'gi.ishikaw'+'a.jp\x22,\x22uch'+'inada.ishi'+'kawa.jp\x22,\x22'+'wajima.ish'+'ikawa.jp\x22,'+'\x22fudai.iwa'+'te.jp\x22,\x22fu'+'jisawa.iwa'+'te.jp\x22,\x22ha'+'namaki.iwa'+'te.jp\x22,\x22hi'+'raizumi.iw'+'ate.jp\x22,\x22h'+'irono.iwat'+'e.jp\x22,\x22ich'+'inohe.iwat'+'e.jp\x22,\x22ich'+'inoseki.iw'+'ate.jp\x22,\x22i'+'waizumi.iw'+'ate.jp\x22,\x22i'+'wate.iwate')+('.jp\x22,\x22jobo'+'ji.iwate.j'+'p\x22,\x22kamais'+'hi.iwate.j'+'p\x22,\x22kanega'+'saki.iwate'+'.jp\x22,\x22karu'+'mai.iwate.'+'jp\x22,\x22kawai'+'.iwate.jp\x22'+',\x22kitakami'+'.iwate.jp\x22'+',\x22kuji.iwa'+'te.jp\x22,\x22ku'+'nohe.iwate'+'.jp\x22,\x22kuzu'+'maki.iwate'+'.jp\x22,\x22miya'+'ko.iwate.j'+'p\x22,\x22mizusa'+'wa.iwate.j'+'p\x22,\x22moriok'+'a.iwate.jp'+'\x22,\x22ninohe.'+'iwate.jp\x22,'+'\x22noda.iwat'+'e.jp\x22,\x22ofu'+'nato.iwate'+'.jp\x22,\x22oshu'+'.iwate.jp\x22'+',\x22otsuchi.'+'iwate.jp\x22,'+'\x22rikuzenta'+'kata.iwate'+'.jp\x22,\x22shiw'+'a.iwate.jp'+'\x22,\x22shizuku'+'ishi.iwate'+'.jp\x22,\x22sumi'+'ta.iwate.j'+'p\x22,\x22tanoha'+'ta.iwate.j'+'p\x22,\x22tono.i'+'wate.jp\x22,\x22'+'yahaba.iwa'+'te.jp\x22,\x22ya'+'mada.iwate'+'.jp\x22,\x22ayag'+'awa.kagawa'+'.jp\x22,\x22higa'+'shikagawa.'+'kagawa.jp\x22'+',\x22kanonji.'+'kagawa.jp\x22'+',\x22kotohira'+'.kagawa.jp'+'\x22,\x22manno.k'+'agawa.jp\x22,'+'\x22marugame.'+'kagawa.jp\x22'+',\x22mitoyo.k'+'agawa.jp\x22,'+'\x22naoshima.'+'kagawa.jp\x22'+',\x22sanuki.k'+'agawa.jp\x22,'+'\x22tadotsu.k'+'agawa.jp\x22,'+'\x22takamatsu'+'.kagawa.jp'+'\x22,\x22tonosho'+'.kagawa.jp'+'\x22,\x22uchinom'+'i.kagawa.j'+'p\x22,\x22utazu.'+'kagawa.jp\x22'+',\x22zentsuji'+'.kagawa.jp'+'\x22,\x22akune.k'+'agoshima.j'+'p\x22,\x22amami.'+'kagoshima.'+'jp\x22,\x22hioki'+'.kagoshima'+'.jp\x22,\x22isa.'+'kagoshima.'+'jp\x22,\x22isen.'+'kagoshima.'+'jp\x22,\x22izumi'+'.kagoshima'+'.jp\x22,\x22kago'+'shima.kago'+'shima.jp\x22,'+'\x22kanoya.ka'+'goshima.jp'+'\x22,\x22kawanab'+'e.kagoshim'+'a.jp\x22,\x22kin'+'ko.kagoshi'+'ma.jp\x22,\x22ko')+('uyama.kago'+'shima.jp\x22,'+'\x22makurazak'+'i.kagoshim'+'a.jp\x22,\x22mat'+'sumoto.kag'+'oshima.jp\x22'+',\x22minamita'+'ne.kagoshi'+'ma.jp\x22,\x22na'+'katane.kag'+'oshima.jp\x22'+',\x22nishinoo'+'mote.kagos'+'hima.jp\x22,\x22'+'satsumasen'+'dai.kagosh'+'ima.jp\x22,\x22s'+'oo.kagoshi'+'ma.jp\x22,\x22ta'+'rumizu.kag'+'oshima.jp\x22'+',\x22yusui.ka'+'goshima.jp'+'\x22,\x22aikawa.'+'kanagawa.j'+'p\x22,\x22atsugi'+'.kanagawa.'+'jp\x22,\x22ayase'+'.kanagawa.'+'jp\x22,\x22chiga'+'saki.kanag'+'awa.jp\x22,\x22e'+'bina.kanag'+'awa.jp\x22,\x22f'+'ujisawa.ka'+'nagawa.jp\x22'+',\x22hadano.k'+'anagawa.jp'+'\x22,\x22hakone.'+'kanagawa.j'+'p\x22,\x22hirats'+'uka.kanaga'+'wa.jp\x22,\x22is'+'ehara.kana'+'gawa.jp\x22,\x22'+'kaisei.kan'+'agawa.jp\x22,'+'\x22kamakura.'+'kanagawa.j'+'p\x22,\x22kiyoka'+'wa.kanagaw'+'a.jp\x22,\x22mat'+'suda.kanag'+'awa.jp\x22,\x22m'+'inamiashig'+'ara.kanaga'+'wa.jp\x22,\x22mi'+'ura.kanaga'+'wa.jp\x22,\x22na'+'kai.kanaga'+'wa.jp\x22,\x22ni'+'nomiya.kan'+'agawa.jp\x22,'+'\x22odawara.k'+'anagawa.jp'+'\x22,\x22oi.kana'+'gawa.jp\x22,\x22'+'oiso.kanag'+'awa.jp\x22,\x22s'+'agamihara.'+'kanagawa.j'+'p\x22,\x22samuka'+'wa.kanagaw'+'a.jp\x22,\x22tsu'+'kui.kanaga'+'wa.jp\x22,\x22ya'+'makita.kan'+'agawa.jp\x22,'+'\x22yamato.ka'+'nagawa.jp\x22'+',\x22yokosuka'+'.kanagawa.'+'jp\x22,\x22yugaw'+'ara.kanaga'+'wa.jp\x22,\x22za'+'ma.kanagaw'+'a.jp\x22,\x22zus'+'hi.kanagaw'+'a.jp\x22,\x22aki'+'.kochi.jp\x22'+',\x22geisei.k'+'ochi.jp\x22,\x22'+'hidaka.koc'+'hi.jp\x22,\x22hi'+'gashitsuno'+'.kochi.jp\x22'+',\x22ino.koch'+'i.jp\x22,\x22kag'+'ami.kochi.')+('jp\x22,\x22kami.'+'kochi.jp\x22,'+'\x22kitagawa.'+'kochi.jp\x22,'+'\x22kochi.koc'+'hi.jp\x22,\x22mi'+'hara.kochi'+'.jp\x22,\x22moto'+'yama.kochi'+'.jp\x22,\x22muro'+'to.kochi.j'+'p\x22,\x22nahari'+'.kochi.jp\x22'+',\x22nakamura'+'.kochi.jp\x22'+',\x22nankoku.'+'kochi.jp\x22,'+'\x22nishitosa'+'.kochi.jp\x22'+',\x22niyodoga'+'wa.kochi.j'+'p\x22,\x22ochi.k'+'ochi.jp\x22,\x22'+'okawa.koch'+'i.jp\x22,\x22oto'+'yo.kochi.j'+'p\x22,\x22otsuki'+'.kochi.jp\x22'+',\x22sakawa.k'+'ochi.jp\x22,\x22'+'sukumo.koc'+'hi.jp\x22,\x22su'+'saki.kochi'+'.jp\x22,\x22tosa'+'.kochi.jp\x22'+',\x22tosashim'+'izu.kochi.'+'jp\x22,\x22toyo.'+'kochi.jp\x22,'+'\x22tsuno.koc'+'hi.jp\x22,\x22um'+'aji.kochi.'+'jp\x22,\x22yasud'+'a.kochi.jp'+'\x22,\x22yusuhar'+'a.kochi.jp'+'\x22,\x22amakusa'+'.kumamoto.'+'jp\x22,\x22arao.'+'kumamoto.j'+'p\x22,\x22aso.ku'+'mamoto.jp\x22'+',\x22choyo.ku'+'mamoto.jp\x22'+',\x22gyokuto.'+'kumamoto.j'+'p\x22,\x22kamiam'+'akusa.kuma'+'moto.jp\x22,\x22'+'kikuchi.ku'+'mamoto.jp\x22'+',\x22kumamoto'+'.kumamoto.'+'jp\x22,\x22mashi'+'ki.kumamot'+'o.jp\x22,\x22mif'+'une.kumamo'+'to.jp\x22,\x22mi'+'namata.kum'+'amoto.jp\x22,'+'\x22minamiogu'+'ni.kumamot'+'o.jp\x22,\x22nag'+'asu.kumamo'+'to.jp\x22,\x22ni'+'shihara.ku'+'mamoto.jp\x22'+',\x22oguni.ku'+'mamoto.jp\x22'+',\x22ozu.kuma'+'moto.jp\x22,\x22'+'sumoto.kum'+'amoto.jp\x22,'+'\x22takamori.'+'kumamoto.j'+'p\x22,\x22uki.ku'+'mamoto.jp\x22'+',\x22uto.kuma'+'moto.jp\x22,\x22'+'yamaga.kum'+'amoto.jp\x22,'+'\x22yamato.ku'+'mamoto.jp\x22'+',\x22yatsushi'+'ro.kumamot'+'o.jp\x22,\x22aya'+'be.kyoto.j'+'p\x22,\x22fukuch'+'iyama.kyot'+'o.jp\x22,\x22hig')+('ashiyama.k'+'yoto.jp\x22,\x22'+'ide.kyoto.'+'jp\x22,\x22ine.k'+'yoto.jp\x22,\x22'+'joyo.kyoto'+'.jp\x22,\x22kame'+'oka.kyoto.'+'jp\x22,\x22kamo.'+'kyoto.jp\x22,'+'\x22kita.kyot'+'o.jp\x22,\x22kiz'+'u.kyoto.jp'+'\x22,\x22kumiyam'+'a.kyoto.jp'+'\x22,\x22kyotamb'+'a.kyoto.jp'+'\x22,\x22kyotana'+'be.kyoto.j'+'p\x22,\x22kyotan'+'go.kyoto.j'+'p\x22,\x22maizur'+'u.kyoto.jp'+'\x22,\x22minami.'+'kyoto.jp\x22,'+'\x22minamiyam'+'ashiro.kyo'+'to.jp\x22,\x22mi'+'yazu.kyoto'+'.jp\x22,\x22muko'+'.kyoto.jp\x22'+',\x22nagaokak'+'yo.kyoto.j'+'p\x22,\x22nakagy'+'o.kyoto.jp'+'\x22,\x22nantan.'+'kyoto.jp\x22,'+'\x22oyamazaki'+'.kyoto.jp\x22'+',\x22sakyo.ky'+'oto.jp\x22,\x22s'+'eika.kyoto'+'.jp\x22,\x22tana'+'be.kyoto.j'+'p\x22,\x22uji.ky'+'oto.jp\x22,\x22u'+'jitawara.k'+'yoto.jp\x22,\x22'+'wazuka.kyo'+'to.jp\x22,\x22ya'+'mashina.ky'+'oto.jp\x22,\x22y'+'awata.kyot'+'o.jp\x22,\x22asa'+'hi.mie.jp\x22'+',\x22inabe.mi'+'e.jp\x22,\x22ise'+'.mie.jp\x22,\x22'+'kameyama.m'+'ie.jp\x22,\x22ka'+'wagoe.mie.'+'jp\x22,\x22kiho.'+'mie.jp\x22,\x22k'+'isosaki.mi'+'e.jp\x22,\x22kiw'+'a.mie.jp\x22,'+'\x22komono.mi'+'e.jp\x22,\x22kum'+'ano.mie.jp'+'\x22,\x22kuwana.'+'mie.jp\x22,\x22m'+'atsusaka.m'+'ie.jp\x22,\x22me'+'iwa.mie.jp'+'\x22,\x22mihama.'+'mie.jp\x22,\x22m'+'inamiise.m'+'ie.jp\x22,\x22mi'+'sugi.mie.j'+'p\x22,\x22miyama'+'.mie.jp\x22,\x22'+'nabari.mie'+'.jp\x22,\x22shim'+'a.mie.jp\x22,'+'\x22suzuka.mi'+'e.jp\x22,\x22tad'+'o.mie.jp\x22,'+'\x22taiki.mie'+'.jp\x22,\x22taki'+'.mie.jp\x22,\x22'+'tamaki.mie'+'.jp\x22,\x22toba'+'.mie.jp\x22,\x22'+'tsu.mie.jp'+'\x22,\x22udono.m'+'ie.jp\x22,\x22ur'+'eshino.mie'+'.jp\x22,\x22wata'+'rai.mie.jp'+'\x22,\x22yokkaic')+('hi.mie.jp\x22'+',\x22furukawa'+'.miyagi.jp'+'\x22,\x22higashi'+'matsushima'+'.miyagi.jp'+'\x22,\x22ishinom'+'aki.miyagi'+'.jp\x22,\x22iwan'+'uma.miyagi'+'.jp\x22,\x22kaku'+'da.miyagi.'+'jp\x22,\x22kami.'+'miyagi.jp\x22'+',\x22kawasaki'+'.miyagi.jp'+'\x22,\x22marumor'+'i.miyagi.j'+'p\x22,\x22matsus'+'hima.miyag'+'i.jp\x22,\x22min'+'amisanriku'+'.miyagi.jp'+'\x22,\x22misato.'+'miyagi.jp\x22'+',\x22murata.m'+'iyagi.jp\x22,'+'\x22natori.mi'+'yagi.jp\x22,\x22'+'ogawara.mi'+'yagi.jp\x22,\x22'+'ohira.miya'+'gi.jp\x22,\x22on'+'agawa.miya'+'gi.jp\x22,\x22os'+'aki.miyagi'+'.jp\x22,\x22rifu'+'.miyagi.jp'+'\x22,\x22semine.'+'miyagi.jp\x22'+',\x22shibata.'+'miyagi.jp\x22'+',\x22shichika'+'shuku.miya'+'gi.jp\x22,\x22sh'+'ikama.miya'+'gi.jp\x22,\x22sh'+'iogama.miy'+'agi.jp\x22,\x22s'+'hiroishi.m'+'iyagi.jp\x22,'+'\x22tagajo.mi'+'yagi.jp\x22,\x22'+'taiwa.miya'+'gi.jp\x22,\x22to'+'me.miyagi.'+'jp\x22,\x22tomiy'+'a.miyagi.j'+'p\x22,\x22wakuya'+'.miyagi.jp'+'\x22,\x22watari.'+'miyagi.jp\x22'+',\x22yamamoto'+'.miyagi.jp'+'\x22,\x22zao.miy'+'agi.jp\x22,\x22a'+'ya.miyazak'+'i.jp\x22,\x22ebi'+'no.miyazak'+'i.jp\x22,\x22gok'+'ase.miyaza'+'ki.jp\x22,\x22hy'+'uga.miyaza'+'ki.jp\x22,\x22ka'+'dogawa.miy'+'azaki.jp\x22,'+'\x22kawaminam'+'i.miyazaki'+'.jp\x22,\x22kijo'+'.miyazaki.'+'jp\x22,\x22kitag'+'awa.miyaza'+'ki.jp\x22,\x22ki'+'takata.miy'+'azaki.jp\x22,'+'\x22kitaura.m'+'iyazaki.jp'+'\x22,\x22kobayas'+'hi.miyazak'+'i.jp\x22,\x22kun'+'itomi.miya'+'zaki.jp\x22,\x22'+'kushima.mi'+'yazaki.jp\x22'+',\x22mimata.m'+'iyazaki.jp'+'\x22,\x22miyakon'+'ojo.miyaza'+'ki.jp\x22,\x22mi'+'yazaki.miy')+('azaki.jp\x22,'+'\x22morotsuka'+'.miyazaki.'+'jp\x22,\x22nichi'+'nan.miyaza'+'ki.jp\x22,\x22ni'+'shimera.mi'+'yazaki.jp\x22'+',\x22nobeoka.'+'miyazaki.j'+'p\x22,\x22saito.'+'miyazaki.j'+'p\x22,\x22shiiba'+'.miyazaki.'+'jp\x22,\x22shint'+'omi.miyaza'+'ki.jp\x22,\x22ta'+'kaharu.miy'+'azaki.jp\x22,'+'\x22takanabe.'+'miyazaki.j'+'p\x22,\x22takaza'+'ki.miyazak'+'i.jp\x22,\x22tsu'+'no.miyazak'+'i.jp\x22,\x22ach'+'i.nagano.j'+'p\x22,\x22agemat'+'su.nagano.'+'jp\x22,\x22anan.'+'nagano.jp\x22'+',\x22aoki.nag'+'ano.jp\x22,\x22a'+'sahi.nagan'+'o.jp\x22,\x22azu'+'mino.nagan'+'o.jp\x22,\x22chi'+'kuhoku.nag'+'ano.jp\x22,\x22c'+'hikuma.nag'+'ano.jp\x22,\x22c'+'hino.nagan'+'o.jp\x22,\x22fuj'+'imi.nagano'+'.jp\x22,\x22haku'+'ba.nagano.'+'jp\x22,\x22hara.'+'nagano.jp\x22'+',\x22hiraya.n'+'agano.jp\x22,'+'\x22iida.naga'+'no.jp\x22,\x22ii'+'jima.nagan'+'o.jp\x22,\x22iiy'+'ama.nagano'+'.jp\x22,\x22iizu'+'na.nagano.'+'jp\x22,\x22ikeda'+'.nagano.jp'+'\x22,\x22ikusaka'+'.nagano.jp'+'\x22,\x22ina.nag'+'ano.jp\x22,\x22k'+'aruizawa.n'+'agano.jp\x22,'+'\x22kawakami.'+'nagano.jp\x22'+',\x22kiso.nag'+'ano.jp\x22,\x22k'+'isofukushi'+'ma.nagano.'+'jp\x22,\x22kitaa'+'iki.nagano'+'.jp\x22,\x22koma'+'gane.nagan'+'o.jp\x22,\x22kom'+'oro.nagano'+'.jp\x22,\x22mats'+'ukawa.naga'+'no.jp\x22,\x22ma'+'tsumoto.na'+'gano.jp\x22,\x22'+'miasa.naga'+'no.jp\x22,\x22mi'+'namiaiki.n'+'agano.jp\x22,'+'\x22minamimak'+'i.nagano.j'+'p\x22,\x22minami'+'minowa.nag'+'ano.jp\x22,\x22m'+'inowa.naga'+'no.jp\x22,\x22mi'+'yada.nagan'+'o.jp\x22,\x22miy'+'ota.nagano'+'.jp\x22,\x22moch'+'izuki.naga'+'no.jp\x22,\x22na'+'gano.nagan')+('o.jp\x22,\x22nag'+'awa.nagano'+'.jp\x22,\x22nagi'+'so.nagano.'+'jp\x22,\x22nakag'+'awa.nagano'+'.jp\x22,\x22naka'+'no.nagano.'+'jp\x22,\x22nozaw'+'aonsen.nag'+'ano.jp\x22,\x22o'+'buse.nagan'+'o.jp\x22,\x22oga'+'wa.nagano.'+'jp\x22,\x22okaya'+'.nagano.jp'+'\x22,\x22omachi.'+'nagano.jp\x22'+',\x22omi.naga'+'no.jp\x22,\x22oo'+'kuwa.nagan'+'o.jp\x22,\x22oos'+'hika.nagan'+'o.jp\x22,\x22ota'+'ki.nagano.'+'jp\x22,\x22otari'+'.nagano.jp'+'\x22,\x22sakae.n'+'agano.jp\x22,'+'\x22sakaki.na'+'gano.jp\x22,\x22'+'saku.nagan'+'o.jp\x22,\x22sak'+'uho.nagano'+'.jp\x22,\x22shim'+'osuwa.naga'+'no.jp\x22,\x22sh'+'inanomachi'+'.nagano.jp'+'\x22,\x22shiojir'+'i.nagano.j'+'p\x22,\x22suwa.n'+'agano.jp\x22,'+'\x22suzaka.na'+'gano.jp\x22,\x22'+'takagi.nag'+'ano.jp\x22,\x22t'+'akamori.na'+'gano.jp\x22,\x22'+'takayama.n'+'agano.jp\x22,'+'\x22tateshina'+'.nagano.jp'+'\x22,\x22tatsuno'+'.nagano.jp'+'\x22,\x22togakus'+'hi.nagano.'+'jp\x22,\x22togur'+'a.nagano.j'+'p\x22,\x22tomi.n'+'agano.jp\x22,'+'\x22ueda.naga'+'no.jp\x22,\x22wa'+'da.nagano.'+'jp\x22,\x22yamag'+'ata.nagano'+'.jp\x22,\x22yama'+'nouchi.nag'+'ano.jp\x22,\x22y'+'asaka.naga'+'no.jp\x22,\x22ya'+'suoka.naga'+'no.jp\x22,\x22ch'+'ijiwa.naga'+'saki.jp\x22,\x22'+'futsu.naga'+'saki.jp\x22,\x22'+'goto.nagas'+'aki.jp\x22,\x22h'+'asami.naga'+'saki.jp\x22,\x22'+'hirado.nag'+'asaki.jp\x22,'+'\x22iki.nagas'+'aki.jp\x22,\x22i'+'sahaya.nag'+'asaki.jp\x22,'+'\x22kawatana.'+'nagasaki.j'+'p\x22,\x22kuchin'+'otsu.nagas'+'aki.jp\x22,\x22m'+'atsuura.na'+'gasaki.jp\x22'+',\x22nagasaki'+'.nagasaki.'+'jp\x22,\x22obama'+'.nagasaki.'+'jp\x22,\x22omura'+'.nagasaki.')+('jp\x22,\x22oseto'+'.nagasaki.'+'jp\x22,\x22saika'+'i.nagasaki'+'.jp\x22,\x22sase'+'bo.nagasak'+'i.jp\x22,\x22sei'+'hi.nagasak'+'i.jp\x22,\x22shi'+'mabara.nag'+'asaki.jp\x22,'+'\x22shinkamig'+'oto.nagasa'+'ki.jp\x22,\x22to'+'gitsu.naga'+'saki.jp\x22,\x22'+'tsushima.n'+'agasaki.jp'+'\x22,\x22unzen.n'+'agasaki.jp'+'\x22,\x22ando.na'+'ra.jp\x22,\x22go'+'se.nara.jp'+'\x22,\x22heguri.'+'nara.jp\x22,\x22'+'higashiyos'+'hino.nara.'+'jp\x22,\x22ikaru'+'ga.nara.jp'+'\x22,\x22ikoma.n'+'ara.jp\x22,\x22k'+'amikitayam'+'a.nara.jp\x22'+',\x22kanmaki.'+'nara.jp\x22,\x22'+'kashiba.na'+'ra.jp\x22,\x22ka'+'shihara.na'+'ra.jp\x22,\x22ka'+'tsuragi.na'+'ra.jp\x22,\x22ka'+'wai.nara.j'+'p\x22,\x22kawaka'+'mi.nara.jp'+'\x22,\x22kawanis'+'hi.nara.jp'+'\x22,\x22koryo.n'+'ara.jp\x22,\x22k'+'urotaki.na'+'ra.jp\x22,\x22mi'+'tsue.nara.'+'jp\x22,\x22miyak'+'e.nara.jp\x22'+',\x22nara.nar'+'a.jp\x22,\x22nos'+'egawa.nara'+'.jp\x22,\x22oji.'+'nara.jp\x22,\x22'+'ouda.nara.'+'jp\x22,\x22oyodo'+'.nara.jp\x22,'+'\x22sakurai.n'+'ara.jp\x22,\x22s'+'ango.nara.'+'jp\x22,\x22shimo'+'ichi.nara.'+'jp\x22,\x22shimo'+'kitayama.n'+'ara.jp\x22,\x22s'+'hinjo.nara'+'.jp\x22,\x22soni'+'.nara.jp\x22,'+'\x22takatori.'+'nara.jp\x22,\x22'+'tawaramoto'+'.nara.jp\x22,'+'\x22tenkawa.n'+'ara.jp\x22,\x22t'+'enri.nara.'+'jp\x22,\x22uda.n'+'ara.jp\x22,\x22y'+'amatokoriy'+'ama.nara.j'+'p\x22,\x22yamato'+'takada.nar'+'a.jp\x22,\x22yam'+'azoe.nara.'+'jp\x22,\x22yoshi'+'no.nara.jp'+'\x22,\x22aga.nii'+'gata.jp\x22,\x22'+'agano.niig'+'ata.jp\x22,\x22g'+'osen.niiga'+'ta.jp\x22,\x22it'+'oigawa.nii'+'gata.jp\x22,\x22'+'izumozaki.'+'niigata.jp'+'\x22,\x22joetsu.')+('niigata.jp'+'\x22,\x22kamo.ni'+'igata.jp\x22,'+'\x22kariwa.ni'+'igata.jp\x22,'+'\x22kashiwaza'+'ki.niigata'+'.jp\x22,\x22mina'+'miuonuma.n'+'iigata.jp\x22'+',\x22mitsuke.'+'niigata.jp'+'\x22,\x22muika.n'+'iigata.jp\x22'+',\x22murakami'+'.niigata.j'+'p\x22,\x22myoko.'+'niigata.jp'+'\x22,\x22nagaoka'+'.niigata.j'+'p\x22,\x22niigat'+'a.niigata.'+'jp\x22,\x22ojiya'+'.niigata.j'+'p\x22,\x22omi.ni'+'igata.jp\x22,'+'\x22sado.niig'+'ata.jp\x22,\x22s'+'anjo.niiga'+'ta.jp\x22,\x22se'+'iro.niigat'+'a.jp\x22,\x22sei'+'rou.niigat'+'a.jp\x22,\x22sek'+'ikawa.niig'+'ata.jp\x22,\x22s'+'hibata.nii'+'gata.jp\x22,\x22'+'tagami.nii'+'gata.jp\x22,\x22'+'tainai.nii'+'gata.jp\x22,\x22'+'tochio.nii'+'gata.jp\x22,\x22'+'tokamachi.'+'niigata.jp'+'\x22,\x22tsubame'+'.niigata.j'+'p\x22,\x22tsunan'+'.niigata.j'+'p\x22,\x22uonuma'+'.niigata.j'+'p\x22,\x22yahiko'+'.niigata.j'+'p\x22,\x22yoita.'+'niigata.jp'+'\x22,\x22yuzawa.'+'niigata.jp'+'\x22,\x22beppu.o'+'ita.jp\x22,\x22b'+'ungoono.oi'+'ta.jp\x22,\x22bu'+'ngotakada.'+'oita.jp\x22,\x22'+'hasama.oit'+'a.jp\x22,\x22hij'+'i.oita.jp\x22'+',\x22himeshim'+'a.oita.jp\x22'+',\x22hita.oit'+'a.jp\x22,\x22kam'+'itsue.oita'+'.jp\x22,\x22koko'+'noe.oita.j'+'p\x22,\x22kuju.o'+'ita.jp\x22,\x22k'+'unisaki.oi'+'ta.jp\x22,\x22ku'+'su.oita.jp'+'\x22,\x22oita.oi'+'ta.jp\x22,\x22sa'+'iki.oita.j'+'p\x22,\x22taketa'+'.oita.jp\x22,'+'\x22tsukumi.o'+'ita.jp\x22,\x22u'+'sa.oita.jp'+'\x22,\x22usuki.o'+'ita.jp\x22,\x22y'+'ufu.oita.j'+'p\x22,\x22akaiwa'+'.okayama.j'+'p\x22,\x22asakuc'+'hi.okayama'+'.jp\x22,\x22bize'+'n.okayama.'+'jp\x22,\x22hayas'+'hima.okaya'+'ma.jp\x22,\x22ib'+'ara.okayam')+('a.jp\x22,\x22kag'+'amino.okay'+'ama.jp\x22,\x22k'+'asaoka.oka'+'yama.jp\x22,\x22'+'kibichuo.o'+'kayama.jp\x22'+',\x22kumenan.'+'okayama.jp'+'\x22,\x22kurashi'+'ki.okayama'+'.jp\x22,\x22mani'+'wa.okayama'+'.jp\x22,\x22misa'+'ki.okayama'+'.jp\x22,\x22nagi'+'.okayama.j'+'p\x22,\x22niimi.'+'okayama.jp'+'\x22,\x22nishiaw'+'akura.okay'+'ama.jp\x22,\x22o'+'kayama.oka'+'yama.jp\x22,\x22'+'satosho.ok'+'ayama.jp\x22,'+'\x22setouchi.'+'okayama.jp'+'\x22,\x22shinjo.'+'okayama.jp'+'\x22,\x22shoo.ok'+'ayama.jp\x22,'+'\x22soja.okay'+'ama.jp\x22,\x22t'+'akahashi.o'+'kayama.jp\x22'+',\x22tamano.o'+'kayama.jp\x22'+',\x22tsuyama.'+'okayama.jp'+'\x22,\x22wake.ok'+'ayama.jp\x22,'+'\x22yakage.ok'+'ayama.jp\x22,'+'\x22aguni.oki'+'nawa.jp\x22,\x22'+'ginowan.ok'+'inawa.jp\x22,'+'\x22ginoza.ok'+'inawa.jp\x22,'+'\x22gushikami'+'.okinawa.j'+'p\x22,\x22haebar'+'u.okinawa.'+'jp\x22,\x22higas'+'hi.okinawa'+'.jp\x22,\x22hira'+'ra.okinawa'+'.jp\x22,\x22ihey'+'a.okinawa.'+'jp\x22,\x22ishig'+'aki.okinaw'+'a.jp\x22,\x22ish'+'ikawa.okin'+'awa.jp\x22,\x22i'+'toman.okin'+'awa.jp\x22,\x22i'+'zena.okina'+'wa.jp\x22,\x22ka'+'dena.okina'+'wa.jp\x22,\x22ki'+'n.okinawa.'+'jp\x22,\x22kitad'+'aito.okina'+'wa.jp\x22,\x22ki'+'tanakagusu'+'ku.okinawa'+'.jp\x22,\x22kume'+'jima.okina'+'wa.jp\x22,\x22ku'+'nigami.oki'+'nawa.jp\x22,\x22'+'minamidait'+'o.okinawa.'+'jp\x22,\x22motob'+'u.okinawa.'+'jp\x22,\x22nago.'+'okinawa.jp'+'\x22,\x22naha.ok'+'inawa.jp\x22,'+'\x22nakagusuk'+'u.okinawa.'+'jp\x22,\x22nakij'+'in.okinawa'+'.jp\x22,\x22nanj'+'o.okinawa.'+'jp\x22,\x22nishi'+'hara.okina'+'wa.jp\x22,\x22og'+'imi.okinaw')+('a.jp\x22,\x22oki'+'nawa.okina'+'wa.jp\x22,\x22on'+'na.okinawa'+'.jp\x22,\x22shim'+'oji.okinaw'+'a.jp\x22,\x22tak'+'etomi.okin'+'awa.jp\x22,\x22t'+'arama.okin'+'awa.jp\x22,\x22t'+'okashiki.o'+'kinawa.jp\x22'+',\x22tomigusu'+'ku.okinawa'+'.jp\x22,\x22tona'+'ki.okinawa'+'.jp\x22,\x22uras'+'oe.okinawa'+'.jp\x22,\x22urum'+'a.okinawa.'+'jp\x22,\x22yaese'+'.okinawa.j'+'p\x22,\x22yomita'+'n.okinawa.'+'jp\x22,\x22yonab'+'aru.okinaw'+'a.jp\x22,\x22yon'+'aguni.okin'+'awa.jp\x22,\x22z'+'amami.okin'+'awa.jp\x22,\x22a'+'beno.osaka'+'.jp\x22,\x22chih'+'ayaakasaka'+'.osaka.jp\x22'+',\x22chuo.osa'+'ka.jp\x22,\x22da'+'ito.osaka.'+'jp\x22,\x22fujii'+'dera.osaka'+'.jp\x22,\x22habi'+'kino.osaka'+'.jp\x22,\x22hann'+'an.osaka.j'+'p\x22,\x22higash'+'iosaka.osa'+'ka.jp\x22,\x22hi'+'gashisumiy'+'oshi.osaka'+'.jp\x22,\x22higa'+'shiyodogaw'+'a.osaka.jp'+'\x22,\x22hirakat'+'a.osaka.jp'+'\x22,\x22ibaraki'+'.osaka.jp\x22'+',\x22ikeda.os'+'aka.jp\x22,\x22i'+'zumi.osaka'+'.jp\x22,\x22izum'+'iotsu.osak'+'a.jp\x22,\x22izu'+'misano.osa'+'ka.jp\x22,\x22ka'+'doma.osaka'+'.jp\x22,\x22kaiz'+'uka.osaka.'+'jp\x22,\x22kanan'+'.osaka.jp\x22'+',\x22kashiwar'+'a.osaka.jp'+'\x22,\x22katano.'+'osaka.jp\x22,'+'\x22kawachina'+'gano.osaka'+'.jp\x22,\x22kish'+'iwada.osak'+'a.jp\x22,\x22kit'+'a.osaka.jp'+'\x22,\x22kumator'+'i.osaka.jp'+'\x22,\x22matsuba'+'ra.osaka.j'+'p\x22,\x22minato'+'.osaka.jp\x22'+',\x22minoh.os'+'aka.jp\x22,\x22m'+'isaki.osak'+'a.jp\x22,\x22mor'+'iguchi.osa'+'ka.jp\x22,\x22ne'+'yagawa.osa'+'ka.jp\x22,\x22ni'+'shi.osaka.'+'jp\x22,\x22nose.'+'osaka.jp\x22,'+'\x22osakasaya'+'ma.osaka.j'+'p\x22,\x22sakai.')+('osaka.jp\x22,'+'\x22sayama.os'+'aka.jp\x22,\x22s'+'ennan.osak'+'a.jp\x22,\x22set'+'tsu.osaka.'+'jp\x22,\x22shijo'+'nawate.osa'+'ka.jp\x22,\x22sh'+'imamoto.os'+'aka.jp\x22,\x22s'+'uita.osaka'+'.jp\x22,\x22tada'+'oka.osaka.'+'jp\x22,\x22taish'+'i.osaka.jp'+'\x22,\x22tajiri.'+'osaka.jp\x22,'+'\x22takaishi.'+'osaka.jp\x22,'+'\x22takatsuki'+'.osaka.jp\x22'+',\x22tondabay'+'ashi.osaka'+'.jp\x22,\x22toyo'+'naka.osaka'+'.jp\x22,\x22toyo'+'no.osaka.j'+'p\x22,\x22yao.os'+'aka.jp\x22,\x22a'+'riake.saga'+'.jp\x22,\x22arit'+'a.saga.jp\x22'+',\x22fukudomi'+'.saga.jp\x22,'+'\x22genkai.sa'+'ga.jp\x22,\x22ha'+'matama.sag'+'a.jp\x22,\x22hiz'+'en.saga.jp'+'\x22,\x22imari.s'+'aga.jp\x22,\x22k'+'amimine.sa'+'ga.jp\x22,\x22ka'+'nzaki.saga'+'.jp\x22,\x22kara'+'tsu.saga.j'+'p\x22,\x22kashim'+'a.saga.jp\x22'+',\x22kitagata'+'.saga.jp\x22,'+'\x22kitahata.'+'saga.jp\x22,\x22'+'kiyama.sag'+'a.jp\x22,\x22kou'+'hoku.saga.'+'jp\x22,\x22kyura'+'gi.saga.jp'+'\x22,\x22nishiar'+'ita.saga.j'+'p\x22,\x22ogi.sa'+'ga.jp\x22,\x22om'+'achi.saga.'+'jp\x22,\x22ouchi'+'.saga.jp\x22,'+'\x22saga.saga'+'.jp\x22,\x22shir'+'oishi.saga'+'.jp\x22,\x22taku'+'.saga.jp\x22,'+'\x22tara.saga'+'.jp\x22,\x22tosu'+'.saga.jp\x22,'+'\x22yoshinoga'+'ri.saga.jp'+'\x22,\x22arakawa'+'.saitama.j'+'p\x22,\x22asaka.'+'saitama.jp'+'\x22,\x22chichib'+'u.saitama.'+'jp\x22,\x22fujim'+'i.saitama.'+'jp\x22,\x22fujim'+'ino.saitam'+'a.jp\x22,\x22fuk'+'aya.saitam'+'a.jp\x22,\x22han'+'no.saitama'+'.jp\x22,\x22hany'+'u.saitama.'+'jp\x22,\x22hasud'+'a.saitama.'+'jp\x22,\x22hatog'+'aya.saitam'+'a.jp\x22,\x22hat'+'oyama.sait'+'ama.jp\x22,\x22h'+'idaka.sait'+'ama.jp\x22,\x22h')+('igashichic'+'hibu.saita'+'ma.jp\x22,\x22hi'+'gashimatsu'+'yama.saita'+'ma.jp\x22,\x22ho'+'njo.saitam'+'a.jp\x22,\x22ina'+'.saitama.j'+'p\x22,\x22iruma.'+'saitama.jp'+'\x22,\x22iwatsuk'+'i.saitama.'+'jp\x22,\x22kamii'+'zumi.saita'+'ma.jp\x22,\x22ka'+'mikawa.sai'+'tama.jp\x22,\x22'+'kamisato.s'+'aitama.jp\x22'+',\x22kasukabe'+'.saitama.j'+'p\x22,\x22kawago'+'e.saitama.'+'jp\x22,\x22kawag'+'uchi.saita'+'ma.jp\x22,\x22ka'+'wajima.sai'+'tama.jp\x22,\x22'+'kazo.saita'+'ma.jp\x22,\x22ki'+'tamoto.sai'+'tama.jp\x22,\x22'+'koshigaya.'+'saitama.jp'+'\x22,\x22kounosu'+'.saitama.j'+'p\x22,\x22kuki.s'+'aitama.jp\x22'+',\x22kumagaya'+'.saitama.j'+'p\x22,\x22matsub'+'ushi.saita'+'ma.jp\x22,\x22mi'+'nano.saita'+'ma.jp\x22,\x22mi'+'sato.saita'+'ma.jp\x22,\x22mi'+'yashiro.sa'+'itama.jp\x22,'+'\x22miyoshi.s'+'aitama.jp\x22'+',\x22moroyama'+'.saitama.j'+'p\x22,\x22nagato'+'ro.saitama'+'.jp\x22,\x22name'+'gawa.saita'+'ma.jp\x22,\x22ni'+'iza.saitam'+'a.jp\x22,\x22oga'+'no.saitama'+'.jp\x22,\x22ogaw'+'a.saitama.'+'jp\x22,\x22ogose'+'.saitama.j'+'p\x22,\x22okegaw'+'a.saitama.'+'jp\x22,\x22omiya'+'.saitama.j'+'p\x22,\x22otaki.'+'saitama.jp'+'\x22,\x22ranzan.'+'saitama.jp'+'\x22,\x22ryokami'+'.saitama.j'+'p\x22,\x22saitam'+'a.saitama.'+'jp\x22,\x22sakad'+'o.saitama.'+'jp\x22,\x22satte'+'.saitama.j'+'p\x22,\x22sayama'+'.saitama.j'+'p\x22,\x22shiki.'+'saitama.jp'+'\x22,\x22shiraok'+'a.saitama.'+'jp\x22,\x22soka.'+'saitama.jp'+'\x22,\x22sugito.'+'saitama.jp'+'\x22,\x22toda.sa'+'itama.jp\x22,'+'\x22tokigawa.'+'saitama.jp'+'\x22,\x22tokoroz'+'awa.saitam'+'a.jp\x22,\x22tsu'+'rugashima.')+('saitama.jp'+'\x22,\x22urawa.s'+'aitama.jp\x22'+',\x22warabi.s'+'aitama.jp\x22'+',\x22yashio.s'+'aitama.jp\x22'+',\x22yokoze.s'+'aitama.jp\x22'+',\x22yono.sai'+'tama.jp\x22,\x22'+'yorii.sait'+'ama.jp\x22,\x22y'+'oshida.sai'+'tama.jp\x22,\x22'+'yoshikawa.'+'saitama.jp'+'\x22,\x22yoshimi'+'.saitama.j'+'p\x22,\x22aisho.'+'shiga.jp\x22,'+'\x22gamo.shig'+'a.jp\x22,\x22hig'+'ashiomi.sh'+'iga.jp\x22,\x22h'+'ikone.shig'+'a.jp\x22,\x22kok'+'a.shiga.jp'+'\x22,\x22konan.s'+'higa.jp\x22,\x22'+'kosei.shig'+'a.jp\x22,\x22kot'+'o.shiga.jp'+'\x22,\x22kusatsu'+'.shiga.jp\x22'+',\x22maibara.'+'shiga.jp\x22,'+'\x22moriyama.'+'shiga.jp\x22,'+'\x22nagahama.'+'shiga.jp\x22,'+'\x22nishiazai'+'.shiga.jp\x22'+',\x22notogawa'+'.shiga.jp\x22'+',\x22omihachi'+'man.shiga.'+'jp\x22,\x22otsu.'+'shiga.jp\x22,'+'\x22ritto.shi'+'ga.jp\x22,\x22ry'+'uoh.shiga.'+'jp\x22,\x22takas'+'hima.shiga'+'.jp\x22,\x22taka'+'tsuki.shig'+'a.jp\x22,\x22tor'+'ahime.shig'+'a.jp\x22,\x22toy'+'osato.shig'+'a.jp\x22,\x22yas'+'u.shiga.jp'+'\x22,\x22akagi.s'+'himane.jp\x22'+',\x22ama.shim'+'ane.jp\x22,\x22g'+'otsu.shima'+'ne.jp\x22,\x22ha'+'mada.shima'+'ne.jp\x22,\x22hi'+'gashiizumo'+'.shimane.j'+'p\x22,\x22hikawa'+'.shimane.j'+'p\x22,\x22hikimi'+'.shimane.j'+'p\x22,\x22izumo.'+'shimane.jp'+'\x22,\x22kakinok'+'i.shimane.'+'jp\x22,\x22masud'+'a.shimane.'+'jp\x22,\x22matsu'+'e.shimane.'+'jp\x22,\x22misat'+'o.shimane.'+'jp\x22,\x22nishi'+'noshima.sh'+'imane.jp\x22,'+'\x22ohda.shim'+'ane.jp\x22,\x22o'+'kinoshima.'+'shimane.jp'+'\x22,\x22okuizum'+'o.shimane.'+'jp\x22,\x22shima'+'ne.shimane'+'.jp\x22,\x22tama'+'yu.shimane'+'.jp\x22,\x22tsuw')+('ano.shiman'+'e.jp\x22,\x22unn'+'an.shimane'+'.jp\x22,\x22yaku'+'mo.shimane'+'.jp\x22,\x22yasu'+'gi.shimane'+'.jp\x22,\x22yats'+'uka.shiman'+'e.jp\x22,\x22ara'+'i.shizuoka'+'.jp\x22,\x22atam'+'i.shizuoka'+'.jp\x22,\x22fuji'+'.shizuoka.'+'jp\x22,\x22fujie'+'da.shizuok'+'a.jp\x22,\x22fuj'+'ikawa.shiz'+'uoka.jp\x22,\x22'+'fujinomiya'+'.shizuoka.'+'jp\x22,\x22fukur'+'oi.shizuok'+'a.jp\x22,\x22got'+'emba.shizu'+'oka.jp\x22,\x22h'+'aibara.shi'+'zuoka.jp\x22,'+'\x22hamamatsu'+'.shizuoka.'+'jp\x22,\x22higas'+'hiizu.shiz'+'uoka.jp\x22,\x22'+'ito.shizuo'+'ka.jp\x22,\x22iw'+'ata.shizuo'+'ka.jp\x22,\x22iz'+'u.shizuoka'+'.jp\x22,\x22izun'+'okuni.shiz'+'uoka.jp\x22,\x22'+'kakegawa.s'+'hizuoka.jp'+'\x22,\x22kannami'+'.shizuoka.'+'jp\x22,\x22kawan'+'ehon.shizu'+'oka.jp\x22,\x22k'+'awazu.shiz'+'uoka.jp\x22,\x22'+'kikugawa.s'+'hizuoka.jp'+'\x22,\x22kosai.s'+'hizuoka.jp'+'\x22,\x22makinoh'+'ara.shizuo'+'ka.jp\x22,\x22ma'+'tsuzaki.sh'+'izuoka.jp\x22'+',\x22minamiiz'+'u.shizuoka'+'.jp\x22,\x22mish'+'ima.shizuo'+'ka.jp\x22,\x22mo'+'rimachi.sh'+'izuoka.jp\x22'+',\x22nishiizu'+'.shizuoka.'+'jp\x22,\x22numaz'+'u.shizuoka'+'.jp\x22,\x22omae'+'zaki.shizu'+'oka.jp\x22,\x22s'+'himada.shi'+'zuoka.jp\x22,'+'\x22shimizu.s'+'hizuoka.jp'+'\x22,\x22shimoda'+'.shizuoka.'+'jp\x22,\x22shizu'+'oka.shizuo'+'ka.jp\x22,\x22su'+'sono.shizu'+'oka.jp\x22,\x22y'+'aizu.shizu'+'oka.jp\x22,\x22y'+'oshida.shi'+'zuoka.jp\x22,'+'\x22ashikaga.'+'tochigi.jp'+'\x22,\x22bato.to'+'chigi.jp\x22,'+'\x22haga.toch'+'igi.jp\x22,\x22i'+'chikai.toc'+'higi.jp\x22,\x22'+'iwafune.to'+'chigi.jp\x22,'+'\x22kaminokaw')+('a.tochigi.'+'jp\x22,\x22kanum'+'a.tochigi.'+'jp\x22,\x22karas'+'uyama.toch'+'igi.jp\x22,\x22k'+'uroiso.toc'+'higi.jp\x22,\x22'+'mashiko.to'+'chigi.jp\x22,'+'\x22mibu.toch'+'igi.jp\x22,\x22m'+'oka.tochig'+'i.jp\x22,\x22mot'+'egi.tochig'+'i.jp\x22,\x22nas'+'u.tochigi.'+'jp\x22,\x22nasus'+'hiobara.to'+'chigi.jp\x22,'+'\x22nikko.toc'+'higi.jp\x22,\x22'+'nishikata.'+'tochigi.jp'+'\x22,\x22nogi.to'+'chigi.jp\x22,'+'\x22ohira.toc'+'higi.jp\x22,\x22'+'ohtawara.t'+'ochigi.jp\x22'+',\x22oyama.to'+'chigi.jp\x22,'+'\x22sakura.to'+'chigi.jp\x22,'+'\x22sano.toch'+'igi.jp\x22,\x22s'+'himotsuke.'+'tochigi.jp'+'\x22,\x22shioya.'+'tochigi.jp'+'\x22,\x22takanez'+'awa.tochig'+'i.jp\x22,\x22toc'+'higi.tochi'+'gi.jp\x22,\x22ts'+'uga.tochig'+'i.jp\x22,\x22uji'+'ie.tochigi'+'.jp\x22,\x22utsu'+'nomiya.toc'+'higi.jp\x22,\x22'+'yaita.toch'+'igi.jp\x22,\x22a'+'izumi.toku'+'shima.jp\x22,'+'\x22anan.toku'+'shima.jp\x22,'+'\x22ichiba.to'+'kushima.jp'+'\x22,\x22itano.t'+'okushima.j'+'p\x22,\x22kainan'+'.tokushima'+'.jp\x22,\x22koma'+'tsushima.t'+'okushima.j'+'p\x22,\x22matsus'+'hige.tokus'+'hima.jp\x22,\x22'+'mima.tokus'+'hima.jp\x22,\x22'+'minami.tok'+'ushima.jp\x22'+',\x22miyoshi.'+'tokushima.'+'jp\x22,\x22mugi.'+'tokushima.'+'jp\x22,\x22nakag'+'awa.tokush'+'ima.jp\x22,\x22n'+'aruto.toku'+'shima.jp\x22,'+'\x22sanagochi'+'.tokushima'+'.jp\x22,\x22shis'+'hikui.toku'+'shima.jp\x22,'+'\x22tokushima'+'.tokushima'+'.jp\x22,\x22waji'+'ki.tokushi'+'ma.jp\x22,\x22ad'+'achi.tokyo'+'.jp\x22,\x22akir'+'uno.tokyo.'+'jp\x22,\x22akish'+'ima.tokyo.'+'jp\x22,\x22aogas'+'hima.tokyo'+'.jp\x22,\x22arak')+('awa.tokyo.'+'jp\x22,\x22bunky'+'o.tokyo.jp'+'\x22,\x22chiyoda'+'.tokyo.jp\x22'+',\x22chofu.to'+'kyo.jp\x22,\x22c'+'huo.tokyo.'+'jp\x22,\x22edoga'+'wa.tokyo.j'+'p\x22,\x22fuchu.'+'tokyo.jp\x22,'+'\x22fussa.tok'+'yo.jp\x22,\x22ha'+'chijo.toky'+'o.jp\x22,\x22hac'+'hioji.toky'+'o.jp\x22,\x22ham'+'ura.tokyo.'+'jp\x22,\x22higas'+'hikurume.t'+'okyo.jp\x22,\x22'+'higashimur'+'ayama.toky'+'o.jp\x22,\x22hig'+'ashiyamato'+'.tokyo.jp\x22'+',\x22hino.tok'+'yo.jp\x22,\x22hi'+'node.tokyo'+'.jp\x22,\x22hino'+'hara.tokyo'+'.jp\x22,\x22inag'+'i.tokyo.jp'+'\x22,\x22itabash'+'i.tokyo.jp'+'\x22,\x22katsush'+'ika.tokyo.'+'jp\x22,\x22kita.'+'tokyo.jp\x22,'+'\x22kiyose.to'+'kyo.jp\x22,\x22k'+'odaira.tok'+'yo.jp\x22,\x22ko'+'ganei.toky'+'o.jp\x22,\x22kok'+'ubunji.tok'+'yo.jp\x22,\x22ko'+'mae.tokyo.'+'jp\x22,\x22koto.'+'tokyo.jp\x22,'+'\x22kouzushim'+'a.tokyo.jp'+'\x22,\x22kunitac'+'hi.tokyo.j'+'p\x22,\x22machid'+'a.tokyo.jp'+'\x22,\x22meguro.'+'tokyo.jp\x22,'+'\x22minato.to'+'kyo.jp\x22,\x22m'+'itaka.toky'+'o.jp\x22,\x22miz'+'uho.tokyo.'+'jp\x22,\x22musas'+'himurayama'+'.tokyo.jp\x22'+',\x22musashin'+'o.tokyo.jp'+'\x22,\x22nakano.'+'tokyo.jp\x22,'+'\x22nerima.to'+'kyo.jp\x22,\x22o'+'gasawara.t'+'okyo.jp\x22,\x22'+'okutama.to'+'kyo.jp\x22,\x22o'+'me.tokyo.j'+'p\x22,\x22oshima'+'.tokyo.jp\x22'+',\x22ota.toky'+'o.jp\x22,\x22set'+'agaya.toky'+'o.jp\x22,\x22shi'+'buya.tokyo'+'.jp\x22,\x22shin'+'agawa.toky'+'o.jp\x22,\x22shi'+'njuku.toky'+'o.jp\x22,\x22sug'+'inami.toky'+'o.jp\x22,\x22sum'+'ida.tokyo.'+'jp\x22,\x22tachi'+'kawa.tokyo'+'.jp\x22,\x22tait'+'o.tokyo.jp'+'\x22,\x22tama.to'+'kyo.jp\x22,\x22t'+'oshima.tok')+('yo.jp\x22,\x22ch'+'izu.tottor'+'i.jp\x22,\x22hin'+'o.tottori.'+'jp\x22,\x22kawah'+'ara.tottor'+'i.jp\x22,\x22kog'+'e.tottori.'+'jp\x22,\x22kotou'+'ra.tottori'+'.jp\x22,\x22misa'+'sa.tottori'+'.jp\x22,\x22nanb'+'u.tottori.'+'jp\x22,\x22nichi'+'nan.tottor'+'i.jp\x22,\x22sak'+'aiminato.t'+'ottori.jp\x22'+',\x22tottori.'+'tottori.jp'+'\x22,\x22wakasa.'+'tottori.jp'+'\x22,\x22yazu.to'+'ttori.jp\x22,'+'\x22yonago.to'+'ttori.jp\x22,'+'\x22asahi.toy'+'ama.jp\x22,\x22f'+'uchu.toyam'+'a.jp\x22,\x22fuk'+'umitsu.toy'+'ama.jp\x22,\x22f'+'unahashi.t'+'oyama.jp\x22,'+'\x22himi.toya'+'ma.jp\x22,\x22im'+'izu.toyama'+'.jp\x22,\x22inam'+'i.toyama.j'+'p\x22,\x22johana'+'.toyama.jp'+'\x22,\x22kamiich'+'i.toyama.j'+'p\x22,\x22kurobe'+'.toyama.jp'+'\x22,\x22nakanii'+'kawa.toyam'+'a.jp\x22,\x22nam'+'erikawa.to'+'yama.jp\x22,\x22'+'nanto.toya'+'ma.jp\x22,\x22ny'+'uzen.toyam'+'a.jp\x22,\x22oya'+'be.toyama.'+'jp\x22,\x22taira'+'.toyama.jp'+'\x22,\x22takaoka'+'.toyama.jp'+'\x22,\x22tateyam'+'a.toyama.j'+'p\x22,\x22toga.t'+'oyama.jp\x22,'+'\x22tonami.to'+'yama.jp\x22,\x22'+'toyama.toy'+'ama.jp\x22,\x22u'+'nazuki.toy'+'ama.jp\x22,\x22u'+'ozu.toyama'+'.jp\x22,\x22yama'+'da.toyama.'+'jp\x22,\x22arida'+'.wakayama.'+'jp\x22,\x22arida'+'gawa.wakay'+'ama.jp\x22,\x22g'+'obo.wakaya'+'ma.jp\x22,\x22ha'+'shimoto.wa'+'kayama.jp\x22'+',\x22hidaka.w'+'akayama.jp'+'\x22,\x22hirogaw'+'a.wakayama'+'.jp\x22,\x22inam'+'i.wakayama'+'.jp\x22,\x22iwad'+'e.wakayama'+'.jp\x22,\x22kain'+'an.wakayam'+'a.jp\x22,\x22kam'+'itonda.wak'+'ayama.jp\x22,'+'\x22katsuragi'+'.wakayama.'+'jp\x22,\x22kimin'+'o.wakayama'+'.jp\x22,\x22kino')+('kawa.wakay'+'ama.jp\x22,\x22k'+'itayama.wa'+'kayama.jp\x22'+',\x22koya.wak'+'ayama.jp\x22,'+'\x22koza.waka'+'yama.jp\x22,\x22'+'kozagawa.w'+'akayama.jp'+'\x22,\x22kudoyam'+'a.wakayama'+'.jp\x22,\x22kush'+'imoto.waka'+'yama.jp\x22,\x22'+'mihama.wak'+'ayama.jp\x22,'+'\x22misato.wa'+'kayama.jp\x22'+',\x22nachikat'+'suura.waka'+'yama.jp\x22,\x22'+'shingu.wak'+'ayama.jp\x22,'+'\x22shirahama'+'.wakayama.'+'jp\x22,\x22taiji'+'.wakayama.'+'jp\x22,\x22tanab'+'e.wakayama'+'.jp\x22,\x22waka'+'yama.wakay'+'ama.jp\x22,\x22y'+'uasa.wakay'+'ama.jp\x22,\x22y'+'ura.wakaya'+'ma.jp\x22,\x22as'+'ahi.yamaga'+'ta.jp\x22,\x22fu'+'nagata.yam'+'agata.jp\x22,'+'\x22higashine'+'.yamagata.'+'jp\x22,\x22iide.'+'yamagata.j'+'p\x22,\x22kahoku'+'.yamagata.'+'jp\x22,\x22kamin'+'oyama.yama'+'gata.jp\x22,\x22'+'kaneyama.y'+'amagata.jp'+'\x22,\x22kawanis'+'hi.yamagat'+'a.jp\x22,\x22mam'+'urogawa.ya'+'magata.jp\x22'+',\x22mikawa.y'+'amagata.jp'+'\x22,\x22murayam'+'a.yamagata'+'.jp\x22,\x22naga'+'i.yamagata'+'.jp\x22,\x22naka'+'yama.yamag'+'ata.jp\x22,\x22n'+'anyo.yamag'+'ata.jp\x22,\x22n'+'ishikawa.y'+'amagata.jp'+'\x22,\x22obanaza'+'wa.yamagat'+'a.jp\x22,\x22oe.'+'yamagata.j'+'p\x22,\x22oguni.'+'yamagata.j'+'p\x22,\x22ohkura'+'.yamagata.'+'jp\x22,\x22oishi'+'da.yamagat'+'a.jp\x22,\x22sag'+'ae.yamagat'+'a.jp\x22,\x22sak'+'ata.yamaga'+'ta.jp\x22,\x22sa'+'kegawa.yam'+'agata.jp\x22,'+'\x22shinjo.ya'+'magata.jp\x22'+',\x22shiratak'+'a.yamagata'+'.jp\x22,\x22shon'+'ai.yamagat'+'a.jp\x22,\x22tak'+'ahata.yama'+'gata.jp\x22,\x22'+'tendo.yama'+'gata.jp\x22,\x22'+'tozawa.yam'+'agata.jp\x22,')+('\x22tsuruoka.'+'yamagata.j'+'p\x22,\x22yamaga'+'ta.yamagat'+'a.jp\x22,\x22yam'+'anobe.yama'+'gata.jp\x22,\x22'+'yonezawa.y'+'amagata.jp'+'\x22,\x22yuza.ya'+'magata.jp\x22'+',\x22abu.yama'+'guchi.jp\x22,'+'\x22hagi.yama'+'guchi.jp\x22,'+'\x22hikari.ya'+'maguchi.jp'+'\x22,\x22hofu.ya'+'maguchi.jp'+'\x22,\x22iwakuni'+'.yamaguchi'+'.jp\x22,\x22kuda'+'matsu.yama'+'guchi.jp\x22,'+'\x22mitou.yam'+'aguchi.jp\x22'+',\x22nagato.y'+'amaguchi.j'+'p\x22,\x22oshima'+'.yamaguchi'+'.jp\x22,\x22shim'+'onoseki.ya'+'maguchi.jp'+'\x22,\x22shunan.'+'yamaguchi.'+'jp\x22,\x22tabus'+'e.yamaguch'+'i.jp\x22,\x22tok'+'uyama.yama'+'guchi.jp\x22,'+'\x22toyota.ya'+'maguchi.jp'+'\x22,\x22ube.yam'+'aguchi.jp\x22'+',\x22yuu.yama'+'guchi.jp\x22,'+'\x22chuo.yama'+'nashi.jp\x22,'+'\x22doshi.yam'+'anashi.jp\x22'+',\x22fuefuki.'+'yamanashi.'+'jp\x22,\x22fujik'+'awa.yamana'+'shi.jp\x22,\x22f'+'ujikawaguc'+'hiko.yaman'+'ashi.jp\x22,\x22'+'fujiyoshid'+'a.yamanash'+'i.jp\x22,\x22hay'+'akawa.yama'+'nashi.jp\x22,'+'\x22hokuto.ya'+'manashi.jp'+'\x22,\x22ichikaw'+'amisato.ya'+'manashi.jp'+'\x22,\x22kai.yam'+'anashi.jp\x22'+',\x22kofu.yam'+'anashi.jp\x22'+',\x22koshu.ya'+'manashi.jp'+'\x22,\x22kosuge.'+'yamanashi.'+'jp\x22,\x22minam'+'i-alps.yam'+'anashi.jp\x22'+',\x22minobu.y'+'amanashi.j'+'p\x22,\x22nakami'+'chi.yamana'+'shi.jp\x22,\x22n'+'anbu.yaman'+'ashi.jp\x22,\x22'+'narusawa.y'+'amanashi.j'+'p\x22,\x22nirasa'+'ki.yamanas'+'hi.jp\x22,\x22ni'+'shikatsura'+'.yamanashi'+'.jp\x22,\x22oshi'+'no.yamanas'+'hi.jp\x22,\x22ot'+'suki.yaman'+'ashi.jp\x22,\x22'+'showa.yama'+'nashi.jp\x22,')+('\x22tabayama.'+'yamanashi.'+'jp\x22,\x22tsuru'+'.yamanashi'+'.jp\x22,\x22ueno'+'hara.yaman'+'ashi.jp\x22,\x22'+'yamanakako'+'.yamanashi'+'.jp\x22,\x22yama'+'nashi.yama'+'nashi.jp\x22,'+'\x22ke\x22,\x22ac.k'+'e\x22,\x22co.ke\x22'+',\x22go.ke\x22,\x22'+'info.ke\x22,\x22'+'me.ke\x22,\x22mo'+'bi.ke\x22,\x22ne'+'.ke\x22,\x22or.k'+'e\x22,\x22sc.ke\x22'+',\x22kg\x22,\x22org'+'.kg\x22,\x22net.'+'kg\x22,\x22com.k'+'g\x22,\x22edu.kg'+'\x22,\x22gov.kg\x22'+',\x22mil.kg\x22,'+'\x22*.kh\x22,\x22ki'+'\x22,\x22edu.ki\x22'+',\x22biz.ki\x22,'+'\x22net.ki\x22,\x22'+'org.ki\x22,\x22g'+'ov.ki\x22,\x22in'+'fo.ki\x22,\x22co'+'m.ki\x22,\x22km\x22'+',\x22org.km\x22,'+'\x22nom.km\x22,\x22'+'gov.km\x22,\x22p'+'rd.km\x22,\x22tm'+'.km\x22,\x22edu.'+'km\x22,\x22mil.k'+'m\x22,\x22ass.km'+'\x22,\x22com.km\x22'+',\x22coop.km\x22'+',\x22asso.km\x22'+',\x22presse.k'+'m\x22,\x22medeci'+'n.km\x22,\x22not'+'aires.km\x22,'+'\x22pharmacie'+'ns.km\x22,\x22ve'+'terinaire.'+'km\x22,\x22gouv.'+'km\x22,\x22kn\x22,\x22'+'net.kn\x22,\x22o'+'rg.kn\x22,\x22ed'+'u.kn\x22,\x22gov'+'.kn\x22,\x22kp\x22,'+'\x22com.kp\x22,\x22'+'edu.kp\x22,\x22g'+'ov.kp\x22,\x22or'+'g.kp\x22,\x22rep'+'.kp\x22,\x22tra.'+'kp\x22,\x22kr\x22,\x22'+'ac.kr\x22,\x22co'+'.kr\x22,\x22es.k'+'r\x22,\x22go.kr\x22'+',\x22hs.kr\x22,\x22'+'kg.kr\x22,\x22mi'+'l.kr\x22,\x22ms.'+'kr\x22,\x22ne.kr'+'\x22,\x22or.kr\x22,'+'\x22pe.kr\x22,\x22r'+'e.kr\x22,\x22sc.'+'kr\x22,\x22busan'+'.kr\x22,\x22chun'+'gbuk.kr\x22,\x22'+'chungnam.k'+'r\x22,\x22daegu.'+'kr\x22,\x22daeje'+'on.kr\x22,\x22ga'+'ngwon.kr\x22,'+'\x22gwangju.k'+'r\x22,\x22gyeong'+'buk.kr\x22,\x22g'+'yeonggi.kr'+'\x22,\x22gyeongn'+'am.kr\x22,\x22in'+'cheon.kr\x22,'+'\x22jeju.kr\x22,'+'\x22jeonbuk.k'+'r\x22,\x22jeonna'+'m.kr\x22,\x22seo'+'ul.kr\x22,\x22ul'+'san.kr\x22,\x22k'+'w\x22,\x22com.kw'+'\x22,\x22edu.kw\x22'+',\x22emb.kw\x22,'+'\x22gov.kw\x22,\x22'+'ind.kw\x22,\x22n'+'et.kw\x22,\x22or')+('g.kw\x22,\x22ky\x22'+',\x22edu.ky\x22,'+'\x22gov.ky\x22,\x22'+'com.ky\x22,\x22o'+'rg.ky\x22,\x22ne'+'t.ky\x22,\x22kz\x22'+',\x22org.kz\x22,'+'\x22edu.kz\x22,\x22'+'net.kz\x22,\x22g'+'ov.kz\x22,\x22mi'+'l.kz\x22,\x22com'+'.kz\x22,\x22la\x22,'+'\x22int.la\x22,\x22'+'net.la\x22,\x22i'+'nfo.la\x22,\x22e'+'du.la\x22,\x22go'+'v.la\x22,\x22per'+'.la\x22,\x22com.'+'la\x22,\x22org.l'+'a\x22,\x22lb\x22,\x22c'+'om.lb\x22,\x22ed'+'u.lb\x22,\x22gov'+'.lb\x22,\x22net.'+'lb\x22,\x22org.l'+'b\x22,\x22lc\x22,\x22c'+'om.lc\x22,\x22ne'+'t.lc\x22,\x22co.'+'lc\x22,\x22org.l'+'c\x22,\x22edu.lc'+'\x22,\x22gov.lc\x22'+',\x22li\x22,\x22lk\x22'+',\x22gov.lk\x22,'+'\x22sch.lk\x22,\x22'+'net.lk\x22,\x22i'+'nt.lk\x22,\x22co'+'m.lk\x22,\x22org'+'.lk\x22,\x22edu.'+'lk\x22,\x22ngo.l'+'k\x22,\x22soc.lk'+'\x22,\x22web.lk\x22'+',\x22ltd.lk\x22,'+'\x22assn.lk\x22,'+'\x22grp.lk\x22,\x22'+'hotel.lk\x22,'+'\x22ac.lk\x22,\x22l'+'r\x22,\x22com.lr'+'\x22,\x22edu.lr\x22'+',\x22gov.lr\x22,'+'\x22org.lr\x22,\x22'+'net.lr\x22,\x22l'+'s\x22,\x22ac.ls\x22'+',\x22biz.ls\x22,'+'\x22co.ls\x22,\x22e'+'du.ls\x22,\x22go'+'v.ls\x22,\x22inf'+'o.ls\x22,\x22net'+'.ls\x22,\x22org.'+'ls\x22,\x22sc.ls'+'\x22,\x22lt\x22,\x22go'+'v.lt\x22,\x22lu\x22'+',\x22lv\x22,\x22com'+'.lv\x22,\x22edu.'+'lv\x22,\x22gov.l'+'v\x22,\x22org.lv'+'\x22,\x22mil.lv\x22'+',\x22id.lv\x22,\x22'+'net.lv\x22,\x22a'+'sn.lv\x22,\x22co'+'nf.lv\x22,\x22ly'+'\x22,\x22com.ly\x22'+',\x22net.ly\x22,'+'\x22gov.ly\x22,\x22'+'plc.ly\x22,\x22e'+'du.ly\x22,\x22sc'+'h.ly\x22,\x22med'+'.ly\x22,\x22org.'+'ly\x22,\x22id.ly'+'\x22,\x22ma\x22,\x22co'+'.ma\x22,\x22net.'+'ma\x22,\x22gov.m'+'a\x22,\x22org.ma'+'\x22,\x22ac.ma\x22,'+'\x22press.ma\x22'+',\x22mc\x22,\x22tm.'+'mc\x22,\x22asso.'+'mc\x22,\x22md\x22,\x22'+'me\x22,\x22co.me'+'\x22,\x22net.me\x22'+',\x22org.me\x22,'+'\x22edu.me\x22,\x22'+'ac.me\x22,\x22go'+'v.me\x22,\x22its'+'.me\x22,\x22priv'+'.me\x22,\x22mg\x22,'+'\x22org.mg\x22,\x22'+'nom.mg\x22,\x22g'+'ov.mg\x22,\x22pr'+'d.mg\x22,\x22tm.'+'mg\x22,\x22edu.m'+'g\x22,\x22mil.mg')+('\x22,\x22com.mg\x22'+',\x22co.mg\x22,\x22'+'mh\x22,\x22mil\x22,'+'\x22mk\x22,\x22com.'+'mk\x22,\x22org.m'+'k\x22,\x22net.mk'+'\x22,\x22edu.mk\x22'+',\x22gov.mk\x22,'+'\x22inf.mk\x22,\x22'+'name.mk\x22,\x22'+'ml\x22,\x22com.m'+'l\x22,\x22edu.ml'+'\x22,\x22gouv.ml'+'\x22,\x22gov.ml\x22'+',\x22net.ml\x22,'+'\x22org.ml\x22,\x22'+'presse.ml\x22'+',\x22*.mm\x22,\x22m'+'n\x22,\x22gov.mn'+'\x22,\x22edu.mn\x22'+',\x22org.mn\x22,'+'\x22mo\x22,\x22com.'+'mo\x22,\x22net.m'+'o\x22,\x22org.mo'+'\x22,\x22edu.mo\x22'+',\x22gov.mo\x22,'+'\x22mobi\x22,\x22mp'+'\x22,\x22mq\x22,\x22mr'+'\x22,\x22gov.mr\x22'+',\x22ms\x22,\x22com'+'.ms\x22,\x22edu.'+'ms\x22,\x22gov.m'+'s\x22,\x22net.ms'+'\x22,\x22org.ms\x22'+',\x22mt\x22,\x22com'+'.mt\x22,\x22edu.'+'mt\x22,\x22net.m'+'t\x22,\x22org.mt'+'\x22,\x22mu\x22,\x22co'+'m.mu\x22,\x22net'+'.mu\x22,\x22org.'+'mu\x22,\x22gov.m'+'u\x22,\x22ac.mu\x22'+',\x22co.mu\x22,\x22'+'or.mu\x22,\x22mu'+'seum\x22,\x22aca'+'demy.museu'+'m\x22,\x22agricu'+'lture.muse'+'um\x22,\x22air.m'+'useum\x22,\x22ai'+'rguard.mus'+'eum\x22,\x22alab'+'ama.museum'+'\x22,\x22alaska.'+'museum\x22,\x22a'+'mber.museu'+'m\x22,\x22ambula'+'nce.museum'+'\x22,\x22america'+'n.museum\x22,'+'\x22americana'+'.museum\x22,\x22'+'americanan'+'tiques.mus'+'eum\x22,\x22amer'+'icanart.mu'+'seum\x22,\x22ams'+'terdam.mus'+'eum\x22,\x22and.'+'museum\x22,\x22a'+'nnefrank.m'+'useum\x22,\x22an'+'thro.museu'+'m\x22,\x22anthro'+'pology.mus'+'eum\x22,\x22anti'+'ques.museu'+'m\x22,\x22aquari'+'um.museum\x22'+',\x22arboretu'+'m.museum\x22,'+'\x22archaeolo'+'gical.muse'+'um\x22,\x22archa'+'eology.mus'+'eum\x22,\x22arch'+'itecture.m'+'useum\x22,\x22ar'+'t.museum\x22,'+'\x22artanddes'+'ign.museum'+'\x22,\x22artcent'+'er.museum\x22'+',\x22artdeco.'+'museum\x22,\x22a'+'rteducatio'+'n.museum\x22,'+'\x22artgaller'+'y.museum\x22,')+('\x22arts.muse'+'um\x22,\x22artsa'+'ndcrafts.m'+'useum\x22,\x22as'+'matart.mus'+'eum\x22,\x22assa'+'ssination.'+'museum\x22,\x22a'+'ssisi.muse'+'um\x22,\x22assoc'+'iation.mus'+'eum\x22,\x22astr'+'onomy.muse'+'um\x22,\x22atlan'+'ta.museum\x22'+',\x22austin.m'+'useum\x22,\x22au'+'stralia.mu'+'seum\x22,\x22aut'+'omotive.mu'+'seum\x22,\x22avi'+'ation.muse'+'um\x22,\x22axis.'+'museum\x22,\x22b'+'adajoz.mus'+'eum\x22,\x22bagh'+'dad.museum'+'\x22,\x22bahn.mu'+'seum\x22,\x22bal'+'e.museum\x22,'+'\x22baltimore'+'.museum\x22,\x22'+'barcelona.'+'museum\x22,\x22b'+'aseball.mu'+'seum\x22,\x22bas'+'el.museum\x22'+',\x22baths.mu'+'seum\x22,\x22bau'+'ern.museum'+'\x22,\x22beauxar'+'ts.museum\x22'+',\x22beeldeng'+'eluid.muse'+'um\x22,\x22belle'+'vue.museum'+'\x22,\x22bergbau'+'.museum\x22,\x22'+'berkeley.m'+'useum\x22,\x22be'+'rlin.museu'+'m\x22,\x22bern.m'+'useum\x22,\x22bi'+'ble.museum'+'\x22,\x22bilbao.'+'museum\x22,\x22b'+'ill.museum'+'\x22,\x22birdart'+'.museum\x22,\x22'+'birthplace'+'.museum\x22,\x22'+'bonn.museu'+'m\x22,\x22boston'+'.museum\x22,\x22'+'botanical.'+'museum\x22,\x22b'+'otanicalga'+'rden.museu'+'m\x22,\x22botani'+'cgarden.mu'+'seum\x22,\x22bot'+'any.museum'+'\x22,\x22brandyw'+'inevalley.'+'museum\x22,\x22b'+'rasil.muse'+'um\x22,\x22brist'+'ol.museum\x22'+',\x22british.'+'museum\x22,\x22b'+'ritishcolu'+'mbia.museu'+'m\x22,\x22broadc'+'ast.museum'+'\x22,\x22brunel.'+'museum\x22,\x22b'+'russel.mus'+'eum\x22,\x22brus'+'sels.museu'+'m\x22,\x22bruxel'+'les.museum'+'\x22,\x22buildin'+'g.museum\x22,'+'\x22burghof.m'+'useum\x22,\x22bu'+'s.museum\x22,'+'\x22bushey.mu'+'seum\x22,\x22cad'+'aques.muse'+'um\x22,\x22calif')+('ornia.muse'+'um\x22,\x22cambr'+'idge.museu'+'m\x22,\x22can.mu'+'seum\x22,\x22can'+'ada.museum'+'\x22,\x22capebre'+'ton.museum'+'\x22,\x22carrier'+'.museum\x22,\x22'+'cartoonart'+'.museum\x22,\x22'+'casadelamo'+'neda.museu'+'m\x22,\x22castle'+'.museum\x22,\x22'+'castres.mu'+'seum\x22,\x22cel'+'tic.museum'+'\x22,\x22center.'+'museum\x22,\x22c'+'hattanooga'+'.museum\x22,\x22'+'cheltenham'+'.museum\x22,\x22'+'chesapeake'+'bay.museum'+'\x22,\x22chicago'+'.museum\x22,\x22'+'children.m'+'useum\x22,\x22ch'+'ildrens.mu'+'seum\x22,\x22chi'+'ldrensgard'+'en.museum\x22'+',\x22chiropra'+'ctic.museu'+'m\x22,\x22chocol'+'ate.museum'+'\x22,\x22christi'+'ansburg.mu'+'seum\x22,\x22cin'+'cinnati.mu'+'seum\x22,\x22cin'+'ema.museum'+'\x22,\x22circus.'+'museum\x22,\x22c'+'ivilisatio'+'n.museum\x22,'+'\x22civilizat'+'ion.museum'+'\x22,\x22civilwa'+'r.museum\x22,'+'\x22clinton.m'+'useum\x22,\x22cl'+'ock.museum'+'\x22,\x22coal.mu'+'seum\x22,\x22coa'+'staldefenc'+'e.museum\x22,'+'\x22cody.muse'+'um\x22,\x22coldw'+'ar.museum\x22'+',\x22collecti'+'on.museum\x22'+',\x22colonial'+'williamsbu'+'rg.museum\x22'+',\x22colorado'+'plateau.mu'+'seum\x22,\x22col'+'umbia.muse'+'um\x22,\x22colum'+'bus.museum'+'\x22,\x22communi'+'cation.mus'+'eum\x22,\x22comm'+'unications'+'.museum\x22,\x22'+'community.'+'museum\x22,\x22c'+'omputer.mu'+'seum\x22,\x22com'+'puterhisto'+'ry.museum\x22'+',\x22comunica'+'es.museu'+'m\x22,\x22contem'+'porary.mus'+'eum\x22,\x22cont'+'emporaryar'+'t.museum\x22,'+'\x22convent.m'+'useum\x22,\x22co'+'penhagen.m'+'useum\x22,\x22co'+'rporation.'+'museum\x22,\x22c'+'orreios-e-'+'telecomuni')+('caes.mus'+'eum\x22,\x22corv'+'ette.museu'+'m\x22,\x22costum'+'e.museum\x22,'+'\x22countryes'+'tate.museu'+'m\x22,\x22county'+'.museum\x22,\x22'+'crafts.mus'+'eum\x22,\x22cran'+'brook.muse'+'um\x22,\x22creat'+'ion.museum'+'\x22,\x22cultura'+'l.museum\x22,'+'\x22culturalc'+'enter.muse'+'um\x22,\x22cultu'+'re.museum\x22'+',\x22cyber.mu'+'seum\x22,\x22cym'+'ru.museum\x22'+',\x22dali.mus'+'eum\x22,\x22dall'+'as.museum\x22'+',\x22database'+'.museum\x22,\x22'+'ddr.museum'+'\x22,\x22decorat'+'ivearts.mu'+'seum\x22,\x22del'+'aware.muse'+'um\x22,\x22delme'+'nhorst.mus'+'eum\x22,\x22denm'+'ark.museum'+'\x22,\x22depot.m'+'useum\x22,\x22de'+'sign.museu'+'m\x22,\x22detroi'+'t.museum\x22,'+'\x22dinosaur.'+'museum\x22,\x22d'+'iscovery.m'+'useum\x22,\x22do'+'lls.museum'+'\x22,\x22donosti'+'a.museum\x22,'+'\x22durham.mu'+'seum\x22,\x22eas'+'tafrica.mu'+'seum\x22,\x22eas'+'tcoast.mus'+'eum\x22,\x22educ'+'ation.muse'+'um\x22,\x22educa'+'tional.mus'+'eum\x22,\x22egyp'+'tian.museu'+'m\x22,\x22eisenb'+'ahn.museum'+'\x22,\x22elburg.'+'museum\x22,\x22e'+'lvendrell.'+'museum\x22,\x22e'+'mbroidery.'+'museum\x22,\x22e'+'ncyclopedi'+'c.museum\x22,'+'\x22england.m'+'useum\x22,\x22en'+'tomology.m'+'useum\x22,\x22en'+'vironment.'+'museum\x22,\x22e'+'nvironment'+'alconserva'+'tion.museu'+'m\x22,\x22epilep'+'sy.museum\x22'+',\x22essex.mu'+'seum\x22,\x22est'+'ate.museum'+'\x22,\x22ethnolo'+'gy.museum\x22'+',\x22exeter.m'+'useum\x22,\x22ex'+'hibition.m'+'useum\x22,\x22fa'+'mily.museu'+'m\x22,\x22farm.m'+'useum\x22,\x22fa'+'rmequipmen'+'t.museum\x22,'+'\x22farmers.m'+'useum\x22,\x22fa'+'rmstead.mu'+'seum\x22,\x22fie'+'ld.museum\x22')+(',\x22figueres'+'.museum\x22,\x22'+'filatelia.'+'museum\x22,\x22f'+'ilm.museum'+'\x22,\x22fineart'+'.museum\x22,\x22'+'finearts.m'+'useum\x22,\x22fi'+'nland.muse'+'um\x22,\x22fland'+'ers.museum'+'\x22,\x22florida'+'.museum\x22,\x22'+'force.muse'+'um\x22,\x22fortm'+'issoula.mu'+'seum\x22,\x22for'+'tworth.mus'+'eum\x22,\x22foun'+'dation.mus'+'eum\x22,\x22fran'+'caise.muse'+'um\x22,\x22frank'+'furt.museu'+'m\x22,\x22franzi'+'skaner.mus'+'eum\x22,\x22free'+'masonry.mu'+'seum\x22,\x22fre'+'iburg.muse'+'um\x22,\x22fribo'+'urg.museum'+'\x22,\x22frog.mu'+'seum\x22,\x22fun'+'dacio.muse'+'um\x22,\x22furni'+'ture.museu'+'m\x22,\x22galler'+'y.museum\x22,'+'\x22garden.mu'+'seum\x22,\x22gat'+'eway.museu'+'m\x22,\x22geelvi'+'nck.museum'+'\x22,\x22gemolog'+'ical.museu'+'m\x22,\x22geolog'+'y.museum\x22,'+'\x22georgia.m'+'useum\x22,\x22gi'+'essen.muse'+'um\x22,\x22glas.'+'museum\x22,\x22g'+'lass.museu'+'m\x22,\x22gorge.'+'museum\x22,\x22g'+'randrapids'+'.museum\x22,\x22'+'graz.museu'+'m\x22,\x22guerns'+'ey.museum\x22'+',\x22halloffa'+'me.museum\x22'+',\x22hamburg.'+'museum\x22,\x22h'+'andson.mus'+'eum\x22,\x22harv'+'estcelebra'+'tion.museu'+'m\x22,\x22hawaii'+'.museum\x22,\x22'+'health.mus'+'eum\x22,\x22heim'+'atunduhren'+'.museum\x22,\x22'+'hellas.mus'+'eum\x22,\x22hels'+'inki.museu'+'m\x22,\x22hembyg'+'dsforbund.'+'museum\x22,\x22h'+'eritage.mu'+'seum\x22,\x22his'+'toire.muse'+'um\x22,\x22histo'+'rical.muse'+'um\x22,\x22histo'+'ricalsocie'+'ty.museum\x22'+',\x22historic'+'houses.mus'+'eum\x22,\x22hist'+'orisch.mus'+'eum\x22,\x22hist'+'orisches.m'+'useum\x22,\x22hi'+'story.muse'+'um\x22,\x22histo'+'ryofscienc')+('e.museum\x22,'+'\x22horology.'+'museum\x22,\x22h'+'ouse.museu'+'m\x22,\x22humani'+'ties.museu'+'m\x22,\x22illust'+'ration.mus'+'eum\x22,\x22imag'+'eandsound.'+'museum\x22,\x22i'+'ndian.muse'+'um\x22,\x22india'+'na.museum\x22'+',\x22indianap'+'olis.museu'+'m\x22,\x22indian'+'market.mus'+'eum\x22,\x22inte'+'lligence.m'+'useum\x22,\x22in'+'teractive.'+'museum\x22,\x22i'+'raq.museum'+'\x22,\x22iron.mu'+'seum\x22,\x22isl'+'eofman.mus'+'eum\x22,\x22jami'+'son.museum'+'\x22,\x22jeffers'+'on.museum\x22'+',\x22jerusale'+'m.museum\x22,'+'\x22jewelry.m'+'useum\x22,\x22je'+'wish.museu'+'m\x22,\x22jewish'+'art.museum'+'\x22,\x22jfk.mus'+'eum\x22,\x22jour'+'nalism.mus'+'eum\x22,\x22juda'+'ica.museum'+'\x22,\x22judygar'+'land.museu'+'m\x22,\x22juedis'+'ches.museu'+'m\x22,\x22juif.m'+'useum\x22,\x22ka'+'rate.museu'+'m\x22,\x22karika'+'tur.museum'+'\x22,\x22kids.mu'+'seum\x22,\x22koe'+'benhavn.mu'+'seum\x22,\x22koe'+'ln.museum\x22'+',\x22kunst.mu'+'seum\x22,\x22kun'+'stsammlung'+'.museum\x22,\x22'+'kunstundde'+'sign.museu'+'m\x22,\x22labor.'+'museum\x22,\x22l'+'abour.muse'+'um\x22,\x22lajol'+'la.museum\x22'+',\x22lancashi'+'re.museum\x22'+',\x22landes.m'+'useum\x22,\x22la'+'ns.museum\x22'+',\x22lns.mus'+'eum\x22,\x22lars'+'son.museum'+'\x22,\x22lewismi'+'ller.museu'+'m\x22,\x22lincol'+'n.museum\x22,'+'\x22linz.muse'+'um\x22,\x22livin'+'g.museum\x22,'+'\x22livinghis'+'tory.museu'+'m\x22,\x22localh'+'istory.mus'+'eum\x22,\x22lond'+'on.museum\x22'+',\x22losangel'+'es.museum\x22'+',\x22louvre.m'+'useum\x22,\x22lo'+'yalist.mus'+'eum\x22,\x22luce'+'rne.museum'+'\x22,\x22luxembo'+'urg.museum'+'\x22,\x22luzern.'+'museum\x22,\x22m')+('ad.museum\x22'+',\x22madrid.m'+'useum\x22,\x22ma'+'llorca.mus'+'eum\x22,\x22manc'+'hester.mus'+'eum\x22,\x22mans'+'ion.museum'+'\x22,\x22mansion'+'s.museum\x22,'+'\x22manx.muse'+'um\x22,\x22marbu'+'rg.museum\x22'+',\x22maritime'+'.museum\x22,\x22'+'maritimo.m'+'useum\x22,\x22ma'+'ryland.mus'+'eum\x22,\x22mary'+'lhurst.mus'+'eum\x22,\x22medi'+'a.museum\x22,'+'\x22medical.m'+'useum\x22,\x22me'+'dizinhisto'+'risches.mu'+'seum\x22,\x22mee'+'res.museum'+'\x22,\x22memoria'+'l.museum\x22,'+'\x22mesaverde'+'.museum\x22,\x22'+'michigan.m'+'useum\x22,\x22mi'+'datlantic.'+'museum\x22,\x22m'+'ilitary.mu'+'seum\x22,\x22mil'+'l.museum\x22,'+'\x22miners.mu'+'seum\x22,\x22min'+'ing.museum'+'\x22,\x22minneso'+'ta.museum\x22'+',\x22missile.'+'museum\x22,\x22m'+'issoula.mu'+'seum\x22,\x22mod'+'ern.museum'+'\x22,\x22moma.mu'+'seum\x22,\x22mon'+'ey.museum\x22'+',\x22monmouth'+'.museum\x22,\x22'+'monticello'+'.museum\x22,\x22'+'montreal.m'+'useum\x22,\x22mo'+'scow.museu'+'m\x22,\x22motorc'+'ycle.museu'+'m\x22,\x22muench'+'en.museum\x22'+',\x22muenster'+'.museum\x22,\x22'+'mulhouse.m'+'useum\x22,\x22mu'+'ncie.museu'+'m\x22,\x22museet'+'.museum\x22,\x22'+'museumcent'+'er.museum\x22'+',\x22museumve'+'reniging.m'+'useum\x22,\x22mu'+'sic.museum'+'\x22,\x22nationa'+'l.museum\x22,'+'\x22nationalf'+'irearms.mu'+'seum\x22,\x22nat'+'ionalherit'+'age.museum'+'\x22,\x22nativea'+'merican.mu'+'seum\x22,\x22nat'+'uralhistor'+'y.museum\x22,'+'\x22naturalhi'+'storymuseu'+'m.museum\x22,'+'\x22naturalsc'+'iences.mus'+'eum\x22,\x22natu'+'re.museum\x22'+',\x22naturhis'+'torisches.'+'museum\x22,\x22n'+'atuurweten'+'schappen.m')+('useum\x22,\x22na'+'umburg.mus'+'eum\x22,\x22nava'+'l.museum\x22,'+'\x22nebraska.'+'museum\x22,\x22n'+'eues.museu'+'m\x22,\x22newham'+'pshire.mus'+'eum\x22,\x22newj'+'ersey.muse'+'um\x22,\x22newme'+'xico.museu'+'m\x22,\x22newpor'+'t.museum\x22,'+'\x22newspaper'+'.museum\x22,\x22'+'newyork.mu'+'seum\x22,\x22nie'+'pce.museum'+'\x22,\x22norfolk'+'.museum\x22,\x22'+'north.muse'+'um\x22,\x22nrw.m'+'useum\x22,\x22ny'+'c.museum\x22,'+'\x22nyny.muse'+'um\x22,\x22ocean'+'ographic.m'+'useum\x22,\x22oc'+'eanographi'+'que.museum'+'\x22,\x22omaha.m'+'useum\x22,\x22on'+'line.museu'+'m\x22,\x22ontari'+'o.museum\x22,'+'\x22openair.m'+'useum\x22,\x22or'+'egon.museu'+'m\x22,\x22oregon'+'trail.muse'+'um\x22,\x22otago'+'.museum\x22,\x22'+'oxford.mus'+'eum\x22,\x22paci'+'fic.museum'+'\x22,\x22paderbo'+'rn.museum\x22'+',\x22palace.m'+'useum\x22,\x22pa'+'leo.museum'+'\x22,\x22palmspr'+'ings.museu'+'m\x22,\x22panama'+'.museum\x22,\x22'+'paris.muse'+'um\x22,\x22pasad'+'ena.museum'+'\x22,\x22pharmac'+'y.museum\x22,'+'\x22philadelp'+'hia.museum'+'\x22,\x22philade'+'lphiaarea.'+'museum\x22,\x22p'+'hilately.m'+'useum\x22,\x22ph'+'oenix.muse'+'um\x22,\x22photo'+'graphy.mus'+'eum\x22,\x22pilo'+'ts.museum\x22'+',\x22pittsbur'+'gh.museum\x22'+',\x22planetar'+'ium.museum'+'\x22,\x22plantat'+'ion.museum'+'\x22,\x22plants.'+'museum\x22,\x22p'+'laza.museu'+'m\x22,\x22portal'+'.museum\x22,\x22'+'portland.m'+'useum\x22,\x22po'+'rtlligat.m'+'useum\x22,\x22po'+'sts-and-te'+'lecommunic'+'ations.mus'+'eum\x22,\x22pres'+'ervation.m'+'useum\x22,\x22pr'+'esidio.mus'+'eum\x22,\x22pres'+'s.museum\x22,'+'\x22project.m'+'useum\x22,\x22pu'+'blic.museu')+('m\x22,\x22pubol.'+'museum\x22,\x22q'+'uebec.muse'+'um\x22,\x22railr'+'oad.museum'+'\x22,\x22railway'+'.museum\x22,\x22'+'research.m'+'useum\x22,\x22re'+'sistance.m'+'useum\x22,\x22ri'+'odejaneiro'+'.museum\x22,\x22'+'rochester.'+'museum\x22,\x22r'+'ockart.mus'+'eum\x22,\x22roma'+'.museum\x22,\x22'+'russia.mus'+'eum\x22,\x22sain'+'tlouis.mus'+'eum\x22,\x22sale'+'m.museum\x22,'+'\x22salvadord'+'ali.museum'+'\x22,\x22salzbur'+'g.museum\x22,'+'\x22sandiego.'+'museum\x22,\x22s'+'anfrancisc'+'o.museum\x22,'+'\x22santabarb'+'ara.museum'+'\x22,\x22santacr'+'uz.museum\x22'+',\x22santafe.'+'museum\x22,\x22s'+'askatchewa'+'n.museum\x22,'+'\x22satx.muse'+'um\x22,\x22savan'+'nahga.muse'+'um\x22,\x22schle'+'sisches.mu'+'seum\x22,\x22sch'+'oenbrunn.m'+'useum\x22,\x22sc'+'hokoladen.'+'museum\x22,\x22s'+'chool.muse'+'um\x22,\x22schwe'+'iz.museum\x22'+',\x22science.'+'museum\x22,\x22s'+'cienceandh'+'istory.mus'+'eum\x22,\x22scie'+'nceandindu'+'stry.museu'+'m\x22,\x22scienc'+'ecenter.mu'+'seum\x22,\x22sci'+'encecenter'+'s.museum\x22,'+'\x22science-f'+'iction.mus'+'eum\x22,\x22scie'+'ncehistory'+'.museum\x22,\x22'+'sciences.m'+'useum\x22,\x22sc'+'iencesnatu'+'relles.mus'+'eum\x22,\x22scot'+'land.museu'+'m\x22,\x22seapor'+'t.museum\x22,'+'\x22settlemen'+'t.museum\x22,'+'\x22settlers.'+'museum\x22,\x22s'+'hell.museu'+'m\x22,\x22sherbr'+'ooke.museu'+'m\x22,\x22sibeni'+'k.museum\x22,'+'\x22silk.muse'+'um\x22,\x22ski.m'+'useum\x22,\x22sk'+'ole.museum'+'\x22,\x22society'+'.museum\x22,\x22'+'sologne.mu'+'seum\x22,\x22sou'+'ndandvisio'+'n.museum\x22,'+'\x22southcaro'+'lina.museu'+'m\x22,\x22southw'+'est.museum')+('\x22,\x22space.m'+'useum\x22,\x22sp'+'y.museum\x22,'+'\x22square.mu'+'seum\x22,\x22sta'+'dt.museum\x22'+',\x22stalbans'+'.museum\x22,\x22'+'starnberg.'+'museum\x22,\x22s'+'tate.museu'+'m\x22,\x22stateo'+'fdelaware.'+'museum\x22,\x22s'+'tation.mus'+'eum\x22,\x22stea'+'m.museum\x22,'+'\x22steiermar'+'k.museum\x22,'+'\x22stjohn.mu'+'seum\x22,\x22sto'+'ckholm.mus'+'eum\x22,\x22stpe'+'tersburg.m'+'useum\x22,\x22st'+'uttgart.mu'+'seum\x22,\x22sui'+'sse.museum'+'\x22,\x22surgeon'+'shall.muse'+'um\x22,\x22surre'+'y.museum\x22,'+'\x22svizzera.'+'museum\x22,\x22s'+'weden.muse'+'um\x22,\x22sydne'+'y.museum\x22,'+'\x22tank.muse'+'um\x22,\x22tcm.m'+'useum\x22,\x22te'+'chnology.m'+'useum\x22,\x22te'+'lekommunik'+'ation.muse'+'um\x22,\x22telev'+'ision.muse'+'um\x22,\x22texas'+'.museum\x22,\x22'+'textile.mu'+'seum\x22,\x22the'+'ater.museu'+'m\x22,\x22time.m'+'useum\x22,\x22ti'+'mekeeping.'+'museum\x22,\x22t'+'opology.mu'+'seum\x22,\x22tor'+'ino.museum'+'\x22,\x22touch.m'+'useum\x22,\x22to'+'wn.museum\x22'+',\x22transpor'+'t.museum\x22,'+'\x22tree.muse'+'um\x22,\x22troll'+'ey.museum\x22'+',\x22trust.mu'+'seum\x22,\x22tru'+'stee.museu'+'m\x22,\x22uhren.'+'museum\x22,\x22u'+'lm.museum\x22'+',\x22undersea'+'.museum\x22,\x22'+'university'+'.museum\x22,\x22'+'usa.museum'+'\x22,\x22usantiq'+'ues.museum'+'\x22,\x22usarts.'+'museum\x22,\x22u'+'scountryes'+'tate.museu'+'m\x22,\x22uscult'+'ure.museum'+'\x22,\x22usdecor'+'ativearts.'+'museum\x22,\x22u'+'sgarden.mu'+'seum\x22,\x22ush'+'istory.mus'+'eum\x22,\x22ushu'+'aia.museum'+'\x22,\x22uslivin'+'ghistory.m'+'useum\x22,\x22ut'+'ah.museum\x22'+',\x22uvic.mus'+'eum\x22,\x22vall'+'ey.museum\x22')+(',\x22vantaa.m'+'useum\x22,\x22ve'+'rsailles.m'+'useum\x22,\x22vi'+'king.museu'+'m\x22,\x22villag'+'e.museum\x22,'+'\x22virginia.'+'museum\x22,\x22v'+'irtual.mus'+'eum\x22,\x22virt'+'uel.museum'+'\x22,\x22vlaande'+'ren.museum'+'\x22,\x22volkenk'+'unde.museu'+'m\x22,\x22wales.'+'museum\x22,\x22w'+'allonie.mu'+'seum\x22,\x22war'+'.museum\x22,\x22'+'washington'+'dc.museum\x22'+',\x22watchand'+'clock.muse'+'um\x22,\x22watch'+'-and-clock'+'.museum\x22,\x22'+'western.mu'+'seum\x22,\x22wes'+'tfalen.mus'+'eum\x22,\x22whal'+'ing.museum'+'\x22,\x22wildlif'+'e.museum\x22,'+'\x22williamsb'+'urg.museum'+'\x22,\x22windmil'+'l.museum\x22,'+'\x22workshop.'+'museum\x22,\x22y'+'ork.museum'+'\x22,\x22yorkshi'+'re.museum\x22'+',\x22yosemite'+'.museum\x22,\x22'+'youth.muse'+'um\x22,\x22zoolo'+'gical.muse'+'um\x22,\x22zoolo'+'gy.museum\x22'+',\x22.'+'museum\x22,\x22'+'.museum'+'\x22,\x22mv\x22,\x22ae'+'ro.mv\x22,\x22bi'+'z.mv\x22,\x22com'+'.mv\x22,\x22coop'+'.mv\x22,\x22edu.'+'mv\x22,\x22gov.m'+'v\x22,\x22info.m'+'v\x22,\x22int.mv'+'\x22,\x22mil.mv\x22'+',\x22museum.m'+'v\x22,\x22name.m'+'v\x22,\x22net.mv'+'\x22,\x22org.mv\x22'+',\x22pro.mv\x22,'+'\x22mw\x22,\x22ac.m'+'w\x22,\x22biz.mw'+'\x22,\x22co.mw\x22,'+'\x22com.mw\x22,\x22'+'coop.mw\x22,\x22'+'edu.mw\x22,\x22g'+'ov.mw\x22,\x22in'+'t.mw\x22,\x22mus'+'eum.mw\x22,\x22n'+'et.mw\x22,\x22or'+'g.mw\x22,\x22mx\x22'+',\x22com.mx\x22,'+'\x22org.mx\x22,\x22'+'gob.mx\x22,\x22e'+'du.mx\x22,\x22ne'+'t.mx\x22,\x22my\x22'+',\x22com.my\x22,'+'\x22net.my\x22,\x22'+'org.my\x22,\x22g'+'ov.my\x22,\x22ed'+'u.my\x22,\x22mil'+'.my\x22,\x22name'+'.my\x22,\x22mz\x22,'+'\x22ac.mz\x22,\x22a'+'dv.mz\x22,\x22co'+'.mz\x22,\x22edu.'+'mz\x22,\x22gov.m'+'z\x22,\x22mil.mz'+'\x22,\x22net.mz\x22'+',\x22org.mz\x22,'+'\x22na\x22,\x22info'+'.na\x22,\x22pro.')+('na\x22,\x22name.'+'na\x22,\x22schoo'+'l.na\x22,\x22or.'+'na\x22,\x22dr.na'+'\x22,\x22us.na\x22,'+'\x22mx.na\x22,\x22c'+'a.na\x22,\x22in.'+'na\x22,\x22cc.na'+'\x22,\x22tv.na\x22,'+'\x22ws.na\x22,\x22m'+'obi.na\x22,\x22c'+'o.na\x22,\x22com'+'.na\x22,\x22org.'+'na\x22,\x22name\x22'+',\x22nc\x22,\x22ass'+'o.nc\x22,\x22nom'+'.nc\x22,\x22ne\x22,'+'\x22net\x22,\x22nf\x22'+',\x22com.nf\x22,'+'\x22net.nf\x22,\x22'+'per.nf\x22,\x22r'+'ec.nf\x22,\x22we'+'b.nf\x22,\x22art'+'s.nf\x22,\x22fir'+'m.nf\x22,\x22inf'+'o.nf\x22,\x22oth'+'er.nf\x22,\x22st'+'ore.nf\x22,\x22n'+'g\x22,\x22com.ng'+'\x22,\x22edu.ng\x22'+',\x22gov.ng\x22,'+'\x22i.ng\x22,\x22mi'+'l.ng\x22,\x22mob'+'i.ng\x22,\x22nam'+'e.ng\x22,\x22net'+'.ng\x22,\x22org.'+'ng\x22,\x22sch.n'+'g\x22,\x22ni\x22,\x22a'+'c.ni\x22,\x22biz'+'.ni\x22,\x22co.n'+'i\x22,\x22com.ni'+'\x22,\x22edu.ni\x22'+',\x22gob.ni\x22,'+'\x22in.ni\x22,\x22i'+'nfo.ni\x22,\x22i'+'nt.ni\x22,\x22mi'+'l.ni\x22,\x22net'+'.ni\x22,\x22nom.'+'ni\x22,\x22org.n'+'i\x22,\x22web.ni'+'\x22,\x22nl\x22,\x22no'+'\x22,\x22fhs.no\x22'+',\x22vgs.no\x22,'+'\x22fylkesbib'+'l.no\x22,\x22fol'+'kebibl.no\x22'+',\x22museum.n'+'o\x22,\x22idrett'+'.no\x22,\x22priv'+'.no\x22,\x22mil.'+'no\x22,\x22stat.'+'no\x22,\x22dep.n'+'o\x22,\x22kommun'+'e.no\x22,\x22her'+'ad.no\x22,\x22aa'+'.no\x22,\x22ah.n'+'o\x22,\x22bu.no\x22'+',\x22fm.no\x22,\x22'+'hl.no\x22,\x22hm'+'.no\x22,\x22jan-'+'mayen.no\x22,'+'\x22mr.no\x22,\x22n'+'l.no\x22,\x22nt.'+'no\x22,\x22of.no'+'\x22,\x22ol.no\x22,'+'\x22oslo.no\x22,'+'\x22rl.no\x22,\x22s'+'f.no\x22,\x22st.'+'no\x22,\x22svalb'+'ard.no\x22,\x22t'+'m.no\x22,\x22tr.'+'no\x22,\x22va.no'+'\x22,\x22vf.no\x22,'+'\x22gs.aa.no\x22'+',\x22gs.ah.no'+'\x22,\x22gs.bu.n'+'o\x22,\x22gs.fm.'+'no\x22,\x22gs.hl'+'.no\x22,\x22gs.h'+'m.no\x22,\x22gs.'+'jan-mayen.'+'no\x22,\x22gs.mr'+'.no\x22,\x22gs.n'+'l.no\x22,\x22gs.'+'nt.no\x22,\x22gs'+'.of.no\x22,\x22g'+'s.ol.no\x22,\x22'+'gs.oslo.no'+'\x22,\x22gs.rl.n'+'o\x22,\x22gs.sf.')+('no\x22,\x22gs.st'+'.no\x22,\x22gs.s'+'valbard.no'+'\x22,\x22gs.tm.n'+'o\x22,\x22gs.tr.'+'no\x22,\x22gs.va'+'.no\x22,\x22gs.v'+'f.no\x22,\x22akr'+'ehamn.no\x22,'+'\x22krehamn.'+'no\x22,\x22algar'+'d.no\x22,\x22lg'+'rd.no\x22,\x22a'+'rna.no\x22,\x22b'+'rumunddal.'+'no\x22,\x22bryne'+'.no\x22,\x22bron'+'noysund.no'+'\x22,\x22brnny'+'sund.no\x22,\x22'+'drobak.no\x22'+',\x22drbak.n'+'o\x22,\x22egersu'+'nd.no\x22,\x22fe'+'tsund.no\x22,'+'\x22floro.no\x22'+',\x22flor.no'+'\x22,\x22fredrik'+'stad.no\x22,\x22'+'hokksund.n'+'o\x22,\x22honefo'+'ss.no\x22,\x22h'+'nefoss.no\x22'+',\x22jessheim'+'.no\x22,\x22jorp'+'eland.no\x22,'+'\x22jrpeland'+'.no\x22,\x22kirk'+'enes.no\x22,\x22'+'kopervik.n'+'o\x22,\x22krokst'+'adelva.no\x22'+',\x22langevag'+'.no\x22,\x22lang'+'evg.no\x22,\x22'+'leirvik.no'+'\x22,\x22mjondal'+'en.no\x22,\x22mj'+'ndalen.no'+'\x22,\x22mo-i-ra'+'na.no\x22,\x22mo'+'sjoen.no\x22,'+'\x22mosjen.n'+'o\x22,\x22nesodd'+'tangen.no\x22'+',\x22orkanger'+'.no\x22,\x22osoy'+'ro.no\x22,\x22os'+'yro.no\x22,\x22'+'raholt.no\x22'+',\x22rholt.n'+'o\x22,\x22sandne'+'ssjoen.no\x22'+',\x22sandness'+'jen.no\x22,\x22'+'skedsmokor'+'set.no\x22,\x22s'+'lattum.no\x22'+',\x22spjelkav'+'ik.no\x22,\x22st'+'athelle.no'+'\x22,\x22stavern'+'.no\x22,\x22stjo'+'rdalshalse'+'n.no\x22,\x22stj'+'rdalshals'+'en.no\x22,\x22ta'+'nanger.no\x22'+',\x22tranby.n'+'o\x22,\x22vossev'+'angen.no\x22,'+'\x22afjord.no'+'\x22,\x22fjord.'+'no\x22,\x22agden'+'es.no\x22,\x22al'+'.no\x22,\x22l.n'+'o\x22,\x22alesun'+'d.no\x22,\x22le'+'sund.no\x22,\x22'+'alstahaug.'+'no\x22,\x22alta.'+'no\x22,\x22lt.'+'no\x22,\x22alahe'+'adju.no\x22,\x22'+'laheadju.'+'no\x22,\x22alvda'+'l.no\x22,\x22aml'+'i.no\x22,\x22ml'+'i.no\x22,\x22amo'+'t.no\x22,\x22mo')+('t.no\x22,\x22and'+'ebu.no\x22,\x22a'+'ndoy.no\x22,\x22'+'andy.no\x22,'+'\x22andasuolo'+'.no\x22,\x22arda'+'l.no\x22,\x22rd'+'al.no\x22,\x22ar'+'emark.no\x22,'+'\x22arendal.n'+'o\x22,\x22s.no\x22'+',\x22aseral.n'+'o\x22,\x22seral'+'.no\x22,\x22aske'+'r.no\x22,\x22ask'+'im.no\x22,\x22as'+'kvoll.no\x22,'+'\x22askoy.no\x22'+',\x22asky.no'+'\x22,\x22asnes.n'+'o\x22,\x22snes.'+'no\x22,\x22audne'+'daln.no\x22,\x22'+'aukra.no\x22,'+'\x22aure.no\x22,'+'\x22aurland.n'+'o\x22,\x22aursko'+'g-holand.n'+'o\x22,\x22aursko'+'g-hland.n'+'o\x22,\x22austev'+'oll.no\x22,\x22a'+'ustrheim.n'+'o\x22,\x22averoy'+'.no\x22,\x22aver'+'y.no\x22,\x22ba'+'lestrand.n'+'o\x22,\x22ballan'+'gen.no\x22,\x22b'+'alat.no\x22,\x22'+'blt.no\x22,'+'\x22balsfjord'+'.no\x22,\x22bahc'+'cavuotna.n'+'o\x22,\x22bhcca'+'vuotna.no\x22'+',\x22bamble.n'+'o\x22,\x22bardu.'+'no\x22,\x22beard'+'u.no\x22,\x22bei'+'arn.no\x22,\x22b'+'ajddar.no\x22'+',\x22bjddar.'+'no\x22,\x22baida'+'r.no\x22,\x22bi'+'dr.no\x22,\x22b'+'erg.no\x22,\x22b'+'ergen.no\x22,'+'\x22berlevag.'+'no\x22,\x22berle'+'vg.no\x22,\x22b'+'earalvahki'+'.no\x22,\x22bear'+'alvhki.no'+'\x22,\x22bindal.'+'no\x22,\x22birke'+'nes.no\x22,\x22b'+'jarkoy.no\x22'+',\x22bjarky.'+'no\x22,\x22bjerk'+'reim.no\x22,\x22'+'bjugn.no\x22,'+'\x22bodo.no\x22,'+'\x22bod.no\x22,'+'\x22badaddja.'+'no\x22,\x22bdd'+'dj.no\x22,\x22b'+'udejju.no\x22'+',\x22bokn.no\x22'+',\x22bremange'+'r.no\x22,\x22bro'+'nnoy.no\x22,\x22'+'brnny.no'+'\x22,\x22bygland'+'.no\x22,\x22bykl'+'e.no\x22,\x22bar'+'um.no\x22,\x22b'+'rum.no\x22,\x22b'+'o.telemark'+'.no\x22,\x22b.t'+'elemark.no'+'\x22,\x22bo.nord'+'land.no\x22,\x22'+'b.nordlan'+'d.no\x22,\x22bie'+'vat.no\x22,\x22b'+'ievt.no\x22,'+'\x22bomlo.no\x22'+',\x22bmlo.no'+'\x22,\x22batsfjo')+('rd.no\x22,\x22b'+'tsfjord.no'+'\x22,\x22bahcavu'+'otna.no\x22,\x22'+'bhcavuotn'+'a.no\x22,\x22dov'+'re.no\x22,\x22dr'+'ammen.no\x22,'+'\x22drangedal'+'.no\x22,\x22dyro'+'y.no\x22,\x22dyr'+'y.no\x22,\x22do'+'nna.no\x22,\x22d'+'nna.no\x22,\x22'+'eid.no\x22,\x22e'+'idfjord.no'+'\x22,\x22eidsber'+'g.no\x22,\x22eid'+'skog.no\x22,\x22'+'eidsvoll.n'+'o\x22,\x22eigers'+'und.no\x22,\x22e'+'lverum.no\x22'+',\x22enebakk.'+'no\x22,\x22enger'+'dal.no\x22,\x22e'+'tne.no\x22,\x22e'+'tnedal.no\x22'+',\x22evenes.n'+'o\x22,\x22evenas'+'si.no\x22,\x22ev'+'eni.no\x22'+',\x22evje-og-'+'hornnes.no'+'\x22,\x22farsund'+'.no\x22,\x22faus'+'ke.no\x22,\x22fu'+'ossko.no\x22,'+'\x22fuoisku.n'+'o\x22,\x22fedje.'+'no\x22,\x22fet.n'+'o\x22,\x22finnoy'+'.no\x22,\x22finn'+'y.no\x22,\x22fi'+'tjar.no\x22,\x22'+'fjaler.no\x22'+',\x22fjell.no'+'\x22,\x22flaksta'+'d.no\x22,\x22fla'+'tanger.no\x22'+',\x22flekkefj'+'ord.no\x22,\x22f'+'lesberg.no'+'\x22,\x22flora.n'+'o\x22,\x22fla.no'+'\x22,\x22fl.no\x22'+',\x22folldal.'+'no\x22,\x22forsa'+'nd.no\x22,\x22fo'+'snes.no\x22,\x22'+'frei.no\x22,\x22'+'frogn.no\x22,'+'\x22froland.n'+'o\x22,\x22frosta'+'.no\x22,\x22fran'+'a.no\x22,\x22fr'+'na.no\x22,\x22fr'+'oya.no\x22,\x22f'+'rya.no\x22,\x22'+'fusa.no\x22,\x22'+'fyresdal.n'+'o\x22,\x22forde.'+'no\x22,\x22frde'+'.no\x22,\x22gamv'+'ik.no\x22,\x22ga'+'ngaviika.n'+'o\x22,\x22ggav'+'iika.no\x22,\x22'+'gaular.no\x22'+',\x22gausdal.'+'no\x22,\x22gilde'+'skal.no\x22,\x22'+'gildeskl.'+'no\x22,\x22giske'+'.no\x22,\x22gjem'+'nes.no\x22,\x22g'+'jerdrum.no'+'\x22,\x22gjersta'+'d.no\x22,\x22gje'+'sdal.no\x22,\x22'+'gjovik.no\x22'+',\x22gjvik.n'+'o\x22,\x22gloppe'+'n.no\x22,\x22gol'+'.no\x22,\x22gran'+'.no\x22,\x22gran'+'e.no\x22,\x22gra'+'nvin.no\x22,\x22'+'gratangen.'+'no\x22,\x22grims')+('tad.no\x22,\x22g'+'rong.no\x22,\x22'+'kraanghke.'+'no\x22,\x22kran'+'ghke.no\x22,\x22'+'grue.no\x22,\x22'+'gulen.no\x22,'+'\x22hadsel.no'+'\x22,\x22halden.'+'no\x22,\x22halsa'+'.no\x22,\x22hama'+'r.no\x22,\x22ham'+'aroy.no\x22,\x22'+'habmer.no\x22'+',\x22hbmer.n'+'o\x22,\x22hapmir'+'.no\x22,\x22hpm'+'ir.no\x22,\x22ha'+'mmerfest.n'+'o\x22,\x22hammar'+'feasta.no\x22'+',\x22hmmrfe'+'asta.no\x22,\x22'+'haram.no\x22,'+'\x22hareid.no'+'\x22,\x22harstad'+'.no\x22,\x22hasv'+'ik.no\x22,\x22ak'+'noluokta.n'+'o\x22,\x22kolu'+'okta.no\x22,\x22'+'hattfjelld'+'al.no\x22,\x22aa'+'rborte.no\x22'+',\x22haugesun'+'d.no\x22,\x22hem'+'ne.no\x22,\x22he'+'mnes.no\x22,\x22'+'hemsedal.n'+'o\x22,\x22heroy.'+'more-og-ro'+'msdal.no\x22,'+'\x22hery.mr'+'e-og-romsd'+'al.no\x22,\x22he'+'roy.nordla'+'nd.no\x22,\x22he'+'ry.nordla'+'nd.no\x22,\x22hi'+'tra.no\x22,\x22h'+'jartdal.no'+'\x22,\x22hjelmel'+'and.no\x22,\x22h'+'obol.no\x22,\x22'+'hobl.no\x22,'+'\x22hof.no\x22,\x22'+'hol.no\x22,\x22h'+'ole.no\x22,\x22h'+'olmestrand'+'.no\x22,\x22holt'+'alen.no\x22,\x22'+'holtlen.n'+'o\x22,\x22hornin'+'dal.no\x22,\x22h'+'orten.no\x22,'+'\x22hurdal.no'+'\x22,\x22hurum.n'+'o\x22,\x22hvaler'+'.no\x22,\x22hyll'+'estad.no\x22,'+'\x22hagebosta'+'d.no\x22,\x22hg'+'ebostad.no'+'\x22,\x22hoyange'+'r.no\x22,\x22hy'+'anger.no\x22,'+'\x22hoylandet'+'.no\x22,\x22hyl'+'andet.no\x22,'+'\x22ha.no\x22,\x22h'+'.no\x22,\x22ibe'+'stad.no\x22,\x22'+'inderoy.no'+'\x22,\x22indery'+'.no\x22,\x22ivel'+'and.no\x22,\x22j'+'evnaker.no'+'\x22,\x22jondal.'+'no\x22,\x22jolst'+'er.no\x22,\x22j'+'lster.no\x22,'+'\x22karasjok.'+'no\x22,\x22karas'+'johka.no\x22,'+'\x22krjohk'+'a.no\x22,\x22kar'+'lsoy.no\x22,\x22'+'galsa.no\x22,'+'\x22gls.no\x22'+',\x22karmoy.n')+('o\x22,\x22karmy'+'.no\x22,\x22kaut'+'okeino.no\x22'+',\x22guovdage'+'aidnu.no\x22,'+'\x22klepp.no\x22'+',\x22klabu.no'+'\x22,\x22klbu.n'+'o\x22,\x22kongsb'+'erg.no\x22,\x22k'+'ongsvinger'+'.no\x22,\x22krag'+'ero.no\x22,\x22k'+'rager.no\x22'+',\x22kristian'+'sand.no\x22,\x22'+'kristiansu'+'nd.no\x22,\x22kr'+'odsherad.n'+'o\x22,\x22krdsh'+'erad.no\x22,\x22'+'kvalsund.n'+'o\x22,\x22rahkke'+'ravju.no\x22,'+'\x22rhkkerv'+'ju.no\x22,\x22kv'+'am.no\x22,\x22kv'+'inesdal.no'+'\x22,\x22kvinnhe'+'rad.no\x22,\x22k'+'viteseid.n'+'o\x22,\x22kvitso'+'y.no\x22,\x22kvi'+'tsy.no\x22,\x22'+'kvafjord.n'+'o\x22,\x22kvfjo'+'rd.no\x22,\x22gi'+'ehtavuoatn'+'a.no\x22,\x22kva'+'nangen.no\x22'+',\x22kvnange'+'n.no\x22,\x22nav'+'uotna.no\x22,'+'\x22nvuotna.'+'no\x22,\x22kafjo'+'rd.no\x22,\x22k'+'fjord.no\x22,'+'\x22gaivuotna'+'.no\x22,\x22giv'+'uotna.no\x22,'+'\x22larvik.no'+'\x22,\x22lavange'+'n.no\x22,\x22lav'+'agis.no\x22,\x22'+'loabat.no\x22'+',\x22loabt.n'+'o\x22,\x22lebesb'+'y.no\x22,\x22dav'+'vesiida.no'+'\x22,\x22leikang'+'er.no\x22,\x22le'+'irfjord.no'+'\x22,\x22leka.no'+'\x22,\x22leksvik'+'.no\x22,\x22lenv'+'ik.no\x22,\x22le'+'angaviika.'+'no\x22,\x22leag'+'aviika.no\x22'+',\x22lesja.no'+'\x22,\x22levange'+'r.no\x22,\x22lie'+'r.no\x22,\x22lie'+'rne.no\x22,\x22l'+'illehammer'+'.no\x22,\x22lill'+'esand.no\x22,'+'\x22lindesnes'+'.no\x22,\x22lind'+'as.no\x22,\x22li'+'nds.no\x22,\x22'+'lom.no\x22,\x22l'+'oppa.no\x22,\x22'+'lahppi.no\x22'+',\x22lhppi.n'+'o\x22,\x22lund.n'+'o\x22,\x22lunner'+'.no\x22,\x22luro'+'y.no\x22,\x22lur'+'y.no\x22,\x22lu'+'ster.no\x22,\x22'+'lyngdal.no'+'\x22,\x22lyngen.'+'no\x22,\x22ivgu.'+'no\x22,\x22larda'+'l.no\x22,\x22ler'+'dal.no\x22,\x22l'+'rdal.no\x22,'+'\x22lodingen.'+'no\x22,\x22ldin')+('gen.no\x22,\x22l'+'orenskog.n'+'o\x22,\x22lrens'+'kog.no\x22,\x22l'+'oten.no\x22,\x22'+'lten.no\x22,'+'\x22malvik.no'+'\x22,\x22masoy.n'+'o\x22,\x22msy.'+'no\x22,\x22muosa'+'t.no\x22,\x22muo'+'st.no\x22,\x22m'+'andal.no\x22,'+'\x22marker.no'+'\x22,\x22marnard'+'al.no\x22,\x22ma'+'sfjorden.n'+'o\x22,\x22meland'+'.no\x22,\x22meld'+'al.no\x22,\x22me'+'lhus.no\x22,\x22'+'meloy.no\x22,'+'\x22mely.no\x22'+',\x22meraker.'+'no\x22,\x22merk'+'er.no\x22,\x22mo'+'areke.no\x22,'+'\x22moreke.n'+'o\x22,\x22midsun'+'d.no\x22,\x22mid'+'tre-gaulda'+'l.no\x22,\x22mod'+'alen.no\x22,\x22'+'modum.no\x22,'+'\x22molde.no\x22'+',\x22moskenes'+'.no\x22,\x22moss'+'.no\x22,\x22mosv'+'ik.no\x22,\x22ma'+'lselv.no\x22,'+'\x22mlselv.n'+'o\x22,\x22malatv'+'uopmi.no\x22,'+'\x22mlatvuop'+'mi.no\x22,\x22na'+'mdalseid.n'+'o\x22,\x22aejrie'+'.no\x22,\x22nams'+'os.no\x22,\x22na'+'msskogan.n'+'o\x22,\x22naames'+'jevuemie.n'+'o\x22,\x22nmes'+'jevuemie.n'+'o\x22,\x22laakes'+'vuemie.no\x22'+',\x22nannesta'+'d.no\x22,\x22nar'+'vik.no\x22,\x22n'+'arviika.no'+'\x22,\x22naustda'+'l.no\x22,\x22ned'+'re-eiker.n'+'o\x22,\x22nes.ak'+'ershus.no\x22'+',\x22nes.busk'+'erud.no\x22,\x22'+'nesna.no\x22,'+'\x22nesodden.'+'no\x22,\x22nesse'+'by.no\x22,\x22un'+'jarga.no\x22,'+'\x22unjrga.n'+'o\x22,\x22nesset'+'.no\x22,\x22niss'+'edal.no\x22,\x22'+'nittedal.n'+'o\x22,\x22nord-a'+'urdal.no\x22,'+'\x22nord-fron'+'.no\x22,\x22nord'+'-odal.no\x22,'+'\x22norddal.n'+'o\x22,\x22nordka'+'pp.no\x22,\x22da'+'vvenjarga.'+'no\x22,\x22davve'+'njrga.no\x22'+',\x22nordre-l'+'and.no\x22,\x22n'+'ordreisa.n'+'o\x22,\x22raisa.'+'no\x22,\x22risa'+'.no\x22,\x22nore'+'-og-uvdal.'+'no\x22,\x22notod'+'den.no\x22,\x22n'+'aroy.no\x22,\x22'+'nry.no\x22,'+'\x22notteroy.')+('no\x22,\x22ntte'+'ry.no\x22,\x22o'+'dda.no\x22,\x22o'+'ksnes.no\x22,'+'\x22ksnes.no'+'\x22,\x22oppdal.'+'no\x22,\x22oppeg'+'ard.no\x22,\x22o'+'ppegrd.no'+'\x22,\x22orkdal.'+'no\x22,\x22orlan'+'d.no\x22,\x22rl'+'and.no\x22,\x22o'+'rskog.no\x22,'+'\x22rskog.no'+'\x22,\x22orsta.n'+'o\x22,\x22rsta.'+'no\x22,\x22os.he'+'dmark.no\x22,'+'\x22os.hordal'+'and.no\x22,\x22o'+'sen.no\x22,\x22o'+'steroy.no\x22'+',\x22ostery.'+'no\x22,\x22ostre'+'-toten.no\x22'+',\x22stre-to'+'ten.no\x22,\x22o'+'verhalla.n'+'o\x22,\x22ovre-e'+'iker.no\x22,\x22'+'vre-eiker'+'.no\x22,\x22oyer'+'.no\x22,\x22yer'+'.no\x22,\x22oyga'+'rden.no\x22,\x22'+'ygarden.n'+'o\x22,\x22oystre'+'-slidre.no'+'\x22,\x22ystre-'+'slidre.no\x22'+',\x22porsange'+'r.no\x22,\x22por'+'sangu.no\x22,'+'\x22porsgu.'+'no\x22,\x22porsg'+'runn.no\x22,\x22'+'radoy.no\x22,'+'\x22rady.no\x22'+',\x22rakkesta'+'d.no\x22,\x22ran'+'a.no\x22,\x22ruo'+'vat.no\x22,\x22r'+'andaberg.n'+'o\x22,\x22rauma.'+'no\x22,\x22renda'+'len.no\x22,\x22r'+'ennebu.no\x22'+',\x22rennesoy'+'.no\x22,\x22renn'+'esy.no\x22,\x22'+'rindal.no\x22'+',\x22ringebu.'+'no\x22,\x22ringe'+'rike.no\x22,\x22'+'ringsaker.'+'no\x22,\x22rissa'+'.no\x22,\x22riso'+'r.no\x22,\x22ris'+'r.no\x22,\x22ro'+'an.no\x22,\x22ro'+'llag.no\x22,\x22'+'rygge.no\x22,'+'\x22ralingen.'+'no\x22,\x22rlin'+'gen.no\x22,\x22r'+'odoy.no\x22,\x22'+'rdy.no\x22,'+'\x22romskog.n'+'o\x22,\x22rmsko'+'g.no\x22,\x22ror'+'os.no\x22,\x22r'+'ros.no\x22,\x22r'+'ost.no\x22,\x22r'+'st.no\x22,\x22r'+'oyken.no\x22,'+'\x22ryken.no'+'\x22,\x22royrvik'+'.no\x22,\x22ryr'+'vik.no\x22,\x22r'+'ade.no\x22,\x22r'+'de.no\x22,\x22s'+'alangen.no'+'\x22,\x22siellak'+'.no\x22,\x22salt'+'dal.no\x22,\x22s'+'alat.no\x22,\x22'+'slt.no\x22,'+'\x22slat.no\x22'+',\x22samnange')+('r.no\x22,\x22san'+'de.more-og'+'-romsdal.n'+'o\x22,\x22sande.'+'mre-og-ro'+'msdal.no\x22,'+'\x22sande.ves'+'tfold.no\x22,'+'\x22sandefjor'+'d.no\x22,\x22san'+'dnes.no\x22,\x22'+'sandoy.no\x22'+',\x22sandy.n'+'o\x22,\x22sarpsb'+'org.no\x22,\x22s'+'auda.no\x22,\x22'+'sauherad.n'+'o\x22,\x22sel.no'+'\x22,\x22selbu.n'+'o\x22,\x22selje.'+'no\x22,\x22seljo'+'rd.no\x22,\x22si'+'gdal.no\x22,\x22'+'siljan.no\x22'+',\x22sirdal.n'+'o\x22,\x22skaun.'+'no\x22,\x22skeds'+'mo.no\x22,\x22sk'+'i.no\x22,\x22ski'+'en.no\x22,\x22sk'+'iptvet.no\x22'+',\x22skjervoy'+'.no\x22,\x22skje'+'rvy.no\x22,\x22'+'skierva.no'+'\x22,\x22skierv'+'.no\x22,\x22skja'+'k.no\x22,\x22skj'+'k.no\x22,\x22sk'+'odje.no\x22,\x22'+'skanland.n'+'o\x22,\x22sknla'+'nd.no\x22,\x22sk'+'anit.no\x22,\x22'+'sknit.no\x22'+',\x22smola.no'+'\x22,\x22smla.n'+'o\x22,\x22snillf'+'jord.no\x22,\x22'+'snasa.no\x22,'+'\x22snsa.no\x22'+',\x22snoasa.n'+'o\x22,\x22snaase'+'.no\x22,\x22sna'+'se.no\x22,\x22so'+'gndal.no\x22,'+'\x22sokndal.n'+'o\x22,\x22sola.n'+'o\x22,\x22solund'+'.no\x22,\x22song'+'dalen.no\x22,'+'\x22sortland.'+'no\x22,\x22spyde'+'berg.no\x22,\x22'+'stange.no\x22'+',\x22stavange'+'r.no\x22,\x22ste'+'igen.no\x22,\x22'+'steinkjer.'+'no\x22,\x22stjor'+'dal.no\x22,\x22s'+'tjrdal.no'+'\x22,\x22stokke.'+'no\x22,\x22stor-'+'elvdal.no\x22'+',\x22stord.no'+'\x22,\x22stordal'+'.no\x22,\x22stor'+'fjord.no\x22,'+'\x22omasvuotn'+'a.no\x22,\x22str'+'and.no\x22,\x22s'+'tranda.no\x22'+',\x22stryn.no'+'\x22,\x22sula.no'+'\x22,\x22suldal.'+'no\x22,\x22sund.'+'no\x22,\x22sunnd'+'al.no\x22,\x22su'+'rnadal.no\x22'+',\x22sveio.no'+'\x22,\x22svelvik'+'.no\x22,\x22sykk'+'ylven.no\x22,'+'\x22sogne.no\x22'+',\x22sgne.no'+'\x22,\x22somna.n'+'o\x22,\x22smna.'+'no\x22,\x22sondr'+'e-land.no\x22')+(',\x22sndre-l'+'and.no\x22,\x22s'+'or-aurdal.'+'no\x22,\x22sr-a'+'urdal.no\x22,'+'\x22sor-fron.'+'no\x22,\x22sr-f'+'ron.no\x22,\x22s'+'or-odal.no'+'\x22,\x22sr-oda'+'l.no\x22,\x22sor'+'-varanger.'+'no\x22,\x22sr-v'+'aranger.no'+'\x22,\x22matta-v'+'arjjat.no\x22'+',\x22mtta-v'+'rjjat.no\x22,'+'\x22sorfold.n'+'o\x22,\x22srfol'+'d.no\x22,\x22sor'+'reisa.no\x22,'+'\x22srreisa.'+'no\x22,\x22sorum'+'.no\x22,\x22sru'+'m.no\x22,\x22tan'+'a.no\x22,\x22dea'+'tnu.no\x22,\x22t'+'ime.no\x22,\x22t'+'ingvoll.no'+'\x22,\x22tinn.no'+'\x22,\x22tjeldsu'+'nd.no\x22,\x22di'+'elddanuorr'+'i.no\x22,\x22tjo'+'me.no\x22,\x22tj'+'me.no\x22,\x22t'+'okke.no\x22,\x22'+'tolga.no\x22,'+'\x22torsken.n'+'o\x22,\x22tranoy'+'.no\x22,\x22tran'+'y.no\x22,\x22tr'+'omso.no\x22,\x22'+'troms.no\x22'+',\x22tromsa.n'+'o\x22,\x22romsa.'+'no\x22,\x22trond'+'heim.no\x22,\x22'+'troandin.n'+'o\x22,\x22trysil'+'.no\x22,\x22tran'+'a.no\x22,\x22tr'+'na.no\x22,\x22tr'+'ogstad.no\x22'+',\x22trgstad'+'.no\x22,\x22tved'+'estrand.no'+'\x22,\x22tydal.n'+'o\x22,\x22tynset'+'.no\x22,\x22tysf'+'jord.no\x22,\x22'+'divtasvuod'+'na.no\x22,\x22di'+'vttasvuotn'+'a.no\x22,\x22tys'+'nes.no\x22,\x22t'+'ysvar.no\x22,'+'\x22tysvr.no'+'\x22,\x22tonsber'+'g.no\x22,\x22tn'+'sberg.no\x22,'+'\x22ullensake'+'r.no\x22,\x22ull'+'ensvang.no'+'\x22,\x22ulvik.n'+'o\x22,\x22utsira'+'.no\x22,\x22vads'+'o.no\x22,\x22vad'+'s.no\x22,\x22ca'+'hcesuolo.n'+'o\x22,\x22hces'+'uolo.no\x22,\x22'+'vaksdal.no'+'\x22,\x22valle.n'+'o\x22,\x22vang.n'+'o\x22,\x22vanylv'+'en.no\x22,\x22va'+'rdo.no\x22,\x22v'+'ard.no\x22,\x22'+'varggat.no'+'\x22,\x22vrggt'+'.no\x22,\x22vefs'+'n.no\x22,\x22vaa'+'pste.no\x22,\x22'+'vega.no\x22,\x22'+'vegarshei.'+'no\x22,\x22vegr'+'shei.no\x22,\x22'+'vennesla.n')+('o\x22,\x22verdal'+'.no\x22,\x22verr'+'an.no\x22,\x22ve'+'stby.no\x22,\x22'+'vestnes.no'+'\x22,\x22vestre-'+'slidre.no\x22'+',\x22vestre-t'+'oten.no\x22,\x22'+'vestvagoy.'+'no\x22,\x22vestv'+'gy.no\x22,\x22'+'vevelstad.'+'no\x22,\x22vik.n'+'o\x22,\x22vikna.'+'no\x22,\x22vinda'+'fjord.no\x22,'+'\x22volda.no\x22'+',\x22voss.no\x22'+',\x22varoy.no'+'\x22,\x22vry.n'+'o\x22,\x22vagan.'+'no\x22,\x22vgan'+'.no\x22,\x22voag'+'at.no\x22,\x22va'+'gsoy.no\x22,\x22'+'vgsy.no\x22'+',\x22vaga.no\x22'+',\x22vg.no\x22'+',\x22valer.os'+'tfold.no\x22,'+'\x22vler.st'+'fold.no\x22,\x22'+'valer.hedm'+'ark.no\x22,\x22v'+'ler.hedma'+'rk.no\x22,\x22*.'+'np\x22,\x22nr\x22,\x22'+'biz.nr\x22,\x22i'+'nfo.nr\x22,\x22g'+'ov.nr\x22,\x22ed'+'u.nr\x22,\x22org'+'.nr\x22,\x22net.'+'nr\x22,\x22com.n'+'r\x22,\x22nu\x22,\x22n'+'z\x22,\x22ac.nz\x22'+',\x22co.nz\x22,\x22'+'cri.nz\x22,\x22g'+'eek.nz\x22,\x22g'+'en.nz\x22,\x22go'+'vt.nz\x22,\x22he'+'alth.nz\x22,\x22'+'iwi.nz\x22,\x22k'+'iwi.nz\x22,\x22m'+'aori.nz\x22,\x22'+'mil.nz\x22,\x22m'+'ori.nz\x22,\x22'+'net.nz\x22,\x22o'+'rg.nz\x22,\x22pa'+'rliament.n'+'z\x22,\x22school'+'.nz\x22,\x22om\x22,'+'\x22co.om\x22,\x22c'+'om.om\x22,\x22ed'+'u.om\x22,\x22gov'+'.om\x22,\x22med.'+'om\x22,\x22museu'+'m.om\x22,\x22net'+'.om\x22,\x22org.'+'om\x22,\x22pro.o'+'m\x22,\x22onion\x22'+',\x22org\x22,\x22pa'+'\x22,\x22ac.pa\x22,'+'\x22gob.pa\x22,\x22'+'com.pa\x22,\x22o'+'rg.pa\x22,\x22sl'+'d.pa\x22,\x22edu'+'.pa\x22,\x22net.'+'pa\x22,\x22ing.p'+'a\x22,\x22abo.pa'+'\x22,\x22med.pa\x22'+',\x22nom.pa\x22,'+'\x22pe\x22,\x22edu.'+'pe\x22,\x22gob.p'+'e\x22,\x22nom.pe'+'\x22,\x22mil.pe\x22'+',\x22org.pe\x22,'+'\x22com.pe\x22,\x22'+'net.pe\x22,\x22p'+'f\x22,\x22com.pf'+'\x22,\x22org.pf\x22'+',\x22edu.pf\x22,'+'\x22*.pg\x22,\x22ph'+'\x22,\x22com.ph\x22'+',\x22net.ph\x22,'+'\x22org.ph\x22,\x22'+'gov.ph\x22,\x22e'+'du.ph\x22,\x22ng'+'o.ph\x22,\x22mil'+'.ph\x22,\x22i.ph')+('\x22,\x22pk\x22,\x22co'+'m.pk\x22,\x22net'+'.pk\x22,\x22edu.'+'pk\x22,\x22org.p'+'k\x22,\x22fam.pk'+'\x22,\x22biz.pk\x22'+',\x22web.pk\x22,'+'\x22gov.pk\x22,\x22'+'gob.pk\x22,\x22g'+'ok.pk\x22,\x22go'+'n.pk\x22,\x22gop'+'.pk\x22,\x22gos.'+'pk\x22,\x22info.'+'pk\x22,\x22pl\x22,\x22'+'com.pl\x22,\x22n'+'et.pl\x22,\x22or'+'g.pl\x22,\x22aid'+'.pl\x22,\x22agro'+'.pl\x22,\x22atm.'+'pl\x22,\x22auto.'+'pl\x22,\x22biz.p'+'l\x22,\x22edu.pl'+'\x22,\x22gmina.p'+'l\x22,\x22gsm.pl'+'\x22,\x22info.pl'+'\x22,\x22mail.pl'+'\x22,\x22miasta.'+'pl\x22,\x22media'+'.pl\x22,\x22mil.'+'pl\x22,\x22nieru'+'chomosci.p'+'l\x22,\x22nom.pl'+'\x22,\x22pc.pl\x22,'+'\x22powiat.pl'+'\x22,\x22priv.pl'+'\x22,\x22realest'+'ate.pl\x22,\x22r'+'el.pl\x22,\x22se'+'x.pl\x22,\x22sho'+'p.pl\x22,\x22skl'+'ep.pl\x22,\x22so'+'s.pl\x22,\x22szk'+'ola.pl\x22,\x22t'+'argi.pl\x22,\x22'+'tm.pl\x22,\x22to'+'urism.pl\x22,'+'\x22travel.pl'+'\x22,\x22turysty'+'ka.pl\x22,\x22go'+'v.pl\x22,\x22ap.'+'gov.pl\x22,\x22i'+'c.gov.pl\x22,'+'\x22is.gov.pl'+'\x22,\x22us.gov.'+'pl\x22,\x22kmpsp'+'.gov.pl\x22,\x22'+'kppsp.gov.'+'pl\x22,\x22kwpsp'+'.gov.pl\x22,\x22'+'psp.gov.pl'+'\x22,\x22wskr.go'+'v.pl\x22,\x22kwp'+'.gov.pl\x22,\x22'+'mw.gov.pl\x22'+',\x22ug.gov.p'+'l\x22,\x22um.gov'+'.pl\x22,\x22umig'+'.gov.pl\x22,\x22'+'ugim.gov.p'+'l\x22,\x22upow.g'+'ov.pl\x22,\x22uw'+'.gov.pl\x22,\x22'+'starostwo.'+'gov.pl\x22,\x22p'+'a.gov.pl\x22,'+'\x22po.gov.pl'+'\x22,\x22psse.go'+'v.pl\x22,\x22pup'+'.gov.pl\x22,\x22'+'rzgw.gov.p'+'l\x22,\x22sa.gov'+'.pl\x22,\x22so.g'+'ov.pl\x22,\x22sr'+'.gov.pl\x22,\x22'+'wsa.gov.pl'+'\x22,\x22sko.gov'+'.pl\x22,\x22uzs.'+'gov.pl\x22,\x22w'+'iih.gov.pl'+'\x22,\x22winb.go'+'v.pl\x22,\x22pin'+'b.gov.pl\x22,'+'\x22wios.gov.'+'pl\x22,\x22witd.'+'gov.pl\x22,\x22w'+'zmiuw.gov.'+'pl\x22,\x22piw.g'+'ov.pl\x22,\x22wi'+'w.gov.pl\x22,'+'\x22griw.gov.')+('pl\x22,\x22wif.g'+'ov.pl\x22,\x22ou'+'m.gov.pl\x22,'+'\x22sdn.gov.p'+'l\x22,\x22zp.gov'+'.pl\x22,\x22uppo'+'.gov.pl\x22,\x22'+'mup.gov.pl'+'\x22,\x22wuoz.go'+'v.pl\x22,\x22kon'+'sulat.gov.'+'pl\x22,\x22oirm.'+'gov.pl\x22,\x22a'+'ugustow.pl'+'\x22,\x22babia-g'+'ora.pl\x22,\x22b'+'edzin.pl\x22,'+'\x22beskidy.p'+'l\x22,\x22bialow'+'ieza.pl\x22,\x22'+'bialystok.'+'pl\x22,\x22biela'+'wa.pl\x22,\x22bi'+'eszczady.p'+'l\x22,\x22bolesl'+'awiec.pl\x22,'+'\x22bydgoszcz'+'.pl\x22,\x22byto'+'m.pl\x22,\x22cie'+'szyn.pl\x22,\x22'+'czeladz.pl'+'\x22,\x22czest.p'+'l\x22,\x22dlugol'+'eka.pl\x22,\x22e'+'lblag.pl\x22,'+'\x22elk.pl\x22,\x22'+'glogow.pl\x22'+',\x22gniezno.'+'pl\x22,\x22gorli'+'ce.pl\x22,\x22gr'+'ajewo.pl\x22,'+'\x22ilawa.pl\x22'+',\x22jaworzno'+'.pl\x22,\x22jele'+'nia-gora.p'+'l\x22,\x22jgora.'+'pl\x22,\x22kalis'+'z.pl\x22,\x22kaz'+'imierz-dol'+'ny.pl\x22,\x22ka'+'rpacz.pl\x22,'+'\x22kartuzy.p'+'l\x22,\x22kaszub'+'y.pl\x22,\x22kat'+'owice.pl\x22,'+'\x22kepno.pl\x22'+',\x22ketrzyn.'+'pl\x22,\x22klodz'+'ko.pl\x22,\x22ko'+'bierzyce.p'+'l\x22,\x22kolobr'+'zeg.pl\x22,\x22k'+'onin.pl\x22,\x22'+'konskowola'+'.pl\x22,\x22kutn'+'o.pl\x22,\x22lap'+'y.pl\x22,\x22leb'+'ork.pl\x22,\x22l'+'egnica.pl\x22'+',\x22lezajsk.'+'pl\x22,\x22liman'+'owa.pl\x22,\x22l'+'omza.pl\x22,\x22'+'lowicz.pl\x22'+',\x22lubin.pl'+'\x22,\x22lukow.p'+'l\x22,\x22malbor'+'k.pl\x22,\x22mal'+'opolska.pl'+'\x22,\x22mazowsz'+'e.pl\x22,\x22maz'+'ury.pl\x22,\x22m'+'ielec.pl\x22,'+'\x22mielno.pl'+'\x22,\x22mragowo'+'.pl\x22,\x22nakl'+'o.pl\x22,\x22now'+'aruda.pl\x22,'+'\x22nysa.pl\x22,'+'\x22olawa.pl\x22'+',\x22olecko.p'+'l\x22,\x22olkusz'+'.pl\x22,\x22olsz'+'tyn.pl\x22,\x22o'+'poczno.pl\x22'+',\x22opole.pl'+'\x22,\x22ostroda'+'.pl\x22,\x22ostr'+'oleka.pl\x22,'+'\x22ostrowiec')+('.pl\x22,\x22ostr'+'owwlkp.pl\x22'+',\x22pila.pl\x22'+',\x22pisz.pl\x22'+',\x22podhale.'+'pl\x22,\x22podla'+'sie.pl\x22,\x22p'+'olkowice.p'+'l\x22,\x22pomorz'+'e.pl\x22,\x22pom'+'orskie.pl\x22'+',\x22prochowi'+'ce.pl\x22,\x22pr'+'uszkow.pl\x22'+',\x22przewors'+'k.pl\x22,\x22pul'+'awy.pl\x22,\x22r'+'adom.pl\x22,\x22'+'rawa-maz.p'+'l\x22,\x22rybnik'+'.pl\x22,\x22rzes'+'zow.pl\x22,\x22s'+'anok.pl\x22,\x22'+'sejny.pl\x22,'+'\x22slask.pl\x22'+',\x22slupsk.p'+'l\x22,\x22sosnow'+'iec.pl\x22,\x22s'+'talowa-wol'+'a.pl\x22,\x22sko'+'czow.pl\x22,\x22'+'starachowi'+'ce.pl\x22,\x22st'+'argard.pl\x22'+',\x22suwalki.'+'pl\x22,\x22swidn'+'ica.pl\x22,\x22s'+'wiebodzin.'+'pl\x22,\x22swino'+'ujscie.pl\x22'+',\x22szczecin'+'.pl\x22,\x22szcz'+'ytno.pl\x22,\x22'+'tarnobrzeg'+'.pl\x22,\x22tgor'+'y.pl\x22,\x22tur'+'ek.pl\x22,\x22ty'+'chy.pl\x22,\x22u'+'stka.pl\x22,\x22'+'walbrzych.'+'pl\x22,\x22warmi'+'a.pl\x22,\x22war'+'szawa.pl\x22,'+'\x22waw.pl\x22,\x22'+'wegrow.pl\x22'+',\x22wielun.p'+'l\x22,\x22wlocl.'+'pl\x22,\x22wlocl'+'awek.pl\x22,\x22'+'wodzislaw.'+'pl\x22,\x22wolom'+'in.pl\x22,\x22wr'+'oclaw.pl\x22,'+'\x22zachpomor'+'.pl\x22,\x22zaga'+'n.pl\x22,\x22zar'+'ow.pl\x22,\x22zg'+'ora.pl\x22,\x22z'+'gorzelec.p'+'l\x22,\x22pm\x22,\x22p'+'n\x22,\x22gov.pn'+'\x22,\x22co.pn\x22,'+'\x22org.pn\x22,\x22'+'edu.pn\x22,\x22n'+'et.pn\x22,\x22po'+'st\x22,\x22pr\x22,\x22'+'com.pr\x22,\x22n'+'et.pr\x22,\x22or'+'g.pr\x22,\x22gov'+'.pr\x22,\x22edu.'+'pr\x22,\x22isla.'+'pr\x22,\x22pro.p'+'r\x22,\x22biz.pr'+'\x22,\x22info.pr'+'\x22,\x22name.pr'+'\x22,\x22est.pr\x22'+',\x22prof.pr\x22'+',\x22ac.pr\x22,\x22'+'pro\x22,\x22aaa.'+'pro\x22,\x22aca.'+'pro\x22,\x22acct'+'.pro\x22,\x22avo'+'cat.pro\x22,\x22'+'bar.pro\x22,\x22'+'cpa.pro\x22,\x22'+'eng.pro\x22,\x22'+'jur.pro\x22,\x22'+'law.pro\x22,\x22'+'med.pro\x22,\x22'+'recht.pro\x22')+(',\x22ps\x22,\x22edu'+'.ps\x22,\x22gov.'+'ps\x22,\x22sec.p'+'s\x22,\x22plo.ps'+'\x22,\x22com.ps\x22'+',\x22org.ps\x22,'+'\x22net.ps\x22,\x22'+'pt\x22,\x22net.p'+'t\x22,\x22gov.pt'+'\x22,\x22org.pt\x22'+',\x22edu.pt\x22,'+'\x22int.pt\x22,\x22'+'publ.pt\x22,\x22'+'com.pt\x22,\x22n'+'ome.pt\x22,\x22p'+'w\x22,\x22co.pw\x22'+',\x22ne.pw\x22,\x22'+'or.pw\x22,\x22ed'+'.pw\x22,\x22go.p'+'w\x22,\x22belau.'+'pw\x22,\x22py\x22,\x22'+'com.py\x22,\x22c'+'oop.py\x22,\x22e'+'du.py\x22,\x22go'+'v.py\x22,\x22mil'+'.py\x22,\x22net.'+'py\x22,\x22org.p'+'y\x22,\x22qa\x22,\x22c'+'om.qa\x22,\x22ed'+'u.qa\x22,\x22gov'+'.qa\x22,\x22mil.'+'qa\x22,\x22name.'+'qa\x22,\x22net.q'+'a\x22,\x22org.qa'+'\x22,\x22sch.qa\x22'+',\x22re\x22,\x22ass'+'o.re\x22,\x22com'+'.re\x22,\x22nom.'+'re\x22,\x22ro\x22,\x22'+'arts.ro\x22,\x22'+'com.ro\x22,\x22f'+'irm.ro\x22,\x22i'+'nfo.ro\x22,\x22n'+'om.ro\x22,\x22nt'+'.ro\x22,\x22org.'+'ro\x22,\x22rec.r'+'o\x22,\x22store.'+'ro\x22,\x22tm.ro'+'\x22,\x22www.ro\x22'+',\x22rs\x22,\x22ac.'+'rs\x22,\x22co.rs'+'\x22,\x22edu.rs\x22'+',\x22gov.rs\x22,'+'\x22in.rs\x22,\x22o'+'rg.rs\x22,\x22ru'+'\x22,\x22rw\x22,\x22ac'+'.rw\x22,\x22co.r'+'w\x22,\x22coop.r'+'w\x22,\x22gov.rw'+'\x22,\x22mil.rw\x22'+',\x22net.rw\x22,'+'\x22org.rw\x22,\x22'+'sa\x22,\x22com.s'+'a\x22,\x22net.sa'+'\x22,\x22org.sa\x22'+',\x22gov.sa\x22,'+'\x22med.sa\x22,\x22'+'pub.sa\x22,\x22e'+'du.sa\x22,\x22sc'+'h.sa\x22,\x22sb\x22'+',\x22com.sb\x22,'+'\x22edu.sb\x22,\x22'+'gov.sb\x22,\x22n'+'et.sb\x22,\x22or'+'g.sb\x22,\x22sc\x22'+',\x22com.sc\x22,'+'\x22gov.sc\x22,\x22'+'net.sc\x22,\x22o'+'rg.sc\x22,\x22ed'+'u.sc\x22,\x22sd\x22'+',\x22com.sd\x22,'+'\x22net.sd\x22,\x22'+'org.sd\x22,\x22e'+'du.sd\x22,\x22me'+'d.sd\x22,\x22tv.'+'sd\x22,\x22gov.s'+'d\x22,\x22info.s'+'d\x22,\x22se\x22,\x22a'+'.se\x22,\x22ac.s'+'e\x22,\x22b.se\x22,'+'\x22bd.se\x22,\x22b'+'rand.se\x22,\x22'+'c.se\x22,\x22d.s'+'e\x22,\x22e.se\x22,'+'\x22f.se\x22,\x22fh'+'.se\x22,\x22fhsk'+'.se\x22,\x22fhv.'+'se\x22,\x22g.se\x22'+',\x22h.se\x22,\x22i'+'.se\x22,\x22k.se')+('\x22,\x22komforb'+'.se\x22,\x22komm'+'unalforbun'+'d.se\x22,\x22kom'+'vux.se\x22,\x22l'+'.se\x22,\x22lanb'+'ib.se\x22,\x22m.'+'se\x22,\x22n.se\x22'+',\x22naturbru'+'ksgymn.se\x22'+',\x22o.se\x22,\x22o'+'rg.se\x22,\x22p.'+'se\x22,\x22parti'+'.se\x22,\x22pp.s'+'e\x22,\x22press.'+'se\x22,\x22r.se\x22'+',\x22s.se\x22,\x22t'+'.se\x22,\x22tm.s'+'e\x22,\x22u.se\x22,'+'\x22w.se\x22,\x22x.'+'se\x22,\x22y.se\x22'+',\x22z.se\x22,\x22s'+'g\x22,\x22com.sg'+'\x22,\x22net.sg\x22'+',\x22org.sg\x22,'+'\x22gov.sg\x22,\x22'+'edu.sg\x22,\x22p'+'er.sg\x22,\x22sh'+'\x22,\x22com.sh\x22'+',\x22net.sh\x22,'+'\x22gov.sh\x22,\x22'+'org.sh\x22,\x22m'+'il.sh\x22,\x22si'+'\x22,\x22sj\x22,\x22sk'+'\x22,\x22sl\x22,\x22co'+'m.sl\x22,\x22net'+'.sl\x22,\x22edu.'+'sl\x22,\x22gov.s'+'l\x22,\x22org.sl'+'\x22,\x22sm\x22,\x22sn'+'\x22,\x22art.sn\x22'+',\x22com.sn\x22,'+'\x22edu.sn\x22,\x22'+'gouv.sn\x22,\x22'+'org.sn\x22,\x22p'+'erso.sn\x22,\x22'+'univ.sn\x22,\x22'+'so\x22,\x22com.s'+'o\x22,\x22edu.so'+'\x22,\x22gov.so\x22'+',\x22me.so\x22,\x22'+'net.so\x22,\x22o'+'rg.so\x22,\x22sr'+'\x22,\x22ss\x22,\x22bi'+'z.ss\x22,\x22com'+'.ss\x22,\x22edu.'+'ss\x22,\x22gov.s'+'s\x22,\x22net.ss'+'\x22,\x22org.ss\x22'+',\x22st\x22,\x22co.'+'st\x22,\x22com.s'+'t\x22,\x22consul'+'ado.st\x22,\x22e'+'du.st\x22,\x22em'+'baixada.st'+'\x22,\x22gov.st\x22'+',\x22mil.st\x22,'+'\x22net.st\x22,\x22'+'org.st\x22,\x22p'+'rincipe.st'+'\x22,\x22saotome'+'.st\x22,\x22stor'+'e.st\x22,\x22su\x22'+',\x22sv\x22,\x22com'+'.sv\x22,\x22edu.'+'sv\x22,\x22gob.s'+'v\x22,\x22org.sv'+'\x22,\x22red.sv\x22'+',\x22sx\x22,\x22gov'+'.sx\x22,\x22sy\x22,'+'\x22edu.sy\x22,\x22'+'gov.sy\x22,\x22n'+'et.sy\x22,\x22mi'+'l.sy\x22,\x22com'+'.sy\x22,\x22org.'+'sy\x22,\x22sz\x22,\x22'+'co.sz\x22,\x22ac'+'.sz\x22,\x22org.'+'sz\x22,\x22tc\x22,\x22'+'td\x22,\x22tel\x22,'+'\x22tf\x22,\x22tg\x22,'+'\x22th\x22,\x22ac.t'+'h\x22,\x22co.th\x22'+',\x22go.th\x22,\x22'+'in.th\x22,\x22mi'+'.th\x22,\x22net.'+'th\x22,\x22or.th'+'\x22,\x22tj\x22,\x22ac'+'.tj\x22,\x22biz.'+'tj\x22,\x22co.tj')+('\x22,\x22com.tj\x22'+',\x22edu.tj\x22,'+'\x22go.tj\x22,\x22g'+'ov.tj\x22,\x22in'+'t.tj\x22,\x22mil'+'.tj\x22,\x22name'+'.tj\x22,\x22net.'+'tj\x22,\x22nic.t'+'j\x22,\x22org.tj'+'\x22,\x22test.tj'+'\x22,\x22web.tj\x22'+',\x22tk\x22,\x22tl\x22'+',\x22gov.tl\x22,'+'\x22tm\x22,\x22com.'+'tm\x22,\x22co.tm'+'\x22,\x22org.tm\x22'+',\x22net.tm\x22,'+'\x22nom.tm\x22,\x22'+'gov.tm\x22,\x22m'+'il.tm\x22,\x22ed'+'u.tm\x22,\x22tn\x22'+',\x22com.tn\x22,'+'\x22ens.tn\x22,\x22'+'fin.tn\x22,\x22g'+'ov.tn\x22,\x22in'+'d.tn\x22,\x22int'+'l.tn\x22,\x22nat'+'.tn\x22,\x22net.'+'tn\x22,\x22org.t'+'n\x22,\x22info.t'+'n\x22,\x22perso.'+'tn\x22,\x22touri'+'sm.tn\x22,\x22ed'+'unet.tn\x22,\x22'+'rnrt.tn\x22,\x22'+'rns.tn\x22,\x22r'+'nu.tn\x22,\x22mi'+'ncom.tn\x22,\x22'+'agrinet.tn'+'\x22,\x22defense'+'.tn\x22,\x22ture'+'n.tn\x22,\x22to\x22'+',\x22com.to\x22,'+'\x22gov.to\x22,\x22'+'net.to\x22,\x22o'+'rg.to\x22,\x22ed'+'u.to\x22,\x22mil'+'.to\x22,\x22tr\x22,'+'\x22av.tr\x22,\x22b'+'bs.tr\x22,\x22be'+'l.tr\x22,\x22biz'+'.tr\x22,\x22com.'+'tr\x22,\x22dr.tr'+'\x22,\x22edu.tr\x22'+',\x22gen.tr\x22,'+'\x22gov.tr\x22,\x22'+'info.tr\x22,\x22'+'mil.tr\x22,\x22k'+'12.tr\x22,\x22ke'+'p.tr\x22,\x22nam'+'e.tr\x22,\x22net'+'.tr\x22,\x22org.'+'tr\x22,\x22pol.t'+'r\x22,\x22tel.tr'+'\x22,\x22tsk.tr\x22'+',\x22tv.tr\x22,\x22'+'web.tr\x22,\x22n'+'c.tr\x22,\x22gov'+'.nc.tr\x22,\x22t'+'t\x22,\x22co.tt\x22'+',\x22com.tt\x22,'+'\x22org.tt\x22,\x22'+'net.tt\x22,\x22b'+'iz.tt\x22,\x22in'+'fo.tt\x22,\x22pr'+'o.tt\x22,\x22int'+'.tt\x22,\x22coop'+'.tt\x22,\x22jobs'+'.tt\x22,\x22mobi'+'.tt\x22,\x22trav'+'el.tt\x22,\x22mu'+'seum.tt\x22,\x22'+'aero.tt\x22,\x22'+'name.tt\x22,\x22'+'gov.tt\x22,\x22e'+'du.tt\x22,\x22tv'+'\x22,\x22tw\x22,\x22ed'+'u.tw\x22,\x22gov'+'.tw\x22,\x22mil.'+'tw\x22,\x22com.t'+'w\x22,\x22net.tw'+'\x22,\x22org.tw\x22'+',\x22idv.tw\x22,'+'\x22game.tw\x22,'+'\x22ebiz.tw\x22,'+'\x22club.tw\x22,'+'\x22.tw\x22,\x22'+'.tw\x22,\x22.'+'tw\x22,\x22tz\x22,\x22'+'ac.tz\x22,\x22co')+('.tz\x22,\x22go.t'+'z\x22,\x22hotel.'+'tz\x22,\x22info.'+'tz\x22,\x22me.tz'+'\x22,\x22mil.tz\x22'+',\x22mobi.tz\x22'+',\x22ne.tz\x22,\x22'+'or.tz\x22,\x22sc'+'.tz\x22,\x22tv.t'+'z\x22,\x22ua\x22,\x22c'+'om.ua\x22,\x22ed'+'u.ua\x22,\x22gov'+'.ua\x22,\x22in.u'+'a\x22,\x22net.ua'+'\x22,\x22org.ua\x22'+',\x22cherkass'+'y.ua\x22,\x22che'+'rkasy.ua\x22,'+'\x22chernigov'+'.ua\x22,\x22cher'+'nihiv.ua\x22,'+'\x22chernivts'+'i.ua\x22,\x22che'+'rnovtsy.ua'+'\x22,\x22ck.ua\x22,'+'\x22cn.ua\x22,\x22c'+'r.ua\x22,\x22cri'+'mea.ua\x22,\x22c'+'v.ua\x22,\x22dn.'+'ua\x22,\x22dnepr'+'opetrovsk.'+'ua\x22,\x22dnipr'+'opetrovsk.'+'ua\x22,\x22domin'+'ic.ua\x22,\x22do'+'netsk.ua\x22,'+'\x22dp.ua\x22,\x22i'+'f.ua\x22,\x22iva'+'no-frankiv'+'sk.ua\x22,\x22kh'+'.ua\x22,\x22khar'+'kiv.ua\x22,\x22k'+'harkov.ua\x22'+',\x22kherson.'+'ua\x22,\x22khmel'+'nitskiy.ua'+'\x22,\x22khmelny'+'tskyi.ua\x22,'+'\x22kiev.ua\x22,'+'\x22kirovogra'+'d.ua\x22,\x22km.'+'ua\x22,\x22kr.ua'+'\x22,\x22krym.ua'+'\x22,\x22ks.ua\x22,'+'\x22kv.ua\x22,\x22k'+'yiv.ua\x22,\x22l'+'g.ua\x22,\x22lt.'+'ua\x22,\x22lugan'+'sk.ua\x22,\x22lu'+'tsk.ua\x22,\x22l'+'v.ua\x22,\x22lvi'+'v.ua\x22,\x22mk.'+'ua\x22,\x22mykol'+'aiv.ua\x22,\x22n'+'ikolaev.ua'+'\x22,\x22od.ua\x22,'+'\x22odesa.ua\x22'+',\x22odessa.u'+'a\x22,\x22pl.ua\x22'+',\x22poltava.'+'ua\x22,\x22rivne'+'.ua\x22,\x22rovn'+'o.ua\x22,\x22rv.'+'ua\x22,\x22sb.ua'+'\x22,\x22sebasto'+'pol.ua\x22,\x22s'+'evastopol.'+'ua\x22,\x22sm.ua'+'\x22,\x22sumy.ua'+'\x22,\x22te.ua\x22,'+'\x22ternopil.'+'ua\x22,\x22uz.ua'+'\x22,\x22uzhgoro'+'d.ua\x22,\x22vin'+'nica.ua\x22,\x22'+'vinnytsia.'+'ua\x22,\x22vn.ua'+'\x22,\x22volyn.u'+'a\x22,\x22yalta.'+'ua\x22,\x22zapor'+'izhzhe.ua\x22'+',\x22zaporizh'+'zhia.ua\x22,\x22'+'zhitomir.u'+'a\x22,\x22zhytom'+'yr.ua\x22,\x22zp'+'.ua\x22,\x22zt.u'+'a\x22,\x22ug\x22,\x22c'+'o.ug\x22,\x22or.'+'ug\x22,\x22ac.ug')+('\x22,\x22sc.ug\x22,'+'\x22go.ug\x22,\x22n'+'e.ug\x22,\x22com'+'.ug\x22,\x22org.'+'ug\x22,\x22uk\x22,\x22'+'ac.uk\x22,\x22co'+'.uk\x22,\x22gov.'+'uk\x22,\x22ltd.u'+'k\x22,\x22me.uk\x22'+',\x22net.uk\x22,'+'\x22nhs.uk\x22,\x22'+'org.uk\x22,\x22p'+'lc.uk\x22,\x22po'+'lice.uk\x22,\x22'+'*.sch.uk\x22,'+'\x22us\x22,\x22dni.'+'us\x22,\x22fed.u'+'s\x22,\x22isa.us'+'\x22,\x22kids.us'+'\x22,\x22nsn.us\x22'+',\x22ak.us\x22,\x22'+'al.us\x22,\x22ar'+'.us\x22,\x22as.u'+'s\x22,\x22az.us\x22'+',\x22ca.us\x22,\x22'+'co.us\x22,\x22ct'+'.us\x22,\x22dc.u'+'s\x22,\x22de.us\x22'+',\x22fl.us\x22,\x22'+'ga.us\x22,\x22gu'+'.us\x22,\x22hi.u'+'s\x22,\x22ia.us\x22'+',\x22id.us\x22,\x22'+'il.us\x22,\x22in'+'.us\x22,\x22ks.u'+'s\x22,\x22ky.us\x22'+',\x22la.us\x22,\x22'+'ma.us\x22,\x22md'+'.us\x22,\x22me.u'+'s\x22,\x22mi.us\x22'+',\x22mn.us\x22,\x22'+'mo.us\x22,\x22ms'+'.us\x22,\x22mt.u'+'s\x22,\x22nc.us\x22'+',\x22nd.us\x22,\x22'+'ne.us\x22,\x22nh'+'.us\x22,\x22nj.u'+'s\x22,\x22nm.us\x22'+',\x22nv.us\x22,\x22'+'ny.us\x22,\x22oh'+'.us\x22,\x22ok.u'+'s\x22,\x22or.us\x22'+',\x22pa.us\x22,\x22'+'pr.us\x22,\x22ri'+'.us\x22,\x22sc.u'+'s\x22,\x22sd.us\x22'+',\x22tn.us\x22,\x22'+'tx.us\x22,\x22ut'+'.us\x22,\x22vi.u'+'s\x22,\x22vt.us\x22'+',\x22va.us\x22,\x22'+'wa.us\x22,\x22wi'+'.us\x22,\x22wv.u'+'s\x22,\x22wy.us\x22'+',\x22k12.ak.u'+'s\x22,\x22k12.al'+'.us\x22,\x22k12.'+'ar.us\x22,\x22k1'+'2.as.us\x22,\x22'+'k12.az.us\x22'+',\x22k12.ca.u'+'s\x22,\x22k12.co'+'.us\x22,\x22k12.'+'ct.us\x22,\x22k1'+'2.dc.us\x22,\x22'+'k12.de.us\x22'+',\x22k12.fl.u'+'s\x22,\x22k12.ga'+'.us\x22,\x22k12.'+'gu.us\x22,\x22k1'+'2.ia.us\x22,\x22'+'k12.id.us\x22'+',\x22k12.il.u'+'s\x22,\x22k12.in'+'.us\x22,\x22k12.'+'ks.us\x22,\x22k1'+'2.ky.us\x22,\x22'+'k12.la.us\x22'+',\x22k12.ma.u'+'s\x22,\x22k12.md'+'.us\x22,\x22k12.'+'me.us\x22,\x22k1'+'2.mi.us\x22,\x22'+'k12.mn.us\x22'+',\x22k12.mo.u'+'s\x22,\x22k12.ms'+'.us\x22,\x22k12.'+'mt.us\x22,\x22k1'+'2.nc.us\x22,\x22'+'k12.ne.us\x22')+(',\x22k12.nh.u'+'s\x22,\x22k12.nj'+'.us\x22,\x22k12.'+'nm.us\x22,\x22k1'+'2.nv.us\x22,\x22'+'k12.ny.us\x22'+',\x22k12.oh.u'+'s\x22,\x22k12.ok'+'.us\x22,\x22k12.'+'or.us\x22,\x22k1'+'2.pa.us\x22,\x22'+'k12.pr.us\x22'+',\x22k12.ri.u'+'s\x22,\x22k12.sc'+'.us\x22,\x22k12.'+'tn.us\x22,\x22k1'+'2.tx.us\x22,\x22'+'k12.ut.us\x22'+',\x22k12.vi.u'+'s\x22,\x22k12.vt'+'.us\x22,\x22k12.'+'va.us\x22,\x22k1'+'2.wa.us\x22,\x22'+'k12.wi.us\x22'+',\x22k12.wy.u'+'s\x22,\x22cc.ak.'+'us\x22,\x22cc.al'+'.us\x22,\x22cc.a'+'r.us\x22,\x22cc.'+'as.us\x22,\x22cc'+'.az.us\x22,\x22c'+'c.ca.us\x22,\x22'+'cc.co.us\x22,'+'\x22cc.ct.us\x22'+',\x22cc.dc.us'+'\x22,\x22cc.de.u'+'s\x22,\x22cc.fl.'+'us\x22,\x22cc.ga'+'.us\x22,\x22cc.g'+'u.us\x22,\x22cc.'+'hi.us\x22,\x22cc'+'.ia.us\x22,\x22c'+'c.id.us\x22,\x22'+'cc.il.us\x22,'+'\x22cc.in.us\x22'+',\x22cc.ks.us'+'\x22,\x22cc.ky.u'+'s\x22,\x22cc.la.'+'us\x22,\x22cc.ma'+'.us\x22,\x22cc.m'+'d.us\x22,\x22cc.'+'me.us\x22,\x22cc'+'.mi.us\x22,\x22c'+'c.mn.us\x22,\x22'+'cc.mo.us\x22,'+'\x22cc.ms.us\x22'+',\x22cc.mt.us'+'\x22,\x22cc.nc.u'+'s\x22,\x22cc.nd.'+'us\x22,\x22cc.ne'+'.us\x22,\x22cc.n'+'h.us\x22,\x22cc.'+'nj.us\x22,\x22cc'+'.nm.us\x22,\x22c'+'c.nv.us\x22,\x22'+'cc.ny.us\x22,'+'\x22cc.oh.us\x22'+',\x22cc.ok.us'+'\x22,\x22cc.or.u'+'s\x22,\x22cc.pa.'+'us\x22,\x22cc.pr'+'.us\x22,\x22cc.r'+'i.us\x22,\x22cc.'+'sc.us\x22,\x22cc'+'.sd.us\x22,\x22c'+'c.tn.us\x22,\x22'+'cc.tx.us\x22,'+'\x22cc.ut.us\x22'+',\x22cc.vi.us'+'\x22,\x22cc.vt.u'+'s\x22,\x22cc.va.'+'us\x22,\x22cc.wa'+'.us\x22,\x22cc.w'+'i.us\x22,\x22cc.'+'wv.us\x22,\x22cc'+'.wy.us\x22,\x22l'+'ib.ak.us\x22,'+'\x22lib.al.us'+'\x22,\x22lib.ar.'+'us\x22,\x22lib.a'+'s.us\x22,\x22lib'+'.az.us\x22,\x22l'+'ib.ca.us\x22,'+'\x22lib.co.us'+'\x22,\x22lib.ct.'+'us\x22,\x22lib.d'+'c.us\x22,\x22lib'+'.fl.us\x22,\x22l'+'ib.ga.us\x22,'+'\x22lib.gu.us')+('\x22,\x22lib.hi.'+'us\x22,\x22lib.i'+'a.us\x22,\x22lib'+'.id.us\x22,\x22l'+'ib.il.us\x22,'+'\x22lib.in.us'+'\x22,\x22lib.ks.'+'us\x22,\x22lib.k'+'y.us\x22,\x22lib'+'.la.us\x22,\x22l'+'ib.ma.us\x22,'+'\x22lib.md.us'+'\x22,\x22lib.me.'+'us\x22,\x22lib.m'+'i.us\x22,\x22lib'+'.mn.us\x22,\x22l'+'ib.mo.us\x22,'+'\x22lib.ms.us'+'\x22,\x22lib.mt.'+'us\x22,\x22lib.n'+'c.us\x22,\x22lib'+'.nd.us\x22,\x22l'+'ib.ne.us\x22,'+'\x22lib.nh.us'+'\x22,\x22lib.nj.'+'us\x22,\x22lib.n'+'m.us\x22,\x22lib'+'.nv.us\x22,\x22l'+'ib.ny.us\x22,'+'\x22lib.oh.us'+'\x22,\x22lib.ok.'+'us\x22,\x22lib.o'+'r.us\x22,\x22lib'+'.pa.us\x22,\x22l'+'ib.pr.us\x22,'+'\x22lib.ri.us'+'\x22,\x22lib.sc.'+'us\x22,\x22lib.s'+'d.us\x22,\x22lib'+'.tn.us\x22,\x22l'+'ib.tx.us\x22,'+'\x22lib.ut.us'+'\x22,\x22lib.vi.'+'us\x22,\x22lib.v'+'t.us\x22,\x22lib'+'.va.us\x22,\x22l'+'ib.wa.us\x22,'+'\x22lib.wi.us'+'\x22,\x22lib.wy.'+'us\x22,\x22pvt.k'+'12.ma.us\x22,'+'\x22chtr.k12.'+'ma.us\x22,\x22pa'+'roch.k12.m'+'a.us\x22,\x22ann'+'-arbor.mi.'+'us\x22,\x22cog.m'+'i.us\x22,\x22dst'+'.mi.us\x22,\x22e'+'aton.mi.us'+'\x22,\x22gen.mi.'+'us\x22,\x22mus.m'+'i.us\x22,\x22tec'+'.mi.us\x22,\x22w'+'ashtenaw.m'+'i.us\x22,\x22uy\x22'+',\x22com.uy\x22,'+'\x22edu.uy\x22,\x22'+'gub.uy\x22,\x22m'+'il.uy\x22,\x22ne'+'t.uy\x22,\x22org'+'.uy\x22,\x22uz\x22,'+'\x22co.uz\x22,\x22c'+'om.uz\x22,\x22ne'+'t.uz\x22,\x22org'+'.uz\x22,\x22va\x22,'+'\x22vc\x22,\x22com.'+'vc\x22,\x22net.v'+'c\x22,\x22org.vc'+'\x22,\x22gov.vc\x22'+',\x22mil.vc\x22,'+'\x22edu.vc\x22,\x22'+'ve\x22,\x22arts.'+'ve\x22,\x22co.ve'+'\x22,\x22com.ve\x22'+',\x22e12.ve\x22,'+'\x22edu.ve\x22,\x22'+'firm.ve\x22,\x22'+'gob.ve\x22,\x22g'+'ov.ve\x22,\x22in'+'fo.ve\x22,\x22in'+'t.ve\x22,\x22mil'+'.ve\x22,\x22net.'+'ve\x22,\x22org.v'+'e\x22,\x22rec.ve'+'\x22,\x22store.v'+'e\x22,\x22tec.ve'+'\x22,\x22web.ve\x22'+',\x22vg\x22,\x22vi\x22'+',\x22co.vi\x22,\x22')+('com.vi\x22,\x22k'+'12.vi\x22,\x22ne'+'t.vi\x22,\x22org'+'.vi\x22,\x22vn\x22,'+'\x22com.vn\x22,\x22'+'net.vn\x22,\x22o'+'rg.vn\x22,\x22ed'+'u.vn\x22,\x22gov'+'.vn\x22,\x22int.'+'vn\x22,\x22ac.vn'+'\x22,\x22biz.vn\x22'+',\x22info.vn\x22'+',\x22name.vn\x22'+',\x22pro.vn\x22,'+'\x22health.vn'+'\x22,\x22vu\x22,\x22co'+'m.vu\x22,\x22edu'+'.vu\x22,\x22net.'+'vu\x22,\x22org.v'+'u\x22,\x22wf\x22,\x22w'+'s\x22,\x22com.ws'+'\x22,\x22net.ws\x22'+',\x22org.ws\x22,'+'\x22gov.ws\x22,\x22'+'edu.ws\x22,\x22y'+'t\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22,'+'\x22.\x22,\x22'+'.\x22,\x22.'+'\x22,\x22.'+'\x22,\x22.\x22,'+'\x22.\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22.'+'\x22,\x22.'+'\x22,\x22.'+'\x22,\x22.\x22'+',\x22.\x22'+',\x22.\x22,'+'\x22\x22,\x22\x22'+',\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+''+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22'+'.\x22,\x22'+'.\x22,'+'\x22.'+'\x22,\x22.'+'\x22,\x22.'+'\x22,\x22'+'.\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22xxx\x22,'+'\x22*.ye\x22,\x22ac'+'.za\x22,\x22agri'+'c.za\x22,\x22alt'+'.za\x22,\x22co.z'+'a\x22,\x22edu.za'+'\x22,\x22gov.za\x22'+',\x22grondar.')+('za\x22,\x22law.z'+'a\x22,\x22mil.za'+'\x22,\x22net.za\x22'+',\x22ngo.za\x22,'+'\x22nic.za\x22,\x22'+'nis.za\x22,\x22n'+'om.za\x22,\x22or'+'g.za\x22,\x22sch'+'ool.za\x22,\x22t'+'m.za\x22,\x22web'+'.za\x22,\x22zm\x22,'+'\x22ac.zm\x22,\x22b'+'iz.zm\x22,\x22co'+'.zm\x22,\x22com.'+'zm\x22,\x22edu.z'+'m\x22,\x22gov.zm'+'\x22,\x22info.zm'+'\x22,\x22mil.zm\x22'+',\x22net.zm\x22,'+'\x22org.zm\x22,\x22'+'sch.zm\x22,\x22z'+'w\x22,\x22ac.zw\x22'+',\x22co.zw\x22,\x22'+'gov.zw\x22,\x22m'+'il.zw\x22,\x22or'+'g.zw\x22,\x22aaa'+'\x22,\x22aarp\x22,\x22'+'abarth\x22,\x22a'+'bb\x22,\x22abbot'+'t\x22,\x22abbvie'+'\x22,\x22abc\x22,\x22a'+'ble\x22,\x22abog'+'ado\x22,\x22abud'+'habi\x22,\x22aca'+'demy\x22,\x22acc'+'enture\x22,\x22a'+'ccountant\x22'+',\x22accounta'+'nts\x22,\x22aco\x22'+',\x22actor\x22,\x22'+'adac\x22,\x22ads'+'\x22,\x22adult\x22,'+'\x22aeg\x22,\x22aet'+'na\x22,\x22afami'+'lycompany\x22'+',\x22afl\x22,\x22af'+'rica\x22,\x22aga'+'khan\x22,\x22age'+'ncy\x22,\x22aig\x22'+',\x22aigo\x22,\x22a'+'irbus\x22,\x22ai'+'rforce\x22,\x22a'+'irtel\x22,\x22ak'+'dn\x22,\x22alfar'+'omeo\x22,\x22ali'+'baba\x22,\x22ali'+'pay\x22,\x22allf'+'inanz\x22,\x22al'+'lstate\x22,\x22a'+'lly\x22,\x22alsa'+'ce\x22,\x22alsto'+'m\x22,\x22amazon'+'\x22,\x22america'+'nexpress\x22,'+'\x22americanf'+'amily\x22,\x22am'+'ex\x22,\x22amfam'+'\x22,\x22amica\x22,'+'\x22amsterdam'+'\x22,\x22analyti'+'cs\x22,\x22andro'+'id\x22,\x22anqua'+'n\x22,\x22anz\x22,\x22'+'aol\x22,\x22apar'+'tments\x22,\x22a'+'pp\x22,\x22apple'+'\x22,\x22aquarel'+'le\x22,\x22arab\x22'+',\x22aramco\x22,'+'\x22archi\x22,\x22a'+'rmy\x22,\x22art\x22'+',\x22arte\x22,\x22a'+'sda\x22,\x22asso'+'ciates\x22,\x22a'+'thleta\x22,\x22a'+'ttorney\x22,\x22'+'auction\x22,\x22'+'audi\x22,\x22aud'+'ible\x22,\x22aud'+'io\x22,\x22auspo'+'st\x22,\x22autho'+'r\x22,\x22auto\x22,'+'\x22autos\x22,\x22a'+'vianca\x22,\x22a'+'ws\x22,\x22axa\x22,'+'\x22azure\x22,\x22b'+'aby\x22,\x22baid'+'u\x22,\x22baname'+'x\x22,\x22banana'+'republic\x22,')+('\x22band\x22,\x22ba'+'nk\x22,\x22bar\x22,'+'\x22barcelona'+'\x22,\x22barclay'+'card\x22,\x22bar'+'clays\x22,\x22ba'+'refoot\x22,\x22b'+'argains\x22,\x22'+'baseball\x22,'+'\x22basketbal'+'l\x22,\x22bauhau'+'s\x22,\x22bayern'+'\x22,\x22bbc\x22,\x22b'+'bt\x22,\x22bbva\x22'+',\x22bcg\x22,\x22bc'+'n\x22,\x22beats\x22'+',\x22beauty\x22,'+'\x22beer\x22,\x22be'+'ntley\x22,\x22be'+'rlin\x22,\x22bes'+'t\x22,\x22bestbu'+'y\x22,\x22bet\x22,\x22'+'bharti\x22,\x22b'+'ible\x22,\x22bid'+'\x22,\x22bike\x22,\x22'+'bing\x22,\x22bin'+'go\x22,\x22bio\x22,'+'\x22black\x22,\x22b'+'lackfriday'+'\x22,\x22blockbu'+'ster\x22,\x22blo'+'g\x22,\x22bloomb'+'erg\x22,\x22blue'+'\x22,\x22bms\x22,\x22b'+'mw\x22,\x22bnppa'+'ribas\x22,\x22bo'+'ats\x22,\x22boeh'+'ringer\x22,\x22b'+'ofa\x22,\x22bom\x22'+',\x22bond\x22,\x22b'+'oo\x22,\x22book\x22'+',\x22booking\x22'+',\x22bosch\x22,\x22'+'bostik\x22,\x22b'+'oston\x22,\x22bo'+'t\x22,\x22boutiq'+'ue\x22,\x22box\x22,'+'\x22bradesco\x22'+',\x22bridgest'+'one\x22,\x22broa'+'dway\x22,\x22bro'+'ker\x22,\x22brot'+'her\x22,\x22brus'+'sels\x22,\x22bud'+'apest\x22,\x22bu'+'gatti\x22,\x22bu'+'ild\x22,\x22buil'+'ders\x22,\x22bus'+'iness\x22,\x22bu'+'y\x22,\x22buzz\x22,'+'\x22bzh\x22,\x22cab'+'\x22,\x22cafe\x22,\x22'+'cal\x22,\x22call'+'\x22,\x22calvink'+'lein\x22,\x22cam'+'\x22,\x22camera\x22'+',\x22camp\x22,\x22c'+'ancerresea'+'rch\x22,\x22cano'+'n\x22,\x22capeto'+'wn\x22,\x22capit'+'al\x22,\x22capit'+'alone\x22,\x22ca'+'r\x22,\x22carava'+'n\x22,\x22cards\x22'+',\x22care\x22,\x22c'+'areer\x22,\x22ca'+'reers\x22,\x22ca'+'rs\x22,\x22casa\x22'+',\x22case\x22,\x22c'+'aseih\x22,\x22ca'+'sh\x22,\x22casin'+'o\x22,\x22cateri'+'ng\x22,\x22catho'+'lic\x22,\x22cba\x22'+',\x22cbn\x22,\x22cb'+'re\x22,\x22cbs\x22,'+'\x22ceb\x22,\x22cen'+'ter\x22,\x22ceo\x22'+',\x22cern\x22,\x22c'+'fa\x22,\x22cfd\x22,'+'\x22chanel\x22,\x22'+'channel\x22,\x22'+'charity\x22,\x22'+'chase\x22,\x22ch'+'at\x22,\x22cheap'+'\x22,\x22chintai'+'\x22,\x22christm'+'as\x22,\x22chrom'+'e\x22,\x22church')+('\x22,\x22ciprian'+'i\x22,\x22circle'+'\x22,\x22cisco\x22,'+'\x22citadel\x22,'+'\x22citi\x22,\x22ci'+'tic\x22,\x22city'+'\x22,\x22cityeat'+'s\x22,\x22claims'+'\x22,\x22cleanin'+'g\x22,\x22click\x22'+',\x22clinic\x22,'+'\x22clinique\x22'+',\x22clothing'+'\x22,\x22cloud\x22,'+'\x22club\x22,\x22cl'+'ubmed\x22,\x22co'+'ach\x22,\x22code'+'s\x22,\x22coffee'+'\x22,\x22college'+'\x22,\x22cologne'+'\x22,\x22comcast'+'\x22,\x22commban'+'k\x22,\x22commun'+'ity\x22,\x22comp'+'any\x22,\x22comp'+'are\x22,\x22comp'+'uter\x22,\x22com'+'sec\x22,\x22cond'+'os\x22,\x22const'+'ruction\x22,\x22'+'consulting'+'\x22,\x22contact'+'\x22,\x22contrac'+'tors\x22,\x22coo'+'king\x22,\x22coo'+'kingchanne'+'l\x22,\x22cool\x22,'+'\x22corsica\x22,'+'\x22country\x22,'+'\x22coupon\x22,\x22'+'coupons\x22,\x22'+'courses\x22,\x22'+'cpa\x22,\x22cred'+'it\x22,\x22credi'+'tcard\x22,\x22cr'+'editunion\x22'+',\x22cricket\x22'+',\x22crown\x22,\x22'+'crs\x22,\x22crui'+'se\x22,\x22cruis'+'es\x22,\x22csc\x22,'+'\x22cuisinell'+'a\x22,\x22cymru\x22'+',\x22cyou\x22,\x22d'+'abur\x22,\x22dad'+'\x22,\x22dance\x22,'+'\x22data\x22,\x22da'+'te\x22,\x22datin'+'g\x22,\x22datsun'+'\x22,\x22day\x22,\x22d'+'clk\x22,\x22dds\x22'+',\x22deal\x22,\x22d'+'ealer\x22,\x22de'+'als\x22,\x22degr'+'ee\x22,\x22deliv'+'ery\x22,\x22dell'+'\x22,\x22deloitt'+'e\x22,\x22delta\x22'+',\x22democrat'+'\x22,\x22dental\x22'+',\x22dentist\x22'+',\x22desi\x22,\x22d'+'esign\x22,\x22de'+'v\x22,\x22dhl\x22,\x22'+'diamonds\x22,'+'\x22diet\x22,\x22di'+'gital\x22,\x22di'+'rect\x22,\x22dir'+'ectory\x22,\x22d'+'iscount\x22,\x22'+'discover\x22,'+'\x22dish\x22,\x22di'+'y\x22,\x22dnp\x22,\x22'+'docs\x22,\x22doc'+'tor\x22,\x22dog\x22'+',\x22domains\x22'+',\x22dot\x22,\x22do'+'wnload\x22,\x22d'+'rive\x22,\x22dtv'+'\x22,\x22dubai\x22,'+'\x22duck\x22,\x22du'+'nlop\x22,\x22dup'+'ont\x22,\x22durb'+'an\x22,\x22dvag\x22'+',\x22dvr\x22,\x22ea'+'rth\x22,\x22eat\x22'+',\x22eco\x22,\x22ed'+'eka\x22,\x22educ'+'ation\x22,\x22em'+'ail\x22,\x22emer')+('ck\x22,\x22energ'+'y\x22,\x22engine'+'er\x22,\x22engin'+'eering\x22,\x22e'+'nterprises'+'\x22,\x22epson\x22,'+'\x22equipment'+'\x22,\x22ericsso'+'n\x22,\x22erni\x22,'+'\x22esq\x22,\x22est'+'ate\x22,\x22esur'+'ance\x22,\x22eti'+'salat\x22,\x22eu'+'rovision\x22,'+'\x22eus\x22,\x22eve'+'nts\x22,\x22exch'+'ange\x22,\x22exp'+'ert\x22,\x22expo'+'sed\x22,\x22expr'+'ess\x22,\x22extr'+'aspace\x22,\x22f'+'age\x22,\x22fail'+'\x22,\x22fairwin'+'ds\x22,\x22faith'+'\x22,\x22family\x22'+',\x22fan\x22,\x22fa'+'ns\x22,\x22farm\x22'+',\x22farmers\x22'+',\x22fashion\x22'+',\x22fast\x22,\x22f'+'edex\x22,\x22fee'+'dback\x22,\x22fe'+'rrari\x22,\x22fe'+'rrero\x22,\x22fi'+'at\x22,\x22fidel'+'ity\x22,\x22fido'+'\x22,\x22film\x22,\x22'+'final\x22,\x22fi'+'nance\x22,\x22fi'+'nancial\x22,\x22'+'fire\x22,\x22fir'+'estone\x22,\x22f'+'irmdale\x22,\x22'+'fish\x22,\x22fis'+'hing\x22,\x22fit'+'\x22,\x22fitness'+'\x22,\x22flickr\x22'+',\x22flights\x22'+',\x22flir\x22,\x22f'+'lorist\x22,\x22f'+'lowers\x22,\x22f'+'ly\x22,\x22foo\x22,'+'\x22food\x22,\x22fo'+'odnetwork\x22'+',\x22football'+'\x22,\x22ford\x22,\x22'+'forex\x22,\x22fo'+'rsale\x22,\x22fo'+'rum\x22,\x22foun'+'dation\x22,\x22f'+'ox\x22,\x22free\x22'+',\x22freseniu'+'s\x22,\x22frl\x22,\x22'+'frogans\x22,\x22'+'frontdoor\x22'+',\x22frontier'+'\x22,\x22ftr\x22,\x22f'+'ujitsu\x22,\x22f'+'ujixerox\x22,'+'\x22fun\x22,\x22fun'+'d\x22,\x22furnit'+'ure\x22,\x22futb'+'ol\x22,\x22fyi\x22,'+'\x22gal\x22,\x22gal'+'lery\x22,\x22gal'+'lo\x22,\x22gallu'+'p\x22,\x22game\x22,'+'\x22games\x22,\x22g'+'ap\x22,\x22garde'+'n\x22,\x22gay\x22,\x22'+'gbiz\x22,\x22gdn'+'\x22,\x22gea\x22,\x22g'+'ent\x22,\x22gent'+'ing\x22,\x22geor'+'ge\x22,\x22ggee\x22'+',\x22gift\x22,\x22g'+'ifts\x22,\x22giv'+'es\x22,\x22givin'+'g\x22,\x22glade\x22'+',\x22glass\x22,\x22'+'gle\x22,\x22glob'+'al\x22,\x22globo'+'\x22,\x22gmail\x22,'+'\x22gmbh\x22,\x22gm'+'o\x22,\x22gmx\x22,\x22'+'godaddy\x22,\x22'+'gold\x22,\x22gol'+'dpoint\x22,\x22g'+'olf\x22,\x22goo\x22'+',\x22goodyear')+('\x22,\x22goog\x22,\x22'+'google\x22,\x22g'+'op\x22,\x22got\x22,'+'\x22grainger\x22'+',\x22graphics'+'\x22,\x22gratis\x22'+',\x22green\x22,\x22'+'gripe\x22,\x22gr'+'ocery\x22,\x22gr'+'oup\x22,\x22guar'+'dian\x22,\x22guc'+'ci\x22,\x22guge\x22'+',\x22guide\x22,\x22'+'guitars\x22,\x22'+'guru\x22,\x22hai'+'r\x22,\x22hambur'+'g\x22,\x22hangou'+'t\x22,\x22haus\x22,'+'\x22hbo\x22,\x22hdf'+'c\x22,\x22hdfcba'+'nk\x22,\x22healt'+'h\x22,\x22health'+'care\x22,\x22hel'+'p\x22,\x22helsin'+'ki\x22,\x22here\x22'+',\x22hermes\x22,'+'\x22hgtv\x22,\x22hi'+'phop\x22,\x22his'+'amitsu\x22,\x22h'+'itachi\x22,\x22h'+'iv\x22,\x22hkt\x22,'+'\x22hockey\x22,\x22'+'holdings\x22,'+'\x22holiday\x22,'+'\x22homedepot'+'\x22,\x22homegoo'+'ds\x22,\x22homes'+'\x22,\x22homesen'+'se\x22,\x22honda'+'\x22,\x22horse\x22,'+'\x22hospital\x22'+',\x22host\x22,\x22h'+'osting\x22,\x22h'+'ot\x22,\x22hotel'+'es\x22,\x22hotel'+'s\x22,\x22hotmai'+'l\x22,\x22house\x22'+',\x22how\x22,\x22hs'+'bc\x22,\x22hughe'+'s\x22,\x22hyatt\x22'+',\x22hyundai\x22'+',\x22ibm\x22,\x22ic'+'bc\x22,\x22ice\x22,'+'\x22icu\x22,\x22iee'+'e\x22,\x22ifm\x22,\x22'+'ikano\x22,\x22im'+'amat\x22,\x22imd'+'b\x22,\x22immo\x22,'+'\x22immobilie'+'n\x22,\x22inc\x22,\x22'+'industries'+'\x22,\x22infinit'+'i\x22,\x22ing\x22,\x22'+'ink\x22,\x22inst'+'itute\x22,\x22in'+'surance\x22,\x22'+'insure\x22,\x22i'+'ntel\x22,\x22int'+'ernational'+'\x22,\x22intuit\x22'+',\x22investme'+'nts\x22,\x22ipir'+'anga\x22,\x22iri'+'sh\x22,\x22ismai'+'li\x22,\x22ist\x22,'+'\x22istanbul\x22'+',\x22itau\x22,\x22i'+'tv\x22,\x22iveco'+'\x22,\x22jaguar\x22'+',\x22java\x22,\x22j'+'cb\x22,\x22jcp\x22,'+'\x22jeep\x22,\x22je'+'tzt\x22,\x22jewe'+'lry\x22,\x22jio\x22'+',\x22jll\x22,\x22jm'+'p\x22,\x22jnj\x22,\x22'+'joburg\x22,\x22j'+'ot\x22,\x22joy\x22,'+'\x22jpmorgan\x22'+',\x22jprs\x22,\x22j'+'uegos\x22,\x22ju'+'niper\x22,\x22ka'+'ufen\x22,\x22kdd'+'i\x22,\x22kerryh'+'otels\x22,\x22ke'+'rrylogisti'+'cs\x22,\x22kerry'+'properties'+'\x22,\x22kfh\x22,\x22k'+'ia\x22,\x22kim\x22,')+('\x22kinder\x22,\x22'+'kindle\x22,\x22k'+'itchen\x22,\x22k'+'iwi\x22,\x22koel'+'n\x22,\x22komats'+'u\x22,\x22kosher'+'\x22,\x22kpmg\x22,\x22'+'kpn\x22,\x22krd\x22'+',\x22kred\x22,\x22k'+'uokgroup\x22,'+'\x22kyoto\x22,\x22l'+'acaixa\x22,\x22l'+'amborghini'+'\x22,\x22lamer\x22,'+'\x22lancaster'+'\x22,\x22lancia\x22'+',\x22land\x22,\x22l'+'androver\x22,'+'\x22lanxess\x22,'+'\x22lasalle\x22,'+'\x22lat\x22,\x22lat'+'ino\x22,\x22latr'+'obe\x22,\x22law\x22'+',\x22lawyer\x22,'+'\x22lds\x22,\x22lea'+'se\x22,\x22lecle'+'rc\x22,\x22lefra'+'k\x22,\x22legal\x22'+',\x22lego\x22,\x22l'+'exus\x22,\x22lgb'+'t\x22,\x22lidl\x22,'+'\x22life\x22,\x22li'+'feinsuranc'+'e\x22,\x22lifest'+'yle\x22,\x22ligh'+'ting\x22,\x22lik'+'e\x22,\x22lilly\x22'+',\x22limited\x22'+',\x22limo\x22,\x22l'+'incoln\x22,\x22l'+'inde\x22,\x22lin'+'k\x22,\x22lipsy\x22'+',\x22live\x22,\x22l'+'iving\x22,\x22li'+'xil\x22,\x22llc\x22'+',\x22llp\x22,\x22lo'+'an\x22,\x22loans'+'\x22,\x22locker\x22'+',\x22locus\x22,\x22'+'loft\x22,\x22lol'+'\x22,\x22london\x22'+',\x22lotte\x22,\x22'+'lotto\x22,\x22lo'+'ve\x22,\x22lpl\x22,'+'\x22lplfinanc'+'ial\x22,\x22ltd\x22'+',\x22ltda\x22,\x22l'+'undbeck\x22,\x22'+'lupin\x22,\x22lu'+'xe\x22,\x22luxur'+'y\x22,\x22macys\x22'+',\x22madrid\x22,'+'\x22maif\x22,\x22ma'+'ison\x22,\x22mak'+'eup\x22,\x22man\x22'+',\x22manageme'+'nt\x22,\x22mango'+'\x22,\x22map\x22,\x22m'+'arket\x22,\x22ma'+'rketing\x22,\x22'+'markets\x22,\x22'+'marriott\x22,'+'\x22marshalls'+'\x22,\x22maserat'+'i\x22,\x22mattel'+'\x22,\x22mba\x22,\x22m'+'ckinsey\x22,\x22'+'med\x22,\x22medi'+'a\x22,\x22meet\x22,'+'\x22melbourne'+'\x22,\x22meme\x22,\x22'+'memorial\x22,'+'\x22men\x22,\x22men'+'u\x22,\x22merckm'+'sd\x22,\x22metli'+'fe\x22,\x22miami'+'\x22,\x22microso'+'ft\x22,\x22mini\x22'+',\x22mint\x22,\x22m'+'it\x22,\x22mitsu'+'bishi\x22,\x22ml'+'b\x22,\x22mls\x22,\x22'+'mma\x22,\x22mobi'+'le\x22,\x22moda\x22'+',\x22moe\x22,\x22mo'+'i\x22,\x22mom\x22,\x22'+'monash\x22,\x22m'+'oney\x22,\x22mon'+'ster\x22,\x22mor'+'mon\x22,\x22mort')+('gage\x22,\x22mos'+'cow\x22,\x22moto'+'\x22,\x22motorcy'+'cles\x22,\x22mov'+'\x22,\x22movie\x22,'+'\x22msd\x22,\x22mtn'+'\x22,\x22mtr\x22,\x22m'+'utual\x22,\x22na'+'b\x22,\x22nadex\x22'+',\x22nagoya\x22,'+'\x22nationwid'+'e\x22,\x22natura'+'\x22,\x22navy\x22,\x22'+'nba\x22,\x22nec\x22'+',\x22netbank\x22'+',\x22netflix\x22'+',\x22network\x22'+',\x22neustar\x22'+',\x22new\x22,\x22ne'+'wholland\x22,'+'\x22news\x22,\x22ne'+'xt\x22,\x22nextd'+'irect\x22,\x22ne'+'xus\x22,\x22nfl\x22'+',\x22ngo\x22,\x22nh'+'k\x22,\x22nico\x22,'+'\x22nike\x22,\x22ni'+'kon\x22,\x22ninj'+'a\x22,\x22nissan'+'\x22,\x22nissay\x22'+',\x22nokia\x22,\x22'+'northweste'+'rnmutual\x22,'+'\x22norton\x22,\x22'+'now\x22,\x22nowr'+'uz\x22,\x22nowtv'+'\x22,\x22nra\x22,\x22n'+'rw\x22,\x22ntt\x22,'+'\x22nyc\x22,\x22obi'+'\x22,\x22observe'+'r\x22,\x22off\x22,\x22'+'office\x22,\x22o'+'kinawa\x22,\x22o'+'layan\x22,\x22ol'+'ayangroup\x22'+',\x22oldnavy\x22'+',\x22ollo\x22,\x22o'+'mega\x22,\x22one'+'\x22,\x22ong\x22,\x22o'+'nl\x22,\x22onlin'+'e\x22,\x22onyour'+'side\x22,\x22ooo'+'\x22,\x22open\x22,\x22'+'oracle\x22,\x22o'+'range\x22,\x22or'+'ganic\x22,\x22or'+'igins\x22,\x22os'+'aka\x22,\x22otsu'+'ka\x22,\x22ott\x22,'+'\x22ovh\x22,\x22pag'+'e\x22,\x22panaso'+'nic\x22,\x22pari'+'s\x22,\x22pars\x22,'+'\x22partners\x22'+',\x22parts\x22,\x22'+'party\x22,\x22pa'+'ssagens\x22,\x22'+'pay\x22,\x22pccw'+'\x22,\x22pet\x22,\x22p'+'fizer\x22,\x22ph'+'armacy\x22,\x22p'+'hd\x22,\x22phili'+'ps\x22,\x22phone'+'\x22,\x22photo\x22,'+'\x22photograp'+'hy\x22,\x22photo'+'s\x22,\x22physio'+'\x22,\x22pics\x22,\x22'+'pictet\x22,\x22p'+'ictures\x22,\x22'+'pid\x22,\x22pin\x22'+',\x22ping\x22,\x22p'+'ink\x22,\x22pion'+'eer\x22,\x22pizz'+'a\x22,\x22place\x22'+',\x22play\x22,\x22p'+'laystation'+'\x22,\x22plumbin'+'g\x22,\x22plus\x22,'+'\x22pnc\x22,\x22poh'+'l\x22,\x22poker\x22'+',\x22politie\x22'+',\x22porn\x22,\x22p'+'ramerica\x22,'+'\x22praxi\x22,\x22p'+'ress\x22,\x22pri'+'me\x22,\x22prod\x22'+',\x22producti'+'ons\x22,\x22prof'+'\x22,\x22progres')+('sive\x22,\x22pro'+'mo\x22,\x22prope'+'rties\x22,\x22pr'+'operty\x22,\x22p'+'rotection\x22'+',\x22pru\x22,\x22pr'+'udential\x22,'+'\x22pub\x22,\x22pwc'+'\x22,\x22qpon\x22,\x22'+'quebec\x22,\x22q'+'uest\x22,\x22qvc'+'\x22,\x22racing\x22'+',\x22radio\x22,\x22'+'raid\x22,\x22rea'+'d\x22,\x22reales'+'tate\x22,\x22rea'+'ltor\x22,\x22rea'+'lty\x22,\x22reci'+'pes\x22,\x22red\x22'+',\x22redstone'+'\x22,\x22redumbr'+'ella\x22,\x22reh'+'ab\x22,\x22reise'+'\x22,\x22reisen\x22'+',\x22reit\x22,\x22r'+'eliance\x22,\x22'+'ren\x22,\x22rent'+'\x22,\x22rentals'+'\x22,\x22repair\x22'+',\x22report\x22,'+'\x22republica'+'n\x22,\x22rest\x22,'+'\x22restauran'+'t\x22,\x22review'+'\x22,\x22reviews'+'\x22,\x22rexroth'+'\x22,\x22rich\x22,\x22'+'richardli\x22'+',\x22ricoh\x22,\x22'+'rightathom'+'e\x22,\x22ril\x22,\x22'+'rio\x22,\x22rip\x22'+',\x22rmit\x22,\x22r'+'ocher\x22,\x22ro'+'cks\x22,\x22rode'+'o\x22,\x22rogers'+'\x22,\x22room\x22,\x22'+'rsvp\x22,\x22rug'+'by\x22,\x22ruhr\x22'+',\x22run\x22,\x22rw'+'e\x22,\x22ryukyu'+'\x22,\x22saarlan'+'d\x22,\x22safe\x22,'+'\x22safety\x22,\x22'+'sakura\x22,\x22s'+'ale\x22,\x22salo'+'n\x22,\x22samscl'+'ub\x22,\x22samsu'+'ng\x22,\x22sandv'+'ik\x22,\x22sandv'+'ikcoromant'+'\x22,\x22sanofi\x22'+',\x22sap\x22,\x22sa'+'rl\x22,\x22sas\x22,'+'\x22save\x22,\x22sa'+'xo\x22,\x22sbi\x22,'+'\x22sbs\x22,\x22sca'+'\x22,\x22scb\x22,\x22s'+'chaeffler\x22'+',\x22schmidt\x22'+',\x22scholars'+'hips\x22,\x22sch'+'ool\x22,\x22schu'+'le\x22,\x22schwa'+'rz\x22,\x22scien'+'ce\x22,\x22scjoh'+'nson\x22,\x22sco'+'r\x22,\x22scot\x22,'+'\x22search\x22,\x22'+'seat\x22,\x22sec'+'ure\x22,\x22secu'+'rity\x22,\x22see'+'k\x22,\x22select'+'\x22,\x22sener\x22,'+'\x22services\x22'+',\x22ses\x22,\x22se'+'ven\x22,\x22sew\x22'+',\x22sex\x22,\x22se'+'xy\x22,\x22sfr\x22,'+'\x22shangrila'+'\x22,\x22sharp\x22,'+'\x22shaw\x22,\x22sh'+'ell\x22,\x22shia'+'\x22,\x22shiksha'+'\x22,\x22shoes\x22,'+'\x22shop\x22,\x22sh'+'opping\x22,\x22s'+'houji\x22,\x22sh'+'ow\x22,\x22showt'+'ime\x22,\x22shri')+('ram\x22,\x22silk'+'\x22,\x22sina\x22,\x22'+'singles\x22,\x22'+'site\x22,\x22ski'+'\x22,\x22skin\x22,\x22'+'sky\x22,\x22skyp'+'e\x22,\x22sling\x22'+',\x22smart\x22,\x22'+'smile\x22,\x22sn'+'cf\x22,\x22socce'+'r\x22,\x22social'+'\x22,\x22softban'+'k\x22,\x22softwa'+'re\x22,\x22sohu\x22'+',\x22solar\x22,\x22'+'solutions\x22'+',\x22song\x22,\x22s'+'ony\x22,\x22soy\x22'+',\x22spa\x22,\x22sp'+'ace\x22,\x22spor'+'t\x22,\x22spot\x22,'+'\x22spreadbet'+'ting\x22,\x22srl'+'\x22,\x22stada\x22,'+'\x22staples\x22,'+'\x22star\x22,\x22st'+'atebank\x22,\x22'+'statefarm\x22'+',\x22stc\x22,\x22st'+'cgroup\x22,\x22s'+'tockholm\x22,'+'\x22storage\x22,'+'\x22store\x22,\x22s'+'tream\x22,\x22st'+'udio\x22,\x22stu'+'dy\x22,\x22style'+'\x22,\x22sucks\x22,'+'\x22supplies\x22'+',\x22supply\x22,'+'\x22support\x22,'+'\x22surf\x22,\x22su'+'rgery\x22,\x22su'+'zuki\x22,\x22swa'+'tch\x22,\x22swif'+'tcover\x22,\x22s'+'wiss\x22,\x22syd'+'ney\x22,\x22syma'+'ntec\x22,\x22sys'+'tems\x22,\x22tab'+'\x22,\x22taipei\x22'+',\x22talk\x22,\x22t'+'aobao\x22,\x22ta'+'rget\x22,\x22tat'+'amotors\x22,\x22'+'tatar\x22,\x22ta'+'ttoo\x22,\x22tax'+'\x22,\x22taxi\x22,\x22'+'tci\x22,\x22tdk\x22'+',\x22team\x22,\x22t'+'ech\x22,\x22tech'+'nology\x22,\x22t'+'emasek\x22,\x22t'+'ennis\x22,\x22te'+'va\x22,\x22thd\x22,'+'\x22theater\x22,'+'\x22theatre\x22,'+'\x22tiaa\x22,\x22ti'+'ckets\x22,\x22ti'+'enda\x22,\x22tif'+'fany\x22,\x22tip'+'s\x22,\x22tires\x22'+',\x22tirol\x22,\x22'+'tjmaxx\x22,\x22t'+'jx\x22,\x22tkmax'+'x\x22,\x22tmall\x22'+',\x22today\x22,\x22'+'tokyo\x22,\x22to'+'ols\x22,\x22top\x22'+',\x22toray\x22,\x22'+'toshiba\x22,\x22'+'total\x22,\x22to'+'urs\x22,\x22town'+'\x22,\x22toyota\x22'+',\x22toys\x22,\x22t'+'rade\x22,\x22tra'+'ding\x22,\x22tra'+'ining\x22,\x22tr'+'avel\x22,\x22tra'+'velchannel'+'\x22,\x22travele'+'rs\x22,\x22trave'+'lersinsura'+'nce\x22,\x22trus'+'t\x22,\x22trv\x22,\x22'+'tube\x22,\x22tui'+'\x22,\x22tunes\x22,'+'\x22tushu\x22,\x22t'+'vs\x22,\x22ubank'+'\x22,\x22ubs\x22,\x22u'+'nicom\x22,\x22un')+('iversity\x22,'+'\x22uno\x22,\x22uol'+'\x22,\x22ups\x22,\x22v'+'acations\x22,'+'\x22vana\x22,\x22va'+'nguard\x22,\x22v'+'egas\x22,\x22ven'+'tures\x22,\x22ve'+'risign\x22,\x22v'+'ersicherun'+'g\x22,\x22vet\x22,\x22'+'viajes\x22,\x22v'+'ideo\x22,\x22vig'+'\x22,\x22viking\x22'+',\x22villas\x22,'+'\x22vin\x22,\x22vip'+'\x22,\x22virgin\x22'+',\x22visa\x22,\x22v'+'ision\x22,\x22vi'+'va\x22,\x22vivo\x22'+',\x22vlaander'+'en\x22,\x22vodka'+'\x22,\x22volkswa'+'gen\x22,\x22volv'+'o\x22,\x22vote\x22,'+'\x22voting\x22,\x22'+'voto\x22,\x22voy'+'age\x22,\x22vuel'+'os\x22,\x22wales'+'\x22,\x22walmart'+'\x22,\x22walter\x22'+',\x22wang\x22,\x22w'+'anggou\x22,\x22w'+'atch\x22,\x22wat'+'ches\x22,\x22wea'+'ther\x22,\x22wea'+'therchanne'+'l\x22,\x22webcam'+'\x22,\x22weber\x22,'+'\x22website\x22,'+'\x22wed\x22,\x22wed'+'ding\x22,\x22wei'+'bo\x22,\x22weir\x22'+',\x22whoswho\x22'+',\x22wien\x22,\x22w'+'iki\x22,\x22will'+'iamhill\x22,\x22'+'win\x22,\x22wind'+'ows\x22,\x22wine'+'\x22,\x22winners'+'\x22,\x22wme\x22,\x22w'+'olterskluw'+'er\x22,\x22woods'+'ide\x22,\x22work'+'\x22,\x22works\x22,'+'\x22world\x22,\x22w'+'ow\x22,\x22wtc\x22,'+'\x22wtf\x22,\x22xbo'+'x\x22,\x22xerox\x22'+',\x22xfinity\x22'+',\x22xihuan\x22,'+'\x22xin\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22'+',\x22\x22,'+'\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22'+',\x22\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22')+('\x22,\x22'+'\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22\x22,\x22\x22'+',\x22\x22,\x22\x22'+',\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22\x22,'+'\x22vermgens'+'berater\x22,\x22'+'vermgensb'+'eratung\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22'+'\x22,\x22\x22,\x22'+'\x22,\x22xyz\x22,\x22y'+'achts\x22,\x22ya'+'hoo\x22,\x22yama'+'xun\x22,\x22yand'+'ex\x22,\x22yodob'+'ashi\x22,\x22yog'+'a\x22,\x22yokoha'+'ma\x22,\x22you\x22,'+'\x22youtube\x22,'+'\x22yun\x22,\x22zap'+'pos\x22,\x22zara'+'\x22,\x22zero\x22,\x22'+'zip\x22,\x22zone'+'\x22,\x22zuerich'+'\x22,\x22cc.ua\x22,'+'\x22inf.ua\x22,\x22'+'ltd.ua\x22,\x22a'+'dobeaemclo'+'ud.com\x22,\x22a'+'dobeaemclo'+'ud.net\x22,\x22*'+'.dev.adobe'+'aemcloud.c'+'om\x22,\x22beep.'+'pl\x22,\x22barsy'+'.ca\x22,\x22*.co'+'mpute.esta'+'te\x22,\x22*.alc'+'es.network'+'\x22,\x22altervi'+'sta.org\x22,\x22'+'alwaysdata'+'.net\x22,\x22clo'+'udfront.ne'+'t\x22,\x22*.comp'+'ute.amazon'+'aws.com\x22,\x22'+'*.compute-'+'1.amazonaw'+'s.com\x22,\x22*.'+'compute.am'+'azonaws.co'+'m.cn\x22,\x22us-'+'east-1.ama'+'zonaws.com'+'\x22,\x22cn-nort'+'h-1.eb.ama'+'zonaws.com'+'.cn\x22,\x22cn-n'+'orthwest-1'+'.eb.amazon'+'aws.com.cn'+'\x22,\x22elastic'+'beanstalk.'+'com\x22,\x22ap-n'+'ortheast-1'+'.elasticbe'+'anstalk.co'+'m\x22,\x22ap-nor'+'theast-2.e'+'lasticbean'+'stalk.com\x22'+',\x22ap-north'+'east-3.ela'+'sticbeanst'+'alk.com\x22,\x22'+'ap-south-1'+'.elasticbe'+'anstalk.co'+'m\x22,\x22ap-sou'+'theast-1.e'+'lasticbean'+'stalk.com\x22'+',\x22ap-south'+'east-2.ela'+'sticbeanst'+'alk.com\x22,\x22'+'ca-central')+('-1.elastic'+'beanstalk.'+'com\x22,\x22eu-c'+'entral-1.e'+'lasticbean'+'stalk.com\x22'+',\x22eu-west-'+'1.elasticb'+'eanstalk.c'+'om\x22,\x22eu-we'+'st-2.elast'+'icbeanstal'+'k.com\x22,\x22eu'+'-west-3.el'+'asticbeans'+'talk.com\x22,'+'\x22sa-east-1'+'.elasticbe'+'anstalk.co'+'m\x22,\x22us-eas'+'t-1.elasti'+'cbeanstalk'+'.com\x22,\x22us-'+'east-2.ela'+'sticbeanst'+'alk.com\x22,\x22'+'us-gov-wes'+'t-1.elasti'+'cbeanstalk'+'.com\x22,\x22us-'+'west-1.ela'+'sticbeanst'+'alk.com\x22,\x22'+'us-west-2.'+'elasticbea'+'nstalk.com'+'\x22,\x22*.elb.a'+'mazonaws.c'+'om\x22,\x22*.elb'+'.amazonaws'+'.com.cn\x22,\x22'+'s3.amazona'+'ws.com\x22,\x22s'+'3-ap-north'+'east-1.ama'+'zonaws.com'+'\x22,\x22s3-ap-n'+'ortheast-2'+'.amazonaws'+'.com\x22,\x22s3-'+'ap-south-1'+'.amazonaws'+'.com\x22,\x22s3-'+'ap-southea'+'st-1.amazo'+'naws.com\x22,'+'\x22s3-ap-sou'+'theast-2.a'+'mazonaws.c'+'om\x22,\x22s3-ca'+'-central-1'+'.amazonaws'+'.com\x22,\x22s3-'+'eu-central'+'-1.amazona'+'ws.com\x22,\x22s'+'3-eu-west-'+'1.amazonaw'+'s.com\x22,\x22s3'+'-eu-west-2'+'.amazonaws'+'.com\x22,\x22s3-'+'eu-west-3.'+'amazonaws.'+'com\x22,\x22s3-e'+'xternal-1.'+'amazonaws.'+'com\x22,\x22s3-f'+'ips-us-gov'+'-west-1.am'+'azonaws.co'+'m\x22,\x22s3-sa-'+'east-1.ama'+'zonaws.com'+'\x22,\x22s3-us-g'+'ov-west-1.'+'amazonaws.'+'com\x22,\x22s3-u'+'s-east-2.a'+'mazonaws.c'+'om\x22,\x22s3-us'+'-west-1.am'+'azonaws.co'+'m\x22,\x22s3-us-'+'west-2.ama'+'zonaws.com'+'\x22,\x22s3.ap-n'+'ortheast-2'+'.amazonaws'+'.com\x22,\x22s3.')+('ap-south-1'+'.amazonaws'+'.com\x22,\x22s3.'+'cn-north-1'+'.amazonaws'+'.com.cn\x22,\x22'+'s3.ca-cent'+'ral-1.amaz'+'onaws.com\x22'+',\x22s3.eu-ce'+'ntral-1.am'+'azonaws.co'+'m\x22,\x22s3.eu-'+'west-2.ama'+'zonaws.com'+'\x22,\x22s3.eu-w'+'est-3.amaz'+'onaws.com\x22'+',\x22s3.us-ea'+'st-2.amazo'+'naws.com\x22,'+'\x22s3.dualst'+'ack.ap-nor'+'theast-1.a'+'mazonaws.c'+'om\x22,\x22s3.du'+'alstack.ap'+'-northeast'+'-2.amazona'+'ws.com\x22,\x22s'+'3.dualstac'+'k.ap-south'+'-1.amazona'+'ws.com\x22,\x22s'+'3.dualstac'+'k.ap-south'+'east-1.ama'+'zonaws.com'+'\x22,\x22s3.dual'+'stack.ap-s'+'outheast-2'+'.amazonaws'+'.com\x22,\x22s3.'+'dualstack.'+'ca-central'+'-1.amazona'+'ws.com\x22,\x22s'+'3.dualstac'+'k.eu-centr'+'al-1.amazo'+'naws.com\x22,'+'\x22s3.dualst'+'ack.eu-wes'+'t-1.amazon'+'aws.com\x22,\x22'+'s3.dualsta'+'ck.eu-west'+'-2.amazona'+'ws.com\x22,\x22s'+'3.dualstac'+'k.eu-west-'+'3.amazonaw'+'s.com\x22,\x22s3'+'.dualstack'+'.sa-east-1'+'.amazonaws'+'.com\x22,\x22s3.'+'dualstack.'+'us-east-1.'+'amazonaws.'+'com\x22,\x22s3.d'+'ualstack.u'+'s-east-2.a'+'mazonaws.c'+'om\x22,\x22s3-we'+'bsite-us-e'+'ast-1.amaz'+'onaws.com\x22'+',\x22s3-websi'+'te-us-west'+'-1.amazona'+'ws.com\x22,\x22s'+'3-website-'+'us-west-2.'+'amazonaws.'+'com\x22,\x22s3-w'+'ebsite-ap-'+'northeast-'+'1.amazonaw'+'s.com\x22,\x22s3'+'-website-a'+'p-southeas'+'t-1.amazon'+'aws.com\x22,\x22'+'s3-website'+'-ap-southe'+'ast-2.amaz'+'onaws.com\x22'+',\x22s3-websi'+'te-eu-west')+('-1.amazona'+'ws.com\x22,\x22s'+'3-website-'+'sa-east-1.'+'amazonaws.'+'com\x22,\x22s3-w'+'ebsite.ap-'+'northeast-'+'2.amazonaw'+'s.com\x22,\x22s3'+'-website.a'+'p-south-1.'+'amazonaws.'+'com\x22,\x22s3-w'+'ebsite.ca-'+'central-1.'+'amazonaws.'+'com\x22,\x22s3-w'+'ebsite.eu-'+'central-1.'+'amazonaws.'+'com\x22,\x22s3-w'+'ebsite.eu-'+'west-2.ama'+'zonaws.com'+'\x22,\x22s3-webs'+'ite.eu-wes'+'t-3.amazon'+'aws.com\x22,\x22'+'s3-website'+'.us-east-2'+'.amazonaws'+'.com\x22,\x22ams'+'w.nl\x22,\x22t3l'+'3p0rt.net\x22'+',\x22tele.amu'+'ne.org\x22,\x22a'+'pigee.io\x22,'+'\x22on-aptibl'+'e.com\x22,\x22us'+'er.aseinet'+'.ne.jp\x22,\x22g'+'v.vc\x22,\x22d.g'+'v.vc\x22,\x22use'+'r.party.eu'+'s\x22,\x22pimien'+'ta.org\x22,\x22p'+'oivron.org'+'\x22,\x22potager'+'.org\x22,\x22swe'+'etpepper.o'+'rg\x22,\x22myasu'+'stor.com\x22,'+'\x22myfritz.n'+'et\x22,\x22*.awd'+'ev.ca\x22,\x22*.'+'advisor.ws'+'\x22,\x22b-data.'+'io\x22,\x22backp'+'laneapp.io'+'\x22,\x22balena-'+'devices.co'+'m\x22,\x22app.ba'+'nzaicloud.'+'io\x22,\x22betai'+'nabox.com\x22'+',\x22bnr.la\x22,'+'\x22blackbaud'+'cdn.net\x22,\x22'+'boomla.net'+'\x22,\x22boxfuse'+'.io\x22,\x22squa'+'re7.ch\x22,\x22b'+'placed.com'+'\x22,\x22bplaced'+'.de\x22,\x22squa'+'re7.de\x22,\x22b'+'placed.net'+'\x22,\x22square7'+'.net\x22,\x22bro'+'wsersafety'+'mark.io\x22,\x22'+'uk0.bigv.i'+'o\x22,\x22dh.byt'+'emark.co.u'+'k\x22,\x22vm.byt'+'emark.co.u'+'k\x22,\x22mycd.e'+'u\x22,\x22carrd.'+'co\x22,\x22crd.c'+'o\x22,\x22uwu.ai'+'\x22,\x22ae.org\x22'+',\x22ar.com\x22,'+'\x22br.com\x22,\x22'+'cn.com\x22,\x22c'+'om.de\x22,\x22co'+'m.se\x22,\x22de.'+'com\x22,\x22eu.c'+'om\x22,\x22gb.co'+'m\x22,\x22gb.net')+('\x22,\x22hu.com\x22'+',\x22hu.net\x22,'+'\x22jp.net\x22,\x22'+'jpn.com\x22,\x22'+'kr.com\x22,\x22m'+'ex.com\x22,\x22n'+'o.com\x22,\x22qc'+'.com\x22,\x22ru.'+'com\x22,\x22sa.c'+'om\x22,\x22se.ne'+'t\x22,\x22uk.com'+'\x22,\x22uk.net\x22'+',\x22us.com\x22,'+'\x22uy.com\x22,\x22'+'za.bz\x22,\x22za'+'.com\x22,\x22afr'+'ica.com\x22,\x22'+'gr.com\x22,\x22i'+'n.net\x22,\x22us'+'.org\x22,\x22co.'+'com\x22,\x22c.la'+'\x22,\x22certmgr'+'.org\x22,\x22xen'+'apponazure'+'.com\x22,\x22dis'+'course.gro'+'up\x22,\x22disco'+'urse.team\x22'+',\x22virtueel'+'domein.nl\x22'+',\x22cleverap'+'ps.io\x22,\x22*.'+'lcl.dev\x22,\x22'+'*.stg.dev\x22'+',\x22c66.me\x22,'+'\x22cloud66.w'+'s\x22,\x22cloud6'+'6.zone\x22,\x22j'+'devcloud.c'+'om\x22,\x22wpdev'+'cloud.com\x22'+',\x22cloudacc'+'ess.host\x22,'+'\x22freesite.'+'host\x22,\x22clo'+'udaccess.n'+'et\x22,\x22cloud'+'controlled'+'.com\x22,\x22clo'+'udcontrola'+'pp.com\x22,\x22c'+'loudera.si'+'te\x22,\x22trycl'+'oudflare.c'+'om\x22,\x22worke'+'rs.dev\x22,\x22w'+'next.app\x22,'+'\x22co.ca\x22,\x22*'+'.otap.co\x22,'+'\x22co.cz\x22,\x22c'+'.cdn77.org'+'\x22,\x22cdn77-s'+'sl.net\x22,\x22r'+'.cdn77.net'+'\x22,\x22rsc.cdn'+'77.org\x22,\x22s'+'sl.origin.'+'cdn77-secu'+'re.org\x22,\x22c'+'loudns.asi'+'a\x22,\x22cloudn'+'s.biz\x22,\x22cl'+'oudns.club'+'\x22,\x22cloudns'+'.cc\x22,\x22clou'+'dns.eu\x22,\x22c'+'loudns.in\x22'+',\x22cloudns.'+'info\x22,\x22clo'+'udns.org\x22,'+'\x22cloudns.p'+'ro\x22,\x22cloud'+'ns.pw\x22,\x22cl'+'oudns.us\x22,'+'\x22cloudeity'+'.net\x22,\x22cnp'+'y.gdn\x22,\x22co'+'.nl\x22,\x22co.n'+'o\x22,\x22webhos'+'ting.be\x22,\x22'+'hosting-cl'+'uster.nl\x22,'+'\x22ac.ru\x22,\x22e'+'du.ru\x22,\x22go'+'v.ru\x22,\x22int'+'.ru\x22,\x22mil.'+'ru\x22,\x22test.'+'ru\x22,\x22dyn.c'+'osidns.de\x22'+',\x22dynamisc')+('hes-dns.de'+'\x22,\x22dnsupda'+'ter.de\x22,\x22i'+'nternet-dn'+'s.de\x22,\x22l-o'+'-g-i-n.de\x22'+',\x22dynamic-'+'dns.info\x22,'+'\x22feste-ip.'+'net\x22,\x22knx-'+'server.net'+'\x22,\x22static-'+'access.net'+'\x22,\x22realm.c'+'z\x22,\x22*.cryp'+'tonomic.ne'+'t\x22,\x22cupcak'+'e.is\x22,\x22*.c'+'ustomer-oc'+'i.com\x22,\x22*.'+'oci.custom'+'er-oci.com'+'\x22,\x22*.ocp.c'+'ustomer-oc'+'i.com\x22,\x22*.'+'ocs.custom'+'er-oci.com'+'\x22,\x22cyon.li'+'nk\x22,\x22cyon.'+'site\x22,\x22dap'+'lie.me\x22,\x22l'+'ocalhost.d'+'aplie.me\x22,'+'\x22dattoloca'+'l.com\x22,\x22da'+'ttorelay.c'+'om\x22,\x22datto'+'web.com\x22,\x22'+'mydatto.co'+'m\x22,\x22dattol'+'ocal.net\x22,'+'\x22mydatto.n'+'et\x22,\x22biz.d'+'k\x22,\x22co.dk\x22'+',\x22firm.dk\x22'+',\x22reg.dk\x22,'+'\x22store.dk\x22'+',\x22*.dapps.'+'earth\x22,\x22*.'+'bzz.dapps.'+'earth\x22,\x22bu'+'iltwithdar'+'k.com\x22,\x22ed'+'gestack.me'+'\x22,\x22debian.'+'net\x22,\x22dedy'+'n.io\x22,\x22dns'+'home.de\x22,\x22'+'online.th\x22'+',\x22shop.th\x22'+',\x22drayddns'+'.com\x22,\x22dre'+'amhosters.'+'com\x22,\x22mydr'+'obo.com\x22,\x22'+'drud.io\x22,\x22'+'drud.us\x22,\x22'+'duckdns.or'+'g\x22,\x22dy.fi\x22'+',\x22tunk.org'+'\x22,\x22dyndns-'+'at-home.co'+'m\x22,\x22dyndns'+'-at-work.c'+'om\x22,\x22dyndn'+'s-blog.com'+'\x22,\x22dyndns-'+'free.com\x22,'+'\x22dyndns-ho'+'me.com\x22,\x22d'+'yndns-ip.c'+'om\x22,\x22dyndn'+'s-mail.com'+'\x22,\x22dyndns-'+'office.com'+'\x22,\x22dyndns-'+'pics.com\x22,'+'\x22dyndns-re'+'mote.com\x22,'+'\x22dyndns-se'+'rver.com\x22,'+'\x22dyndns-we'+'b.com\x22,\x22dy'+'ndns-wiki.'+'com\x22,\x22dynd'+'ns-work.co'+'m\x22,\x22dyndns'+'.biz\x22,\x22dyn'+'dns.info\x22,'+'\x22dyndns.or')+('g\x22,\x22dyndns'+'.tv\x22,\x22at-b'+'and-camp.n'+'et\x22,\x22ath.c'+'x\x22,\x22barrel'+'-of-knowle'+'dge.info\x22,'+'\x22barrell-o'+'f-knowledg'+'e.info\x22,\x22b'+'etter-than'+'.tv\x22,\x22blog'+'dns.com\x22,\x22'+'blogdns.ne'+'t\x22,\x22blogdn'+'s.org\x22,\x22bl'+'ogsite.org'+'\x22,\x22boldlyg'+'oingnowher'+'e.org\x22,\x22br'+'oke-it.net'+'\x22,\x22buyshou'+'ses.net\x22,\x22'+'cechire.co'+'m\x22,\x22dnsali'+'as.com\x22,\x22d'+'nsalias.ne'+'t\x22,\x22dnsali'+'as.org\x22,\x22d'+'nsdojo.com'+'\x22,\x22dnsdojo'+'.net\x22,\x22dns'+'dojo.org\x22,'+'\x22does-it.n'+'et\x22,\x22doesn'+'texist.com'+'\x22,\x22doesnte'+'xist.org\x22,'+'\x22dontexist'+'.com\x22,\x22don'+'texist.net'+'\x22,\x22dontexi'+'st.org\x22,\x22d'+'oomdns.com'+'\x22,\x22doomdns'+'.org\x22,\x22dvr'+'dns.org\x22,\x22'+'dyn-o-saur'+'.com\x22,\x22dyn'+'alias.com\x22'+',\x22dynalias'+'.net\x22,\x22dyn'+'alias.org\x22'+',\x22dynathom'+'e.net\x22,\x22dy'+'ndns.ws\x22,\x22'+'endofinter'+'net.net\x22,\x22'+'endofinter'+'net.org\x22,\x22'+'endofthein'+'ternet.org'+'\x22,\x22est-a-l'+'a-maison.c'+'om\x22,\x22est-a'+'-la-masion'+'.com\x22,\x22est'+'-le-patron'+'.com\x22,\x22est'+'-mon-blogu'+'eur.com\x22,\x22'+'for-better'+'.biz\x22,\x22for'+'-more.biz\x22'+',\x22for-our.'+'info\x22,\x22for'+'-some.biz\x22'+',\x22for-the.'+'biz\x22,\x22forg'+'ot.her.nam'+'e\x22,\x22forgot'+'.his.name\x22'+',\x22from-ak.'+'com\x22,\x22from'+'-al.com\x22,\x22'+'from-ar.co'+'m\x22,\x22from-a'+'z.net\x22,\x22fr'+'om-ca.com\x22'+',\x22from-co.'+'net\x22,\x22from'+'-ct.com\x22,\x22'+'from-dc.co'+'m\x22,\x22from-d'+'e.com\x22,\x22fr'+'om-fl.com\x22'+',\x22from-ga.'+'com\x22,\x22from'+'-hi.com\x22,\x22'+'from-ia.co')+('m\x22,\x22from-i'+'d.com\x22,\x22fr'+'om-il.com\x22'+',\x22from-in.'+'com\x22,\x22from'+'-ks.com\x22,\x22'+'from-ky.co'+'m\x22,\x22from-l'+'a.net\x22,\x22fr'+'om-ma.com\x22'+',\x22from-md.'+'com\x22,\x22from'+'-me.org\x22,\x22'+'from-mi.co'+'m\x22,\x22from-m'+'n.com\x22,\x22fr'+'om-mo.com\x22'+',\x22from-ms.'+'com\x22,\x22from'+'-mt.com\x22,\x22'+'from-nc.co'+'m\x22,\x22from-n'+'d.com\x22,\x22fr'+'om-ne.com\x22'+',\x22from-nh.'+'com\x22,\x22from'+'-nj.com\x22,\x22'+'from-nm.co'+'m\x22,\x22from-n'+'v.com\x22,\x22fr'+'om-ny.net\x22'+',\x22from-oh.'+'com\x22,\x22from'+'-ok.com\x22,\x22'+'from-or.co'+'m\x22,\x22from-p'+'a.com\x22,\x22fr'+'om-pr.com\x22'+',\x22from-ri.'+'com\x22,\x22from'+'-sc.com\x22,\x22'+'from-sd.co'+'m\x22,\x22from-t'+'n.com\x22,\x22fr'+'om-tx.com\x22'+',\x22from-ut.'+'com\x22,\x22from'+'-va.com\x22,\x22'+'from-vt.co'+'m\x22,\x22from-w'+'a.com\x22,\x22fr'+'om-wi.com\x22'+',\x22from-wv.'+'com\x22,\x22from'+'-wy.com\x22,\x22'+'ftpaccess.'+'cc\x22,\x22fuett'+'ertdasnetz'+'.de\x22,\x22game'+'-host.org\x22'+',\x22game-ser'+'ver.cc\x22,\x22g'+'etmyip.com'+'\x22,\x22gets-it'+'.net\x22,\x22go.'+'dyndns.org'+'\x22,\x22gotdns.'+'com\x22,\x22gotd'+'ns.org\x22,\x22g'+'roks-the.i'+'nfo\x22,\x22grok'+'s-this.inf'+'o\x22,\x22ham-ra'+'dio-op.net'+'\x22,\x22here-fo'+'r-more.inf'+'o\x22,\x22hobby-'+'site.com\x22,'+'\x22hobby-sit'+'e.org\x22,\x22ho'+'me.dyndns.'+'org\x22,\x22home'+'dns.org\x22,\x22'+'homeftp.ne'+'t\x22,\x22homeft'+'p.org\x22,\x22ho'+'meip.net\x22,'+'\x22homelinux'+'.com\x22,\x22hom'+'elinux.net'+'\x22,\x22homelin'+'ux.org\x22,\x22h'+'omeunix.co'+'m\x22,\x22homeun'+'ix.net\x22,\x22h'+'omeunix.or'+'g\x22,\x22iamall'+'ama.com\x22,\x22'+'in-the-ban'+'d.net\x22,\x22is')+('-a-anarchi'+'st.com\x22,\x22i'+'s-a-blogge'+'r.com\x22,\x22is'+'-a-bookkee'+'per.com\x22,\x22'+'is-a-bruin'+'sfan.org\x22,'+'\x22is-a-bull'+'s-fan.com\x22'+',\x22is-a-can'+'didate.org'+'\x22,\x22is-a-ca'+'terer.com\x22'+',\x22is-a-cel'+'ticsfan.or'+'g\x22,\x22is-a-c'+'hef.com\x22,\x22'+'is-a-chef.'+'net\x22,\x22is-a'+'-chef.org\x22'+',\x22is-a-con'+'servative.'+'com\x22,\x22is-a'+'-cpa.com\x22,'+'\x22is-a-cubi'+'cle-slave.'+'com\x22,\x22is-a'+'-democrat.'+'com\x22,\x22is-a'+'-designer.'+'com\x22,\x22is-a'+'-doctor.co'+'m\x22,\x22is-a-f'+'inancialad'+'visor.com\x22'+',\x22is-a-gee'+'k.com\x22,\x22is'+'-a-geek.ne'+'t\x22,\x22is-a-g'+'eek.org\x22,\x22'+'is-a-green'+'.com\x22,\x22is-'+'a-guru.com'+'\x22,\x22is-a-ha'+'rd-worker.'+'com\x22,\x22is-a'+'-hunter.co'+'m\x22,\x22is-a-k'+'night.org\x22'+',\x22is-a-lan'+'dscaper.co'+'m\x22,\x22is-a-l'+'awyer.com\x22'+',\x22is-a-lib'+'eral.com\x22,'+'\x22is-a-libe'+'rtarian.co'+'m\x22,\x22is-a-l'+'inux-user.'+'org\x22,\x22is-a'+'-llama.com'+'\x22,\x22is-a-mu'+'sician.com'+'\x22,\x22is-a-na'+'scarfan.co'+'m\x22,\x22is-a-n'+'urse.com\x22,'+'\x22is-a-pain'+'ter.com\x22,\x22'+'is-a-patsf'+'an.org\x22,\x22i'+'s-a-person'+'altrainer.'+'com\x22,\x22is-a'+'-photograp'+'her.com\x22,\x22'+'is-a-playe'+'r.com\x22,\x22is'+'-a-republi'+'can.com\x22,\x22'+'is-a-rocks'+'tar.com\x22,\x22'+'is-a-socia'+'list.com\x22,'+'\x22is-a-soxf'+'an.org\x22,\x22i'+'s-a-studen'+'t.com\x22,\x22is'+'-a-teacher'+'.com\x22,\x22is-'+'a-techie.c'+'om\x22,\x22is-a-'+'therapist.'+'com\x22,\x22is-a'+'n-accounta'+'nt.com\x22,\x22i'+'s-an-actor'+'.com\x22,\x22is-'+'an-actress')+('.com\x22,\x22is-'+'an-anarchi'+'st.com\x22,\x22i'+'s-an-artis'+'t.com\x22,\x22is'+'-an-engine'+'er.com\x22,\x22i'+'s-an-enter'+'tainer.com'+'\x22,\x22is-by.u'+'s\x22,\x22is-cer'+'tified.com'+'\x22,\x22is-foun'+'d.org\x22,\x22is'+'-gone.com\x22'+',\x22is-into-'+'anime.com\x22'+',\x22is-into-'+'cars.com\x22,'+'\x22is-into-c'+'artoons.co'+'m\x22,\x22is-int'+'o-games.co'+'m\x22,\x22is-lee'+'t.com\x22,\x22is'+'-lost.org\x22'+',\x22is-not-c'+'ertified.c'+'om\x22,\x22is-sa'+'ved.org\x22,\x22'+'is-slick.c'+'om\x22,\x22is-ub'+'erleet.com'+'\x22,\x22is-very'+'-bad.org\x22,'+'\x22is-very-e'+'vil.org\x22,\x22'+'is-very-go'+'od.org\x22,\x22i'+'s-very-nic'+'e.org\x22,\x22is'+'-very-swee'+'t.org\x22,\x22is'+'-with-theb'+'and.com\x22,\x22'+'isa-geek.c'+'om\x22,\x22isa-g'+'eek.net\x22,\x22'+'isa-geek.o'+'rg\x22,\x22isa-h'+'ockeynut.c'+'om\x22,\x22issma'+'rterthanyo'+'u.com\x22,\x22is'+'teingeek.d'+'e\x22,\x22istmei'+'n.de\x22,\x22kic'+'ks-ass.net'+'\x22,\x22kicks-a'+'ss.org\x22,\x22k'+'nowsitall.'+'info\x22,\x22lan'+'d-4-sale.u'+'s\x22,\x22lebtim'+'netz.de\x22,\x22'+'leitungsen'+'.de\x22,\x22like'+'s-pie.com\x22'+',\x22likescan'+'dy.com\x22,\x22m'+'erseine.nu'+'\x22,\x22mine.nu'+'\x22,\x22misconf'+'used.org\x22,'+'\x22mypets.ws'+'\x22,\x22myphoto'+'s.cc\x22,\x22nea'+'t-url.com\x22'+',\x22office-o'+'n-the.net\x22'+',\x22on-the-w'+'eb.tv\x22,\x22po'+'dzone.net\x22'+',\x22podzone.'+'org\x22,\x22read'+'myblog.org'+'\x22,\x22saves-t'+'he-whales.'+'com\x22,\x22scra'+'pper-site.'+'net\x22,\x22scra'+'pping.cc\x22,'+'\x22selfip.bi'+'z\x22,\x22selfip'+'.com\x22,\x22sel'+'fip.info\x22,'+'\x22selfip.ne'+'t\x22,\x22selfip'+'.org\x22,\x22sel'+'ls-for-les')+('s.com\x22,\x22se'+'lls-for-u.'+'com\x22,\x22sell'+'s-it.net\x22,'+'\x22sellsyour'+'home.org\x22,'+'\x22servebbs.'+'com\x22,\x22serv'+'ebbs.net\x22,'+'\x22servebbs.'+'org\x22,\x22serv'+'eftp.net\x22,'+'\x22serveftp.'+'org\x22,\x22serv'+'egame.org\x22'+',\x22shacknet'+'.nu\x22,\x22simp'+'le-url.com'+'\x22,\x22space-t'+'o-rent.com'+'\x22,\x22stuff-4'+'-sale.org\x22'+',\x22stuff-4-'+'sale.us\x22,\x22'+'teaches-yo'+'ga.com\x22,\x22t'+'hruhere.ne'+'t\x22,\x22traeum'+'tgerade.de'+'\x22,\x22webhop.'+'biz\x22,\x22webh'+'op.info\x22,\x22'+'webhop.net'+'\x22,\x22webhop.'+'org\x22,\x22wors'+'e-than.tv\x22'+',\x22writesth'+'isblog.com'+'\x22,\x22ddnss.d'+'e\x22,\x22dyn.dd'+'nss.de\x22,\x22d'+'yndns.ddns'+'s.de\x22,\x22dyn'+'dns1.de\x22,\x22'+'dyn-ip24.d'+'e\x22,\x22home-w'+'ebserver.d'+'e\x22,\x22dyn.ho'+'me-webserv'+'er.de\x22,\x22my'+'home-serve'+'r.de\x22,\x22ddn'+'ss.org\x22,\x22d'+'efinima.ne'+'t\x22,\x22defini'+'ma.io\x22,\x22bc'+'i.dnstrace'+'.pro\x22,\x22ddn'+'sfree.com\x22'+',\x22ddnsgeek'+'.com\x22,\x22gii'+'ze.com\x22,\x22g'+'leeze.com\x22'+',\x22kozow.co'+'m\x22,\x22loseyo'+'urip.com\x22,'+'\x22ooguy.com'+'\x22,\x22thework'+'pc.com\x22,\x22c'+'asacam.net'+'\x22,\x22dynu.ne'+'t\x22,\x22access'+'cam.org\x22,\x22'+'camdvr.org'+'\x22,\x22freeddn'+'s.org\x22,\x22my'+'wire.org\x22,'+'\x22webredire'+'ct.org\x22,\x22m'+'yddns.rock'+'s\x22,\x22blogsi'+'te.xyz\x22,\x22d'+'ynv6.net\x22,'+'\x22e4.cz\x22,\x22e'+'n-root.fr\x22'+',\x22mytuleap'+'.com\x22,\x22onr'+'ed.one\x22,\x22s'+'taging.onr'+'ed.one\x22,\x22e'+'nonic.io\x22,'+'\x22customer.'+'enonic.io\x22'+',\x22eu.org\x22,'+'\x22al.eu.org'+'\x22,\x22asso.eu'+'.org\x22,\x22at.'+'eu.org\x22,\x22a'+'u.eu.org\x22,'+'\x22be.eu.org')+('\x22,\x22bg.eu.o'+'rg\x22,\x22ca.eu'+'.org\x22,\x22cd.'+'eu.org\x22,\x22c'+'h.eu.org\x22,'+'\x22cn.eu.org'+'\x22,\x22cy.eu.o'+'rg\x22,\x22cz.eu'+'.org\x22,\x22de.'+'eu.org\x22,\x22d'+'k.eu.org\x22,'+'\x22edu.eu.or'+'g\x22,\x22ee.eu.'+'org\x22,\x22es.e'+'u.org\x22,\x22fi'+'.eu.org\x22,\x22'+'fr.eu.org\x22'+',\x22gr.eu.or'+'g\x22,\x22hr.eu.'+'org\x22,\x22hu.e'+'u.org\x22,\x22ie'+'.eu.org\x22,\x22'+'il.eu.org\x22'+',\x22in.eu.or'+'g\x22,\x22int.eu'+'.org\x22,\x22is.'+'eu.org\x22,\x22i'+'t.eu.org\x22,'+'\x22jp.eu.org'+'\x22,\x22kr.eu.o'+'rg\x22,\x22lt.eu'+'.org\x22,\x22lu.'+'eu.org\x22,\x22l'+'v.eu.org\x22,'+'\x22mc.eu.org'+'\x22,\x22me.eu.o'+'rg\x22,\x22mk.eu'+'.org\x22,\x22mt.'+'eu.org\x22,\x22m'+'y.eu.org\x22,'+'\x22net.eu.or'+'g\x22,\x22ng.eu.'+'org\x22,\x22nl.e'+'u.org\x22,\x22no'+'.eu.org\x22,\x22'+'nz.eu.org\x22'+',\x22paris.eu'+'.org\x22,\x22pl.'+'eu.org\x22,\x22p'+'t.eu.org\x22,'+'\x22q-a.eu.or'+'g\x22,\x22ro.eu.'+'org\x22,\x22ru.e'+'u.org\x22,\x22se'+'.eu.org\x22,\x22'+'si.eu.org\x22'+',\x22sk.eu.or'+'g\x22,\x22tr.eu.'+'org\x22,\x22uk.e'+'u.org\x22,\x22us'+'.eu.org\x22,\x22'+'eu-1.evenn'+'ode.com\x22,\x22'+'eu-2.evenn'+'ode.com\x22,\x22'+'eu-3.evenn'+'ode.com\x22,\x22'+'eu-4.evenn'+'ode.com\x22,\x22'+'us-1.evenn'+'ode.com\x22,\x22'+'us-2.evenn'+'ode.com\x22,\x22'+'us-3.evenn'+'ode.com\x22,\x22'+'us-4.evenn'+'ode.com\x22,\x22'+'twmail.cc\x22'+',\x22twmail.n'+'et\x22,\x22twmai'+'l.org\x22,\x22my'+'mailer.com'+'.tw\x22,\x22url.'+'tw\x22,\x22apps.'+'fbsbx.com\x22'+',\x22ru.net\x22,'+'\x22adygeya.r'+'u\x22,\x22bashki'+'ria.ru\x22,\x22b'+'ir.ru\x22,\x22cb'+'g.ru\x22,\x22com'+'.ru\x22,\x22dage'+'stan.ru\x22,\x22'+'grozny.ru\x22'+',\x22kalmykia'+'.ru\x22,\x22kust'+'anai.ru\x22,\x22'+'marine.ru\x22'+',\x22mordovia'+'.ru\x22,\x22msk.')+('ru\x22,\x22mytis'+'.ru\x22,\x22nalc'+'hik.ru\x22,\x22n'+'ov.ru\x22,\x22py'+'atigorsk.r'+'u\x22,\x22spb.ru'+'\x22,\x22vladika'+'vkaz.ru\x22,\x22'+'vladimir.r'+'u\x22,\x22abkhaz'+'ia.su\x22,\x22ad'+'ygeya.su\x22,'+'\x22aktyubins'+'k.su\x22,\x22ark'+'hangelsk.s'+'u\x22,\x22armeni'+'a.su\x22,\x22ash'+'gabad.su\x22,'+'\x22azerbaija'+'n.su\x22,\x22bal'+'ashov.su\x22,'+'\x22bashkiria'+'.su\x22,\x22brya'+'nsk.su\x22,\x22b'+'ukhara.su\x22'+',\x22chimkent'+'.su\x22,\x22dage'+'stan.su\x22,\x22'+'east-kazak'+'hstan.su\x22,'+'\x22exnet.su\x22'+',\x22georgia.'+'su\x22,\x22grozn'+'y.su\x22,\x22iva'+'novo.su\x22,\x22'+'jambyl.su\x22'+',\x22kalmykia'+'.su\x22,\x22kalu'+'ga.su\x22,\x22ka'+'racol.su\x22,'+'\x22karaganda'+'.su\x22,\x22kare'+'lia.su\x22,\x22k'+'hakassia.s'+'u\x22,\x22krasno'+'dar.su\x22,\x22k'+'urgan.su\x22,'+'\x22kustanai.'+'su\x22,\x22lenug'+'.su\x22,\x22mang'+'yshlak.su\x22'+',\x22mordovia'+'.su\x22,\x22msk.'+'su\x22,\x22murma'+'nsk.su\x22,\x22n'+'alchik.su\x22'+',\x22navoi.su'+'\x22,\x22north-k'+'azakhstan.'+'su\x22,\x22nov.s'+'u\x22,\x22obnins'+'k.su\x22,\x22pen'+'za.su\x22,\x22po'+'krovsk.su\x22'+',\x22sochi.su'+'\x22,\x22spb.su\x22'+',\x22tashkent'+'.su\x22,\x22term'+'ez.su\x22,\x22to'+'gliatti.su'+'\x22,\x22troitsk'+'.su\x22,\x22tsel'+'inograd.su'+'\x22,\x22tula.su'+'\x22,\x22tuva.su'+'\x22,\x22vladika'+'vkaz.su\x22,\x22'+'vladimir.s'+'u\x22,\x22vologd'+'a.su\x22,\x22cha'+'nnelsdvr.n'+'et\x22,\x22u.cha'+'nnelsdvr.n'+'et\x22,\x22fastl'+'y-terrariu'+'m.com\x22,\x22fa'+'stlylb.net'+'\x22,\x22map.fas'+'tlylb.net\x22'+',\x22freetls.'+'fastly.net'+'\x22,\x22map.fas'+'tly.net\x22,\x22'+'a.prod.fas'+'tly.net\x22,\x22'+'global.pro'+'d.fastly.n'+'et\x22,\x22a.ssl'+'.fastly.ne'+'t\x22,\x22b.ssl.')+('fastly.net'+'\x22,\x22global.'+'ssl.fastly'+'.net\x22,\x22fas'+'tpanel.dir'+'ect\x22,\x22fast'+'vps-server'+'.com\x22,\x22fha'+'pp.xyz\x22,\x22f'+'edorainfra'+'cloud.org\x22'+',\x22fedorape'+'ople.org\x22,'+'\x22cloud.fed'+'oraproject'+'.org\x22,\x22app'+'.os.fedora'+'project.or'+'g\x22,\x22app.os'+'.stg.fedor'+'aproject.o'+'rg\x22,\x22mydob'+'iss.com\x22,\x22'+'filegear.m'+'e\x22,\x22filege'+'ar-au.me\x22,'+'\x22filegear-'+'de.me\x22,\x22fi'+'legear-gb.'+'me\x22,\x22fileg'+'ear-ie.me\x22'+',\x22filegear'+'-jp.me\x22,\x22f'+'ilegear-sg'+'.me\x22,\x22fire'+'baseapp.co'+'m\x22,\x22flynnh'+'ub.com\x22,\x22f'+'lynnhostin'+'g.net\x22,\x220e'+'.vc\x22,\x22free'+'box-os.com'+'\x22,\x22freebox'+'os.com\x22,\x22f'+'bx-os.fr\x22,'+'\x22fbxos.fr\x22'+',\x22freebox-'+'os.fr\x22,\x22fr'+'eeboxos.fr'+'\x22,\x22freedes'+'ktop.org\x22,'+'\x22*.futurec'+'ms.at\x22,\x22*.'+'ex.futurec'+'ms.at\x22,\x22*.'+'in.futurec'+'ms.at\x22,\x22fu'+'turehostin'+'g.at\x22,\x22fut'+'uremailing'+'.at\x22,\x22*.ex'+'.ortsinfo.'+'at\x22,\x22*.kun'+'den.ortsin'+'fo.at\x22,\x22*.'+'statics.cl'+'oud\x22,\x22serv'+'ice.gov.uk'+'\x22,\x22gehirn.'+'ne.jp\x22,\x22us'+'ercontent.'+'jp\x22,\x22genta'+'pps.com\x22,\x22'+'lab.ms\x22,\x22g'+'ithub.io\x22,'+'\x22githubuse'+'rcontent.c'+'om\x22,\x22gitla'+'b.io\x22,\x22gli'+'tch.me\x22,\x22l'+'olipop.io\x22'+',\x22cloudapp'+'s.digital\x22'+',\x22london.c'+'loudapps.d'+'igital\x22,\x22h'+'omeoffice.'+'gov.uk\x22,\x22r'+'o.im\x22,\x22sho'+'p.ro\x22,\x22goi'+'p.de\x22,\x22run'+'.app\x22,\x22a.r'+'un.app\x22,\x22w'+'eb.app\x22,\x22*'+'.0emm.com\x22'+',\x22appspot.'+'com\x22,\x22*.r.'+'appspot.co'+'m\x22,\x22blogsp'+'ot.ae\x22,\x22bl')+('ogspot.al\x22'+',\x22blogspot'+'.am\x22,\x22blog'+'spot.ba\x22,\x22'+'blogspot.b'+'e\x22,\x22blogsp'+'ot.bg\x22,\x22bl'+'ogspot.bj\x22'+',\x22blogspot'+'.ca\x22,\x22blog'+'spot.cf\x22,\x22'+'blogspot.c'+'h\x22,\x22blogsp'+'ot.cl\x22,\x22bl'+'ogspot.co.'+'at\x22,\x22blogs'+'pot.co.id\x22'+',\x22blogspot'+'.co.il\x22,\x22b'+'logspot.co'+'.ke\x22,\x22blog'+'spot.co.nz'+'\x22,\x22blogspo'+'t.co.uk\x22,\x22'+'blogspot.c'+'o.za\x22,\x22blo'+'gspot.com\x22'+',\x22blogspot'+'.com.ar\x22,\x22'+'blogspot.c'+'om.au\x22,\x22bl'+'ogspot.com'+'.br\x22,\x22blog'+'spot.com.b'+'y\x22,\x22blogsp'+'ot.com.co\x22'+',\x22blogspot'+'.com.cy\x22,\x22'+'blogspot.c'+'om.ee\x22,\x22bl'+'ogspot.com'+'.eg\x22,\x22blog'+'spot.com.e'+'s\x22,\x22blogsp'+'ot.com.mt\x22'+',\x22blogspot'+'.com.ng\x22,\x22'+'blogspot.c'+'om.tr\x22,\x22bl'+'ogspot.com'+'.uy\x22,\x22blog'+'spot.cv\x22,\x22'+'blogspot.c'+'z\x22,\x22blogsp'+'ot.de\x22,\x22bl'+'ogspot.dk\x22'+',\x22blogspot'+'.fi\x22,\x22blog'+'spot.fr\x22,\x22'+'blogspot.g'+'r\x22,\x22blogsp'+'ot.hk\x22,\x22bl'+'ogspot.hr\x22'+',\x22blogspot'+'.hu\x22,\x22blog'+'spot.ie\x22,\x22'+'blogspot.i'+'n\x22,\x22blogsp'+'ot.is\x22,\x22bl'+'ogspot.it\x22'+',\x22blogspot'+'.jp\x22,\x22blog'+'spot.kr\x22,\x22'+'blogspot.l'+'i\x22,\x22blogsp'+'ot.lt\x22,\x22bl'+'ogspot.lu\x22'+',\x22blogspot'+'.md\x22,\x22blog'+'spot.mk\x22,\x22'+'blogspot.m'+'r\x22,\x22blogsp'+'ot.mx\x22,\x22bl'+'ogspot.my\x22'+',\x22blogspot'+'.nl\x22,\x22blog'+'spot.no\x22,\x22'+'blogspot.p'+'e\x22,\x22blogsp'+'ot.pt\x22,\x22bl'+'ogspot.qa\x22'+',\x22blogspot'+'.re\x22,\x22blog'+'spot.ro\x22,\x22'+'blogspot.r'+'s\x22,\x22blogsp'+'ot.ru\x22,\x22bl'+'ogspot.se\x22'+',\x22blogspot'+'.sg\x22,\x22blog')+('spot.si\x22,\x22'+'blogspot.s'+'k\x22,\x22blogsp'+'ot.sn\x22,\x22bl'+'ogspot.td\x22'+',\x22blogspot'+'.tw\x22,\x22blog'+'spot.ug\x22,\x22'+'blogspot.v'+'n\x22,\x22cloudf'+'unctions.n'+'et\x22,\x22cloud'+'.goog\x22,\x22co'+'despot.com'+'\x22,\x22googlea'+'pis.com\x22,\x22'+'googlecode'+'.com\x22,\x22pag'+'espeedmobi'+'lizer.com\x22'+',\x22publishp'+'roxy.com\x22,'+'\x22withgoogl'+'e.com\x22,\x22wi'+'thyoutube.'+'com\x22,\x22awsm'+'ppl.com\x22,\x22'+'fin.ci\x22,\x22f'+'ree.hr\x22,\x22c'+'aa.li\x22,\x22ua'+'.rs\x22,\x22conf'+'.se\x22,\x22hs.z'+'one\x22,\x22hs.r'+'un\x22,\x22hashb'+'ang.sh\x22,\x22h'+'asura.app\x22'+',\x22hasura-a'+'pp.io\x22,\x22he'+'pforge.org'+'\x22,\x22herokua'+'pp.com\x22,\x22h'+'erokussl.c'+'om\x22,\x22myrav'+'endb.com\x22,'+'\x22ravendb.c'+'ommunity\x22,'+'\x22ravendb.m'+'e\x22,\x22develo'+'pment.run\x22'+',\x22ravendb.'+'run\x22,\x22bpl.'+'biz\x22,\x22orx.'+'biz\x22,\x22ng.c'+'ity\x22,\x22biz.'+'gl\x22,\x22ng.in'+'k\x22,\x22col.ng'+'\x22,\x22firm.ng'+'\x22,\x22gen.ng\x22'+',\x22ltd.ng\x22,'+'\x22ngo.ng\x22,\x22'+'ng.school\x22'+',\x22sch.so\x22,'+'\x22hkkinen.'+'fi\x22,\x22*.moo'+'nscale.io\x22'+',\x22moonscal'+'e.net\x22,\x22ik'+'i.fi\x22,\x22dyn'+'-berlin.de'+'\x22,\x22in-berl'+'in.de\x22,\x22in'+'-brb.de\x22,\x22'+'in-butter.'+'de\x22,\x22in-ds'+'l.de\x22,\x22in-'+'dsl.net\x22,\x22'+'in-dsl.org'+'\x22,\x22in-vpn.'+'de\x22,\x22in-vp'+'n.net\x22,\x22in'+'-vpn.org\x22,'+'\x22biz.at\x22,\x22'+'info.at\x22,\x22'+'info.cx\x22,\x22'+'ac.leg.br\x22'+',\x22al.leg.b'+'r\x22,\x22am.leg'+'.br\x22,\x22ap.l'+'eg.br\x22,\x22ba'+'.leg.br\x22,\x22'+'ce.leg.br\x22'+',\x22df.leg.b'+'r\x22,\x22es.leg'+'.br\x22,\x22go.l'+'eg.br\x22,\x22ma'+'.leg.br\x22,\x22'+'mg.leg.br\x22'+',\x22ms.leg.b'+'r\x22,\x22mt.leg'+'.br\x22,\x22pa.l')+('eg.br\x22,\x22pb'+'.leg.br\x22,\x22'+'pe.leg.br\x22'+',\x22pi.leg.b'+'r\x22,\x22pr.leg'+'.br\x22,\x22rj.l'+'eg.br\x22,\x22rn'+'.leg.br\x22,\x22'+'ro.leg.br\x22'+',\x22rr.leg.b'+'r\x22,\x22rs.leg'+'.br\x22,\x22sc.l'+'eg.br\x22,\x22se'+'.leg.br\x22,\x22'+'sp.leg.br\x22'+',\x22to.leg.b'+'r\x22,\x22pixoli'+'no.com\x22,\x22i'+'pifony.net'+'\x22,\x22mein-is'+'erv.de\x22,\x22t'+'est-iserv.'+'de\x22,\x22iserv'+'.dev\x22,\x22iob'+'b.net\x22,\x22my'+'jino.ru\x22,\x22'+'*.hosting.'+'myjino.ru\x22'+',\x22*.landin'+'g.myjino.r'+'u\x22,\x22*.spec'+'trum.myjin'+'o.ru\x22,\x22*.v'+'ps.myjino.'+'ru\x22,\x22*.tri'+'ton.zone\x22,'+'\x22*.cns.joy'+'ent.com\x22,\x22'+'js.org\x22,\x22k'+'aas.gg\x22,\x22k'+'hplay.nl\x22,'+'\x22keymachin'+'e.de\x22,\x22kin'+'ghost.net\x22'+',\x22uni5.net'+'\x22,\x22knightp'+'oint.syste'+'ms\x22,\x22oya.t'+'o\x22,\x22co.krd'+'\x22,\x22edu.krd'+'\x22,\x22git-rep'+'os.de\x22,\x22lc'+'ube-server'+'.de\x22,\x22svn-'+'repos.de\x22,'+'\x22leadpages'+'.co\x22,\x22lpag'+'es.co\x22,\x22lp'+'userconten'+'t.com\x22,\x22le'+'lux.site\x22,'+'\x22co.busine'+'ss\x22,\x22co.ed'+'ucation\x22,\x22'+'co.events\x22'+',\x22co.finan'+'cial\x22,\x22co.'+'network\x22,\x22'+'co.place\x22,'+'\x22co.techno'+'logy\x22,\x22app'+'.lmpm.com\x22'+',\x22linkitoo'+'ls.space\x22,'+'\x22linkyard.'+'cloud\x22,\x22li'+'nkyard-clo'+'ud.ch\x22,\x22me'+'mbers.lino'+'de.com\x22,\x22n'+'odebalance'+'r.linode.c'+'om\x22,\x22we.bs'+'\x22,\x22loginli'+'ne.app\x22,\x22l'+'oginline.d'+'ev\x22,\x22login'+'line.io\x22,\x22'+'loginline.'+'services\x22,'+'\x22loginline'+'.site\x22,\x22kr'+'asnik.pl\x22,'+'\x22leczna.pl'+'\x22,\x22lubarto'+'w.pl\x22,\x22lub'+'lin.pl\x22,\x22p'+'oniatowa.p'+'l\x22,\x22swidni'+'k.pl\x22,\x22ukl')+('ugs.org\x22,\x22'+'glug.org.u'+'k\x22,\x22lug.or'+'g.uk\x22,\x22lug'+'s.org.uk\x22,'+'\x22barsy.bg\x22'+',\x22barsy.co'+'.uk\x22,\x22bars'+'yonline.co'+'.uk\x22,\x22bars'+'ycenter.co'+'m\x22,\x22barsyo'+'nline.com\x22'+',\x22barsy.cl'+'ub\x22,\x22barsy'+'.de\x22,\x22bars'+'y.eu\x22,\x22bar'+'sy.in\x22,\x22ba'+'rsy.info\x22,'+'\x22barsy.io\x22'+',\x22barsy.me'+'\x22,\x22barsy.m'+'enu\x22,\x22bars'+'y.mobi\x22,\x22b'+'arsy.net\x22,'+'\x22barsy.onl'+'ine\x22,\x22bars'+'y.org\x22,\x22ba'+'rsy.pro\x22,\x22'+'barsy.pub\x22'+',\x22barsy.sh'+'op\x22,\x22barsy'+'.site\x22,\x22ba'+'rsy.suppor'+'t\x22,\x22barsy.'+'uk\x22,\x22*.mag'+'entosite.c'+'loud\x22,\x22may'+'first.info'+'\x22,\x22mayfirs'+'t.org\x22,\x22hb'+'.cldmail.r'+'u\x22,\x22minise'+'rver.com\x22,'+'\x22memset.ne'+'t\x22,\x22cloud.'+'metacentru'+'m.cz\x22,\x22cus'+'tom.metace'+'ntrum.cz\x22,'+'\x22flt.cloud'+'.muni.cz\x22,'+'\x22usr.cloud'+'.muni.cz\x22,'+'\x22meteorapp'+'.com\x22,\x22eu.'+'meteorapp.'+'com\x22,\x22co.p'+'l\x22,\x22azurec'+'ontainer.i'+'o\x22,\x22azurew'+'ebsites.ne'+'t\x22,\x22azure-'+'mobile.net'+'\x22,\x22cloudap'+'p.net\x22,\x22mo'+'zilla-iot.'+'org\x22,\x22bmoa'+'ttachments'+'.org\x22,\x22net'+'.ru\x22,\x22org.'+'ru\x22,\x22pp.ru'+'\x22,\x22ui.nabu'+'.casa\x22,\x22po'+'ny.club\x22,\x22'+'of.fashion'+'\x22,\x22on.fash'+'ion\x22,\x22of.f'+'ootball\x22,\x22'+'in.london\x22'+',\x22of.londo'+'n\x22,\x22for.me'+'n\x22,\x22and.mo'+'m\x22,\x22for.mo'+'m\x22,\x22for.on'+'e\x22,\x22for.sa'+'le\x22,\x22of.wo'+'rk\x22,\x22to.wo'+'rk\x22,\x22nctu.'+'me\x22,\x22bitba'+'lloon.com\x22'+',\x22netlify.'+'com\x22,\x224u.c'+'om\x22,\x22ngrok'+'.io\x22,\x22nh-s'+'erv.co.uk\x22'+',\x22nfshost.'+'com\x22,\x22dnsk'+'ing.ch\x22,\x22m'+'ypi.co\x22,\x22n')+('4t.co\x22,\x2200'+'1www.com\x22,'+'\x22ddnslive.'+'com\x22,\x22myip'+'host.com\x22,'+'\x22forumz.in'+'fo\x22,\x2216-b.'+'it\x22,\x2232-b.'+'it\x22,\x2264-b.'+'it\x22,\x22sound'+'cast.me\x22,\x22'+'tcp4.me\x22,\x22'+'dnsup.net\x22'+',\x22hicam.ne'+'t\x22,\x22now-dn'+'s.net\x22,\x22ow'+'nip.net\x22,\x22'+'vpndns.net'+'\x22,\x22dynserv'+'.org\x22,\x22now'+'-dns.org\x22,'+'\x22x443.pw\x22,'+'\x22now-dns.t'+'op\x22,\x22ntdll'+'.top\x22,\x22fre'+'eddns.us\x22,'+'\x22crafting.'+'xyz\x22,\x22zapt'+'o.xyz\x22,\x22ns'+'update.inf'+'o\x22,\x22nerdpo'+'l.ovh\x22,\x22bl'+'ogsyte.com'+'\x22,\x22brasili'+'a.me\x22,\x22cab'+'le-modem.o'+'rg\x22,\x22cisco'+'freak.com\x22'+',\x22collegef'+'an.org\x22,\x22c'+'ouchpotato'+'fries.org\x22'+',\x22damnserv'+'er.com\x22,\x22d'+'dns.me\x22,\x22d'+'itchyourip'+'.com\x22,\x22dns'+'for.me\x22,\x22d'+'nsiskinky.'+'com\x22,\x22dvrc'+'am.info\x22,\x22'+'dynns.com\x22'+',\x22eating-o'+'rganic.net'+'\x22,\x22fantasy'+'league.cc\x22'+',\x22geekgala'+'xy.com\x22,\x22g'+'olffan.us\x22'+',\x22health-c'+'arereform.'+'com\x22,\x22home'+'securityma'+'c.com\x22,\x22ho'+'mesecurity'+'pc.com\x22,\x22h'+'opto.me\x22,\x22'+'ilovecolle'+'ge.info\x22,\x22'+'loginto.me'+'\x22,\x22mlbfan.'+'org\x22,\x22mmaf'+'an.biz\x22,\x22m'+'yactivedir'+'ectory.com'+'\x22,\x22mydisse'+'nt.net\x22,\x22m'+'yeffect.ne'+'t\x22,\x22mymedi'+'apc.net\x22,\x22'+'mypsx.net\x22'+',\x22mysecuri'+'tycamera.c'+'om\x22,\x22mysec'+'uritycamer'+'a.net\x22,\x22my'+'securityca'+'mera.org\x22,'+'\x22net-freak'+'s.com\x22,\x22nf'+'lfan.org\x22,'+'\x22nhlfan.ne'+'t\x22,\x22no-ip.'+'ca\x22,\x22no-ip'+'.co.uk\x22,\x22n'+'o-ip.net\x22,'+'\x22noip.us\x22,'+'\x22onthewifi'+'.com\x22,\x22pga'+'fan.net\x22,\x22')+('point2this'+'.com\x22,\x22poi'+'ntto.us\x22,\x22'+'privatizeh'+'ealthinsur'+'ance.net\x22,'+'\x22quicksyte'+'s.com\x22,\x22re'+'ad-books.o'+'rg\x22,\x22secur'+'itytactics'+'.com\x22,\x22ser'+'veexchange'+'.com\x22,\x22ser'+'vehumour.c'+'om\x22,\x22serve'+'p2p.com\x22,\x22'+'servesarca'+'sm.com\x22,\x22s'+'tufftoread'+'.com\x22,\x22ufc'+'fan.org\x22,\x22'+'unusualper'+'son.com\x22,\x22'+'workisbori'+'ng.com\x22,\x223'+'utilities.'+'com\x22,\x22boun'+'ceme.net\x22,'+'\x22ddns.net\x22'+',\x22ddnsking'+'.com\x22,\x22got'+'dns.ch\x22,\x22h'+'opto.org\x22,'+'\x22myftp.biz'+'\x22,\x22myftp.o'+'rg\x22,\x22myvnc'+'.com\x22,\x22no-'+'ip.biz\x22,\x22n'+'o-ip.info\x22'+',\x22no-ip.or'+'g\x22,\x22noip.m'+'e\x22,\x22redire'+'ctme.net\x22,'+'\x22servebeer'+'.com\x22,\x22ser'+'veblog.net'+'\x22,\x22serveco'+'unterstrik'+'e.com\x22,\x22se'+'rveftp.com'+'\x22,\x22servega'+'me.com\x22,\x22s'+'ervehalfli'+'fe.com\x22,\x22s'+'ervehttp.c'+'om\x22,\x22serve'+'irc.com\x22,\x22'+'serveminec'+'raft.net\x22,'+'\x22servemp3.'+'com\x22,\x22serv'+'epics.com\x22'+',\x22servequa'+'ke.com\x22,\x22s'+'ytes.net\x22,'+'\x22webhop.me'+'\x22,\x22zapto.o'+'rg\x22,\x22stage'+'.nodeart.i'+'o\x22,\x22nodum.'+'co\x22,\x22nodum'+'.io\x22,\x22pclo'+'ud.host\x22,\x22'+'nyc.mn\x22,\x22n'+'om.ae\x22,\x22no'+'m.af\x22,\x22nom'+'.ai\x22,\x22nom.'+'al\x22,\x22nym.b'+'y\x22,\x22nom.bz'+'\x22,\x22nym.bz\x22'+',\x22nom.cl\x22,'+'\x22nym.ec\x22,\x22'+'nom.gd\x22,\x22n'+'om.ge\x22,\x22no'+'m.gl\x22,\x22nym'+'.gr\x22,\x22nom.'+'gt\x22,\x22nym.g'+'y\x22,\x22nym.hk'+'\x22,\x22nom.hn\x22'+',\x22nym.ie\x22,'+'\x22nom.im\x22,\x22'+'nom.ke\x22,\x22n'+'ym.kz\x22,\x22ny'+'m.la\x22,\x22nym'+'.lc\x22,\x22nom.'+'li\x22,\x22nym.l'+'i\x22,\x22nym.lt'+'\x22,\x22nym.lu\x22'+',\x22nom.lv\x22,')+('\x22nym.me\x22,\x22'+'nom.mk\x22,\x22n'+'ym.mn\x22,\x22ny'+'m.mx\x22,\x22nom'+'.nu\x22,\x22nym.'+'nz\x22,\x22nym.p'+'e\x22,\x22nym.pt'+'\x22,\x22nom.pw\x22'+',\x22nom.qa\x22,'+'\x22nym.ro\x22,\x22'+'nom.rs\x22,\x22n'+'om.si\x22,\x22ny'+'m.sk\x22,\x22nom'+'.st\x22,\x22nym.'+'su\x22,\x22nym.s'+'x\x22,\x22nom.tj'+'\x22,\x22nym.tw\x22'+',\x22nom.ug\x22,'+'\x22nom.uy\x22,\x22'+'nom.vc\x22,\x22n'+'om.vg\x22,\x22st'+'atic.obser'+'vableuserc'+'ontent.com'+'\x22,\x22cya.gg\x22'+',\x22cloudycl'+'uster.net\x22'+',\x22nid.io\x22,'+'\x22opencraft'+'.hosting\x22,'+'\x22operaunit'+'e.com\x22,\x22sk'+'ygearapp.c'+'om\x22,\x22outsy'+'stemscloud'+'.com\x22,\x22own'+'provider.c'+'om\x22,\x22own.p'+'m\x22,\x22ox.rs\x22'+',\x22oy.lc\x22,\x22'+'pgfog.com\x22'+',\x22pagefron'+'tapp.com\x22,'+'\x22art.pl\x22,\x22'+'gliwice.pl'+'\x22,\x22krakow.'+'pl\x22,\x22pozna'+'n.pl\x22,\x22wro'+'c.pl\x22,\x22zak'+'opane.pl\x22,'+'\x22pantheons'+'ite.io\x22,\x22g'+'otpantheon'+'.com\x22,\x22myp'+'ep.link\x22,\x22'+'perspecta.'+'cloud\x22,\x22on'+'-web.fr\x22,\x22'+'*.platform'+'.sh\x22,\x22*.pl'+'atformsh.s'+'ite\x22,\x22dyn5'+'3.io\x22,\x22co.'+'bn\x22,\x22xen.p'+'rgmr.com\x22,'+'\x22priv.at\x22,'+'\x22prvcy.pag'+'e\x22,\x22*.dweb'+'.link\x22,\x22pr'+'otonet.io\x22'+',\x22chirurgi'+'ens-dentis'+'tes-en-fra'+'nce.fr\x22,\x22b'+'yen.site\x22,'+'\x22pubtls.or'+'g\x22,\x22qualif'+'ioapp.com\x22'+',\x22qbuser.c'+'om\x22,\x22insta'+'ntcloud.cn'+'\x22,\x22ras.ru\x22'+',\x22qa2.com\x22'+',\x22qcx.io\x22,'+'\x22*.sys.qcx'+'.io\x22,\x22dev-'+'myqnapclou'+'d.com\x22,\x22al'+'pha-myqnap'+'cloud.com\x22'+',\x22myqnapcl'+'oud.com\x22,\x22'+'*.quipelem'+'ents.com\x22,'+'\x22vapor.clo'+'ud\x22,\x22vapor'+'cloud.io\x22,'+'\x22rackmaze.'+'com\x22,\x22rack'+'maze.net\x22,')+('\x22*.on-k3s.'+'io\x22,\x22*.on-'+'rancher.cl'+'oud\x22,\x22*.on'+'-rio.io\x22,\x22'+'readthedoc'+'s.io\x22,\x22rhc'+'loud.com\x22,'+'\x22app.rende'+'r.com\x22,\x22on'+'render.com'+'\x22,\x22repl.co'+'\x22,\x22repl.ru'+'n\x22,\x22resind'+'evice.io\x22,'+'\x22devices.r'+'esinstagin'+'g.io\x22,\x22hzc'+'.io\x22,\x22well'+'beingzone.'+'eu\x22,\x22ptplu'+'s.fit\x22,\x22we'+'llbeingzon'+'e.co.uk\x22,\x22'+'git-pages.'+'rit.edu\x22,\x22'+'sandcats.i'+'o\x22,\x22logoip'+'.de\x22,\x22logo'+'ip.com\x22,\x22s'+'chokokeks.'+'net\x22,\x22gov.'+'scot\x22,\x22scr'+'ysec.com\x22,'+'\x22firewall-'+'gateway.co'+'m\x22,\x22firewa'+'ll-gateway'+'.de\x22,\x22my-g'+'ateway.de\x22'+',\x22my-route'+'r.de\x22,\x22spd'+'ns.de\x22,\x22sp'+'dns.eu\x22,\x22f'+'irewall-ga'+'teway.net\x22'+',\x22my-firew'+'all.org\x22,\x22'+'myfirewall'+'.org\x22,\x22spd'+'ns.org\x22,\x22s'+'enseering.'+'net\x22,\x22biz.'+'ua\x22,\x22co.ua'+'\x22,\x22pp.ua\x22,'+'\x22shiftedit'+'.io\x22,\x22mysh'+'opblocks.c'+'om\x22,\x22shopi'+'tsite.com\x22'+',\x22mo-sieme'+'ns.io\x22,\x221k'+'app.com\x22,\x22'+'appchizi.c'+'om\x22,\x22appli'+'nzi.com\x22,\x22'+'sinaapp.co'+'m\x22,\x22vipsin'+'aapp.com\x22,'+'\x22siteleaf.'+'net\x22,\x22boun'+'ty-full.co'+'m\x22,\x22alpha.'+'bounty-ful'+'l.com\x22,\x22be'+'ta.bounty-'+'full.com\x22,'+'\x22stackhero'+'-network.c'+'om\x22,\x22stati'+'c.land\x22,\x22d'+'ev.static.'+'land\x22,\x22sit'+'es.static.'+'land\x22,\x22app'+'s.lair.io\x22'+',\x22*.stolos'+'.io\x22,\x22spac'+'ekit.io\x22,\x22'+'customer.s'+'peedpartne'+'r.de\x22,\x22api'+'.stdlib.co'+'m\x22,\x22storj.'+'farm\x22,\x22utw'+'ente.io\x22,\x22'+'soc.srcf.n'+'et\x22,\x22user.'+'srcf.net\x22,'+'\x22temp-dns.')+('com\x22,\x22appl'+'icationclo'+'ud.io\x22,\x22sc'+'app.io\x22,\x22*'+'.s5y.io\x22,\x22'+'*.sensiosi'+'te.cloud\x22,'+'\x22syncloud.'+'it\x22,\x22disks'+'tation.me\x22'+',\x22dscloud.'+'biz\x22,\x22dscl'+'oud.me\x22,\x22d'+'scloud.mob'+'i\x22,\x22dsmyna'+'s.com\x22,\x22ds'+'mynas.net\x22'+',\x22dsmynas.'+'org\x22,\x22fami'+'lyds.com\x22,'+'\x22familyds.'+'net\x22,\x22fami'+'lyds.org\x22,'+'\x22i234.me\x22,'+'\x22myds.me\x22,'+'\x22synology.'+'me\x22,\x22vpnpl'+'us.to\x22,\x22di'+'rect.quick'+'connect.to'+'\x22,\x22taifun-'+'dns.de\x22,\x22g'+'da.pl\x22,\x22gd'+'ansk.pl\x22,\x22'+'gdynia.pl\x22'+',\x22med.pl\x22,'+'\x22sopot.pl\x22'+',\x22edugit.o'+'rg\x22,\x22teleb'+'it.app\x22,\x22t'+'elebit.io\x22'+',\x22*.telebi'+'t.xyz\x22,\x22gw'+'iddle.co.u'+'k\x22,\x22thingd'+'ustdata.co'+'m\x22,\x22cust.d'+'ev.thingdu'+'st.io\x22,\x22cu'+'st.disrec.'+'thingdust.'+'io\x22,\x22cust.'+'prod.thing'+'dust.io\x22,\x22'+'cust.testi'+'ng.thingdu'+'st.io\x22,\x22ar'+'vo.network'+'\x22,\x22azimuth'+'.network\x22,'+'\x22bloxcms.c'+'om\x22,\x22townn'+'ews-stagin'+'g.com\x22,\x2212'+'hp.at\x22,\x222i'+'x.at\x22,\x224li'+'ma.at\x22,\x22li'+'ma-city.at'+'\x22,\x2212hp.ch'+'\x22,\x222ix.ch\x22'+',\x224lima.ch'+'\x22,\x22lima-ci'+'ty.ch\x22,\x22tr'+'afficplex.'+'cloud\x22,\x22de'+'.cool\x22,\x2212'+'hp.de\x22,\x222i'+'x.de\x22,\x224li'+'ma.de\x22,\x22li'+'ma-city.de'+'\x22,\x221337.pi'+'ctures\x22,\x22c'+'lan.rip\x22,\x22'+'lima-city.'+'rocks\x22,\x22we'+'bspace.roc'+'ks\x22,\x22lima.'+'zone\x22,\x22*.t'+'ransurl.be'+'\x22,\x22*.trans'+'url.eu\x22,\x22*'+'.transurl.'+'nl\x22,\x22tuxfa'+'mily.org\x22,'+'\x22dd-dns.de'+'\x22,\x22disksta'+'tion.eu\x22,\x22'+'diskstatio'+'n.org\x22,\x22dr'+'ay-dns.de\x22')+(',\x22draydns.'+'de\x22,\x22dyn-v'+'pn.de\x22,\x22dy'+'nvpn.de\x22,\x22'+'mein-vigor'+'.de\x22,\x22my-v'+'igor.de\x22,\x22'+'my-wan.de\x22'+',\x22syno-ds.'+'de\x22,\x22synol'+'ogy-diskst'+'ation.de\x22,'+'\x22synology-'+'ds.de\x22,\x22ub'+'er.space\x22,'+'\x22*.uberspa'+'ce.de\x22,\x22hk'+'.com\x22,\x22hk.'+'org\x22,\x22ltd.'+'hk\x22,\x22inc.h'+'k\x22,\x22virtua'+'luser.de\x22,'+'\x22virtual-u'+'ser.de\x22,\x22u'+'rown.cloud'+'\x22,\x22dnsupda'+'te.info\x22,\x22'+'lib.de.us\x22'+',\x222038.io\x22'+',\x22router.m'+'anagement\x22'+',\x22v-info.i'+'nfo\x22,\x22voor'+'loper.clou'+'d\x22,\x22v.ua\x22,'+'\x22wafflecel'+'l.com\x22,\x22*.'+'webhare.de'+'v\x22,\x22wedepl'+'oy.io\x22,\x22we'+'deploy.me\x22'+',\x22wedeploy'+'.sh\x22,\x22remo'+'tewd.com\x22,'+'\x22wmflabs.o'+'rg\x22,\x22myfor'+'um.communi'+'ty\x22,\x22commu'+'nity-pro.d'+'e\x22,\x22diskus'+'sionsberei'+'ch.de\x22,\x22co'+'mmunity-pr'+'o.net\x22,\x22me'+'inforum.ne'+'t\x22,\x22half.h'+'ost\x22,\x22xnba'+'y.com\x22,\x22u2'+'.xnbay.com'+'\x22,\x22u2-loca'+'l.xnbay.co'+'m\x22,\x22cistro'+'n.nl\x22,\x22dem'+'on.nl\x22,\x22xs'+'4all.space'+'\x22,\x22yandexc'+'loud.net\x22,'+'\x22storage.y'+'andexcloud'+'.net\x22,\x22web'+'site.yande'+'xcloud.net'+'\x22,\x22officia'+'l.academy\x22'+',\x22yolasite'+'.com\x22,\x22ybo'+'.faith\x22,\x22y'+'ombo.me\x22,\x22'+'homelink.o'+'ne\x22,\x22ybo.p'+'arty\x22,\x22ybo'+'.review\x22,\x22'+'ybo.scienc'+'e\x22,\x22ybo.tr'+'ade\x22,\x22noho'+'st.me\x22,\x22no'+'ho.st\x22,\x22za'+'.net\x22,\x22za.'+'org\x22,\x22now.'+'sh\x22,\x22bss.d'+'esign\x22,\x22ba'+'sicserver.'+'io\x22,\x22virtu'+'alserver.i'+'o\x22,\x22enterp'+'risecloud.'+'nu\x22]'));}},_0x2ab68f={};function _0xf95e82(_0x22d292){var _0x5e5f08=_0x2ab68f[_0x22d292];if(void(-0x1daa+0x9e4*0x2+0x73*0x16)!==_0x5e5f08)return _0x5e5f08['exports'];var _0x3d559d=_0x2ab68f[_0x22d292]={'exports':{}};return _0x25c6d4[_0x22d292]['call'](_0x3d559d['exports'],_0x3d559d,_0x3d559d['exports'],_0xf95e82),_0x3d559d['exports'];}_0xf95e82['d']=(_0x4b6519,_0xce5f6e)=>{for(var _0x142d0c in _0xce5f6e)_0xf95e82['o'](_0xce5f6e,_0x142d0c)&&!_0xf95e82['o'](_0x4b6519,_0x142d0c)&&Object['defineProp'+'erty'](_0x4b6519,_0x142d0c,{'enumerable':!(0x198b+0x59e+-0x1*0x1f29),'get':_0xce5f6e[_0x142d0c]});},_0xf95e82['o']=(_0x148dbb,_0x3f3c97)=>Object['prototype']['hasOwnProp'+'erty']['call'](_0x148dbb,_0x3f3c97),_0xf95e82['r']=_0x151206=>{'undefined'!=typeof Symbol&&Symbol['toStringTa'+'g']&&Object['defineProp'+'erty'](_0x151206,Symbol['toStringTa'+'g'],{'value':'Module'}),Object['defineProp'+'erty'](_0x151206,'__esModule',{'value':!(-0x4*-0x62+0x133c+-0x14c4)});};var _0x4bbd44=_0xf95e82(0x1d3a+0x3b3f+-0x3171);module['exports']=_0x4bbd44;})());

/***/ }),

/***/ "./src/mvm/impl/MVM.js":
/*!*****************************!*\
  !*** ./src/mvm/impl/MVM.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

((()=>{'use strict';var _0x2216b1={0x2ae:function(_0x5a21df,_0x29eed8,_0x228c46){var _0x5c9687=this&&this['__createBi'+'nding']||(Object['create']?function(_0x21132e,_0xda7c28,_0x51266c,_0x3335f0){void(-0x672+0x1*-0xaca+0x1*0x113c)===_0x3335f0&&(_0x3335f0=_0x51266c);var _0x270415=Object['getOwnProp'+'ertyDescri'+'ptor'](_0xda7c28,_0x51266c);_0x270415&&!('get'in _0x270415?!_0xda7c28['__esModule']:_0x270415['writable']||_0x270415['configurab'+'le'])||(_0x270415={'enumerable':!(0x17b1+-0x6f2+-0x3*0x595),'get':function(){return _0xda7c28[_0x51266c];}}),Object['defineProp'+'erty'](_0x21132e,_0x3335f0,_0x270415);}:function(_0x47dee9,_0x3d37c5,_0x243943,_0x586c84){void(0x252b+0x110*-0x1f+0x1*-0x43b)===_0x586c84&&(_0x586c84=_0x243943),_0x47dee9[_0x586c84]=_0x3d37c5[_0x243943];}),_0xdd452b=this&&this['__exportSt'+'ar']||function(_0xda2027,_0x33a3fd){for(var _0x56f8bb in _0xda2027)'default'===_0x56f8bb||Object['prototype']['hasOwnProp'+'erty']['call'](_0x33a3fd,_0x56f8bb)||_0x5c9687(_0x33a3fd,_0xda2027,_0x56f8bb);},_0x3f2b80=this&&this['__awaiter']||function(_0x1fbbd1,_0x5c9c68,_0x19dff8,_0x190bbd){return new(_0x19dff8||(_0x19dff8=Promise))(function(_0x17d8e7,_0x58b079){function _0x5f8c6f(_0x5b87ce){try{_0x132007(_0x190bbd['next'](_0x5b87ce));}catch(_0xdceee1){_0x58b079(_0xdceee1);}}function _0x2d9bc1(_0x1ac5cd){try{_0x132007(_0x190bbd['throw'](_0x1ac5cd));}catch(_0x47146e){_0x58b079(_0x47146e);}}function _0x132007(_0x34a9ba){var _0x4905c8;_0x34a9ba['done']?_0x17d8e7(_0x34a9ba['value']):(_0x4905c8=_0x34a9ba['value'],_0x4905c8 instanceof _0x19dff8?_0x4905c8:new _0x19dff8(function(_0xb1ed7c){_0xb1ed7c(_0x4905c8);}))['then'](_0x5f8c6f,_0x2d9bc1);}_0x132007((_0x190bbd=_0x190bbd['apply'](_0x1fbbd1,_0x5c9c68||[]))['next']());});},_0x561905=this&&this['__importDe'+'fault']||function(_0x22596c){return _0x22596c&&_0x22596c['__esModule']?_0x22596c:{'default':_0x22596c};};Object['defineProp'+'erty'](_0x29eed8,'__esModule',{'value':!(0x1edc+-0x154c+0x330*-0x3)}),_0x29eed8['MatlabStat'+'e']=void(-0x1908+0xfc2+0x2*0x4a3);const _0xf8f572=_0x561905(_0x228c46(0x1*0xe09+-0x69*-0x51+-0x2b9b)),_0x4d53c4=_0x561905(_0x228c46(0xf42+-0x2306+0x174e)),_0x163b6d=_0x561905(_0x228c46(0x1e6b+-0x1*-0x1981+0x361c*-0x1)),_0x5ab2de=_0x228c46(-0x1*-0x1ba2+0x2412+0x3b*-0x113),_0x1ba8a0=_0x561905(_0x228c46(0x1*0xd13+-0x184f+0xca5));var _0x289d32;_0xdd452b(_0x228c46(-0x2bd*0x7+-0x2146+0x34c4),_0x29eed8),function(_0x389779){_0x389779['DISCONNECT'+'ED']='disconnect'+'ed',_0x389779['READY']='ready',_0x389779['BUSY']='busy';}(_0x289d32=_0x29eed8['MatlabStat'+'e']||(_0x29eed8['MatlabStat'+'e']={}));class _0x11289a extends _0x1ba8a0['default']{constructor(_0xb1bf19){super(),this['_lifecycle'+'Manager']=_0xb1bf19,this['_lifecycle'+'Manager']['eventEmitt'+'er']['on']('connected',this['_handleMat'+'labConnect'+'ed']['bind'](this)),this['_lifecycle'+'Manager']['eventEmitt'+'er']['on']('disconnect'+'ed',this['_handleMat'+'labDisconn'+'ected']['bind'](this));}['eval'](_0x31ef6f,_0x35fa30=!(-0x10b0+-0x2f*0x43+0x1cfd),_0x597944){return this['_mvmImpl']?this['_mvmImpl']['eval'](_0x31ef6f,_0x35fa30,_0x597944):Promise['reject']();}['feval'](_0x10a357,_0x1b6e7f,_0x45a372,_0x53f81e){return this['_mvmImpl']?this['_mvmImpl']['feval'](_0x10a357,_0x1b6e7f,_0x45a372,_0x53f81e):Promise['reject']();}['setBreakpo'+'int'](_0x4b6fb7,_0x319ff7,_0x9401a0,_0x27fa3a){return this['_mvmImpl']?this['_mvmImpl']['setBreakpo'+'int'](_0x4b6fb7,_0x319ff7,_0x9401a0,_0x27fa3a):Promise['reject']();}['clearBreak'+'point'](_0x5ce6e3,_0x3afd82,_0x59112c,_0x12aa75){return this['_mvmImpl']?this['_mvmImpl']['clearBreak'+'point'](_0x5ce6e3,_0x3afd82,_0x59112c,_0x12aa75):Promise['reject']();}['unpause'](){var _0x577f22;null===(_0x577f22=this['_mvmImpl'])||void(-0x26f5+-0x1*-0xf7c+0x7d3*0x3)===_0x577f22||_0x577f22['unpause']();}['interrupt'](){var _0x17e689;null===(_0x17e689=this['_mvmImpl'])||void(-0x21d0+-0x146b+0x363b)===_0x17e689||_0x17e689['interrupt']();}['getMatlabR'+'elease'](){var _0x2f4621;return null!==(_0x2f4621=this['_lifecycle'+'Manager']['getMatlabR'+'elease']())&&void(-0x7d*-0x1+-0x22dc+0x225f)!==_0x2f4621?_0x2f4621:null;}['_handleMat'+'labDisconn'+'ected'](){this['_mvmImpl']&&this['_mvmImpl']['detach'](),this['_mvmImpl']=void(-0x1001+0x205d*0x1+-0x105c),this['emit'](_0x5ab2de['IMVM']['Events']['stateChang'+'e'],_0x289d32['DISCONNECT'+'ED'],void(-0x1cb1+0x10e*-0xf+0x5*0x8e7));}['_handleMat'+'labConnect'+'ed'](){this['_tryAttach']();}['_tryAttach'](){this['_readyProm'+'ise']=this['_detectImp'+'l'](),this['_readyProm'+'ise']['then'](this['_handleRea'+'dy']['bind'](this),this['_handleRea'+'dyError']['bind'](this));}['_handleRea'+'dy'](){if(!this['_mvmImpl'])throw'MVMImpl\x20no'+'t\x20set';this['_mvmImpl']['on'](_0x5ab2de['IMVM']['Events']['output'],this['emit']['bind'](this,_0x5ab2de['IMVM']['Events']['output'])),this['_mvmImpl']['on'](_0x5ab2de['IMVM']['Events']['clc'],this['emit']['bind'](this,_0x5ab2de['IMVM']['Events']['clc'])),this['_mvmImpl']['on'](_0x5ab2de['IMVM']['Events']['promptChan'+'ge'],this['emit']['bind'](this,_0x5ab2de['IMVM']['Events']['promptChan'+'ge'])),this['emit'](_0x5ab2de['IMVM']['Events']['stateChang'+'e'],_0x289d32['READY'],this['_lifecycle'+'Manager']['getMatlabR'+'elease']()),this['_setupDebu'+'ggerListen'+'ers']();}['_handleRea'+'dyError'](){}['_detectImp'+'lBasedOnTi'+'meout'](){return _0x3f2b80(this,void(-0x2306+-0x1bde+0x3ee4),void(0xf50+0x1375+0xb97*-0x3),function*(){const _0x5e6ab2=new _0x4d53c4['default'](this['_lifecycle'+'Manager']);let _0x522664=yield _0x5e6ab2['tryAttach']();if(_0x522664)return void(this['_mvmImpl']=_0x5e6ab2);const _0x2e25c2=new _0x163b6d['default'](this['_lifecycle'+'Manager']);if(_0x522664=yield _0x2e25c2['tryAttach'](),!_0x522664)throw'Unable\x20to\x20'+'attach\x20to\x20'+'MATLAB\x20MVM';this['_mvmImpl']=_0x2e25c2;});}['_detectImp'+'l'](){return _0x3f2b80(this,void(0x10e0+-0x12d4+-0x1*-0x1f4),void(-0x15f7+-0xf*0x61+0x1ba6),function*(){const _0x1c9770=this['_lifecycle'+'Manager']['getMatlabR'+'elease']();if(null===_0x1c9770)return this['_detectImp'+'lBasedOnTi'+'meout']();const _0x197ea9=_0x1c9770['match'](/^R20([0-9]{2}[ab])$/);if(null==_0x197ea9)return this['_detectImp'+'lBasedOnTi'+'meout']();const _0x5861d8=_0x197ea9[0x150b+0x240b+-0x3915];switch(_0x5861d8){case'21a':case'21b':{const _0x2f199d=new _0x163b6d['default'](this['_lifecycle'+'Manager']);if(yield _0x2f199d['tryAttach'](_0x5861d8))return void(this['_mvmImpl']=_0x2f199d);}break;case'22a':{const _0xb39787=new _0x4d53c4['default'](this['_lifecycle'+'Manager']);if(yield _0xb39787['tryAttach'](_0x5861d8))return void(this['_mvmImpl']=_0xb39787);}break;default:{const _0xbd4ecc=new _0xf8f572['default'](this['_lifecycle'+'Manager']);if(yield _0xbd4ecc['tryAttach'](_0x5861d8))return void(this['_mvmImpl']=_0xbd4ecc);}}return this['_detectImp'+'lBasedOnTi'+'meout']();});}['_setupDebu'+'ggerListen'+'ers'](){return _0x3f2b80(this,void(0x15bd*0x1+0x27b+0x14*-0x136),void(0x11*0x21f+0x1b01*0x1+-0x3f10),function*(){const _0x3ab3a2=yield this['_lifecycle'+'Manager']['getMatlabC'+'onnection']();_0x3ab3a2&&(this['_setupDebu'+'gListener'](_0x3ab3a2,'EnterDebug'+'gerEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'EnterDebug'+'gerWithWar'+'ningEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'ContinueEx'+'ecutionEve'+'nt'),this['_setupDebu'+'gListener'](_0x3ab3a2,'ExitDebugg'+'erEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'ChangeCurr'+'entWorkspa'+'ceEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'AddLineNum'+'berBreakpo'+'intEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'DeleteLine'+'NumberBrea'+'kpointEven'+'t'),this['_setupDebu'+'gListener'](_0x3ab3a2,'DeleteAllB'+'reakpoints'+'Event'),this['_setupDebu'+'gListener'](_0x3ab3a2,'AddProgram'+'WideBreakp'+'ointEvent'),this['_setupDebu'+'gListener'](_0x3ab3a2,'DeleteProg'+'ramWideBre'+'akpointEve'+'nt'));});}['_setupDebu'+'gListener'](_0x17a814,_0x559358){_0x17a814['subscribe']('/eventmgr/'+'1/::MathWo'+'rks::Execu'+'tionEvents'+'::'+_0x559358,_0x3ee63f=>{this['emit'](_0x559358,_0x3ee63f);});}}_0x29eed8['default']=_0x11289a;},0x1d0:function(_0x1f240d,_0xa87e41,_0x1fa6e7){var _0x2773d1=this&&this['__createBi'+'nding']||(Object['create']?function(_0x5c1411,_0x136411,_0x26e0ee,_0x410368){void(-0x404*-0x4+-0x10c*0xc+-0x70*0x8)===_0x410368&&(_0x410368=_0x26e0ee);var _0x5a2e67=Object['getOwnProp'+'ertyDescri'+'ptor'](_0x136411,_0x26e0ee);_0x5a2e67&&!('get'in _0x5a2e67?!_0x136411['__esModule']:_0x5a2e67['writable']||_0x5a2e67['configurab'+'le'])||(_0x5a2e67={'enumerable':!(0x16aa+-0x1f09*0x1+-0x1*-0x85f),'get':function(){return _0x136411[_0x26e0ee];}}),Object['defineProp'+'erty'](_0x5c1411,_0x410368,_0x5a2e67);}:function(_0x4c28ad,_0x3a0c16,_0x5d7021,_0x179ea6){void(0x7*0x3e5+0x22c6+-0x3e09)===_0x179ea6&&(_0x179ea6=_0x5d7021),_0x4c28ad[_0x179ea6]=_0x3a0c16[_0x5d7021];}),_0x5fd836=this&&this['__setModul'+'eDefault']||(Object['create']?function(_0x15b2f6,_0x42e659){Object['defineProp'+'erty'](_0x15b2f6,'default',{'enumerable':!(-0x1d33+-0x66a+-0x239d*-0x1),'value':_0x42e659});}:function(_0x26ef9b,_0x1247ab){_0x26ef9b['default']=_0x1247ab;}),_0x5dd22d=this&&this['__importSt'+'ar']||function(_0x216091){if(_0x216091&&_0x216091['__esModule'])return _0x216091;var _0x1467ee={};if(null!=_0x216091){for(var _0x5d61c4 in _0x216091)'default'!==_0x5d61c4&&Object['prototype']['hasOwnProp'+'erty']['call'](_0x216091,_0x5d61c4)&&_0x2773d1(_0x1467ee,_0x216091,_0x5d61c4);}return _0x5fd836(_0x1467ee,_0x216091),_0x1467ee;},_0x1aad03=this&&this['__awaiter']||function(_0x534a2e,_0x1fd0d6,_0x1e7c0f,_0x3bbd62){return new(_0x1e7c0f||(_0x1e7c0f=Promise))(function(_0xa1a08b,_0x46e93f){function _0x26f5dc(_0x1481bc){try{_0x771ecc(_0x3bbd62['next'](_0x1481bc));}catch(_0x4e1d15){_0x46e93f(_0x4e1d15);}}function _0x40ceff(_0x1b0833){try{_0x771ecc(_0x3bbd62['throw'](_0x1b0833));}catch(_0x16dc6d){_0x46e93f(_0x16dc6d);}}function _0x771ecc(_0x4e592b){var _0x198a7d;_0x4e592b['done']?_0xa1a08b(_0x4e592b['value']):(_0x198a7d=_0x4e592b['value'],_0x198a7d instanceof _0x1e7c0f?_0x198a7d:new _0x1e7c0f(function(_0x5ae4cd){_0x5ae4cd(_0x198a7d);}))['then'](_0x26f5dc,_0x40ceff);}_0x771ecc((_0x3bbd62=_0x3bbd62['apply'](_0x534a2e,_0x1fd0d6||[]))['next']());});};Object['defineProp'+'erty'](_0xa87e41,'__esModule',{'value':!(-0x777*0x3+-0x2*0x3c3+0x1deb)});const _0x1a74fc=_0x5dd22d(_0x1fa6e7(-0x43f+-0x139*-0x7+-0x44d)),_0x157de8=_0x1fa6e7(0xce7+-0x4b1+-0x81c),_0x108488=_0x1fa6e7(-0x1693*-0x1+0x11b1*-0x1+-0x48f);class _0x5540db extends _0x1a74fc['default']{constructor(_0x344276){super(),this['_currentRe'+'questId']=-0x25dd+-0x185*-0x5+0x1e44,this['_eventSubs'+'criptions']={},this['_lifecycle'+'Manager']=_0x344276;}['_getChanne'+'l'](_0x3d20e6,..._0x291662){switch(_0x3d20e6){case _0x1a74fc['MessageTyp'+'e']['ATTACH']:return'/mvm/attac'+'h';case _0x1a74fc['MessageTyp'+'e']['ATTACH_RES'+'PONSE']:return'/mvm/attac'+'h/response'+'/'+_0x291662[0x8d*-0x1a+-0x1a73+0x15*0x1f1];case _0x1a74fc['MessageTyp'+'e']['EVAL_REQUE'+'ST']:return'/mvm/reque'+'st/eval';case _0x1a74fc['MessageTyp'+'e']['FEVAL_REQU'+'EST']:return'/mvm/reque'+'st/feval';case _0x1a74fc['MessageTyp'+'e']['CANCEL']:return'/mvm/cance'+'l';case _0x1a74fc['MessageTyp'+'e']['EVAL_FEVAL'+'_RESPONSE']:return'/mvm/respo'+'nse/'+this['_attachId'];case _0x1a74fc['MessageTyp'+'e']['OUTPUT']:return'/mvm/outpu'+'t/'+this['_attachId'];case _0x1a74fc['MessageTyp'+'e']['ERROR_OUTP'+'UT']:return'/mvm/error'+'/'+this['_attachId'];case _0x1a74fc['MessageTyp'+'e']['CLC']:return'/matlabls/'+'events/clc';case _0x1a74fc['MessageTyp'+'e']['EVENT_FIRE'+'D']:return'/mvm/event'+'Mgr/event/'+this['_attachId'];case _0x1a74fc['MessageTyp'+'e']['EVENT_SUBS'+'CRIBE']:return'/mvm/event'+'Mgr/reques'+'t';case _0x1a74fc['MessageTyp'+'e']['EVENT_SUBS'+'CRIBED']:return'/mvm/event'+'Mgr/respon'+'se/'+this['_attachId'];case _0x1a74fc['MessageTyp'+'e']['SET_BREAKP'+'OINT_REQUE'+'ST']:case _0x1a74fc['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_REQ'+'UEST']:case _0x1a74fc['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_RES'+'PONSE']:case _0x1a74fc['MessageTyp'+'e']['SET_BREAKP'+'OINT_RESPO'+'NSE']:case _0x1a74fc['MessageTyp'+'e']['EVAL_RESPO'+'NSE']:case _0x1a74fc['MessageTyp'+'e']['FEVAL_RESP'+'ONSE']:case _0x1a74fc['MessageTyp'+'e']['STILL_ALIV'+'E']:case _0x1a74fc['MessageTyp'+'e']['INTERRUPT']:throw'Message\x20un'+'used';}}['_getMessag'+'eData'](_0x2b80df,..._0x73c887){switch(_0x2b80df){case _0x1a74fc['MessageTyp'+'e']['ATTACH']:return{'attachID':_0x73c887[-0x1add+0x1*-0x1aaa+-0x3587*-0x1],'mvmID':'user-mvm'};case _0x1a74fc['MessageTyp'+'e']['EVAL_REQUE'+'ST']:return{'attachID':this['_attachId'],'requestID':_0x73c887[0x32*-0x2d+-0x2*0x4af+0x38*0x53],'command':_0x73c887[-0x86*0x10+-0x53*-0x61+-0x1*0x1712],'isUserEval':!(0x819*0x2+-0x56*-0x4c+-0x31*0xda),'runOptions':_0x73c887[-0x1*-0x1a1+0x182f+-0x19ce]};case _0x1a74fc['MessageTyp'+'e']['FEVAL_REQU'+'EST']:return{'attachID':this['_attachId'],'requestID':_0x73c887[-0xfcf+0x2124+-0x1155],'function':_0x73c887[-0x11*-0x9d+-0x54*-0x51+-0x2*0x1280],'numOutputsExpected':_0x73c887[-0x1*0x3+-0x79c*0x4+0x1e75],'rhsArgs':_0x73c887[0x184e+-0x4d*-0x3b+-0x2a0a],'runOptions':_0x73c887[-0x272+-0x1d7d*0x1+0x1ff3]};case _0x1a74fc['MessageTyp'+'e']['CANCEL']:return{'attachID':this['_attachId'],'requestID':_0x73c887[-0x431*0x7+0x4cc+0x188b],'interrupt':!(-0x991*0x1+-0x6c7+0x1058)};case _0x1a74fc['MessageTyp'+'e']['SET_BREAKP'+'OINT_REQUE'+'ST']:return{'attachID':this['_attachId'],'requestID':_0x73c887[-0x10*0x243+-0x5*-0x4ff+0x97*0x13],'breakpoint':_0x73c887[-0x733+-0x14d*-0x15+0x10f*-0x13]};case _0x1a74fc['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_REQ'+'UEST']:return{'attachID':this['_attachId'],'requestID':_0x73c887[-0x22a7+0x1*0x1492+0xe15],'interrupt':_0x73c887[-0xb*-0x365+0x1273+-0x37c9*0x1]};}throw'Unknown\x20me'+'ssage\x20type'+'\x20to\x20get\x20da'+'ta\x20from';}['tryAttach'](_0x54e9ab){return _0x1aad03(this,void(-0x237f*0x1+0x1d10+0x66f),void(-0x1*0x1c2b+0x1e63+0x4*-0x8e),function*(){if(this['_matlabCon'+'nection']=yield this['_lifecycle'+'Manager']['getMatlabC'+'onnection'](),null==this['_matlabCon'+'nection'])return!(-0xae+0x1c50+-0x1ba1);const _0x2eb242=(-0x2208+0xd8+0x588*0x6,_0x157de8['createReso'+'lvableProm'+'ise'])();let _0x36654f=!(0x85*0x1+0x1f*0x105+0xab5*-0x3);const _0x21b60e=setTimeout(()=>{_0x2eb242['resolve'](!(0x3e6+0x25f2+-0x29d7)),_0x36654f=!(-0x212f+-0xa*0xa3+0x9*0x465);},0x5*-0x50d+-0x83*0x7+0x20be),_0x53c870=this['_getNewAtt'+'achId']();return this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['ATTACH_RES'+'PONSE'],_0x53c870),_0x3d4e5c=>{clearTimeout(_0x21b60e),_0x36654f||(_0x3d4e5c['error']?_0x2eb242['resolve'](!(0x71*-0x43+0x2279*0x1+0x4e5*-0x1)):this['_matlabCon'+'nection']?(this['_attachId']=_0x53c870,this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['EVAL_FEVAL'+'_RESPONSE']),this['_handleGen'+'ericRespon'+'se']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['OUTPUT']),this['_handleOut'+'put']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['ERROR_OUTP'+'UT']),this['_handleOut'+'put']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['EVENT_FIRE'+'D']),this['_handleEve'+'ntFired']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['EVENT_SUBS'+'CRIBED']),this['_handleEve'+'ntSubscrip'+'tion']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['CLC']),this['_handleClc'+'Event']['bind'](this))),this['_listenToP'+'romptEvent'](),_0x2eb242['resolve'](!(0x3*-0xaed+-0x17e0+0x38a7*0x1))):_0x2eb242['resolve'](!(-0x7*-0x575+0x265*-0x7+-0x3*0x725)));}),this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['ATTACH']),this['_getMessag'+'eData'](_0x1a74fc['MessageTyp'+'e']['ATTACH'],_0x53c870)),_0x2eb242;});}['_listenToP'+'romptEvent'](){this['_subscribe'+'Event']('mlutil::pr'+'ompt::Prom'+'ptEvent',this['_handlePro'+'mptEvent']['bind'](this));}['_subscribe'+'Event'](_0x75e143,_0x1a8c81){var _0x3d5f6d;return _0x1aad03(this,void(-0x1*-0x8cb+0x19*-0x2b+-0xe*0x54),void(0x1b54+-0x9*0x302+-0x1*0x42),function*(){if(yield this['_attachPro'+'mise'],void(0x19a3+-0x9b*0x19+-0xa80)===this['_eventSubs'+'criptions'][_0x75e143]){const _0x5578e0=(-0x1ff1+-0x1f*0x59+0x2ab8,_0x157de8['createReso'+'lvableProm'+'ise'])(),_0x1855e8=Math['random']()['toString'](0x1886+0x4fb+-0x1d5d*0x1)['substr'](0xa30+-0x1*0xcd1+0x2a3,0x1853+-0x4*-0x1ed+-0x1ffe);this['_eventSubs'+'criptions'][_0x75e143]={'subscriptionPromise':_0x5578e0,'eventSubscriptionRequestId':_0x1855e8,'callbacks':[]},null===(_0x3d5f6d=this['_matlabCon'+'nection'])||void(0x1b60+-0x24f9+0x9*0x111)===_0x3d5f6d||_0x3d5f6d['publish'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['EVENT_SUBS'+'CRIBE']),{'type':'subscribe','uId':_0x75e143,'eventName':_0x75e143,'requestId':_0x1855e8,'connectionId':this['_attachId']});}return this['_eventSubs'+'criptions'][_0x75e143]['callbacks']['push'](_0x1a8c81),()=>{this['_eventSubs'+'criptions'][_0x75e143]['callbacks']=this['_eventSubs'+'criptions'][_0x75e143]['callbacks']['filter'](_0x3c4571=>_0x3c4571!==_0x1a8c81);};});}['_handleEve'+'ntSubscrip'+'tion'](_0x2e60d8){if(_0x2e60d8['requestId']){for(const _0x4a9dd9 in this['_eventSubs'+'criptions'])if(this['_eventSubs'+'criptions'][_0x4a9dd9]['eventSubsc'+'riptionReq'+'uestId']===_0x2e60d8['requestId'])return this['_eventSubs'+'criptions'][_0x4a9dd9]['subscripti'+'onPromise']['resolve'](),void(this['_eventSubs'+'criptions'][_0x4a9dd9]['eventSubsc'+'riptionReq'+'uestId']='');}}['_handleEve'+'ntFired'](_0x32f43f){for(let _0x402a3b=-0x11e5+0x3ee*0x5+-0x1c1;_0x402a3b<_0x32f43f['eventData']['filterTags']['length'];_0x402a3b++){const _0x5c8bad=this['_eventSubs'+'criptions'][_0x32f43f['eventData']['filterTags'][_0x402a3b]];void(0x1*-0x269+-0x1a6d+0x1cd6*0x1)===_0x5c8bad||_0x5c8bad['callbacks']['slice']()['forEach'](_0x2498db=>{_0x2498db(_0x32f43f['eventData']);});}}['_handlePro'+'mptEvent'](_0x42fcfa){this['emit'](_0x108488['IMVM']['Events']['promptChan'+'ge'],_0x108488['STATE_REQU'+'ESTER_TO_S'+'TATE'][_0x42fcfa['requester']],_0x42fcfa['isIdle']);}['detach'](){super['detach']();}['setBreakpo'+'int'](_0xfe1d9e,_0x2f0e34,_0x973032,_0x559dba){return this['feval']('dbstop',-0xb3f*-0x1+-0xb42+0x3,['in',_0xfe1d9e,'at',_0x2f0e34['toString']()]);}['clearBreak'+'point'](_0x1f9fa5,_0x3c9552,_0x283ed1,_0xe70b3b){return this['feval']('dbclear',-0x1533+0x7*-0x28b+0x2700,['in',_0x1f9fa5,'at',_0x3c9552['toString']()]);}['_cancel'](_0xe81593){var _0xf35f54;null===(_0xf35f54=this['_matlabCon'+'nection'])||void(0x1eaf+-0x1599+0x1*-0x916)===_0xf35f54||_0xf35f54['publish'](this['_getChanne'+'l'](_0x1a74fc['MessageTyp'+'e']['CANCEL']),this['_getMessag'+'eData'](_0x1a74fc['MessageTyp'+'e']['CANCEL'],_0xe81593));}['_getNewAtt'+'achId'](){return Math['random']()['toString'](0x97*-0x1d+0x1da6+-0xc67*0x1)['substr'](-0x10c3+-0x21*-0x12b+-0x15c6,0x1*-0x267d+0xfa0+-0x2*-0xb73);}['_getNewReq'+'uestId'](){return this['_currentRe'+'questId']++;}['getMatlabR'+'elease'](){return this['_lifecycle'+'Manager']['getMatlabR'+'elease']();}}_0xa87e41['default']=_0x5540db;},0x38a:function(_0x29a8d9,_0x2e24f3,_0x5e0b6c){var _0xeb64b2=this&&this['__createBi'+'nding']||(Object['create']?function(_0x31125f,_0x5593cb,_0x8ecbce,_0x1972b1){void(0xa72+0x1bc1+0x2633*-0x1)===_0x1972b1&&(_0x1972b1=_0x8ecbce);var _0x229e61=Object['getOwnProp'+'ertyDescri'+'ptor'](_0x5593cb,_0x8ecbce);_0x229e61&&!('get'in _0x229e61?!_0x5593cb['__esModule']:_0x229e61['writable']||_0x229e61['configurab'+'le'])||(_0x229e61={'enumerable':!(0x1551+0x1a5*-0xd+0x10),'get':function(){return _0x5593cb[_0x8ecbce];}}),Object['defineProp'+'erty'](_0x31125f,_0x1972b1,_0x229e61);}:function(_0x1c5221,_0x4d475b,_0x58fb94,_0x219f25){void(-0x5f8+-0x3ae+0x13*0x82)===_0x219f25&&(_0x219f25=_0x58fb94),_0x1c5221[_0x219f25]=_0x4d475b[_0x58fb94];}),_0x1c0370=this&&this['__setModul'+'eDefault']||(Object['create']?function(_0x334d8,_0x1b1f12){Object['defineProp'+'erty'](_0x334d8,'default',{'enumerable':!(0x10d1+-0x47*-0x47+-0x2482*0x1),'value':_0x1b1f12});}:function(_0x1a5ced,_0x5df224){_0x1a5ced['default']=_0x5df224;}),_0x21cc76=this&&this['__importSt'+'ar']||function(_0xa07fb7){if(_0xa07fb7&&_0xa07fb7['__esModule'])return _0xa07fb7;var _0x52a103={};if(null!=_0xa07fb7){for(var _0x290112 in _0xa07fb7)'default'!==_0x290112&&Object['prototype']['hasOwnProp'+'erty']['call'](_0xa07fb7,_0x290112)&&_0xeb64b2(_0x52a103,_0xa07fb7,_0x290112);}return _0x1c0370(_0x52a103,_0xa07fb7),_0x52a103;},_0x169158=this&&this['__awaiter']||function(_0x4311e7,_0x551efd,_0x3473e2,_0x596e83){return new(_0x3473e2||(_0x3473e2=Promise))(function(_0x370b09,_0x5c6d8b){function _0x2bd81b(_0x5b7334){try{_0x228dc8(_0x596e83['next'](_0x5b7334));}catch(_0x538b4c){_0x5c6d8b(_0x538b4c);}}function _0x37bc01(_0x204d13){try{_0x228dc8(_0x596e83['throw'](_0x204d13));}catch(_0x5c7a08){_0x5c6d8b(_0x5c7a08);}}function _0x228dc8(_0x38fb1b){var _0x17dea0;_0x38fb1b['done']?_0x370b09(_0x38fb1b['value']):(_0x17dea0=_0x38fb1b['value'],_0x17dea0 instanceof _0x3473e2?_0x17dea0:new _0x3473e2(function(_0x327c9e){_0x327c9e(_0x17dea0);}))['then'](_0x2bd81b,_0x37bc01);}_0x228dc8((_0x596e83=_0x596e83['apply'](_0x4311e7,_0x551efd||[]))['next']());});};Object['defineProp'+'erty'](_0x2e24f3,'__esModule',{'value':!(0x1362+-0x1*0x1cc0+0x6d*0x16)});const _0x4f85a7=_0x21cc76(_0x5e0b6c(-0x16c6+0x1454+0x1*0x275)),_0x1ec5d8=_0x5e0b6c(0x10fc*-0x1+0x1*-0x9bc+0x1ad2),_0x5a71ee=_0x5e0b6c(0x17*-0x107+-0xa9*-0x7+0x1355*0x1);var _0x456d7c;!function(_0x5f355e){_0x5f355e[_0x5f355e['PreAttach']=0x11*0x125+-0xd86+0x1f*-0x31]='PreAttach',_0x5f355e[_0x5f355e['Attaching']=0x1a82+0xc83+-0x9c1*0x4]='Attaching',_0x5f355e[_0x5f355e['Attached']=0x1*0x1093+0x5d*-0x53+0xd96]='Attached',_0x5f355e[_0x5f355e['Invalid']=0x267e+0x1*-0x1841+-0xe3a]='Invalid';}(_0x456d7c||(_0x456d7c={}));class _0x5cc49a extends _0x4f85a7['default']{constructor(_0x330f24){super(),this['_channelPr'+'efix']=null,this['_eventSubs'+'criptions']={},this['_attachmen'+'tState']=_0x456d7c['PreAttach'],this['_lifecycle'+'Manager']=_0x330f24,this['_attachPro'+'mise']=(0x761+0x5*0x34b+-0x17d8,_0x1ec5d8['createReso'+'lvableProm'+'ise'])();}['_getChanne'+'l'](_0x5a115b,..._0x1293ac){switch(_0x5a115b){case _0x4f85a7['MessageTyp'+'e']['ATTACH']:return'/mvm/attac'+'h/request';case _0x4f85a7['MessageTyp'+'e']['ATTACH_RES'+'PONSE']:return'/mvm/attac'+'h/response';case _0x4f85a7['MessageTyp'+'e']['EVAL_REQUE'+'ST']:return this['_channelPr'+'efix']+('/eval/requ'+'est');case _0x4f85a7['MessageTyp'+'e']['FEVAL_REQU'+'EST']:return this['_channelPr'+'efix']+('/feval/req'+'uest');case _0x4f85a7['MessageTyp'+'e']['SET_BREAKP'+'OINT_REQUE'+'ST']:return this['_channelPr'+'efix']+('/setLineBr'+'eakpoint/r'+'equest');case _0x4f85a7['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_REQ'+'UEST']:return this['_channelPr'+'efix']+('/clearLine'+'Breakpoint'+'/request');case _0x4f85a7['MessageTyp'+'e']['CANCEL']:return this['_channelPr'+'efix']+('/cancel/re'+'quest');case _0x4f85a7['MessageTyp'+'e']['EVAL_RESPO'+'NSE']:return this['_channelPr'+'efix']+('/eval/resp'+'onse');case _0x4f85a7['MessageTyp'+'e']['FEVAL_RESP'+'ONSE']:return this['_channelPr'+'efix']+('/feval/res'+'ponse');case _0x4f85a7['MessageTyp'+'e']['SET_BREAKP'+'OINT_RESPO'+'NSE']:return this['_channelPr'+'efix']+('/setLineBr'+'eakpoint/r'+'esponse');case _0x4f85a7['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_RES'+'PONSE']:return this['_channelPr'+'efix']+('/clearLine'+'Breakpoint'+'/response');case _0x4f85a7['MessageTyp'+'e']['OUTPUT']:return this['_channelPr'+'efix']+'/output';case _0x4f85a7['MessageTyp'+'e']['ERROR_OUTP'+'UT']:return this['_channelPr'+'efix']+'/error';case _0x4f85a7['MessageTyp'+'e']['STILL_ALIV'+'E']:return this['_channelPr'+'efix']+('/connectio'+'n/stillAli'+'ve');case _0x4f85a7['MessageTyp'+'e']['EVENT_FIRE'+'D']:return this['_channelPr'+'efix']+('/event/fir'+'eEvent');case _0x4f85a7['MessageTyp'+'e']['EVENT_SUBS'+'CRIBE']:return this['_channelPr'+'efix']+('/subscribe'+'Event/requ'+'est');case _0x4f85a7['MessageTyp'+'e']['EVENT_SUBS'+'CRIBED']:return this['_channelPr'+'efix']+('/subscribe'+'Event/resp'+'onse');case _0x4f85a7['MessageTyp'+'e']['CLC']:return'/matlabls/'+'events/clc';case _0x4f85a7['MessageTyp'+'e']['EVAL_FEVAL'+'_RESPONSE']:case _0x4f85a7['MessageTyp'+'e']['INTERRUPT']:throw'Message\x20Ty'+'pe\x20unused';}throw'Unknown\x20me'+'ssage\x20type';}['_getMessag'+'eData'](_0x53804a,..._0x3d4679){switch(_0x53804a){case _0x4f85a7['MessageTyp'+'e']['ATTACH']:return{'requestID':_0x3d4679[-0x17bf+-0x1a3a*-0x1+0x5*-0x7f],'mvmID':'user-mvm','supportedApiVersions':['r22a0']};case _0x4f85a7['MessageTyp'+'e']['EVAL_REQUE'+'ST']:return{'requestID':_0x3d4679[-0x18bc*0x1+-0x22d*0x11+0x3db9],'command':_0x3d4679[0xdb2+0x1*0xad9+-0x6*0x417],'isUserEval':!(-0x7c*-0xa+0x1*-0x7a9+0x1*0x2d1),'runOptions':_0x3d4679[0x1*0xaf7+-0xd3*-0x25+-0x1c*0x17b]};case _0x4f85a7['MessageTyp'+'e']['FEVAL_REQU'+'EST']:return{'requestID':_0x3d4679[-0x1*0x1f22+-0xfaa+0x2ecc],'function':_0x3d4679[0x1299+0x26cc+-0x3964],'numOutputsExpected':_0x3d4679[0x1*0x10d3+-0x910+-0x7c1],'rhsArgs':_0x3d4679[-0x1711+0x32*-0xa9+0x1*0x3816],'runOptions':_0x3d4679[-0x18f4+-0x14fe*0x1+0x2df6]};case _0x4f85a7['MessageTyp'+'e']['SET_BREAKP'+'OINT_REQUE'+'ST']:case _0x4f85a7['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_REQ'+'UEST']:return{'requestID':_0x3d4679[-0x841*0x1+-0x1696+-0x1*-0x1ed7],'breakpoint':_0x3d4679[0x279+0x211d+-0x2395]};case _0x4f85a7['MessageTyp'+'e']['CANCEL']:return{'requestID':_0x3d4679[0x1968+-0x646*-0x4+0x650*-0x8],'interrupt':!(0x1*-0x979+-0x3*-0x82c+-0xf0b),'requestIDtoCancel':_0x3d4679[0x1561+0x21a*0x11+0x1c8d*-0x2]};}throw'Unknown\x20ch'+'annel\x20type'+'\x20to\x20get\x20da'+'ta\x20from';}['tryAttach'](_0x23db4f){return _0x169158(this,void(0xde7*0x1+-0x254+-0xb93),void(-0x335+-0x81*-0x13+-0x146*0x5),function*(){if(this['_attachmen'+'tState']!==_0x456d7c['PreAttach'])throw new Error('Can\x27t\x20reus'+'e\x20impl\x20ins'+'tance');if(this['_attachmen'+'tState']=_0x456d7c['Attaching'],this['_matlabCon'+'nection']=yield this['_lifecycle'+'Manager']['getMatlabC'+'onnection'](),null==this['_matlabCon'+'nection'])return this['_attachmen'+'tState']=_0x456d7c['Invalid'],!(0x440+0x1*-0x77c+0x33d);const _0x2b2ea8=this['_attachPro'+'mise'],_0x4d78b0=setTimeout(()=>{this['_attachmen'+'tState']=_0x456d7c['Invalid'],_0x2b2ea8['resolve'](!(0x12e1+0x1*0x2707+-0x39e7));},0x77a+0x1658+-0x19ea),_0x1b9819=this['_getNewReq'+'uestId']();return this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['ATTACH_RES'+'PONSE']),_0x1b1f68=>{if(_0x1b1f68['requestID']===_0x1b9819&&(clearTimeout(_0x4d78b0),this['_attachmen'+'tState']===_0x456d7c['Attaching']))return _0x1b1f68['error']?(console['error'](_0x1b1f68['error']['msg']),void _0x2b2ea8['resolve'](!(-0x811+0x5*-0x283+0x14a1*0x1))):void(this['_matlabCon'+'nection']?(this['_channelPr'+'efix']=_0x1b1f68['channelPre'+'fix'],this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['STILL_ALIV'+'E']),()=>{})),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['EVAL_RESPO'+'NSE']),this['_handleGen'+'ericRespon'+'se']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['FEVAL_RESP'+'ONSE']),this['_handleGen'+'ericRespon'+'se']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['SET_BREAKP'+'OINT_RESPO'+'NSE']),this['_handleGen'+'ericRespon'+'se']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['CLEAR_BREA'+'KPOINT_RES'+'PONSE']),this['_handleGen'+'ericRespon'+'se']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['OUTPUT']),this['_handleOut'+'put']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['ERROR_OUTP'+'UT']),this['_handleOut'+'put']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['EVENT_FIRE'+'D']),this['_handleEve'+'ntFired']['bind'](this))),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['EVENT_SUBS'+'CRIBED']),this['_handleEve'+'ntSubscrip'+'tion']['bind'](this))),this['_listenToC'+'lcEvent'](),this['_listenToP'+'romptEvent'](),_0x2b2ea8['resolve'](!(-0x1717+0xef*-0x1+0x7b*0x32))):_0x2b2ea8['resolve'](!(0x95e+0x4*-0x176+0x11*-0x35)));}),this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['ATTACH']),this['_getMessag'+'eData'](_0x4f85a7['MessageTyp'+'e']['ATTACH'],_0x1b9819)),_0x2b2ea8;});}['detach'](){this['_attachmen'+'tState']!==_0x456d7c['Attaching']&&this['_attachmen'+'tState']!==_0x456d7c['PreAttach']||this['_attachPro'+'mise']['reject'](),this['_attachmen'+'tState']=_0x456d7c['Invalid'],super['detach']();}['_listenToC'+'lcEvent'](){this['_subscribe'+'Event']('services::'+'io::CLCEve'+'nt',this['_handleClc'+'Event']['bind'](this)),this['_connectio'+'ns']['push'](this['_matlabCon'+'nection']['subscribe'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['CLC']),()=>{this['_handleClc'+'Event']();}));}['_listenToP'+'romptEvent'](){this['_subscribe'+'Event']('mlutil::pr'+'ompt::Prom'+'ptEvent||U'+'serGroup',this['_handlePro'+'mptEvent']['bind'](this));}['_handlePro'+'mptEvent'](_0x1d4b82){this['emit'](_0x5a71ee['IMVM']['Events']['promptChan'+'ge'],_0x5a71ee['STATE_REQU'+'ESTER_TO_S'+'TATE'][_0x1d4b82['requester']],_0x1d4b82['isIdle']);}['_handleEve'+'ntSubscrip'+'tion'](_0x202d50){if(_0x202d50['requestID']){for(const _0x48803f in this['_eventSubs'+'criptions'])if(this['_eventSubs'+'criptions'][_0x48803f]['subscripti'+'onRequestI'+'d']===_0x202d50['requestID'])return this['_eventSubs'+'criptions'][_0x48803f]['subscripti'+'onPromise']['resolve'](),void(this['_eventSubs'+'criptions'][_0x48803f]['subscripti'+'onRequestI'+'d']='');}}['_subscribe'+'Event'](_0x18babe,_0x3bb544){var _0x59c4e5;return _0x169158(this,void(-0x21e9+0x1f75+-0x2*-0x13a),void(-0x1884+0x1*0x1ef1+-0x2f*0x23),function*(){if(yield this['_attachPro'+'mise'],void(-0x1056+-0x171f+0x2775)===this['_eventSubs'+'criptions'][_0x18babe]){const _0x1c3607=(-0x15d*-0x11+-0x1505*-0x1+-0x2c32,_0x1ec5d8['createReso'+'lvableProm'+'ise'])(),_0x4cef29=this['_getNewReq'+'uestId']();this['_eventSubs'+'criptions'][_0x18babe]={'subscriptionPromise':_0x1c3607,'subscriptionRequestId':_0x4cef29,'callbacks':[]},null===(_0x59c4e5=this['_matlabCon'+'nection'])||void(0xc*0x1f+0x1*-0x30d+-0x1*-0x199)===_0x59c4e5||_0x59c4e5['publish'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['EVENT_SUBS'+'CRIBE']),{'requestID':_0x4cef29,'eventName':_0x18babe});}return this['_eventSubs'+'criptions'][_0x18babe]['callbacks']['push'](_0x3bb544),()=>{this['_eventSubs'+'criptions'][_0x18babe]['callbacks']=this['_eventSubs'+'criptions'][_0x18babe]['callbacks']['filter'](_0x45068c=>_0x45068c!==_0x3bb544);};});}['_handleEve'+'ntFired'](_0x559069){for(let _0xd67079=0x1*0x8df+0x1*-0x18a7+0xfc8;_0xd67079<_0x559069['eventData']['filterTags']['length'];_0xd67079++){const _0x433ced=this['_eventSubs'+'criptions'][_0x559069['eventData']['filterTags'][_0xd67079]];void(-0x485+0x1d39+0x66*-0x3e)===_0x433ced||_0x433ced['callbacks']['slice']()['forEach'](_0x3ed380=>{_0x3ed380(_0x559069['eventData']);});}}['_cancel'](_0x2bf431){var _0x1147fe;const _0x483d96=this['_getNewReq'+'uestId']();null===(_0x1147fe=this['_matlabCon'+'nection'])||void(0x1*-0x161+0x251e+0x51b*-0x7)===_0x1147fe||_0x1147fe['publish'](this['_getChanne'+'l'](_0x4f85a7['MessageTyp'+'e']['CANCEL']),this['_getMessag'+'eData'](_0x4f85a7['MessageTyp'+'e']['CANCEL'],_0x483d96,_0x2bf431));}['_getNewReq'+'uestId'](){return Math['random']()['toString'](-0x4*0x6a6+-0x1d52+-0x19*-0x23e)['substr'](-0x128c+-0xb6b*-0x1+-0x105*-0x7,-0xf52+-0x136d+0xc*0x2e6);}['getMatlabR'+'elease'](){return this['_lifecycle'+'Manager']['getMatlabR'+'elease']();}}_0x2e24f3['default']=_0x5cc49a;},0x3:(_0x1c9211,_0x40b5b2,_0x419420)=>{Object['defineProp'+'erty'](_0x40b5b2,'__esModule',{'value':!(0x7*-0x434+-0x33*-0x13+0x19a3*0x1)}),_0x40b5b2['RequestTyp'+'e']=_0x40b5b2['MessageTyp'+'e']=void(0x15fa+-0x4*-0x91f+-0x3a76);const _0x1a2161=_0x419420(0x489+0x1*-0x6bb+-0x8d*-0x8),_0x5855de=_0x419420(0x18ff+-0x2*-0x11fd+0x3cdf*-0x1),_0x20b384=_0x419420(0x5*0x427+0x19*0xc5+-0x27ad),_0x424434=_0x419420(0x548+0x26c1+-0x2c*0xf8);var _0x41e89a,_0x420008;!function(_0x56450c){_0x56450c[_0x56450c['ATTACH']=-0x1*0xc21+-0xa90+-0x16b1*-0x1]='ATTACH',_0x56450c[_0x56450c['ATTACH_RES'+'PONSE']=0x3a0+0x1c*-0x62+0x4f*0x17]='ATTACH_RES'+'PONSE',_0x56450c[_0x56450c['EVAL_REQUE'+'ST']=0xfb2+-0x91f*0x1+-0x691]='EVAL_REQUE'+'ST',_0x56450c[_0x56450c['FEVAL_REQU'+'EST']=-0xa*-0x1cf+0x1*0x124d+-0x2460]='FEVAL_REQU'+'EST',_0x56450c[_0x56450c['SET_BREAKP'+'OINT_REQUE'+'ST']=0x22c0+0x1*0xb5d+-0x2e19]='SET_BREAKP'+'OINT_REQUE'+'ST',_0x56450c[_0x56450c['CLEAR_BREA'+'KPOINT_REQ'+'UEST']=0x21c*-0x2+-0x1923+0x1d60]='CLEAR_BREA'+'KPOINT_REQ'+'UEST',_0x56450c[_0x56450c['CANCEL']=0x233d+-0x1faf*0x1+-0xe2*0x4]='CANCEL',_0x56450c[_0x56450c['INTERRUPT']=0x2*0x714+0x8d3+-0x16f4]='INTERRUPT',_0x56450c[_0x56450c['EVAL_RESPO'+'NSE']=-0x32f*0x1+0xbe9+-0x8b2]='EVAL_RESPO'+'NSE',_0x56450c[_0x56450c['FEVAL_RESP'+'ONSE']=-0x1*0x661+0x184*0x1+-0xd1*-0x6]='FEVAL_RESP'+'ONSE',_0x56450c[_0x56450c['EVAL_FEVAL'+'_RESPONSE']=-0x25ea+0x214d+-0x3*-0x18d]='EVAL_FEVAL'+'_RESPONSE',_0x56450c[_0x56450c['SET_BREAKP'+'OINT_RESPO'+'NSE']=-0x5*0x3f5+0x859+0xb7b]='SET_BREAKP'+'OINT_RESPO'+'NSE',_0x56450c[_0x56450c['CLEAR_BREA'+'KPOINT_RES'+'PONSE']=0x1f7d+-0x5*0x623+0x61*-0x2]='CLEAR_BREA'+'KPOINT_RES'+'PONSE',_0x56450c[_0x56450c['OUTPUT']=0x2170+-0x1ab1+-0x6b2]='OUTPUT',_0x56450c[_0x56450c['ERROR_OUTP'+'UT']=0x1d5b*0x1+-0x2576+0x829*0x1]='ERROR_OUTP'+'UT',_0x56450c[_0x56450c['STILL_ALIV'+'E']=0x16ad+-0x1356+-0x2a*0x14]='STILL_ALIV'+'E',_0x56450c[_0x56450c['EVENT_SUBS'+'CRIBE']=-0x42*-0x8c+0x1*0x2291+-0x4699]='EVENT_SUBS'+'CRIBE',_0x56450c[_0x56450c['EVENT_SUBS'+'CRIBED']=-0x26*0x101+-0x3*-0xc49+-0xc*-0x1d]='EVENT_SUBS'+'CRIBED',_0x56450c[_0x56450c['EVENT_FIRE'+'D']=-0x2aa+0x4*0x52a+0x4a*-0x3e]='EVENT_FIRE'+'D',_0x56450c[_0x56450c['CLC']=-0xd08+-0x306+0x1*0x1021]='CLC';}(_0x41e89a=_0x40b5b2['MessageTyp'+'e']||(_0x40b5b2['MessageTyp'+'e']={})),function(_0x3c3147){_0x3c3147[_0x3c3147['EVAL']=-0x5fb+0xabc+-0x1*0x4c1]='EVAL',_0x3c3147[_0x3c3147['FEVAL']=-0x1d24+0x1*0xbb9+-0x1be*-0xa]='FEVAL',_0x3c3147[_0x3c3147['BREAKPOINT']=-0x1*0x22e7+0x22e4+0x5]='BREAKPOINT';}(_0x420008=_0x40b5b2['RequestTyp'+'e']||(_0x40b5b2['RequestTyp'+'e']={}));class _0x52545c{constructor(_0x220b03,_0x355633,_0x26ae68,_0x5e3caa){this['fileName']=_0x220b03,this['location']={'lineNumber':_0x355633},void(-0x135c+0x1822*0x1+-0x4c6)!==_0x26ae68&&(this['expression']=_0x26ae68),void(-0x605+0x2*0x71d+-0x835)!==_0x5e3caa&&(this['location']['anonymousI'+'ndex']=_0x5e3caa);}}class _0xebd645 extends _0x424434['EventEmitt'+'er']{constructor(){super(...arguments),this['_matlabCon'+'nection']=null,this['_requestMa'+'p']={},this['_connectio'+'ns']=[];}['_getChanne'+'l'](_0x23f5e4,..._0x2aa55b){throw'Unimplemen'+'ted';}['_getMessag'+'eData'](_0x1d9f77,..._0x472fe6){throw'Unimplemen'+'ted';}['_handleClc'+'Event'](){this['emit'](_0x20b384['IMVM']['Events']['clc']);}['_cancel'](_0x73b39){throw'Unimplemen'+'ted';}['_getNewReq'+'uestId'](){throw'Unimplemen'+'ted';}['detach'](){this['_requestMa'+'p']=[],this['_matlabCon'+'nection']=null,this['_connectio'+'ns']=[];}['eval'](_0x4610cf,_0x4ba74b=!(0x1321+-0x133b+0x1a),_0x5eb5d3){const _0x1d12db=(0x59*0x32+0x24b6+-0x3618,_0x5855de['createReso'+'lvableProm'+'ise'])();if(!this['_matlabCon'+'nection'])return _0x1d12db['reject'](),_0x1d12db;const _0x50a971=this['_getNewReq'+'uestId'](),_0x5386bc={'useNullOutSink':!(-0x1c7b+-0x1a51+0x36cd),'useNullErrSink':!(0xd3*-0x23+0x1*0xfac+-0x7*-0x1e2),'suppressDebugControlOutput':!(-0x27e+-0x1307+0xac3*0x2),'eventConnections':{}};return _0x4ba74b&&(_0x5386bc['groupNames']=['UserGroup']),_0x5eb5d3&&(_0x5386bc['capabiliti'+'esList']=_0x1a2161['FullCapabi'+'litiesList']['filter'](_0x543ef9=>!_0x5eb5d3['includes'](_0x543ef9))),this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x41e89a['EVAL_REQUE'+'ST']),this['_getMessag'+'eData'](_0x41e89a['EVAL_REQUE'+'ST'],_0x50a971,_0x4610cf,_0x5386bc)),this['_requestMa'+'p'][_0x50a971]={'promise':_0x1d12db,'requestType':_0x420008['EVAL'],'cancel':this['_cancel']['bind'](this,_0x50a971)},_0x1d12db;}['feval'](_0x3233ca,_0x2a4678,_0x25e906,_0x5358d4){const _0x2d4cb6=(-0x23dc+-0x1461+-0x1*-0x383d,_0x5855de['createReso'+'lvableProm'+'ise'])();if(!this['_matlabCon'+'nection'])return console['error']('Eval\x20with\x20'+'no\x20connect'+'ion!'),_0x2d4cb6['reject'](),_0x2d4cb6;const _0x23b170=this['_getNewReq'+'uestId']();let _0x2e6b6c={'useNullOutSink':!(0x3a4*0x8+-0x85*0x47+0x7c3*0x1),'useNullErrSink':!(-0x3*0x338+0x2135+-0x178d*0x1),'suppressDebugControlOutput':!(-0x1cea+-0x2*0x107d+0x1*0x3de5)};return _0x5358d4&&(_0x2e6b6c['capabiliti'+'esList']=_0x1a2161['FullCapabi'+'litiesList']['filter'](_0x5e843a=>!_0x5358d4['includes'](_0x5e843a))),this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x41e89a['FEVAL_REQU'+'EST']),this['_getMessag'+'eData'](_0x41e89a['FEVAL_REQU'+'EST'],_0x23b170,_0x3233ca,_0x2a4678,_0x25e906,_0x2e6b6c)),this['_requestMa'+'p'][_0x23b170]={'promise':_0x2d4cb6,'requestType':_0x420008['FEVAL'],'cancel':this['_cancel']['bind'](this,_0x23b170)},_0x2d4cb6;}['_handleGen'+'ericRespon'+'se'](_0x63a49d){const _0x13aae6=this['_requestMa'+'p'][_0x63a49d['requestID']];if(!_0x13aae6)return;delete this['_requestMa'+'p'][_0x63a49d['requestID']];const _0x496c15=_0x13aae6['promise'];_0x63a49d['error'],_0x496c15['resolve'](_0x63a49d);}['interrupt'](){if(this['_matlabCon'+'nection'])for(const _0x28594a in this['_requestMa'+'p']){const _0x49ca28=this['_requestMa'+'p'][_0x28594a]['requestTyp'+'e'];_0x49ca28!==_0x420008['EVAL']&&_0x49ca28!=_0x420008['FEVAL']||this['_requestMa'+'p'][_0x28594a]['cancel']();}}['_handleOut'+'put'](_0x3fb87c){this['emit'](_0x20b384['IMVM']['Events']['output'],_0x3fb87c);}['setBreakpo'+'int'](_0xfaf811,_0x11aec4,_0x12c2ed,_0x19d713){const _0x4751bd=(0x1cae+0x1cf2+0x10*-0x39a,_0x5855de['createReso'+'lvableProm'+'ise'])();if(!this['_matlabCon'+'nection'])return _0x4751bd['reject'](),_0x4751bd;const _0x50ec10=this['_getNewReq'+'uestId'](),_0x3500cd=new _0x52545c(_0xfaf811,_0x11aec4,_0x12c2ed,_0x19d713);return this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x41e89a['SET_BREAKP'+'OINT_REQUE'+'ST']),this['_getMessag'+'eData'](_0x41e89a['SET_BREAKP'+'OINT_REQUE'+'ST'],_0x50ec10,_0x3500cd)),this['_requestMa'+'p'][_0x50ec10]={'promise':_0x4751bd,'requestType':_0x420008['BREAKPOINT'],'cancel':()=>{}},_0x4751bd;}['clearBreak'+'point'](_0x461067,_0x51c54b,_0x321a06,_0x32fb61){const _0x1a5242=(0x9bc+-0x1732+0x1*0xd76,_0x5855de['createReso'+'lvableProm'+'ise'])();if(!this['_matlabCon'+'nection'])return _0x1a5242['reject'](),_0x1a5242;const _0x3a9bfd=this['_getNewReq'+'uestId'](),_0x3e7519=new _0x52545c(_0x461067,_0x51c54b,_0x321a06,_0x32fb61);return this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x41e89a['CLEAR_BREA'+'KPOINT_REQ'+'UEST']),this['_getMessag'+'eData'](_0x41e89a['CLEAR_BREA'+'KPOINT_REQ'+'UEST'],_0x3a9bfd,_0x3e7519)),this['_requestMa'+'p'][_0x3a9bfd]={'promise':_0x1a5242,'requestType':_0x420008['BREAKPOINT'],'cancel':()=>{}},_0x1a5242;}['unpause'](){if(!this['_matlabCon'+'nection'])return void console['error']('Unpause\x20wi'+'th\x20no\x20conn'+'ection!');const _0x4b5972=this['_getNewReq'+'uestId']();this['_matlabCon'+'nection']['publish'](this['_getChanne'+'l'](_0x41e89a['FEVAL_REQU'+'EST']),this['_getMessag'+'eData'](_0x41e89a['FEVAL_REQU'+'EST'],_0x4b5972,'matlab.int'+'ernal.sing'+'lekeypress'+'.pause.res'+'ume',0xe83*0x1+0x2*0x186+-0x1*0x118f,[],{'useNullOutSink':!(-0x72*0x13+0x1782+-0xf0c),'useNullErrSink':!(0x8fc+-0x1ce+-0x1*0x72e),'queueName':'SingleKeyP'+'ress'}));const _0x20f4b2=(0x268d+0x6f*-0x3+-0x2540,_0x5855de['createReso'+'lvableProm'+'ise'])();this['_requestMa'+'p'][_0x4b5972]={'promise':_0x20f4b2,'requestType':_0x420008['FEVAL'],'cancel':this['_cancel']['bind'](this,_0x4b5972)};}}_0x40b5b2['default']=_0xebd645;},0x3a7:function(_0x5e71f4,_0x53d9f3,_0x3b0805){var _0xfccb17=this&&this['__awaiter']||function(_0x27b2b5,_0x14cf84,_0x272bbd,_0x57335b){return new(_0x272bbd||(_0x272bbd=Promise))(function(_0x4a72a7,_0x56eb83){function _0x14b034(_0x4c12de){try{_0x31cd63(_0x57335b['next'](_0x4c12de));}catch(_0x2755ed){_0x56eb83(_0x2755ed);}}function _0x350b38(_0x599447){try{_0x31cd63(_0x57335b['throw'](_0x599447));}catch(_0x54f1fe){_0x56eb83(_0x54f1fe);}}function _0x31cd63(_0x282b9f){var _0x245ae6;_0x282b9f['done']?_0x4a72a7(_0x282b9f['value']):(_0x245ae6=_0x282b9f['value'],_0x245ae6 instanceof _0x272bbd?_0x245ae6:new _0x272bbd(function(_0x19d514){_0x19d514(_0x245ae6);}))['then'](_0x14b034,_0x350b38);}_0x31cd63((_0x57335b=_0x57335b['apply'](_0x27b2b5,_0x14cf84||[]))['next']());});},_0x56be5f=this&&this['__importDe'+'fault']||function(_0xdd6748){return _0xdd6748&&_0xdd6748['__esModule']?_0xdd6748:{'default':_0xdd6748};};Object['defineProp'+'erty'](_0x53d9f3,'__esModule',{'value':!(0x57*0x1f+0x2ef+-0xd78)});const _0x506e8f=_0x3b0805(0xce*-0x4+0x376*-0xa+-0xc9d*-0x3),_0x1415aa=_0x56be5f(_0x3b0805(-0x7a*0x11+0x1726+-0xb82));class _0x3612e2 extends _0x1415aa['default']{constructor(_0x136c70){super(_0x136c70);}['_getChanne'+'l'](_0xf536b1,..._0x360ff4){return _0xf536b1===_0x506e8f['MessageTyp'+'e']['OUTPUT']?this['_channelPr'+'efix']+('/text/outp'+'ut'):_0xf536b1===_0x506e8f['MessageTyp'+'e']['ERROR_OUTP'+'UT']?this['_channelPr'+'efix']+('/text/erro'+'r'):_0xf536b1===_0x506e8f['MessageTyp'+'e']['INTERRUPT']?this['_channelPr'+'efix']+('/interrupt'+'/request'):super['_getChanne'+'l'](_0xf536b1,..._0x360ff4);}['_getMessag'+'eData'](_0x2e7d54,..._0x23a701){if(_0x2e7d54===_0x506e8f['MessageTyp'+'e']['ATTACH']){let _0x2f769e;return _0x2f769e='22b'==this['_release']?'r22b0':'23a'==this['_release']?'r23a0':'23b'==this['_release']?'r23b0':'r24a0',{'requestID':_0x23a701[-0x1e04+0x2681+-0x87d],'mvmID':'user-mvm','supportedApiVersions':[_0x2f769e]};}return _0x2e7d54===_0x506e8f['MessageTyp'+'e']['INTERRUPT']?{'requestID':this['_getNewReq'+'uestId']()}:_0x2e7d54===_0x506e8f['MessageTyp'+'e']['FEVAL_REQU'+'EST']?{'requestID':_0x23a701[0x9*-0x229+0x19a4+-0x633],'function':_0x23a701[0xdd*-0x3+0x667+-0x3cf],'numOutputsExpected':_0x23a701[0x22d9+-0x1369*0x1+-0xf6e],'rhsArgs':_0x23a701[-0xebe+-0x1*-0x109c+-0x1db]['map'](JSON['stringify']),'runOptions':_0x23a701[0x127c+0x6ba+-0x1932]}:super['_getMessag'+'eData'](_0x2e7d54,..._0x23a701);}['_supportsR'+'elease'](_0x3a965f){const _0x31ff7a=_0x3a965f['match'](/^([0-9]{2})([ab])$/);if(null===_0x31ff7a)return!(-0x185f+0x159+-0x5*-0x49b);const _0x3a1a99=Number['parseInt'](_0x31ff7a[-0x1959+-0xf34+0x288e]),_0x32c701=_0x31ff7a[0x1327*-0x1+0xcf+0x9*0x20a];return!(_0x3a1a99<-0xbb9*0x2+-0x1*-0x602+0x1186||0x7*0x527+0x1f8d+-0x4388==_0x3a1a99&&'a'==_0x32c701);}['tryAttach'](_0x2a735b){const _0x2cad7e=Object['create'](null,{'tryAttach':{'get':()=>super['tryAttach']}});return _0xfccb17(this,void(-0x26*-0x97+0x1*0x1cea+-0x3354),void(0x3*-0x32c+0x2*-0x73c+0x17fc*0x1),function*(){return!(void(-0x1b1*0x2+0x1960+-0x15fe)===_0x2a735b||!this['_supportsR'+'elease'](_0x2a735b))&&(this['_release']=_0x2a735b,_0x2cad7e['tryAttach']['call'](this,_0x2a735b));});}['interrupt'](){var _0x46a813;null===(_0x46a813=this['_matlabCon'+'nection'])||void(-0x1ed*-0x2+0x17*0x106+-0x4*0x6d9)===_0x46a813||_0x46a813['publish'](this['_getChanne'+'l'](_0x506e8f['MessageTyp'+'e']['INTERRUPT']),this['_getMessag'+'eData'](_0x506e8f['MessageTyp'+'e']['INTERRUPT']));}}_0x53d9f3['default']=_0x3612e2;},0x53:(_0x14c077,_0x1c2873)=>{var _0x55ee9d;Object['defineProp'+'erty'](_0x1c2873,'__esModule',{'value':!(-0x7*-0xa1+-0x1*0x1ee3+0x1a7c)}),_0x1c2873['IMVM']=_0x1c2873['STATE_REQU'+'ESTER_TO_S'+'TATE']=_0x1c2873['STATE_REQU'+'ESTER']=_0x1c2873['PromptStat'+'e']=void(0x1ec6+-0x114c+-0xd7a),function(_0xefa59c){_0xefa59c['INITIALIZI'+'NG']='INITIALIZI'+'NG',_0xefa59c['READY']='READY',_0xefa59c['BUSY']='BUSY',_0xefa59c['DEBUG']='DEBUG',_0xefa59c['INPUT']='INPUT',_0xefa59c['PAUSE']='PAUSE',_0xefa59c['MORE']='MORE',_0xefa59c['COMPLETING'+'_BLOCK']='COMPLETING'+'_BLOCK';}(_0x55ee9d=_0x1c2873['PromptStat'+'e']||(_0x1c2873['PromptStat'+'e']={})),_0x1c2873['STATE_REQU'+'ESTER']={'INITIALIZING':'','READY':'BASE_PROMP'+'T','BUSY':'NO_PROMPT','DEBUG':'DEBUG_PROM'+'PT','INPUT':'INPUT_PROM'+'PT','KEYBOARD':'KEYBOARD_P'+'ROMPT','PAUSE':'PAUSE_PROM'+'PT','MORE':'MORE_PROMP'+'T','COMPLETING_BLOCK':'INCOMPLETE'+'_BLOCK_PRO'+'MPT','BANG':'BANG_PROMP'+'T'},_0x1c2873['STATE_REQU'+'ESTER_TO_S'+'TATE']={[_0x1c2873['STATE_REQU'+'ESTER']['INITIALIZI'+'NG']]:_0x55ee9d['INITIALIZI'+'NG'],[_0x1c2873['STATE_REQU'+'ESTER']['READY']]:_0x55ee9d['READY'],[_0x1c2873['STATE_REQU'+'ESTER']['BUSY']]:_0x55ee9d['BUSY'],[_0x1c2873['STATE_REQU'+'ESTER']['BANG']]:_0x55ee9d['BUSY'],[_0x1c2873['STATE_REQU'+'ESTER']['DEBUG']]:_0x55ee9d['DEBUG'],[_0x1c2873['STATE_REQU'+'ESTER']['INPUT']]:_0x55ee9d['INPUT'],[_0x1c2873['STATE_REQU'+'ESTER']['KEYBOARD']]:_0x55ee9d['DEBUG'],[_0x1c2873['STATE_REQU'+'ESTER']['PAUSE']]:_0x55ee9d['PAUSE'],[_0x1c2873['STATE_REQU'+'ESTER']['MORE']]:_0x55ee9d['MORE'],[_0x1c2873['STATE_REQU'+'ESTER']['COMPLETING'+'_BLOCK']]:_0x55ee9d['COMPLETING'+'_BLOCK']},function(_0x563090){let _0x4f93c8;!function(_0x1c3777){_0x1c3777['clc']='clc',_0x1c3777['output']='output',_0x1c3777['promptChan'+'ge']='promptChan'+'ge',_0x1c3777['stateChang'+'e']='stateChang'+'e';}(_0x4f93c8=_0x563090['Events']||(_0x563090['Events']={}));}(_0x1c2873['IMVM']||(_0x1c2873['IMVM']={}));},0x236:(_0xf37048,_0x53bf83)=>{var _0x111bdc;Object['defineProp'+'erty'](_0x53bf83,'__esModule',{'value':!(0x47*-0x2b+-0x1*-0x586+0x1*0x667)}),_0x53bf83['FullCapabi'+'litiesList']=_0x53bf83['Capability']=void(-0x19*0xb+-0x869*-0x2+-0xfbf),function(_0x3447e5){_0x3447e5['Interactiv'+'eCommandLi'+'ne']='Interactiv'+'eCommandLi'+'ne',_0x3447e5['Swing']='Swing',_0x3447e5['ComplexSwi'+'ng']='ComplexSwi'+'ng',_0x3447e5['LocalClien'+'t']='LocalClien'+'t',_0x3447e5['WebWindow']='WebWindow',_0x3447e5['ModalDialo'+'gs']='ModalDialo'+'gs',_0x3447e5['Debugging']='Debugging';}(_0x111bdc=_0x53bf83['Capability']||(_0x53bf83['Capability']={})),_0x53bf83['FullCapabi'+'litiesList']=[_0x111bdc['Interactiv'+'eCommandLi'+'ne'],_0x111bdc['Swing'],_0x111bdc['ComplexSwi'+'ng'],_0x111bdc['LocalClien'+'t'],_0x111bdc['WebWindow'],_0x111bdc['ModalDialo'+'gs'],_0x111bdc['Debugging']];},0x1a:(_0x2e5456,_0x205c89)=>{Object['defineProp'+'erty'](_0x205c89,'__esModule',{'value':!(0x3d*0x83+0x1b03+0x202*-0x1d)}),_0x205c89['createReso'+'lvableProm'+'ise']=void(0x1c96+0x1*0x20d9+-0x3d6f),_0x205c89['createReso'+'lvableProm'+'ise']=function(){let _0x141815,_0x42bf57;const _0x2e9da7=new Promise((_0x15b85d,_0x4d7187)=>{_0x141815=_0x15b85d,_0x42bf57=_0x4d7187;});return _0x2e9da7['resolve']=_0x141815,_0x2e9da7['reject']=_0x42bf57,_0x2e9da7;};},0x169:_0x16c05d=>{_0x16c05d['exports']=__webpack_require__(/*! events */ "events");}},_0x11f337={},_0x2e1141=function _0x28bffe(_0x3e6dde){var _0x235031=_0x11f337[_0x3e6dde];if(void(-0x1*0x1f51+0x1a*0x7c+0x12b9)!==_0x235031)return _0x235031['exports'];var _0x5ee780=_0x11f337[_0x3e6dde]={'exports':{}};return _0x2216b1[_0x3e6dde]['call'](_0x5ee780['exports'],_0x5ee780,_0x5ee780['exports'],_0x28bffe),_0x5ee780['exports'];}(-0xe*-0x2aa+0x1233*0x1+-0x34d1);module['exports']=_0x2e1141;})());

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ "domain":
/*!*************************!*\
  !*** external "domain" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("domain");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),

/***/ "node:https":
/*!*****************************!*\
  !*** external "node:https" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:https");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream/web");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/cliui/build/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/cliui/build/index.cjs ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* istanbul ignore next: depends on terminal */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* istanbul ignore next */
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}

// Bootstrap cliui with CommonJS dependencies:
const stringWidth = __webpack_require__(/*! string-width */ "./node_modules/string-width/index.js");
const stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js");
const wrap = __webpack_require__(/*! wrap-ansi */ "./node_modules/wrap-ansi/index.js");
function ui(opts) {
    return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
    });
}

module.exports = ui;


/***/ }),

/***/ "./node_modules/fetch-blob/streams.cjs":
/*!*********************************************!*\
  !*** ./node_modules/fetch-blob/streams.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = __webpack_require__(/*! node:process */ "node:process")
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ "node:stream/web"))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
    Object.assign(globalThis, __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.es2018.js */ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"))
  }
}

try {
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = __webpack_require__(/*! buffer */ "buffer")
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
} catch (error) {}
/* c8 ignore end */


/***/ }),

/***/ "./node_modules/y18n/build/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/y18n/build/index.cjs ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");

let shim;
class Y18N {
    constructor(opts) {
        // configurable options.
        opts = opts || {};
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        // internal stuff.
        this.cache = Object.create(null);
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        cb = cb || function () { }; // noop.
        if (!this.cache[this.locale])
            this._readLocaleFile();
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        if (!this.cache[this.locale])
            this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        // if a %d placeholder is provided, add quantity
        // to the arguments expanded by util.format.
        const values = [str];
        if (~str.indexOf('%d'))
            values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale])
            this._readLocaleFile();
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function (part, i) {
            const arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
            this._processWriteQueue();
    }
    _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        // destructure the enqueued work.
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0)
                _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            // When using a bundler such as webpack, readFileSync may not be defined:
            if (shim.fs.readFileSync) {
                localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
            }
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT')
                localeLookup = {};
            else
                throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            // attempt fallback to language only
            const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile))
                file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim.exists(file);
    }
}
function y18n$1(opts, _shim) {
    shim = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}

var nodePlatformShim = {
    fs: {
        readFileSync: fs.readFileSync,
        writeFile: fs.writeFile
    },
    format: util.format,
    resolve: path.resolve,
    exists: (file) => {
        try {
            return fs.statSync(file).isFile();
        }
        catch (err) {
            return false;
        }
    }
};

const y18n = (opts) => {
    return y18n$1(opts, nodePlatformShim);
};

module.exports = y18n;


/***/ }),

/***/ "./node_modules/yargs/build/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/yargs/build/index.cjs ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var t=__webpack_require__(/*! assert */ "assert");class e extends Error{constructor(t){super(t||"yargs error"),this.name="YError",Error.captureStackTrace&&Error.captureStackTrace(this,e)}}let s,i=[];function n(t,o,a,h){s=h;let l={};if(Object.prototype.hasOwnProperty.call(t,"extends")){if("string"!=typeof t.extends)return l;const r=/\.json|\..*rc$/.test(t.extends);let h=null;if(r)h=function(t,e){return s.path.resolve(t,e)}(o,t.extends);else try{h=/*require.resolve*/(__webpack_require__("./node_modules/yargs/build sync recursive").resolve(t.extends))}catch(e){return t}!function(t){if(i.indexOf(t)>-1)throw new e(`Circular extended configurations: '${t}'.`)}(h),i.push(h),l=r?JSON.parse(s.readFileSync(h,"utf8")):__webpack_require__("./node_modules/yargs/build sync recursive")(t.extends),delete t.extends,l=n(l,s.path.dirname(h),a,s)}return i=[],a?r(l,t):Object.assign({},l,t)}function r(t,e){const s={};function i(t){return t&&"object"==typeof t&&!Array.isArray(t)}Object.assign(s,t);for(const n of Object.keys(e))i(e[n])&&i(s[n])?s[n]=r(t[n],e[n]):s[n]=e[n];return s}function o(t){const e=t.replace(/\s{2,}/g," ").split(/\s+(?![^[]*]|[^<]*>)/),s=/\.*[\][<>]/g,i=e.shift();if(!i)throw new Error(`No command found in: ${t}`);const n={cmd:i.replace(s,""),demanded:[],optional:[]};return e.forEach(((t,i)=>{let r=!1;t=t.replace(/\s/g,""),/\.+[\]>]/.test(t)&&i===e.length-1&&(r=!0),/^\[/.test(t)?n.optional.push({cmd:t.replace(s,"").split("|"),variadic:r}):n.demanded.push({cmd:t.replace(s,"").split("|"),variadic:r})})),n}const a=["first","second","third","fourth","fifth","sixth"];function h(t,s,i){try{let n=0;const[r,a,h]="object"==typeof t?[{demanded:[],optional:[]},t,s]:[o(`cmd ${t}`),s,i],f=[].slice.call(a);for(;f.length&&void 0===f[f.length-1];)f.pop();const d=h||f.length;if(d<r.demanded.length)throw new e(`Not enough arguments provided. Expected ${r.demanded.length} but received ${f.length}.`);const u=r.demanded.length+r.optional.length;if(d>u)throw new e(`Too many arguments provided. Expected max ${u} but received ${d}.`);r.demanded.forEach((t=>{const e=l(f.shift());0===t.cmd.filter((t=>t===e||"*"===t)).length&&c(e,t.cmd,n),n+=1})),r.optional.forEach((t=>{if(0===f.length)return;const e=l(f.shift());0===t.cmd.filter((t=>t===e||"*"===t)).length&&c(e,t.cmd,n),n+=1}))}catch(t){console.warn(t.stack)}}function l(t){return Array.isArray(t)?"array":null===t?"null":typeof t}function c(t,s,i){throw new e(`Invalid ${a[i]||"manyith"} argument. Expected ${s.join(" or ")} but received ${t}.`)}function f(t){return!!t&&!!t.then&&"function"==typeof t.then}function d(t,e,s,i){s.assert.notStrictEqual(t,e,i)}function u(t,e){e.assert.strictEqual(typeof t,"string")}function p(t){return Object.keys(t)}function g(t={},e=(()=>!0)){const s={};return p(t).forEach((i=>{e(i,t[i])&&(s[i]=t[i])})),s}function m(){return process.versions.electron&&!process.defaultApp?0:1}function y(){return process.argv[m()]}var b=Object.freeze({__proto__:null,hideBin:function(t){return t.slice(m()+1)},getProcessArgvBin:y});function v(t,e,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!i:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(t):i?i.value:e.get(t)}function O(t,e,s,i,n){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!n)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!n:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?n.call(t,s):n?n.value=s:e.set(t,s),s}class w{constructor(t){this.globalMiddleware=[],this.frozens=[],this.yargs=t}addMiddleware(t,e,s=!0,i=!1){if(h("<array|function> [boolean] [boolean] [boolean]",[t,e,s],arguments.length),Array.isArray(t)){for(let i=0;i<t.length;i++){if("function"!=typeof t[i])throw Error("middleware must be a function");const n=t[i];n.applyBeforeValidation=e,n.global=s}Array.prototype.push.apply(this.globalMiddleware,t)}else if("function"==typeof t){const n=t;n.applyBeforeValidation=e,n.global=s,n.mutates=i,this.globalMiddleware.push(t)}return this.yargs}addCoerceMiddleware(t,e){const s=this.yargs.getAliases();return this.globalMiddleware=this.globalMiddleware.filter((t=>{const i=[...s[e]||[],e];return!t.option||!i.includes(t.option)})),t.option=e,this.addMiddleware(t,!0,!0,!0)}getMiddleware(){return this.globalMiddleware}freeze(){this.frozens.push([...this.globalMiddleware])}unfreeze(){const t=this.frozens.pop();void 0!==t&&(this.globalMiddleware=t)}reset(){this.globalMiddleware=this.globalMiddleware.filter((t=>t.global))}}function C(t,e,s,i){return s.reduce(((t,s)=>{if(s.applyBeforeValidation!==i)return t;if(s.mutates){if(s.applied)return t;s.applied=!0}if(f(t))return t.then((t=>Promise.all([t,s(t,e)]))).then((([t,e])=>Object.assign(t,e)));{const i=s(t,e);return f(i)?i.then((e=>Object.assign(t,e))):Object.assign(t,i)}}),t)}function j(t,e,s=(t=>{throw t})){try{const s="function"==typeof t?t():t;return f(s)?s.then((t=>e(t))):e(s)}catch(t){return s(t)}}const M=/(^\*)|(^\$0)/;class _{constructor(t,e,s,i){this.requireCache=new Set,this.handlers={},this.aliasMap={},this.frozens=[],this.shim=i,this.usage=t,this.globalMiddleware=s,this.validation=e}addDirectory(t,e,s,i){"boolean"!=typeof(i=i||{}).recurse&&(i.recurse=!1),Array.isArray(i.extensions)||(i.extensions=["js"]);const n="function"==typeof i.visit?i.visit:t=>t;i.visit=(t,e,s)=>{const i=n(t,e,s);if(i){if(this.requireCache.has(e))return i;this.requireCache.add(e),this.addHandler(i)}return i},this.shim.requireDirectory({require:e,filename:s},t,i)}addHandler(t,e,s,i,n,r){let a=[];const h=function(t){return t?t.map((t=>(t.applyBeforeValidation=!1,t))):[]}(n);if(i=i||(()=>{}),Array.isArray(t))if(function(t){return t.every((t=>"string"==typeof t))}(t))[t,...a]=t;else for(const e of t)this.addHandler(e);else{if(function(t){return"object"==typeof t&&!Array.isArray(t)}(t)){let e=Array.isArray(t.command)||"string"==typeof t.command?t.command:this.moduleName(t);return t.aliases&&(e=[].concat(e).concat(t.aliases)),void this.addHandler(e,this.extractDesc(t),t.builder,t.handler,t.middlewares,t.deprecated)}if(k(s))return void this.addHandler([t].concat(a),e,s.builder,s.handler,s.middlewares,s.deprecated)}if("string"==typeof t){const n=o(t);a=a.map((t=>o(t).cmd));let l=!1;const c=[n.cmd].concat(a).filter((t=>!M.test(t)||(l=!0,!1)));0===c.length&&l&&c.push("$0"),l&&(n.cmd=c[0],a=c.slice(1),t=t.replace(M,n.cmd)),a.forEach((t=>{this.aliasMap[t]=n.cmd})),!1!==e&&this.usage.command(t,e,l,a,r),this.handlers[n.cmd]={original:t,description:e,handler:i,builder:s||{},middlewares:h,deprecated:r,demanded:n.demanded,optional:n.optional},l&&(this.defaultCommand=this.handlers[n.cmd])}}getCommandHandlers(){return this.handlers}getCommands(){return Object.keys(this.handlers).concat(Object.keys(this.aliasMap))}hasDefaultCommand(){return!!this.defaultCommand}runCommand(t,e,s,i,n,r){const o=this.handlers[t]||this.handlers[this.aliasMap[t]]||this.defaultCommand,a=e.getInternalMethods().getContext(),h=a.commands.slice(),l=!t;t&&(a.commands.push(t),a.fullCommands.push(o.original));const c=this.applyBuilderUpdateUsageAndParse(l,o,e,s.aliases,h,i,n,r);return f(c)?c.then((t=>this.applyMiddlewareAndGetResult(l,o,t.innerArgv,a,n,t.aliases,e))):this.applyMiddlewareAndGetResult(l,o,c.innerArgv,a,n,c.aliases,e)}applyBuilderUpdateUsageAndParse(t,e,s,i,n,r,o,a){const h=e.builder;let l=s;if(x(h)){s.getInternalMethods().getUsageInstance().freeze();const c=h(s.getInternalMethods().reset(i),a);if(f(c))return c.then((i=>{var a;return l=(a=i)&&"function"==typeof a.getInternalMethods?i:s,this.parseAndUpdateUsage(t,e,l,n,r,o)}))}else(function(t){return"object"==typeof t})(h)&&(s.getInternalMethods().getUsageInstance().freeze(),l=s.getInternalMethods().reset(i),Object.keys(e.builder).forEach((t=>{l.option(t,h[t])})));return this.parseAndUpdateUsage(t,e,l,n,r,o)}parseAndUpdateUsage(t,e,s,i,n,r){t&&s.getInternalMethods().getUsageInstance().unfreeze(!0),this.shouldUpdateUsage(s)&&s.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i,e),e.description);const o=s.getInternalMethods().runYargsParserAndExecuteCommands(null,void 0,!0,n,r);return f(o)?o.then((t=>({aliases:s.parsed.aliases,innerArgv:t}))):{aliases:s.parsed.aliases,innerArgv:o}}shouldUpdateUsage(t){return!t.getInternalMethods().getUsageInstance().getUsageDisabled()&&0===t.getInternalMethods().getUsageInstance().getUsage().length}usageFromParentCommandsCommandHandler(t,e){const s=M.test(e.original)?e.original.replace(M,"").trim():e.original,i=t.filter((t=>!M.test(t)));return i.push(s),`$0 ${i.join(" ")}`}handleValidationAndGetResult(t,e,s,i,n,r,o,a){if(!r.getInternalMethods().getHasOutput()){const e=r.getInternalMethods().runValidation(n,a,r.parsed.error,t);s=j(s,(t=>(e(t),t)))}if(e.handler&&!r.getInternalMethods().getHasOutput()){r.getInternalMethods().setHasOutput();const i=!!r.getOptions().configuration["populate--"];r.getInternalMethods().postProcess(s,i,!1,!1),s=j(s=C(s,r,o,!1),(t=>{const s=e.handler(t);return f(s)?s.then((()=>t)):t})),t||r.getInternalMethods().getUsageInstance().cacheHelpMessage(),f(s)&&!r.getInternalMethods().hasParseCallback()&&s.catch((t=>{try{r.getInternalMethods().getUsageInstance().fail(null,t)}catch(t){}}))}return t||(i.commands.pop(),i.fullCommands.pop()),s}applyMiddlewareAndGetResult(t,e,s,i,n,r,o){let a={};if(n)return s;o.getInternalMethods().getHasOutput()||(a=this.populatePositionals(e,s,i,o));const h=this.globalMiddleware.getMiddleware().slice(0).concat(e.middlewares),l=C(s,o,h,!0);return f(l)?l.then((s=>this.handleValidationAndGetResult(t,e,s,i,r,o,h,a))):this.handleValidationAndGetResult(t,e,l,i,r,o,h,a)}populatePositionals(t,e,s,i){e._=e._.slice(s.commands.length);const n=t.demanded.slice(0),r=t.optional.slice(0),o={};for(this.validation.positionalCount(n.length,e._.length);n.length;){const t=n.shift();this.populatePositional(t,e,o)}for(;r.length;){const t=r.shift();this.populatePositional(t,e,o)}return e._=s.commands.concat(e._.map((t=>""+t))),this.postProcessPositionals(e,o,this.cmdToParseOptions(t.original),i),o}populatePositional(t,e,s){const i=t.cmd[0];t.variadic?s[i]=e._.splice(0).map(String):e._.length&&(s[i]=[String(e._.shift())])}cmdToParseOptions(t){const e={array:[],default:{},alias:{},demand:{}},s=o(t);return s.demanded.forEach((t=>{const[s,...i]=t.cmd;t.variadic&&(e.array.push(s),e.default[s]=[]),e.alias[s]=i,e.demand[s]=!0})),s.optional.forEach((t=>{const[s,...i]=t.cmd;t.variadic&&(e.array.push(s),e.default[s]=[]),e.alias[s]=i})),e}postProcessPositionals(t,e,s,i){const n=Object.assign({},i.getOptions());n.default=Object.assign(s.default,n.default);for(const t of Object.keys(s.alias))n.alias[t]=(n.alias[t]||[]).concat(s.alias[t]);n.array=n.array.concat(s.array),n.config={};const r=[];if(Object.keys(e).forEach((t=>{e[t].map((e=>{n.configuration["unknown-options-as-args"]&&(n.key[t]=!0),r.push(`--${t}`),r.push(e)}))})),!r.length)return;const o=Object.assign({},n.configuration,{"populate--":!1}),a=this.shim.Parser.detailed(r,Object.assign({},n,{configuration:o}));if(a.error)i.getInternalMethods().getUsageInstance().fail(a.error.message,a.error);else{const s=Object.keys(e);Object.keys(e).forEach((t=>{s.push(...a.aliases[t])})),Object.keys(a.argv).forEach((n=>{s.includes(n)&&(e[n]||(e[n]=a.argv[n]),!this.isInConfigs(i,n)&&!this.isDefaulted(i,n)&&Object.prototype.hasOwnProperty.call(t,n)&&Object.prototype.hasOwnProperty.call(a.argv,n)&&(Array.isArray(t[n])||Array.isArray(a.argv[n]))?t[n]=[].concat(t[n],a.argv[n]):t[n]=a.argv[n])}))}}isDefaulted(t,e){const{default:s}=t.getOptions();return Object.prototype.hasOwnProperty.call(s,e)||Object.prototype.hasOwnProperty.call(s,this.shim.Parser.camelCase(e))}isInConfigs(t,e){const{configObjects:s}=t.getOptions();return s.some((t=>Object.prototype.hasOwnProperty.call(t,e)))||s.some((t=>Object.prototype.hasOwnProperty.call(t,this.shim.Parser.camelCase(e))))}runDefaultBuilderOn(t){if(!this.defaultCommand)return;if(this.shouldUpdateUsage(t)){const e=M.test(this.defaultCommand.original)?this.defaultCommand.original:this.defaultCommand.original.replace(/^[^[\]<>]*/,"$0 ");t.getInternalMethods().getUsageInstance().usage(e,this.defaultCommand.description)}const e=this.defaultCommand.builder;if(x(e))return e(t,!0);k(e)||Object.keys(e).forEach((s=>{t.option(s,e[s])}))}moduleName(t){const e=function(t){if(false){}for(let e,s=0,i=Object.keys(__webpack_require__.c);s<i.length;s++)if(e=__webpack_require__.c[i[s]],e.exports===t)return e;return null}(t);if(!e)throw new Error(`No command name given for module: ${this.shim.inspect(t)}`);return this.commandFromFilename(e.filename)}commandFromFilename(t){return this.shim.path.basename(t,this.shim.path.extname(t))}extractDesc({describe:t,description:e,desc:s}){for(const i of[t,e,s]){if("string"==typeof i||!1===i)return i;d(i,!0,this.shim)}return!1}freeze(){this.frozens.push({handlers:this.handlers,aliasMap:this.aliasMap,defaultCommand:this.defaultCommand})}unfreeze(){const t=this.frozens.pop();d(t,void 0,this.shim),({handlers:this.handlers,aliasMap:this.aliasMap,defaultCommand:this.defaultCommand}=t)}reset(){return this.handlers={},this.aliasMap={},this.defaultCommand=void 0,this.requireCache=new Set,this}}function k(t){return"object"==typeof t&&!!t.builder&&"function"==typeof t.handler}function x(t){return"function"==typeof t}function E(t){"undefined"!=typeof process&&[process.stdout,process.stderr].forEach((e=>{const s=e;s._handle&&s.isTTY&&"function"==typeof s._handle.setBlocking&&s._handle.setBlocking(t)}))}function A(t){return"boolean"==typeof t}function P(t,s){const i=s.y18n.__,n={},r=[];n.failFn=function(t){r.push(t)};let o=null,a=null,h=!0;n.showHelpOnFail=function(e=!0,s){const[i,r]="string"==typeof e?[!0,e]:[e,s];return t.getInternalMethods().isGlobalContext()&&(a=r),o=r,h=i,n};let l=!1;n.fail=function(s,i){const c=t.getInternalMethods().getLoggerInstance();if(!r.length){if(t.getExitProcess()&&E(!0),!l){l=!0,h&&(t.showHelp("error"),c.error()),(s||i)&&c.error(s||i);const e=o||a;e&&((s||i)&&c.error(""),c.error(e))}if(i=i||new e(s),t.getExitProcess())return t.exit(1);if(t.getInternalMethods().hasParseCallback())return t.exit(1,i);throw i}for(let t=r.length-1;t>=0;--t){const e=r[t];if(A(e)){if(i)throw i;if(s)throw Error(s)}else e(s,i,n)}};let c=[],f=!1;n.usage=(t,e)=>null===t?(f=!0,c=[],n):(f=!1,c.push([t,e||""]),n),n.getUsage=()=>c,n.getUsageDisabled=()=>f,n.getPositionalGroupName=()=>i("Positionals:");let d=[];n.example=(t,e)=>{d.push([t,e||""])};let u=[];n.command=function(t,e,s,i,n=!1){s&&(u=u.map((t=>(t[2]=!1,t)))),u.push([t,e||"",s,i,n])},n.getCommands=()=>u;let p={};n.describe=function(t,e){Array.isArray(t)?t.forEach((t=>{n.describe(t,e)})):"object"==typeof t?Object.keys(t).forEach((e=>{n.describe(e,t[e])})):p[t]=e},n.getDescriptions=()=>p;let m=[];n.epilog=t=>{m.push(t)};let y,b=!1;n.wrap=t=>{b=!0,y=t},n.getWrap=()=>s.getEnv("YARGS_DISABLE_WRAP")?null:(b||(y=function(){const t=80;return s.process.stdColumns?Math.min(t,s.process.stdColumns):t}(),b=!0),y);const v="__yargsString__:";function O(t,e,i){let n=0;return Array.isArray(t)||(t=Object.values(t).map((t=>[t]))),t.forEach((t=>{n=Math.max(s.stringWidth(i?`${i} ${I(t[0])}`:I(t[0]))+$(t[0]),n)})),e&&(n=Math.min(n,parseInt((.5*e).toString(),10))),n}let w;function C(e){return t.getOptions().hiddenOptions.indexOf(e)<0||t.parsed.argv[t.getOptions().showHiddenOpt]}function j(t,e){let s=`[${i("default:")} `;if(void 0===t&&!e)return null;if(e)s+=e;else switch(typeof t){case"string":s+=`"${t}"`;break;case"object":s+=JSON.stringify(t);break;default:s+=t}return`${s}]`}n.deferY18nLookup=t=>v+t,n.help=function(){if(w)return w;!function(){const e=t.getDemandedOptions(),s=t.getOptions();(Object.keys(s.alias)||[]).forEach((i=>{s.alias[i].forEach((r=>{p[r]&&n.describe(i,p[r]),r in e&&t.demandOption(i,e[r]),s.boolean.includes(r)&&t.boolean(i),s.count.includes(r)&&t.count(i),s.string.includes(r)&&t.string(i),s.normalize.includes(r)&&t.normalize(i),s.array.includes(r)&&t.array(i),s.number.includes(r)&&t.number(i)}))}))}();const e=t.customScriptName?t.$0:s.path.basename(t.$0),r=t.getDemandedOptions(),o=t.getDemandedCommands(),a=t.getDeprecatedOptions(),h=t.getGroups(),l=t.getOptions();let g=[];g=g.concat(Object.keys(p)),g=g.concat(Object.keys(r)),g=g.concat(Object.keys(o)),g=g.concat(Object.keys(l.default)),g=g.filter(C),g=Object.keys(g.reduce(((t,e)=>("_"!==e&&(t[e]=!0),t)),{}));const y=n.getWrap(),b=s.cliui({width:y,wrap:!!y});if(!f)if(c.length)c.forEach((t=>{b.div({text:`${t[0].replace(/\$0/g,e)}`}),t[1]&&b.div({text:`${t[1]}`,padding:[1,0,0,0]})})),b.div();else if(u.length){let t=null;t=o._?`${e} <${i("command")}>\n`:`${e} [${i("command")}]\n`,b.div(`${t}`)}if(u.length>1||1===u.length&&!u[0][2]){b.div(i("Commands:"));const s=t.getInternalMethods().getContext(),n=s.commands.length?`${s.commands.join(" ")} `:"";!0===t.getInternalMethods().getParserConfiguration()["sort-commands"]&&(u=u.sort(((t,e)=>t[0].localeCompare(e[0]))));const r=e?`${e} `:"";u.forEach((t=>{const s=`${r}${n}${t[0].replace(/^\$0 ?/,"")}`;b.span({text:s,padding:[0,2,0,2],width:O(u,y,`${e}${n}`)+4},{text:t[1]});const o=[];t[2]&&o.push(`[${i("default")}]`),t[3]&&t[3].length&&o.push(`[${i("aliases:")} ${t[3].join(", ")}]`),t[4]&&("string"==typeof t[4]?o.push(`[${i("deprecated: %s",t[4])}]`):o.push(`[${i("deprecated")}]`)),o.length?b.div({text:o.join(" "),padding:[0,0,0,2],align:"right"}):b.div()})),b.div()}const M=(Object.keys(l.alias)||[]).concat(Object.keys(t.parsed.newAliases)||[]);g=g.filter((e=>!t.parsed.newAliases[e]&&M.every((t=>-1===(l.alias[t]||[]).indexOf(e)))));const _=i("Options:");h[_]||(h[_]=[]),function(t,e,s,i){let n=[],r=null;Object.keys(s).forEach((t=>{n=n.concat(s[t])})),t.forEach((t=>{r=[t].concat(e[t]),r.some((t=>-1!==n.indexOf(t)))||s[i].push(t)}))}(g,l.alias,h,_);const k=t=>/^--/.test(I(t)),x=Object.keys(h).filter((t=>h[t].length>0)).map((t=>({groupName:t,normalizedKeys:h[t].filter(C).map((t=>{if(M.includes(t))return t;for(let e,s=0;void 0!==(e=M[s]);s++)if((l.alias[e]||[]).includes(t))return e;return t}))}))).filter((({normalizedKeys:t})=>t.length>0)).map((({groupName:t,normalizedKeys:e})=>{const s=e.reduce(((e,s)=>(e[s]=[s].concat(l.alias[s]||[]).map((e=>t===n.getPositionalGroupName()?e:(/^[0-9]$/.test(e)?l.boolean.includes(s)?"-":"--":e.length>1?"--":"-")+e)).sort(((t,e)=>k(t)===k(e)?0:k(t)?1:-1)).join(", "),e)),{});return{groupName:t,normalizedKeys:e,switches:s}}));if(x.filter((({groupName:t})=>t!==n.getPositionalGroupName())).some((({normalizedKeys:t,switches:e})=>!t.every((t=>k(e[t])))))&&x.filter((({groupName:t})=>t!==n.getPositionalGroupName())).forEach((({normalizedKeys:t,switches:e})=>{t.forEach((t=>{var s,i;k(e[t])&&(e[t]=(s=e[t],i=4,S(s)?{text:s.text,indentation:s.indentation+i}:{text:s,indentation:i}))}))})),x.forEach((({groupName:e,normalizedKeys:s,switches:o})=>{b.div(e),s.forEach((e=>{const s=o[e];let h=p[e]||"",c=null;h.includes(v)&&(h=i(h.substring(16))),l.boolean.includes(e)&&(c=`[${i("boolean")}]`),l.count.includes(e)&&(c=`[${i("count")}]`),l.string.includes(e)&&(c=`[${i("string")}]`),l.normalize.includes(e)&&(c=`[${i("string")}]`),l.array.includes(e)&&(c=`[${i("array")}]`),l.number.includes(e)&&(c=`[${i("number")}]`);const f=[e in a?(d=a[e],"string"==typeof d?`[${i("deprecated: %s",d)}]`:`[${i("deprecated")}]`):null,c,e in r?`[${i("required")}]`:null,l.choices&&l.choices[e]?`[${i("choices:")} ${n.stringifiedValues(l.choices[e])}]`:null,j(l.default[e],l.defaultDescription[e])].filter(Boolean).join(" ");var d;b.span({text:I(s),padding:[0,2,0,2+$(s)],width:O(o,y)+4},h);const u=!0===t.getInternalMethods().getUsageConfiguration()["hide-types"];f&&!u?b.div({text:f,padding:[0,0,0,2],align:"right"}):b.div()})),b.div()})),d.length&&(b.div(i("Examples:")),d.forEach((t=>{t[0]=t[0].replace(/\$0/g,e)})),d.forEach((t=>{""===t[1]?b.div({text:t[0],padding:[0,2,0,2]}):b.div({text:t[0],padding:[0,2,0,2],width:O(d,y)+4},{text:t[1]})})),b.div()),m.length>0){const t=m.map((t=>t.replace(/\$0/g,e))).join("\n");b.div(`${t}\n`)}return b.toString().replace(/\s*$/,"")},n.cacheHelpMessage=function(){w=this.help()},n.clearCachedHelpMessage=function(){w=void 0},n.hasCachedHelpMessage=function(){return!!w},n.showHelp=e=>{const s=t.getInternalMethods().getLoggerInstance();e||(e="error");("function"==typeof e?e:s[e])(n.help())},n.functionDescription=t=>["(",t.name?s.Parser.decamelize(t.name,"-"):i("generated-value"),")"].join(""),n.stringifiedValues=function(t,e){let s="";const i=e||", ",n=[].concat(t);return t&&n.length?(n.forEach((t=>{s.length&&(s+=i),s+=JSON.stringify(t)})),s):s};let M=null;n.version=t=>{M=t},n.showVersion=e=>{const s=t.getInternalMethods().getLoggerInstance();e||(e="error");("function"==typeof e?e:s[e])(M)},n.reset=function(t){return o=null,l=!1,c=[],f=!1,m=[],d=[],u=[],p=g(p,(e=>!t[e])),n};const _=[];return n.freeze=function(){_.push({failMessage:o,failureOutput:l,usages:c,usageDisabled:f,epilogs:m,examples:d,commands:u,descriptions:p})},n.unfreeze=function(t=!1){const e=_.pop();e&&(t?(p={...e.descriptions,...p},u=[...e.commands,...u],c=[...e.usages,...c],d=[...e.examples,...d],m=[...e.epilogs,...m]):({failMessage:o,failureOutput:l,usages:c,usageDisabled:f,epilogs:m,examples:d,commands:u,descriptions:p}=e))},n}function S(t){return"object"==typeof t}function $(t){return S(t)?t.indentation:0}function I(t){return S(t)?t.text:t}class D{constructor(t,e,s,i){var n,r,o;this.yargs=t,this.usage=e,this.command=s,this.shim=i,this.completionKey="get-yargs-completions",this.aliases=null,this.customCompletionFunction=null,this.indexAfterLastReset=0,this.zshShell=null!==(o=(null===(n=this.shim.getEnv("SHELL"))||void 0===n?void 0:n.includes("zsh"))||(null===(r=this.shim.getEnv("ZSH_NAME"))||void 0===r?void 0:r.includes("zsh")))&&void 0!==o&&o}defaultCompletion(t,e,s,i){const n=this.command.getCommandHandlers();for(let e=0,s=t.length;e<s;++e)if(n[t[e]]&&n[t[e]].builder){const s=n[t[e]].builder;if(x(s)){this.indexAfterLastReset=e+1;const t=this.yargs.getInternalMethods().reset();return s(t,!0),t.argv}}const r=[];this.commandCompletions(r,t,s),this.optionCompletions(r,t,e,s),this.choicesFromOptionsCompletions(r,t,e,s),this.choicesFromPositionalsCompletions(r,t,e,s),i(null,r)}commandCompletions(t,e,s){const i=this.yargs.getInternalMethods().getContext().commands;s.match(/^-/)||i[i.length-1]===s||this.previousArgHasChoices(e)||this.usage.getCommands().forEach((s=>{const i=o(s[0]).cmd;if(-1===e.indexOf(i))if(this.zshShell){const e=s[1]||"";t.push(i.replace(/:/g,"\\:")+":"+e)}else t.push(i)}))}optionCompletions(t,e,s,i){if((i.match(/^-/)||""===i&&0===t.length)&&!this.previousArgHasChoices(e)){const s=this.yargs.getOptions(),n=this.yargs.getGroups()[this.usage.getPositionalGroupName()]||[];Object.keys(s.key).forEach((r=>{const o=!!s.configuration["boolean-negation"]&&s.boolean.includes(r);n.includes(r)||s.hiddenOptions.includes(r)||this.argsContainKey(e,r,o)||this.completeOptionKey(r,t,i,o&&!!s.default[r])}))}}choicesFromOptionsCompletions(t,e,s,i){if(this.previousArgHasChoices(e)){const s=this.getPreviousArgChoices(e);s&&s.length>0&&t.push(...s.map((t=>t.replace(/:/g,"\\:"))))}}choicesFromPositionalsCompletions(t,e,s,i){if(""===i&&t.length>0&&this.previousArgHasChoices(e))return;const n=this.yargs.getGroups()[this.usage.getPositionalGroupName()]||[],r=Math.max(this.indexAfterLastReset,this.yargs.getInternalMethods().getContext().commands.length+1),o=n[s._.length-r-1];if(!o)return;const a=this.yargs.getOptions().choices[o]||[];for(const e of a)e.startsWith(i)&&t.push(e.replace(/:/g,"\\:"))}getPreviousArgChoices(t){if(t.length<1)return;let e=t[t.length-1],s="";if(!e.startsWith("-")&&t.length>1&&(s=e,e=t[t.length-2]),!e.startsWith("-"))return;const i=e.replace(/^-+/,""),n=this.yargs.getOptions(),r=[i,...this.yargs.getAliases()[i]||[]];let o;for(const t of r)if(Object.prototype.hasOwnProperty.call(n.key,t)&&Array.isArray(n.choices[t])){o=n.choices[t];break}return o?o.filter((t=>!s||t.startsWith(s))):void 0}previousArgHasChoices(t){const e=this.getPreviousArgChoices(t);return void 0!==e&&e.length>0}argsContainKey(t,e,s){const i=e=>-1!==t.indexOf((/^[^0-9]$/.test(e)?"-":"--")+e);if(i(e))return!0;if(s&&i(`no-${e}`))return!0;if(this.aliases)for(const t of this.aliases[e])if(i(t))return!0;return!1}completeOptionKey(t,e,s,i){var n,r,o,a;let h=t;if(this.zshShell){const e=this.usage.getDescriptions(),s=null===(r=null===(n=null==this?void 0:this.aliases)||void 0===n?void 0:n[t])||void 0===r?void 0:r.find((t=>{const s=e[t];return"string"==typeof s&&s.length>0})),i=s?e[s]:void 0,l=null!==(a=null!==(o=e[t])&&void 0!==o?o:i)&&void 0!==a?a:"";h=`${t.replace(/:/g,"\\:")}:${l.replace("__yargsString__:","").replace(/(\r\n|\n|\r)/gm," ")}`}const l=!/^--/.test(s)&&(t=>/^[^0-9]$/.test(t))(t)?"-":"--";e.push(l+h),i&&e.push(l+"no-"+h)}customCompletion(t,e,s,i){if(d(this.customCompletionFunction,null,this.shim),this.customCompletionFunction.length<3){const t=this.customCompletionFunction(s,e);return f(t)?t.then((t=>{this.shim.process.nextTick((()=>{i(null,t)}))})).catch((t=>{this.shim.process.nextTick((()=>{i(t,void 0)}))})):i(null,t)}return function(t){return t.length>3}(this.customCompletionFunction)?this.customCompletionFunction(s,e,((n=i)=>this.defaultCompletion(t,e,s,n)),(t=>{i(null,t)})):this.customCompletionFunction(s,e,(t=>{i(null,t)}))}getCompletion(t,e){const s=t.length?t[t.length-1]:"",i=this.yargs.parse(t,!0),n=this.customCompletionFunction?i=>this.customCompletion(t,i,s,e):i=>this.defaultCompletion(t,i,s,e);return f(i)?i.then(n):n(i)}generateCompletionScript(t,e){let s=this.zshShell?'#compdef {{app_name}}\n###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$\'\n\' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "${words[@]}"))\n  IFS=$si\n  _describe \'values\' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n':'###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';const i=this.shim.path.basename(t);return t.match(/\.js$/)&&(t=`./${t}`),s=s.replace(/{{app_name}}/g,i),s=s.replace(/{{completion_command}}/g,e),s.replace(/{{app_path}}/g,t)}registerFunction(t){this.customCompletionFunction=t}setParsed(t){this.aliases=t.aliases}}function N(t,e){if(0===t.length)return e.length;if(0===e.length)return t.length;const s=[];let i,n;for(i=0;i<=e.length;i++)s[i]=[i];for(n=0;n<=t.length;n++)s[0][n]=n;for(i=1;i<=e.length;i++)for(n=1;n<=t.length;n++)e.charAt(i-1)===t.charAt(n-1)?s[i][n]=s[i-1][n-1]:i>1&&n>1&&e.charAt(i-2)===t.charAt(n-1)&&e.charAt(i-1)===t.charAt(n-2)?s[i][n]=s[i-2][n-2]+1:s[i][n]=Math.min(s[i-1][n-1]+1,Math.min(s[i][n-1]+1,s[i-1][n]+1));return s[e.length][t.length]}const H=["$0","--","_"];var z,W,q,U,F,L,V,G,R,T,B,Y,K,J,Z,X,Q,tt,et,st,it,nt,rt,ot,at,ht,lt,ct,ft,dt,ut,pt,gt,mt,yt;const bt=Symbol("copyDoubleDash"),vt=Symbol("copyDoubleDash"),Ot=Symbol("deleteFromParserHintObject"),wt=Symbol("emitWarning"),Ct=Symbol("freeze"),jt=Symbol("getDollarZero"),Mt=Symbol("getParserConfiguration"),_t=Symbol("getUsageConfiguration"),kt=Symbol("guessLocale"),xt=Symbol("guessVersion"),Et=Symbol("parsePositionalNumbers"),At=Symbol("pkgUp"),Pt=Symbol("populateParserHintArray"),St=Symbol("populateParserHintSingleValueDictionary"),$t=Symbol("populateParserHintArrayDictionary"),It=Symbol("populateParserHintDictionary"),Dt=Symbol("sanitizeKey"),Nt=Symbol("setKey"),Ht=Symbol("unfreeze"),zt=Symbol("validateAsync"),Wt=Symbol("getCommandInstance"),qt=Symbol("getContext"),Ut=Symbol("getHasOutput"),Ft=Symbol("getLoggerInstance"),Lt=Symbol("getParseContext"),Vt=Symbol("getUsageInstance"),Gt=Symbol("getValidationInstance"),Rt=Symbol("hasParseCallback"),Tt=Symbol("isGlobalContext"),Bt=Symbol("postProcess"),Yt=Symbol("rebase"),Kt=Symbol("reset"),Jt=Symbol("runYargsParserAndExecuteCommands"),Zt=Symbol("runValidation"),Xt=Symbol("setHasOutput"),Qt=Symbol("kTrackManuallySetKeys");class te{constructor(t=[],e,s,i){this.customScriptName=!1,this.parsed=!1,z.set(this,void 0),W.set(this,void 0),q.set(this,{commands:[],fullCommands:[]}),U.set(this,null),F.set(this,null),L.set(this,"show-hidden"),V.set(this,null),G.set(this,!0),R.set(this,{}),T.set(this,!0),B.set(this,[]),Y.set(this,void 0),K.set(this,{}),J.set(this,!1),Z.set(this,null),X.set(this,!0),Q.set(this,void 0),tt.set(this,""),et.set(this,void 0),st.set(this,void 0),it.set(this,{}),nt.set(this,null),rt.set(this,null),ot.set(this,{}),at.set(this,{}),ht.set(this,void 0),lt.set(this,!1),ct.set(this,void 0),ft.set(this,!1),dt.set(this,!1),ut.set(this,!1),pt.set(this,void 0),gt.set(this,{}),mt.set(this,null),yt.set(this,void 0),O(this,ct,i,"f"),O(this,ht,t,"f"),O(this,W,e,"f"),O(this,st,s,"f"),O(this,Y,new w(this),"f"),this.$0=this[jt](),this[Kt](),O(this,z,v(this,z,"f"),"f"),O(this,pt,v(this,pt,"f"),"f"),O(this,yt,v(this,yt,"f"),"f"),O(this,et,v(this,et,"f"),"f"),v(this,et,"f").showHiddenOpt=v(this,L,"f"),O(this,Q,this[vt](),"f")}addHelpOpt(t,e){return h("[string|boolean] [string]",[t,e],arguments.length),v(this,Z,"f")&&(this[Ot](v(this,Z,"f")),O(this,Z,null,"f")),!1===t&&void 0===e||(O(this,Z,"string"==typeof t?t:"help","f"),this.boolean(v(this,Z,"f")),this.describe(v(this,Z,"f"),e||v(this,pt,"f").deferY18nLookup("Show help"))),this}help(t,e){return this.addHelpOpt(t,e)}addShowHiddenOpt(t,e){if(h("[string|boolean] [string]",[t,e],arguments.length),!1===t&&void 0===e)return this;const s="string"==typeof t?t:v(this,L,"f");return this.boolean(s),this.describe(s,e||v(this,pt,"f").deferY18nLookup("Show hidden options")),v(this,et,"f").showHiddenOpt=s,this}showHidden(t,e){return this.addShowHiddenOpt(t,e)}alias(t,e){return h("<object|string|array> [string|array]",[t,e],arguments.length),this[$t](this.alias.bind(this),"alias",t,e),this}array(t){return h("<array|string>",[t],arguments.length),this[Pt]("array",t),this[Qt](t),this}boolean(t){return h("<array|string>",[t],arguments.length),this[Pt]("boolean",t),this[Qt](t),this}check(t,e){return h("<function> [boolean]",[t,e],arguments.length),this.middleware(((e,s)=>j((()=>t(e,s.getOptions())),(s=>(s?("string"==typeof s||s instanceof Error)&&v(this,pt,"f").fail(s.toString(),s):v(this,pt,"f").fail(v(this,ct,"f").y18n.__("Argument check failed: %s",t.toString())),e)),(t=>(v(this,pt,"f").fail(t.message?t.message:t.toString(),t),e)))),!1,e),this}choices(t,e){return h("<object|string|array> [string|array]",[t,e],arguments.length),this[$t](this.choices.bind(this),"choices",t,e),this}coerce(t,s){if(h("<object|string|array> [function]",[t,s],arguments.length),Array.isArray(t)){if(!s)throw new e("coerce callback must be provided");for(const e of t)this.coerce(e,s);return this}if("object"==typeof t){for(const e of Object.keys(t))this.coerce(e,t[e]);return this}if(!s)throw new e("coerce callback must be provided");return v(this,et,"f").key[t]=!0,v(this,Y,"f").addCoerceMiddleware(((i,n)=>{let r;return Object.prototype.hasOwnProperty.call(i,t)?j((()=>(r=n.getAliases(),s(i[t]))),(e=>{i[t]=e;const s=n.getInternalMethods().getParserConfiguration()["strip-aliased"];if(r[t]&&!0!==s)for(const s of r[t])i[s]=e;return i}),(t=>{throw new e(t.message)})):i}),t),this}conflicts(t,e){return h("<string|object> [string|array]",[t,e],arguments.length),v(this,yt,"f").conflicts(t,e),this}config(t="config",e,s){return h("[object|string] [string|function] [function]",[t,e,s],arguments.length),"object"!=typeof t||Array.isArray(t)?("function"==typeof e&&(s=e,e=void 0),this.describe(t,e||v(this,pt,"f").deferY18nLookup("Path to JSON config file")),(Array.isArray(t)?t:[t]).forEach((t=>{v(this,et,"f").config[t]=s||!0})),this):(t=n(t,v(this,W,"f"),this[Mt]()["deep-merge-config"]||!1,v(this,ct,"f")),v(this,et,"f").configObjects=(v(this,et,"f").configObjects||[]).concat(t),this)}completion(t,e,s){return h("[string] [string|boolean|function] [function]",[t,e,s],arguments.length),"function"==typeof e&&(s=e,e=void 0),O(this,F,t||v(this,F,"f")||"completion","f"),e||!1===e||(e="generate completion script"),this.command(v(this,F,"f"),e),s&&v(this,U,"f").registerFunction(s),this}command(t,e,s,i,n,r){return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]",[t,e,s,i,n,r],arguments.length),v(this,z,"f").addHandler(t,e,s,i,n,r),this}commands(t,e,s,i,n,r){return this.command(t,e,s,i,n,r)}commandDir(t,e){h("<string> [object]",[t,e],arguments.length);const s=v(this,st,"f")||v(this,ct,"f").require;return v(this,z,"f").addDirectory(t,s,v(this,ct,"f").getCallerFile(),e),this}count(t){return h("<array|string>",[t],arguments.length),this[Pt]("count",t),this[Qt](t),this}default(t,e,s){return h("<object|string|array> [*] [string]",[t,e,s],arguments.length),s&&(u(t,v(this,ct,"f")),v(this,et,"f").defaultDescription[t]=s),"function"==typeof e&&(u(t,v(this,ct,"f")),v(this,et,"f").defaultDescription[t]||(v(this,et,"f").defaultDescription[t]=v(this,pt,"f").functionDescription(e)),e=e.call()),this[St](this.default.bind(this),"default",t,e),this}defaults(t,e,s){return this.default(t,e,s)}demandCommand(t=1,e,s,i){return h("[number] [number|string] [string|null|undefined] [string|null|undefined]",[t,e,s,i],arguments.length),"number"!=typeof e&&(s=e,e=1/0),this.global("_",!1),v(this,et,"f").demandedCommands._={min:t,max:e,minMsg:s,maxMsg:i},this}demand(t,e,s){return Array.isArray(e)?(e.forEach((t=>{d(s,!0,v(this,ct,"f")),this.demandOption(t,s)})),e=1/0):"number"!=typeof e&&(s=e,e=1/0),"number"==typeof t?(d(s,!0,v(this,ct,"f")),this.demandCommand(t,e,s,s)):Array.isArray(t)?t.forEach((t=>{d(s,!0,v(this,ct,"f")),this.demandOption(t,s)})):"string"==typeof s?this.demandOption(t,s):!0!==s&&void 0!==s||this.demandOption(t),this}demandOption(t,e){return h("<object|string|array> [string]",[t,e],arguments.length),this[St](this.demandOption.bind(this),"demandedOptions",t,e),this}deprecateOption(t,e){return h("<string> [string|boolean]",[t,e],arguments.length),v(this,et,"f").deprecatedOptions[t]=e,this}describe(t,e){return h("<object|string|array> [string]",[t,e],arguments.length),this[Nt](t,!0),v(this,pt,"f").describe(t,e),this}detectLocale(t){return h("<boolean>",[t],arguments.length),O(this,G,t,"f"),this}env(t){return h("[string|boolean]",[t],arguments.length),!1===t?delete v(this,et,"f").envPrefix:v(this,et,"f").envPrefix=t||"",this}epilogue(t){return h("<string>",[t],arguments.length),v(this,pt,"f").epilog(t),this}epilog(t){return this.epilogue(t)}example(t,e){return h("<string|array> [string]",[t,e],arguments.length),Array.isArray(t)?t.forEach((t=>this.example(...t))):v(this,pt,"f").example(t,e),this}exit(t,e){O(this,J,!0,"f"),O(this,V,e,"f"),v(this,T,"f")&&v(this,ct,"f").process.exit(t)}exitProcess(t=!0){return h("[boolean]",[t],arguments.length),O(this,T,t,"f"),this}fail(t){if(h("<function|boolean>",[t],arguments.length),"boolean"==typeof t&&!1!==t)throw new e("Invalid first argument. Expected function or boolean 'false'");return v(this,pt,"f").failFn(t),this}getAliases(){return this.parsed?this.parsed.aliases:{}}async getCompletion(t,e){return h("<array> [function]",[t,e],arguments.length),e?v(this,U,"f").getCompletion(t,e):new Promise(((e,s)=>{v(this,U,"f").getCompletion(t,((t,i)=>{t?s(t):e(i)}))}))}getDemandedOptions(){return h([],0),v(this,et,"f").demandedOptions}getDemandedCommands(){return h([],0),v(this,et,"f").demandedCommands}getDeprecatedOptions(){return h([],0),v(this,et,"f").deprecatedOptions}getDetectLocale(){return v(this,G,"f")}getExitProcess(){return v(this,T,"f")}getGroups(){return Object.assign({},v(this,K,"f"),v(this,at,"f"))}getHelp(){if(O(this,J,!0,"f"),!v(this,pt,"f").hasCachedHelpMessage()){if(!this.parsed){const t=this[Jt](v(this,ht,"f"),void 0,void 0,0,!0);if(f(t))return t.then((()=>v(this,pt,"f").help()))}const t=v(this,z,"f").runDefaultBuilderOn(this);if(f(t))return t.then((()=>v(this,pt,"f").help()))}return Promise.resolve(v(this,pt,"f").help())}getOptions(){return v(this,et,"f")}getStrict(){return v(this,ft,"f")}getStrictCommands(){return v(this,dt,"f")}getStrictOptions(){return v(this,ut,"f")}global(t,e){return h("<string|array> [boolean]",[t,e],arguments.length),t=[].concat(t),!1!==e?v(this,et,"f").local=v(this,et,"f").local.filter((e=>-1===t.indexOf(e))):t.forEach((t=>{v(this,et,"f").local.includes(t)||v(this,et,"f").local.push(t)})),this}group(t,e){h("<string|array> <string>",[t,e],arguments.length);const s=v(this,at,"f")[e]||v(this,K,"f")[e];v(this,at,"f")[e]&&delete v(this,at,"f")[e];const i={};return v(this,K,"f")[e]=(s||[]).concat(t).filter((t=>!i[t]&&(i[t]=!0))),this}hide(t){return h("<string>",[t],arguments.length),v(this,et,"f").hiddenOptions.push(t),this}implies(t,e){return h("<string|object> [number|string|array]",[t,e],arguments.length),v(this,yt,"f").implies(t,e),this}locale(t){return h("[string]",[t],arguments.length),void 0===t?(this[kt](),v(this,ct,"f").y18n.getLocale()):(O(this,G,!1,"f"),v(this,ct,"f").y18n.setLocale(t),this)}middleware(t,e,s){return v(this,Y,"f").addMiddleware(t,!!e,s)}nargs(t,e){return h("<string|object|array> [number]",[t,e],arguments.length),this[St](this.nargs.bind(this),"narg",t,e),this}normalize(t){return h("<array|string>",[t],arguments.length),this[Pt]("normalize",t),this}number(t){return h("<array|string>",[t],arguments.length),this[Pt]("number",t),this[Qt](t),this}option(t,e){if(h("<string|object> [object]",[t,e],arguments.length),"object"==typeof t)Object.keys(t).forEach((e=>{this.options(e,t[e])}));else{"object"!=typeof e&&(e={}),this[Qt](t),!v(this,mt,"f")||"version"!==t&&"version"!==(null==e?void 0:e.alias)||this[wt](['"version" is a reserved word.',"Please do one of the following:",'- Disable version with `yargs.version(false)` if using "version" as an option',"- Use the built-in `yargs.version` method instead (if applicable)","- Use a different option key","https://yargs.js.org/docs/#api-reference-version"].join("\n"),void 0,"versionWarning"),v(this,et,"f").key[t]=!0,e.alias&&this.alias(t,e.alias);const s=e.deprecate||e.deprecated;s&&this.deprecateOption(t,s);const i=e.demand||e.required||e.require;i&&this.demand(t,i),e.demandOption&&this.demandOption(t,"string"==typeof e.demandOption?e.demandOption:void 0),e.conflicts&&this.conflicts(t,e.conflicts),"default"in e&&this.default(t,e.default),void 0!==e.implies&&this.implies(t,e.implies),void 0!==e.nargs&&this.nargs(t,e.nargs),e.config&&this.config(t,e.configParser),e.normalize&&this.normalize(t),e.choices&&this.choices(t,e.choices),e.coerce&&this.coerce(t,e.coerce),e.group&&this.group(t,e.group),(e.boolean||"boolean"===e.type)&&(this.boolean(t),e.alias&&this.boolean(e.alias)),(e.array||"array"===e.type)&&(this.array(t),e.alias&&this.array(e.alias)),(e.number||"number"===e.type)&&(this.number(t),e.alias&&this.number(e.alias)),(e.string||"string"===e.type)&&(this.string(t),e.alias&&this.string(e.alias)),(e.count||"count"===e.type)&&this.count(t),"boolean"==typeof e.global&&this.global(t,e.global),e.defaultDescription&&(v(this,et,"f").defaultDescription[t]=e.defaultDescription),e.skipValidation&&this.skipValidation(t);const n=e.describe||e.description||e.desc,r=v(this,pt,"f").getDescriptions();Object.prototype.hasOwnProperty.call(r,t)&&"string"!=typeof n||this.describe(t,n),e.hidden&&this.hide(t),e.requiresArg&&this.requiresArg(t)}return this}options(t,e){return this.option(t,e)}parse(t,e,s){h("[string|array] [function|boolean|object] [function]",[t,e,s],arguments.length),this[Ct](),void 0===t&&(t=v(this,ht,"f")),"object"==typeof e&&(O(this,rt,e,"f"),e=s),"function"==typeof e&&(O(this,nt,e,"f"),e=!1),e||O(this,ht,t,"f"),v(this,nt,"f")&&O(this,T,!1,"f");const i=this[Jt](t,!!e),n=this.parsed;return v(this,U,"f").setParsed(this.parsed),f(i)?i.then((t=>(v(this,nt,"f")&&v(this,nt,"f").call(this,v(this,V,"f"),t,v(this,tt,"f")),t))).catch((t=>{throw v(this,nt,"f")&&v(this,nt,"f")(t,this.parsed.argv,v(this,tt,"f")),t})).finally((()=>{this[Ht](),this.parsed=n})):(v(this,nt,"f")&&v(this,nt,"f").call(this,v(this,V,"f"),i,v(this,tt,"f")),this[Ht](),this.parsed=n,i)}parseAsync(t,e,s){const i=this.parse(t,e,s);return f(i)?i:Promise.resolve(i)}parseSync(t,s,i){const n=this.parse(t,s,i);if(f(n))throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");return n}parserConfiguration(t){return h("<object>",[t],arguments.length),O(this,it,t,"f"),this}pkgConf(t,e){h("<string> [string]",[t,e],arguments.length);let s=null;const i=this[At](e||v(this,W,"f"));return i[t]&&"object"==typeof i[t]&&(s=n(i[t],e||v(this,W,"f"),this[Mt]()["deep-merge-config"]||!1,v(this,ct,"f")),v(this,et,"f").configObjects=(v(this,et,"f").configObjects||[]).concat(s)),this}positional(t,e){h("<string> <object>",[t,e],arguments.length);const s=["default","defaultDescription","implies","normalize","choices","conflicts","coerce","type","describe","desc","description","alias"];e=g(e,((t,e)=>!("type"===t&&!["string","number","boolean"].includes(e))&&s.includes(t)));const i=v(this,q,"f").fullCommands[v(this,q,"f").fullCommands.length-1],n=i?v(this,z,"f").cmdToParseOptions(i):{array:[],alias:{},default:{},demand:{}};return p(n).forEach((s=>{const i=n[s];Array.isArray(i)?-1!==i.indexOf(t)&&(e[s]=!0):i[t]&&!(s in e)&&(e[s]=i[t])})),this.group(t,v(this,pt,"f").getPositionalGroupName()),this.option(t,e)}recommendCommands(t=!0){return h("[boolean]",[t],arguments.length),O(this,lt,t,"f"),this}required(t,e,s){return this.demand(t,e,s)}require(t,e,s){return this.demand(t,e,s)}requiresArg(t){return h("<array|string|object> [number]",[t],arguments.length),"string"==typeof t&&v(this,et,"f").narg[t]||this[St](this.requiresArg.bind(this),"narg",t,NaN),this}showCompletionScript(t,e){return h("[string] [string]",[t,e],arguments.length),t=t||this.$0,v(this,Q,"f").log(v(this,U,"f").generateCompletionScript(t,e||v(this,F,"f")||"completion")),this}showHelp(t){if(h("[string|function]",[t],arguments.length),O(this,J,!0,"f"),!v(this,pt,"f").hasCachedHelpMessage()){if(!this.parsed){const e=this[Jt](v(this,ht,"f"),void 0,void 0,0,!0);if(f(e))return e.then((()=>{v(this,pt,"f").showHelp(t)})),this}const e=v(this,z,"f").runDefaultBuilderOn(this);if(f(e))return e.then((()=>{v(this,pt,"f").showHelp(t)})),this}return v(this,pt,"f").showHelp(t),this}scriptName(t){return this.customScriptName=!0,this.$0=t,this}showHelpOnFail(t,e){return h("[boolean|string] [string]",[t,e],arguments.length),v(this,pt,"f").showHelpOnFail(t,e),this}showVersion(t){return h("[string|function]",[t],arguments.length),v(this,pt,"f").showVersion(t),this}skipValidation(t){return h("<array|string>",[t],arguments.length),this[Pt]("skipValidation",t),this}strict(t){return h("[boolean]",[t],arguments.length),O(this,ft,!1!==t,"f"),this}strictCommands(t){return h("[boolean]",[t],arguments.length),O(this,dt,!1!==t,"f"),this}strictOptions(t){return h("[boolean]",[t],arguments.length),O(this,ut,!1!==t,"f"),this}string(t){return h("<array|string>",[t],arguments.length),this[Pt]("string",t),this[Qt](t),this}terminalWidth(){return h([],0),v(this,ct,"f").process.stdColumns}updateLocale(t){return this.updateStrings(t)}updateStrings(t){return h("<object>",[t],arguments.length),O(this,G,!1,"f"),v(this,ct,"f").y18n.updateLocale(t),this}usage(t,s,i,n){if(h("<string|null|undefined> [string|boolean] [function|object] [function]",[t,s,i,n],arguments.length),void 0!==s){if(d(t,null,v(this,ct,"f")),(t||"").match(/^\$0( |$)/))return this.command(t,s,i,n);throw new e(".usage() description must start with $0 if being used as alias for .command()")}return v(this,pt,"f").usage(t),this}usageConfiguration(t){return h("<object>",[t],arguments.length),O(this,gt,t,"f"),this}version(t,e,s){const i="version";if(h("[boolean|string] [string] [string]",[t,e,s],arguments.length),v(this,mt,"f")&&(this[Ot](v(this,mt,"f")),v(this,pt,"f").version(void 0),O(this,mt,null,"f")),0===arguments.length)s=this[xt](),t=i;else if(1===arguments.length){if(!1===t)return this;s=t,t=i}else 2===arguments.length&&(s=e,e=void 0);return O(this,mt,"string"==typeof t?t:i,"f"),e=e||v(this,pt,"f").deferY18nLookup("Show version number"),v(this,pt,"f").version(s||void 0),this.boolean(v(this,mt,"f")),this.describe(v(this,mt,"f"),e),this}wrap(t){return h("<number|null|undefined>",[t],arguments.length),v(this,pt,"f").wrap(t),this}[(z=new WeakMap,W=new WeakMap,q=new WeakMap,U=new WeakMap,F=new WeakMap,L=new WeakMap,V=new WeakMap,G=new WeakMap,R=new WeakMap,T=new WeakMap,B=new WeakMap,Y=new WeakMap,K=new WeakMap,J=new WeakMap,Z=new WeakMap,X=new WeakMap,Q=new WeakMap,tt=new WeakMap,et=new WeakMap,st=new WeakMap,it=new WeakMap,nt=new WeakMap,rt=new WeakMap,ot=new WeakMap,at=new WeakMap,ht=new WeakMap,lt=new WeakMap,ct=new WeakMap,ft=new WeakMap,dt=new WeakMap,ut=new WeakMap,pt=new WeakMap,gt=new WeakMap,mt=new WeakMap,yt=new WeakMap,bt)](t){if(!t._||!t["--"])return t;t._.push.apply(t._,t["--"]);try{delete t["--"]}catch(t){}return t}[vt](){return{log:(...t)=>{this[Rt]()||console.log(...t),O(this,J,!0,"f"),v(this,tt,"f").length&&O(this,tt,v(this,tt,"f")+"\n","f"),O(this,tt,v(this,tt,"f")+t.join(" "),"f")},error:(...t)=>{this[Rt]()||console.error(...t),O(this,J,!0,"f"),v(this,tt,"f").length&&O(this,tt,v(this,tt,"f")+"\n","f"),O(this,tt,v(this,tt,"f")+t.join(" "),"f")}}}[Ot](t){p(v(this,et,"f")).forEach((e=>{if("configObjects"===e)return;const s=v(this,et,"f")[e];Array.isArray(s)?s.includes(t)&&s.splice(s.indexOf(t),1):"object"==typeof s&&delete s[t]})),delete v(this,pt,"f").getDescriptions()[t]}[wt](t,e,s){v(this,R,"f")[s]||(v(this,ct,"f").process.emitWarning(t,e),v(this,R,"f")[s]=!0)}[Ct](){v(this,B,"f").push({options:v(this,et,"f"),configObjects:v(this,et,"f").configObjects.slice(0),exitProcess:v(this,T,"f"),groups:v(this,K,"f"),strict:v(this,ft,"f"),strictCommands:v(this,dt,"f"),strictOptions:v(this,ut,"f"),completionCommand:v(this,F,"f"),output:v(this,tt,"f"),exitError:v(this,V,"f"),hasOutput:v(this,J,"f"),parsed:this.parsed,parseFn:v(this,nt,"f"),parseContext:v(this,rt,"f")}),v(this,pt,"f").freeze(),v(this,yt,"f").freeze(),v(this,z,"f").freeze(),v(this,Y,"f").freeze()}[jt](){let t,e="";return t=/\b(node|iojs|electron)(\.exe)?$/.test(v(this,ct,"f").process.argv()[0])?v(this,ct,"f").process.argv().slice(1,2):v(this,ct,"f").process.argv().slice(0,1),e=t.map((t=>{const e=this[Yt](v(this,W,"f"),t);return t.match(/^(\/|([a-zA-Z]:)?\\)/)&&e.length<t.length?e:t})).join(" ").trim(),v(this,ct,"f").getEnv("_")&&v(this,ct,"f").getProcessArgvBin()===v(this,ct,"f").getEnv("_")&&(e=v(this,ct,"f").getEnv("_").replace(`${v(this,ct,"f").path.dirname(v(this,ct,"f").process.execPath())}/`,"")),e}[Mt](){return v(this,it,"f")}[_t](){return v(this,gt,"f")}[kt](){if(!v(this,G,"f"))return;const t=v(this,ct,"f").getEnv("LC_ALL")||v(this,ct,"f").getEnv("LC_MESSAGES")||v(this,ct,"f").getEnv("LANG")||v(this,ct,"f").getEnv("LANGUAGE")||"en_US";this.locale(t.replace(/[.:].*/,""))}[xt](){return this[At]().version||"unknown"}[Et](t){const e=t["--"]?t["--"]:t._;for(let t,s=0;void 0!==(t=e[s]);s++)v(this,ct,"f").Parser.looksLikeNumber(t)&&Number.isSafeInteger(Math.floor(parseFloat(`${t}`)))&&(e[s]=Number(t));return t}[At](t){const e=t||"*";if(v(this,ot,"f")[e])return v(this,ot,"f")[e];let s={};try{let e=t||v(this,ct,"f").mainFilename;!t&&v(this,ct,"f").path.extname(e)&&(e=v(this,ct,"f").path.dirname(e));const i=v(this,ct,"f").findUp(e,((t,e)=>e.includes("package.json")?"package.json":void 0));d(i,void 0,v(this,ct,"f")),s=JSON.parse(v(this,ct,"f").readFileSync(i,"utf8"))}catch(t){}return v(this,ot,"f")[e]=s||{},v(this,ot,"f")[e]}[Pt](t,e){(e=[].concat(e)).forEach((e=>{e=this[Dt](e),v(this,et,"f")[t].push(e)}))}[St](t,e,s,i){this[It](t,e,s,i,((t,e,s)=>{v(this,et,"f")[t][e]=s}))}[$t](t,e,s,i){this[It](t,e,s,i,((t,e,s)=>{v(this,et,"f")[t][e]=(v(this,et,"f")[t][e]||[]).concat(s)}))}[It](t,e,s,i,n){if(Array.isArray(s))s.forEach((e=>{t(e,i)}));else if((t=>"object"==typeof t)(s))for(const e of p(s))t(e,s[e]);else n(e,this[Dt](s),i)}[Dt](t){return"__proto__"===t?"___proto___":t}[Nt](t,e){return this[St](this[Nt].bind(this),"key",t,e),this}[Ht](){var t,e,s,i,n,r,o,a,h,l,c,f;const u=v(this,B,"f").pop();let p;d(u,void 0,v(this,ct,"f")),t=this,e=this,s=this,i=this,n=this,r=this,o=this,a=this,h=this,l=this,c=this,f=this,({options:{set value(e){O(t,et,e,"f")}}.value,configObjects:p,exitProcess:{set value(t){O(e,T,t,"f")}}.value,groups:{set value(t){O(s,K,t,"f")}}.value,output:{set value(t){O(i,tt,t,"f")}}.value,exitError:{set value(t){O(n,V,t,"f")}}.value,hasOutput:{set value(t){O(r,J,t,"f")}}.value,parsed:this.parsed,strict:{set value(t){O(o,ft,t,"f")}}.value,strictCommands:{set value(t){O(a,dt,t,"f")}}.value,strictOptions:{set value(t){O(h,ut,t,"f")}}.value,completionCommand:{set value(t){O(l,F,t,"f")}}.value,parseFn:{set value(t){O(c,nt,t,"f")}}.value,parseContext:{set value(t){O(f,rt,t,"f")}}.value}=u),v(this,et,"f").configObjects=p,v(this,pt,"f").unfreeze(),v(this,yt,"f").unfreeze(),v(this,z,"f").unfreeze(),v(this,Y,"f").unfreeze()}[zt](t,e){return j(e,(e=>(t(e),e)))}getInternalMethods(){return{getCommandInstance:this[Wt].bind(this),getContext:this[qt].bind(this),getHasOutput:this[Ut].bind(this),getLoggerInstance:this[Ft].bind(this),getParseContext:this[Lt].bind(this),getParserConfiguration:this[Mt].bind(this),getUsageConfiguration:this[_t].bind(this),getUsageInstance:this[Vt].bind(this),getValidationInstance:this[Gt].bind(this),hasParseCallback:this[Rt].bind(this),isGlobalContext:this[Tt].bind(this),postProcess:this[Bt].bind(this),reset:this[Kt].bind(this),runValidation:this[Zt].bind(this),runYargsParserAndExecuteCommands:this[Jt].bind(this),setHasOutput:this[Xt].bind(this)}}[Wt](){return v(this,z,"f")}[qt](){return v(this,q,"f")}[Ut](){return v(this,J,"f")}[Ft](){return v(this,Q,"f")}[Lt](){return v(this,rt,"f")||{}}[Vt](){return v(this,pt,"f")}[Gt](){return v(this,yt,"f")}[Rt](){return!!v(this,nt,"f")}[Tt](){return v(this,X,"f")}[Bt](t,e,s,i){if(s)return t;if(f(t))return t;e||(t=this[bt](t));return(this[Mt]()["parse-positional-numbers"]||void 0===this[Mt]()["parse-positional-numbers"])&&(t=this[Et](t)),i&&(t=C(t,this,v(this,Y,"f").getMiddleware(),!1)),t}[Kt](t={}){O(this,et,v(this,et,"f")||{},"f");const e={};e.local=v(this,et,"f").local||[],e.configObjects=v(this,et,"f").configObjects||[];const s={};e.local.forEach((e=>{s[e]=!0,(t[e]||[]).forEach((t=>{s[t]=!0}))})),Object.assign(v(this,at,"f"),Object.keys(v(this,K,"f")).reduce(((t,e)=>{const i=v(this,K,"f")[e].filter((t=>!(t in s)));return i.length>0&&(t[e]=i),t}),{})),O(this,K,{},"f");return["array","boolean","string","skipValidation","count","normalize","number","hiddenOptions"].forEach((t=>{e[t]=(v(this,et,"f")[t]||[]).filter((t=>!s[t]))})),["narg","key","alias","default","defaultDescription","config","choices","demandedOptions","demandedCommands","deprecatedOptions"].forEach((t=>{e[t]=g(v(this,et,"f")[t],(t=>!s[t]))})),e.envPrefix=v(this,et,"f").envPrefix,O(this,et,e,"f"),O(this,pt,v(this,pt,"f")?v(this,pt,"f").reset(s):P(this,v(this,ct,"f")),"f"),O(this,yt,v(this,yt,"f")?v(this,yt,"f").reset(s):function(t,e,s){const i=s.y18n.__,n=s.y18n.__n,r={nonOptionCount:function(s){const i=t.getDemandedCommands(),r=s._.length+(s["--"]?s["--"].length:0)-t.getInternalMethods().getContext().commands.length;i._&&(r<i._.min||r>i._.max)&&(r<i._.min?void 0!==i._.minMsg?e.fail(i._.minMsg?i._.minMsg.replace(/\$0/g,r.toString()).replace(/\$1/,i._.min.toString()):null):e.fail(n("Not enough non-option arguments: got %s, need at least %s","Not enough non-option arguments: got %s, need at least %s",r,r.toString(),i._.min.toString())):r>i._.max&&(void 0!==i._.maxMsg?e.fail(i._.maxMsg?i._.maxMsg.replace(/\$0/g,r.toString()).replace(/\$1/,i._.max.toString()):null):e.fail(n("Too many non-option arguments: got %s, maximum of %s","Too many non-option arguments: got %s, maximum of %s",r,r.toString(),i._.max.toString()))))},positionalCount:function(t,s){s<t&&e.fail(n("Not enough non-option arguments: got %s, need at least %s","Not enough non-option arguments: got %s, need at least %s",s,s+"",t+""))},requiredArguments:function(t,s){let i=null;for(const e of Object.keys(s))Object.prototype.hasOwnProperty.call(t,e)&&void 0!==t[e]||(i=i||{},i[e]=s[e]);if(i){const t=[];for(const e of Object.keys(i)){const s=i[e];s&&t.indexOf(s)<0&&t.push(s)}const s=t.length?`\n${t.join("\n")}`:"";e.fail(n("Missing required argument: %s","Missing required arguments: %s",Object.keys(i).length,Object.keys(i).join(", ")+s))}},unknownArguments:function(s,i,o,a,h=!0){var l;const c=t.getInternalMethods().getCommandInstance().getCommands(),f=[],d=t.getInternalMethods().getContext();if(Object.keys(s).forEach((e=>{H.includes(e)||Object.prototype.hasOwnProperty.call(o,e)||Object.prototype.hasOwnProperty.call(t.getInternalMethods().getParseContext(),e)||r.isValidAndSomeAliasIsNotNew(e,i)||f.push(e)})),h&&(d.commands.length>0||c.length>0||a)&&s._.slice(d.commands.length).forEach((t=>{c.includes(""+t)||f.push(""+t)})),h){const e=(null===(l=t.getDemandedCommands()._)||void 0===l?void 0:l.max)||0,i=d.commands.length+e;i<s._.length&&s._.slice(i).forEach((t=>{t=String(t),d.commands.includes(t)||f.includes(t)||f.push(t)}))}f.length&&e.fail(n("Unknown argument: %s","Unknown arguments: %s",f.length,f.map((t=>t.trim()?t:`"${t}"`)).join(", ")))},unknownCommands:function(s){const i=t.getInternalMethods().getCommandInstance().getCommands(),r=[],o=t.getInternalMethods().getContext();return(o.commands.length>0||i.length>0)&&s._.slice(o.commands.length).forEach((t=>{i.includes(""+t)||r.push(""+t)})),r.length>0&&(e.fail(n("Unknown command: %s","Unknown commands: %s",r.length,r.join(", "))),!0)},isValidAndSomeAliasIsNotNew:function(e,s){if(!Object.prototype.hasOwnProperty.call(s,e))return!1;const i=t.parsed.newAliases;return[e,...s[e]].some((t=>!Object.prototype.hasOwnProperty.call(i,t)||!i[e]))},limitedChoices:function(s){const n=t.getOptions(),r={};if(!Object.keys(n.choices).length)return;Object.keys(s).forEach((t=>{-1===H.indexOf(t)&&Object.prototype.hasOwnProperty.call(n.choices,t)&&[].concat(s[t]).forEach((e=>{-1===n.choices[t].indexOf(e)&&void 0!==e&&(r[t]=(r[t]||[]).concat(e))}))}));const o=Object.keys(r);if(!o.length)return;let a=i("Invalid values:");o.forEach((t=>{a+=`\n  ${i("Argument: %s, Given: %s, Choices: %s",t,e.stringifiedValues(r[t]),e.stringifiedValues(n.choices[t]))}`})),e.fail(a)}};let o={};function a(t,e){const s=Number(e);return"number"==typeof(e=isNaN(s)?e:s)?e=t._.length>=e:e.match(/^--no-.+/)?(e=e.match(/^--no-(.+)/)[1],e=!Object.prototype.hasOwnProperty.call(t,e)):e=Object.prototype.hasOwnProperty.call(t,e),e}r.implies=function(e,i){h("<string|object> [array|number|string]",[e,i],arguments.length),"object"==typeof e?Object.keys(e).forEach((t=>{r.implies(t,e[t])})):(t.global(e),o[e]||(o[e]=[]),Array.isArray(i)?i.forEach((t=>r.implies(e,t))):(d(i,void 0,s),o[e].push(i)))},r.getImplied=function(){return o},r.implications=function(t){const s=[];if(Object.keys(o).forEach((e=>{const i=e;(o[e]||[]).forEach((e=>{let n=i;const r=e;n=a(t,n),e=a(t,e),n&&!e&&s.push(` ${i} -> ${r}`)}))})),s.length){let t=`${i("Implications failed:")}\n`;s.forEach((e=>{t+=e})),e.fail(t)}};let l={};r.conflicts=function(e,s){h("<string|object> [array|string]",[e,s],arguments.length),"object"==typeof e?Object.keys(e).forEach((t=>{r.conflicts(t,e[t])})):(t.global(e),l[e]||(l[e]=[]),Array.isArray(s)?s.forEach((t=>r.conflicts(e,t))):l[e].push(s))},r.getConflicting=()=>l,r.conflicting=function(n){Object.keys(n).forEach((t=>{l[t]&&l[t].forEach((s=>{s&&void 0!==n[t]&&void 0!==n[s]&&e.fail(i("Arguments %s and %s are mutually exclusive",t,s))}))})),t.getInternalMethods().getParserConfiguration()["strip-dashed"]&&Object.keys(l).forEach((t=>{l[t].forEach((r=>{r&&void 0!==n[s.Parser.camelCase(t)]&&void 0!==n[s.Parser.camelCase(r)]&&e.fail(i("Arguments %s and %s are mutually exclusive",t,r))}))}))},r.recommendCommands=function(t,s){s=s.sort(((t,e)=>e.length-t.length));let n=null,r=1/0;for(let e,i=0;void 0!==(e=s[i]);i++){const s=N(t,e);s<=3&&s<r&&(r=s,n=e)}n&&e.fail(i("Did you mean %s?",n))},r.reset=function(t){return o=g(o,(e=>!t[e])),l=g(l,(e=>!t[e])),r};const c=[];return r.freeze=function(){c.push({implied:o,conflicting:l})},r.unfreeze=function(){const t=c.pop();d(t,void 0,s),({implied:o,conflicting:l}=t)},r}(this,v(this,pt,"f"),v(this,ct,"f")),"f"),O(this,z,v(this,z,"f")?v(this,z,"f").reset():function(t,e,s,i){return new _(t,e,s,i)}(v(this,pt,"f"),v(this,yt,"f"),v(this,Y,"f"),v(this,ct,"f")),"f"),v(this,U,"f")||O(this,U,function(t,e,s,i){return new D(t,e,s,i)}(this,v(this,pt,"f"),v(this,z,"f"),v(this,ct,"f")),"f"),v(this,Y,"f").reset(),O(this,F,null,"f"),O(this,tt,"","f"),O(this,V,null,"f"),O(this,J,!1,"f"),this.parsed=!1,this}[Yt](t,e){return v(this,ct,"f").path.relative(t,e)}[Jt](t,s,i,n=0,r=!1){let o=!!i||r;t=t||v(this,ht,"f"),v(this,et,"f").__=v(this,ct,"f").y18n.__,v(this,et,"f").configuration=this[Mt]();const a=!!v(this,et,"f").configuration["populate--"],h=Object.assign({},v(this,et,"f").configuration,{"populate--":!0}),l=v(this,ct,"f").Parser.detailed(t,Object.assign({},v(this,et,"f"),{configuration:{"parse-positional-numbers":!1,...h}})),c=Object.assign(l.argv,v(this,rt,"f"));let d;const u=l.aliases;let p=!1,g=!1;Object.keys(c).forEach((t=>{t===v(this,Z,"f")&&c[t]?p=!0:t===v(this,mt,"f")&&c[t]&&(g=!0)})),c.$0=this.$0,this.parsed=l,0===n&&v(this,pt,"f").clearCachedHelpMessage();try{if(this[kt](),s)return this[Bt](c,a,!!i,!1);if(v(this,Z,"f")){[v(this,Z,"f")].concat(u[v(this,Z,"f")]||[]).filter((t=>t.length>1)).includes(""+c._[c._.length-1])&&(c._.pop(),p=!0)}O(this,X,!1,"f");const h=v(this,z,"f").getCommands(),m=v(this,U,"f").completionKey in c,y=p||m||r;if(c._.length){if(h.length){let t;for(let e,s=n||0;void 0!==c._[s];s++){if(e=String(c._[s]),h.includes(e)&&e!==v(this,F,"f")){const t=v(this,z,"f").runCommand(e,this,l,s+1,r,p||g||r);return this[Bt](t,a,!!i,!1)}if(!t&&e!==v(this,F,"f")){t=e;break}}!v(this,z,"f").hasDefaultCommand()&&v(this,lt,"f")&&t&&!y&&v(this,yt,"f").recommendCommands(t,h)}v(this,F,"f")&&c._.includes(v(this,F,"f"))&&!m&&(v(this,T,"f")&&E(!0),this.showCompletionScript(),this.exit(0))}if(v(this,z,"f").hasDefaultCommand()&&!y){const t=v(this,z,"f").runCommand(null,this,l,0,r,p||g||r);return this[Bt](t,a,!!i,!1)}if(m){v(this,T,"f")&&E(!0);const s=(t=[].concat(t)).slice(t.indexOf(`--${v(this,U,"f").completionKey}`)+1);return v(this,U,"f").getCompletion(s,((t,s)=>{if(t)throw new e(t.message);(s||[]).forEach((t=>{v(this,Q,"f").log(t)})),this.exit(0)})),this[Bt](c,!a,!!i,!1)}if(v(this,J,"f")||(p?(v(this,T,"f")&&E(!0),o=!0,this.showHelp("log"),this.exit(0)):g&&(v(this,T,"f")&&E(!0),o=!0,v(this,pt,"f").showVersion("log"),this.exit(0))),!o&&v(this,et,"f").skipValidation.length>0&&(o=Object.keys(c).some((t=>v(this,et,"f").skipValidation.indexOf(t)>=0&&!0===c[t]))),!o){if(l.error)throw new e(l.error.message);if(!m){const t=this[Zt](u,{},l.error);i||(d=C(c,this,v(this,Y,"f").getMiddleware(),!0)),d=this[zt](t,null!=d?d:c),f(d)&&!i&&(d=d.then((()=>C(c,this,v(this,Y,"f").getMiddleware(),!1))))}}}catch(t){if(!(t instanceof e))throw t;v(this,pt,"f").fail(t.message,t)}return this[Bt](null!=d?d:c,a,!!i,!0)}[Zt](t,s,i,n){const r={...this.getDemandedOptions()};return o=>{if(i)throw new e(i.message);v(this,yt,"f").nonOptionCount(o),v(this,yt,"f").requiredArguments(o,r);let a=!1;v(this,dt,"f")&&(a=v(this,yt,"f").unknownCommands(o)),v(this,ft,"f")&&!a?v(this,yt,"f").unknownArguments(o,t,s,!!n):v(this,ut,"f")&&v(this,yt,"f").unknownArguments(o,t,{},!1,!1),v(this,yt,"f").limitedChoices(o),v(this,yt,"f").implications(o),v(this,yt,"f").conflicting(o)}}[Xt](){O(this,J,!0,"f")}[Qt](t){if("string"==typeof t)v(this,et,"f").key[t]=!0;else for(const e of t)v(this,et,"f").key[e]=!0}}var ee,se;const{readFileSync:ie}=__webpack_require__(/*! fs */ "fs"),{inspect:ne}=__webpack_require__(/*! util */ "util"),{resolve:re}=__webpack_require__(/*! path */ "path"),oe=__webpack_require__(/*! y18n */ "./node_modules/y18n/build/index.cjs"),ae=__webpack_require__(/*! yargs-parser */ "./node_modules/yargs/node_modules/yargs-parser/build/index.cjs");var he,le={assert:{notStrictEqual:t.notStrictEqual,strictEqual:t.strictEqual},cliui:__webpack_require__(/*! cliui */ "./node_modules/cliui/build/index.cjs"),findUp:__webpack_require__(/*! escalade/sync */ "./node_modules/escalade/sync/index.js"),getEnv:t=>process.env[t],getCallerFile:__webpack_require__(/*! get-caller-file */ "./node_modules/get-caller-file/index.js"),getProcessArgvBin:y,inspect:ne,mainFilename:null!==(se=null===(ee= false||void 0===__webpack_require__("./node_modules/yargs/build sync recursive")?void 0:__webpack_require__.c[__webpack_require__.s])||void 0===ee?void 0:ee.filename)&&void 0!==se?se:process.cwd(),Parser:ae,path:__webpack_require__(/*! path */ "path"),process:{argv:()=>process.argv,cwd:process.cwd,emitWarning:(t,e)=>process.emitWarning(t,e),execPath:()=>process.execPath,exit:t=>{process.exit(t)},nextTick:process.nextTick,stdColumns:void 0!==process.stdout.columns?process.stdout.columns:null},readFileSync:ie,require:__webpack_require__("./node_modules/yargs/build sync recursive"),requireDirectory:__webpack_require__(/*! require-directory */ "./node_modules/require-directory/index.js"),stringWidth:__webpack_require__(/*! string-width */ "./node_modules/string-width/index.js"),y18n:oe({directory:re(__dirname,"../locales"),updateFiles:!1})};const ce=(null===(he=null===process||void 0===process?void 0:process.env)||void 0===he?void 0:he.YARGS_MIN_NODE_VERSION)?Number(process.env.YARGS_MIN_NODE_VERSION):12;if(process&&process.version){if(Number(process.version.match(/v([^.]+)/)[1])<ce)throw Error(`yargs supports a minimum Node.js version of ${ce}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`)}const fe=__webpack_require__(/*! yargs-parser */ "./node_modules/yargs/node_modules/yargs-parser/build/index.cjs");var de,ue={applyExtends:n,cjsPlatformShim:le,Yargs:(de=le,(t=[],e=de.process.cwd(),s)=>{const i=new te(t,e,s,de);return Object.defineProperty(i,"argv",{get:()=>i.parse(),enumerable:!0}),i.help(),i.version(),i}),argsert:h,isPromise:f,objFilter:g,parseCommand:o,Parser:fe,processArgv:b,YError:e};module.exports=ue;


/***/ }),

/***/ "./node_modules/yargs/index.cjs":
/*!**************************************!*\
  !*** ./node_modules/yargs/index.cjs ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// classic singleton yargs API, to use yargs
// without running as a singleton do:
// require('yargs/yargs')(process.argv.slice(2))
const {Yargs, processArgv} = __webpack_require__(/*! ./build/index.cjs */ "./node_modules/yargs/build/index.cjs");

Argv(processArgv.hideBin(process.argv));

module.exports = Argv;

function Argv(processArgs, cwd) {
  const argv = Yargs(processArgs, cwd, __webpack_require__("./node_modules/yargs sync recursive"));
  singletonify(argv);
  // TODO(bcoe): warn if argv.parse() or argv.argv is used directly.
  return argv;
}

function defineGetter(obj, key, getter) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get: getter,
  });
}
function lookupGetter(obj, key) {
  const desc = Object.getOwnPropertyDescriptor(obj, key);
  if (typeof desc !== 'undefined') {
    return desc.get;
  }
}

/*  Hack an instance of Argv with process.argv into Argv
    so people can do
    require('yargs')(['--beeble=1','-z','zizzle']).argv
    to parse a list of args and
    require('yargs').argv
    to get a parsed version of process.argv.
*/
function singletonify(inst) {
  [
    ...Object.keys(inst),
    ...Object.getOwnPropertyNames(inst.constructor.prototype),
  ].forEach(key => {
    if (key === 'argv') {
      defineGetter(Argv, key, lookupGetter(inst, key));
    } else if (typeof inst[key] === 'function') {
      Argv[key] = inst[key].bind(inst);
    } else {
      defineGetter(Argv, '$0', () => inst.$0);
      defineGetter(Argv, 'parsed', () => inst.parsed);
    }
  });
}


/***/ }),

/***/ "./node_modules/yargs/node_modules/yargs-parser/build/index.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/yargs/node_modules/yargs-parser/build/index.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");

function camelCase(str) {
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
        str = str.toLowerCase();
    }
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    }
    else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
            }
            else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        }
        else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined)
        return false;
    if (typeof x === 'number')
        return true;
    if (/^0x[0-9a-f]+$/i.test(x))
        return true;
    if (/^0[^.]/.test(x))
        return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map(e => typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        if (c === opening) {
            opening = null;
        }
        else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i])
            args[i] = '';
        args[i] += c;
    }
    return args;
}

var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey) {
    DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey["STRING"] = "string";
    DefaultValuesForTypeKey["NUMBER"] = "number";
    DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

let mixin;
class YargsParser {
    constructor(_mixin) {
        mixin = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === 'string';
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value]) => {
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value]) => {
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
            }
            else if (truncatedArg.match(/^---+(=|$)/)) {
                pushPositional(arg);
                continue;
            }
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2], true);
                    }
                }
            }
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
            }
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
            }
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) {
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            }
            else {
                for (ii = i + 1; ii < args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii < (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
                }
                for (let ii = i + 1; ii < args.length; ii++) {
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
                }
            }
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function (prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split('.');
                    const a = [].concat(splitKey);
                    a.shift();
                    keyProperties = keyProperties.concat(a);
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === 'string' ? mixin.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val, shouldStripQuotes) {
            if (shouldStripQuotes) {
                val = stripQuotes(val);
            }
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string')
                    val = val === 'true';
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) => { return mixin.normalize(val); });
                else
                    value = mixin.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        function setConfig(argv) {
            const configLookup = Object.create(null);
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    setConfigObject(value, fullKey);
                }
                else {
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    const keys = envVar.split('__').map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) {
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) => {
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [value];
            }
            else if (duplicate && !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) {
                o[key] = [o[key], value];
            }
            else {
                o[key] = value;
            }
        }
        function extendAliases(...args) {
            args.forEach(function (obj) {
                Object.keys(obj || {}).forEach(function (key) {
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function (x) {
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key => keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k => flags[k]));
            return toCheck.some(function (flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        function hasAllShortFlags(arg) {
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for (let j = 0; j < letters.length; j++) {
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if ((letters[j + 1] && letters[j + 1] === '=') ||
                    next === '-' ||
                    (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] && letters[j + 1].match(/\W/))) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            arg = arg.replace(/^-{3,}/, '--');
            if (arg.match(negative)) {
                return false;
            }
            if (hasAllShortFlags(arg)) {
                return false;
            }
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            const normalFlag = /^-+([^=]+?)$/;
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts) &&
                `${key}` in defaults) {
                return defaults[key];
            }
            else {
                return defaultForType(guessType(key));
            }
        }
        function defaultForType(type) {
            const def = {
                [DefaultValuesForTypeKey.BOOLEAN]: true,
                [DefaultValuesForTypeKey.STRING]: '',
                [DefaultValuesForTypeKey.NUMBER]: undefined,
                [DefaultValuesForTypeKey.ARRAY]: []
            };
            return def[type];
        }
        function guessType(key) {
            let type = DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = DefaultValuesForTypeKey.ARRAY;
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        function checkConfiguration() {
            Object.keys(flags.counts).find(key => {
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                }
                else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function (key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
            for (let ii = i + 1; ii < aliasArrays.length; ii++) {
                const intersect = aliasArrays[i].filter(function (v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
    if (key === '__proto__')
        return '___proto___';
    return key;
}
function stripQuotes(val) {
    return (typeof val === 'string' &&
        (val[0] === "'" || val[0] === '"') &&
        val[val.length - 1] === val[0])
        ? val.substring(1, val.length - 1)
        : val;
}

var _a, _b, _c;
const minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)
    ? Number(process.env.YARGS_MIN_NODE_VERSION)
    : 12;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
}
const env = process ? process.env : {};
const parser = new YargsParser({
    cwd: process.cwd,
    env: () => {
        return env;
    },
    format: util.format,
    normalize: path.normalize,
    resolve: path.resolve,
    require: (path) => {
        if (true) {
            return __webpack_require__("./node_modules/yargs/node_modules/yargs-parser/build sync recursive")(path);
        }
        else {}
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function (args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;

module.exports = yargsParser;


/***/ }),

/***/ "./node_modules/data-uri-to-buffer/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/data-uri-to-buffer/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataUriToBuffer: () => (/* binding */ dataUriToBuffer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */
function dataUriToBuffer(uri) {
    if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    // strip newlines
    uri = uri.replace(/\r?\n/g, '');
    // split the URI up into the "metadata" and the "data" portions
    const firstComma = uri.indexOf(',');
    if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError('malformed data: URI');
    }
    // remove the "data:" scheme and parse the metadata
    const meta = uri.substring(5, firstComma).split(';');
    let charset = '';
    let base64 = false;
    const type = meta[0] || 'text/plain';
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) {
        if (meta[i] === 'base64') {
            base64 = true;
        }
        else if (meta[i]) {
            typeFull += `;${meta[i]}`;
            if (meta[i].indexOf('charset=') === 0) {
                charset = meta[i].substring(8);
            }
        }
    }
    // defaults to US-ASCII only if type is not provided
    if (!meta[0] && !charset.length) {
        typeFull += ';charset=US-ASCII';
        charset = 'US-ASCII';
    }
    // get the encoded data portion and decode URI-encoded chars
    const encoding = base64 ? 'base64' : 'ascii';
    const data = unescape(uri.substring(firstComma + 1));
    const buffer = Buffer.from(data, encoding);
    // set `.type` and `.typeFull` properties to MIME type
    buffer.type = type;
    buffer.typeFull = typeFull;
    // set the `.charset` property
    buffer.charset = charset;
    return buffer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataUriToBuffer);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/fetch-blob/file.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/file.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");


const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #lastModified = 0
  #name = ''

  /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */// @ts-ignore
  constructor (fileBits, fileName, options = {}) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)
    }
    super(fileBits, options)

    if (options === null) options = {}

    // Simulate WebIDL type casting for NaN value in lastModified option.
    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)
    if (!Number.isNaN(lastModified)) {
      this.#lastModified = lastModified
    }

    this.#name = String(fileName)
  }

  get name () {
    return this.#name
  }

  get lastModified () {
    return this.#lastModified
  }

  get [Symbol.toStringTag] () {
    return 'File'
  }

  static [Symbol.hasInstance] (object) {
    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] &&
      /^(File)$/.test(object[Symbol.toStringTag])
  }
}

/** @type {typeof globalThis.File} */// @ts-ignore
const File = _File
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);


/***/ }),

/***/ "./node_modules/fetch-blob/from.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/from.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   blobFrom: () => (/* binding */ blobFrom),
/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fileFrom: () => (/* binding */ fileFrom),
/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-domexception */ "./node_modules/node-domexception/index.js");
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ "./node_modules/fetch-blob/file.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");







const { stat } = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const blobFromSync = (path, type) => fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<Blob>}
 */
const blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<File>}
 */
const fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const fileFromSync = (path, type) => fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)

// @ts-ignore
const fromBlob = (stat, path, type = '') => new _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], { type })

// @ts-ignore
const fromFile = (stat, path, type = '') => new _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), { type, lastModified: stat.mtimeMs })

/**
 * This is a blob backed up by a file on the disk
 * with minium requirement. Its wrapped around a Blob as a blobPart
 * so you have no direct access to this.
 *
 * @private
 */
class BlobDataItem {
  #path
  #start

  constructor (options) {
    this.#path = options.path
    this.#start = options.start
    this.size = options.size
    this.lastModified = options.lastModified
  }

  /**
   * Slicing arguments is first validated and formatted
   * to not be out of range by Blob.prototype.slice
   */
  slice (start, end) {
    return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
    })
  }

  async * stream () {
    const { mtimeMs } = await stat(this.#path)
    if (mtimeMs > this.lastModified) {
      throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')
    }
    yield * (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
    })
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);



/***/ }),

/***/ "./node_modules/fetch-blob/index.js":
/*!******************************************!*\
  !*** ./node_modules/fetch-blob/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* binding */ Blob),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streams.cjs */ "./node_modules/fetch-blob/streams.cjs");
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */

// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core



// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

/** @param {(Blob | Uint8Array)[]} parts */
async function * toIterator (parts, clone = true) {
  for (const part of parts) {
    if ('stream' in part) {
      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position = part.byteOffset
        const end = part.byteOffset + part.byteLength
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE)
          const chunk = part.buffer.slice(position, position + size)
          position += chunk.byteLength
          yield new Uint8Array(chunk)
        }
      } else {
        yield part
      }
    /* c8 ignore next 10 */
    } else {
      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
      let position = 0, b = (/** @type {Blob} */ (part))
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))
        const buffer = await chunk.arrayBuffer()
        position += buffer.byteLength
        yield new Uint8Array(buffer)
      }
    }
  }
}

const _Blob = class Blob {
  /** @type {Array.<(Blob|Uint8Array)>} */
  #parts = []
  #type = ''
  #size = 0
  #endings = 'transparent'

  /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */
  constructor (blobParts = [], options = {}) {
    if (typeof blobParts !== 'object' || blobParts === null) {
      throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.')
    }

    if (typeof blobParts[Symbol.iterator] !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.')
    }

    if (typeof options !== 'object' && typeof options !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.')
    }

    if (options === null) options = {}

    const encoder = new TextEncoder()
    for (const element of blobParts) {
      let part
      if (ArrayBuffer.isView(element)) {
        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))
      } else if (element instanceof ArrayBuffer) {
        part = new Uint8Array(element.slice(0))
      } else if (element instanceof Blob) {
        part = element
      } else {
        part = encoder.encode(`${element}`)
      }

      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size
      this.#parts.push(part)
    }

    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`
    const type = options.type === undefined ? '' : String(options.type)
    this.#type = /^[\x20-\x7E]*$/.test(type) ? type : ''
  }

  /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */
  get size () {
    return this.#size
  }

  /**
   * The type property of a Blob object returns the MIME type of the file.
   */
  get type () {
    return this.#type
  }

  /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */
  async text () {
    // More optimized than using this.arrayBuffer()
    // that requires twice as much ram
    const decoder = new TextDecoder()
    let str = ''
    for await (const part of toIterator(this.#parts, false)) {
      str += decoder.decode(part, { stream: true })
    }
    // Remaining
    str += decoder.decode()
    return str
  }

  /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */
  async arrayBuffer () {
    // Easier way... Just a unnecessary overhead
    // const view = new Uint8Array(this.size);
    // await this.stream().getReader({mode: 'byob'}).read(view);
    // return view.buffer;

    const data = new Uint8Array(this.size)
    let offset = 0
    for await (const chunk of toIterator(this.#parts, false)) {
      data.set(chunk, offset)
      offset += chunk.length
    }

    return data.buffer
  }

  stream () {
    const it = toIterator(this.#parts, true)

    return new globalThis.ReadableStream({
      // @ts-ignore
      type: 'bytes',
      async pull (ctrl) {
        const chunk = await it.next()
        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)
      },

      async cancel () {
        await it.return()
      }
    })
  }

  /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */
  slice (start = 0, end = this.size, type = '') {
    const { size } = this

    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)

    const span = Math.max(relativeEnd - relativeStart, 0)
    const parts = this.#parts
    const blobParts = []
    let added = 0

    for (const part of parts) {
      // don't add the overflow to new blobParts
      if (added >= span) {
        break
      }

      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size
      if (relativeStart && size <= relativeStart) {
        // Skip the beginning and change the relative
        // start & end position as we skip the unwanted parts
        relativeStart -= size
        relativeEnd -= size
      } else {
        let chunk
        if (ArrayBuffer.isView(part)) {
          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))
          added += chunk.byteLength
        } else {
          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))
          added += chunk.size
        }
        relativeEnd -= size
        blobParts.push(chunk)
        relativeStart = 0 // All next sequential parts should start at 0
      }
    }

    const blob = new Blob([], { type: String(type).toLowerCase() })
    blob.#size = span
    blob.#parts = blobParts

    return blob
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }

  static [Symbol.hasInstance] (object) {
    return (
      object &&
      typeof object === 'object' &&
      typeof object.constructor === 'function' &&
      (
        typeof object.stream === 'function' ||
        typeof object.arrayBuffer === 'function'
      ) &&
      /^(Blob|File)$/.test(object[Symbol.toStringTag])
    )
  }
}

Object.defineProperties(_Blob.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
})

/** @type {typeof globalThis.Blob} */
const Blob = _Blob
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);


/***/ }),

/***/ "./node_modules/formdata-polyfill/esm.min.js":
/*!***************************************************!*\
  !*** ./node_modules/formdata-polyfill/esm.min.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   FormData: () => (/* binding */ FormData),
/* harmony export */   formDataToBlob: () => (/* binding */ formDataToBlob)
/* harmony export */ });
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fetch-blob/file.js */ "./node_modules/fetch-blob/file.js");
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */




var {toStringTag:t,iterator:i,hasInstance:h}=Symbol,
r=Math.random,
m='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
f=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]([b],c,b):b]:[a,b+'']),
e=(c,f)=>(f?c:c.replace(/\r?\n|\r/g,'\r\n')).replace(/\n/g,'%0A').replace(/\r/g,'%0D').replace(/"/g,'%22'),
x=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}

const File = fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]

/** @type {typeof globalThis.FormData} */
const FormData = class FormData {
#d=[];
constructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}
get [t]() {return 'FormData'}
[i](){return this.entries()}
static [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}
append(...a){x('append',arguments,2);this.#d.push(f(...a))}
delete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}
get(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}
getAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}
has(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}
forEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}
set(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}
*entries(){yield*this.#d}
*keys(){for(var[a]of this)yield a}
*values(){for(var[,a]of this)yield a}}

/** @param {FormData} F */
function formDataToBlob (F,B=fetch_blob__WEBPACK_IMPORTED_MODULE_0__["default"]){
var b=`${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\r\nContent-Disposition: form-data; name="`
F.forEach((v,n)=>typeof v=='string'
?c.push(p+e(n)+`"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`)
:c.push(p+e(n)+`"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type||"application/octet-stream"}\r\n\r\n`, v, '\r\n'))
c.push(`--${b}--`)
return new B(c,{type:"multipart/form-data; boundary="+b})}


/***/ }),

/***/ "./node_modules/node-fetch/src/body.js":
/*!*********************************************!*\
  !*** ./node_modules/node-fetch/src/body.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   "default": () => (/* binding */ Body),
/* harmony export */   extractContentType: () => (/* binding */ extractContentType),
/* harmony export */   getTotalBytes: () => (/* binding */ getTotalBytes),
/* harmony export */   writeToStream: () => (/* binding */ writeToStream)
/* harmony export */ });
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors/base.js */ "./node_modules/node-fetch/src/errors/base.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");

/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */












const pipeline = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_0__.pipeline);
const INTERNALS = Symbol('Body internals');

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Body {
	constructor(body, {
		size = 0
	} = {}) {
		let boundary = null;

		if (body === null) {
			// Body is undefined or null
			body = null;
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
			// Body is a URLSearchParams
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.toString());
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
			// Body is blob
		} else if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
			// Body is Buffer
		} else if (node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body)) {
			// Body is ArrayBuffer
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body);
		} else if (ArrayBuffer.isView(body)) {
			// Body is ArrayBufferView
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		} else if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
			// Body is stream
		} else if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
			// Body is FormData
			body = (0,formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.formDataToBlob)(body);
			boundary = body.type.split('=')[1];
		} else {
			// None of the above
			// coerce to string then buffer
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(String(body));
		}

		let stream = body;

		if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
			stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body);
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
			stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body.stream());
		}

		this[INTERNALS] = {
			body,
			stream,
			boundary,
			disturbed: false,
			error: null
		};
		this.size = size;

		if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
			body.on('error', error_ => {
				const error = error_ instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ?
					error_ :
					new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
				this[INTERNALS].error = error;
			});
		}
	}

	get body() {
		return this[INTERNALS].stream;
	}

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	}

	/**
	 * Decode response as ArrayBuffer
	 *
	 * @return  Promise
	 */
	async arrayBuffer() {
		const {buffer, byteOffset, byteLength} = await consumeBody(this);
		return buffer.slice(byteOffset, byteOffset + byteLength);
	}

	async formData() {
		const ct = this.headers.get('content-type');

		if (ct.startsWith('application/x-www-form-urlencoded')) {
			const formData = new formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData();
			const parameters = new URLSearchParams(await this.text());

			for (const [name, value] of parameters) {
				formData.append(name, value);
			}

			return formData;
		}

		const {toFormData} = await __webpack_require__.e(/*! import() */ "node_modules_node-fetch_src_utils_multipart-parser_js").then(__webpack_require__.bind(__webpack_require__, /*! ./utils/multipart-parser.js */ "./node_modules/node-fetch/src/utils/multipart-parser.js"));
		return toFormData(this.body, ct);
	}

	/**
	 * Return raw response as Blob
	 *
	 * @return Promise
	 */
	async blob() {
		const ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';
		const buf = await this.arrayBuffer();

		return new fetch_blob__WEBPACK_IMPORTED_MODULE_3__["default"]([buf], {
			type: ct
		});
	}

	/**
	 * Decode response as json
	 *
	 * @return  Promise
	 */
	async json() {
		const text = await this.text();
		return JSON.parse(text);
	}

	/**
	 * Decode response as text
	 *
	 * @return  Promise
	 */
	async text() {
		const buffer = await consumeBody(this);
		return new TextDecoder().decode(buffer);
	}

	/**
	 * Decode response as buffer (non-spec api)
	 *
	 * @return  Promise
	 */
	buffer() {
		return consumeBody(this);
	}
}

Body.prototype.buffer = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: {enumerable: true},
	bodyUsed: {enumerable: true},
	arrayBuffer: {enumerable: true},
	blob: {enumerable: true},
	json: {enumerable: true},
	text: {enumerable: true},
	data: {get: (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {},
		'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead',
		'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}
});

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */
async function consumeBody(data) {
	if (data[INTERNALS].disturbed) {
		throw new TypeError(`body used already for: ${data.url}`);
	}

	data[INTERNALS].disturbed = true;

	if (data[INTERNALS].error) {
		throw data[INTERNALS].error;
	}

	const {body} = data;

	// Body is null
	if (body === null) {
		return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
	}

	/* c8 ignore next 3 */
	if (!(body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__)) {
		return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
	}

	// Body is stream
	// get ready to actually consume the body
	const accum = [];
	let accumBytes = 0;

	try {
		for await (const chunk of body) {
			if (data.size > 0 && accumBytes + chunk.length > data.size) {
				const error = new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
				body.destroy(error);
				throw error;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error) {
		const error_ = error instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
		throw error_;
	}

	if (body.readableEnded === true || body._readableState.ended === true) {
		try {
			if (accum.every(c => typeof c === 'string')) {
				return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(accum.join(''));
			}

			return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(accum, accumBytes);
		} catch (error) {
			throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
		}
	} else {
		throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Premature close of server response while trying to fetch ${data.url}`);
	}
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed   instance       Response or Request instance
 * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
 * @return  Mixed
 */
const clone = (instance, highWaterMark) => {
	let p1;
	let p2;
	let {body} = instance[INTERNALS];

	// Don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// Check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if ((body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) && (typeof body.getBoundary !== 'function')) {
		// Tee instance body
		p1 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({highWaterMark});
		p2 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({highWaterMark});
		body.pipe(p1);
		body.pipe(p2);
		// Set instance body to teed body and return the other teed body
		instance[INTERNALS].stream = p1;
		body = p2;
	}

	return body;
};

const getNonSpecFormDataBoundary = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(
	body => body.getBoundary(),
	'form-data doesn\'t follow the spec and requires special treatment. Use alternative package',
	'https://github.com/node-fetch/node-fetch/issues/1167'
);

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param {any} body Any options.body input
 * @returns {string | null}
 */
const extractContentType = (body, request) => {
	// Body is null or undefined
	if (body === null) {
		return null;
	}

	// Body is string
	if (typeof body === 'string') {
		return 'text/plain;charset=UTF-8';
	}

	// Body is a URLSearchParams
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	}

	// Body is blob
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
		return body.type || null;
	}

	// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
	if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body) || node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
		return null;
	}

	if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
		return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getBoundary === 'function') {
		return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
	}

	// Body is stream - can't really do much about this
	if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
		return null;
	}

	// Body constructor defaults other things to string
	return 'text/plain;charset=UTF-8';
};

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param {any} obj.body Body object from the Body instance.
 * @returns {number | null}
 */
const getTotalBytes = request => {
	const {body} = request[INTERNALS];

	// Body is null or undefined
	if (body === null) {
		return 0;
	}

	// Body is Blob
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
		return body.size;
	}

	// Body is Buffer
	if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
		return body.length;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getLengthSync === 'function') {
		return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
	}

	// Body is stream
	return null;
};

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param {Stream.Writable} dest The stream to write to.
 * @param obj.body Body object from the Body instance.
 * @returns {Promise<void>}
 */
const writeToStream = async (dest, {body}) => {
	if (body === null) {
		// Body is null
		dest.end();
	} else {
		// Body is stream
		await pipeline(body, dest);
	}
};


/***/ }),

/***/ "./node_modules/node-fetch/src/errors/abort-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/abort-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");


/**
 * AbortError interface for cancelled requests
 */
class AbortError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
	constructor(message, type = 'aborted') {
		super(message, type);
	}
}


/***/ }),

/***/ "./node_modules/node-fetch/src/errors/base.js":
/*!****************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/base.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBaseError: () => (/* binding */ FetchBaseError)
/* harmony export */ });
class FetchBaseError extends Error {
	constructor(message, type) {
		super(message);
		// Hide custom error implementation details from end-users
		Error.captureStackTrace(this, this.constructor);

		this.type = type;
	}

	get name() {
		return this.constructor.name;
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
}


/***/ }),

/***/ "./node_modules/node-fetch/src/errors/fetch-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/fetch-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchError: () => (/* binding */ FetchError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");



/**
 * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/

/**
 * FetchError interface for operational errors
 */
class FetchError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
	/**
	 * @param  {string} message -      Error message for human
	 * @param  {string} [type] -        Error type for machine
	 * @param  {SystemError} [systemError] - For Node.js system error
	 */
	constructor(message, type, systemError) {
		super(message, type);
		// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
		if (systemError) {
			// eslint-disable-next-line no-multi-assign
			this.code = this.errno = systemError.code;
			this.erroredSysCall = systemError.syscall;
		}
	}
}


/***/ }),

/***/ "./node_modules/node-fetch/src/headers.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/headers.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Headers),
/* harmony export */   fromRawHeaders: () => (/* binding */ fromRawHeaders)
/* harmony export */ });
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:http */ "node:http");
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */




/* c8 ignore next 9 */
const validateHeaderName = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName === 'function' ?
	node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName :
	name => {
		if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
			const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});
			throw error;
		}
	};

/* c8 ignore next 9 */
const validateHeaderValue = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue === 'function' ?
	node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue :
	(name, value) => {
		if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
			const error = new TypeError(`Invalid character in header content ["${name}"]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});
			throw error;
		}
	};

/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */
class Headers extends URLSearchParams {
	/**
	 * Headers class
	 *
	 * @constructor
	 * @param {HeadersInit} [init] - Response headers
	 */
	constructor(init) {
		// Validate and normalize init object in [name, value(s)][]
		/** @type {string[][]} */
		let result = [];
		if (init instanceof Headers) {
			const raw = init.raw();
			for (const [name, values] of Object.entries(raw)) {
				result.push(...values.map(value => [name, value]));
			}
		} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq
			// No op
		} else if (typeof init === 'object' && !node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(init)) {
			const method = init[Symbol.iterator];
			// eslint-disable-next-line no-eq-null, eqeqeq
			if (method == null) {
				// Record<ByteString, ByteString>
				result.push(...Object.entries(init));
			} else {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// Sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				result = [...init]
					.map(pair => {
						if (
							typeof pair !== 'object' || node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(pair)
						) {
							throw new TypeError('Each header pair must be an iterable object');
						}

						return [...pair];
					}).map(pair => {
						if (pair.length !== 2) {
							throw new TypeError('Each header pair must be a name/value tuple');
						}

						return [...pair];
					});
			}
		} else {
			throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
		}

		// Validate and lowercase
		result =
			result.length > 0 ?
				result.map(([name, value]) => {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return [String(name).toLowerCase(), String(value)];
				}) :
				undefined;

		super(result);

		// Returning a Proxy that will lowercase key names, validate parameters and sort keys
		// eslint-disable-next-line no-constructor-return
		return new Proxy(this, {
			get(target, p, receiver) {
				switch (p) {
					case 'append':
					case 'set':
						return (name, value) => {
							validateHeaderName(name);
							validateHeaderValue(name, String(value));
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase(),
								String(value)
							);
						};

					case 'delete':
					case 'has':
					case 'getAll':
						return name => {
							validateHeaderName(name);
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase()
							);
						};

					case 'keys':
						return () => {
							target.sort();
							return new Set(URLSearchParams.prototype.keys.call(target)).keys();
						};

					default:
						return Reflect.get(target, p, receiver);
				}
			}
		});
		/* c8 ignore next */
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}

	toString() {
		return Object.prototype.toString.call(this);
	}

	get(name) {
		const values = this.getAll(name);
		if (values.length === 0) {
			return null;
		}

		let value = values.join(', ');
		if (/^content-encoding$/i.test(name)) {
			value = value.toLowerCase();
		}

		return value;
	}

	forEach(callback, thisArg = undefined) {
		for (const name of this.keys()) {
			Reflect.apply(callback, thisArg, [this.get(name), name, this]);
		}
	}

	* values() {
		for (const name of this.keys()) {
			yield this.get(name);
		}
	}

	/**
	 * @type {() => IterableIterator<[string, string]>}
	 */
	* entries() {
		for (const name of this.keys()) {
			yield [name, this.get(name)];
		}
	}

	[Symbol.iterator]() {
		return this.entries();
	}

	/**
	 * Node-fetch non-spec method
	 * returning all headers and their values as array
	 * @returns {Record<string, string[]>}
	 */
	raw() {
		return [...this.keys()].reduce((result, key) => {
			result[key] = this.getAll(key);
			return result;
		}, {});
	}

	/**
	 * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
	 */
	[Symbol.for('nodejs.util.inspect.custom')]() {
		return [...this.keys()].reduce((result, key) => {
			const values = this.getAll(key);
			// Http.request() only supports string as Host header.
			// This hack makes specifying custom Host header possible.
			if (key === 'host') {
				result[key] = values[0];
			} else {
				result[key] = values.length > 1 ? values : values[0];
			}

			return result;
		}, {});
	}
}

/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */
Object.defineProperties(
	Headers.prototype,
	['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
		result[property] = {enumerable: true};
		return result;
	}, {})
);

/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */
function fromRawHeaders(headers = []) {
	return new Headers(
		headers
			// Split into pairs
			.reduce((result, value, index, array) => {
				if (index % 2 === 0) {
					result.push(array.slice(index, index + 2));
				}

				return result;
			}, [])
			.filter(([name, value]) => {
				try {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return true;
				} catch {
					return false;
				}
			})

	);
}


/***/ }),

/***/ "./node_modules/node-fetch/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-fetch/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* reexport safe */ _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError),
/* harmony export */   Blob: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.Blob),
/* harmony export */   FetchError: () => (/* reexport safe */ _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError),
/* harmony export */   File: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.File),
/* harmony export */   FormData: () => (/* reexport safe */ formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__.FormData),
/* harmony export */   Headers: () => (/* reexport safe */ _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Request: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Response: () => (/* reexport safe */ _response_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   blobFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFrom),
/* harmony export */   blobFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFromSync),
/* harmony export */   "default": () => (/* binding */ fetch),
/* harmony export */   fileFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFrom),
/* harmony export */   fileFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFromSync),
/* harmony export */   isRedirect: () => (/* reexport safe */ _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)
/* harmony export */ });
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ "node:https");
/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:zlib */ "node:zlib");
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! data-uri-to-buffer */ "./node_modules/data-uri-to-buffer/dist/index.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./response.js */ "./node_modules/node-fetch/src/response.js");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./request.js */ "./node_modules/node-fetch/src/request.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors/abort-error.js */ "./node_modules/node-fetch/src/errors/abort-error.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/* harmony import */ var fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fetch-blob/from.js */ "./node_modules/fetch-blob/from.js");
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */
























const supportedSchemas = new Set(['data:', 'http:', 'https:']);

/**
 * Fetch function
 *
 * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
 * @param   {*} [options_] - Fetch options
 * @return  {Promise<import('./response').default>}
 */
async function fetch(url, options_) {
	return new Promise((resolve, reject) => {
		// Build request object
		const request = new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](url, options_);
		const {parsedURL, options} = (0,_request_js__WEBPACK_IMPORTED_MODULE_9__.getNodeRequestOptions)(request);
		if (!supportedSchemas.has(parsedURL.protocol)) {
			throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
		}

		if (parsedURL.protocol === 'data:') {
			const data = (0,data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__["default"])(request.url);
			const response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](data, {headers: {'Content-Type': data.typeFull}});
			resolve(response);
			return;
		}

		// Wrap http.request into fetch
		const send = (parsedURL.protocol === 'https:' ? node_https__WEBPACK_IMPORTED_MODULE_1__ : node_http__WEBPACK_IMPORTED_MODULE_0__).request;
		const {signal} = request;
		let response = null;

		const abort = () => {
			const error = new _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError('The operation was aborted.');
			reject(error);
			if (request.body && request.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
				request.body.destroy(error);
			}

			if (!response || !response.body) {
				return;
			}

			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = () => {
			abort();
			finalize();
		};

		// Send request
		const request_ = send(parsedURL.toString(), options);

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		const finalize = () => {
			request_.abort();
			if (signal) {
				signal.removeEventListener('abort', abortAndFinalize);
			}
		};

		request_.on('error', error => {
			reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
			finalize();
		});

		fixResponseChunkedTransferBadEnding(request_, error => {
			if (response && response.body) {
				response.body.destroy(error);
			}
		});

		/* c8 ignore next 18 */
		if (process.version < 'v14') {
			// Before Node.js 14, pipeline() does not fully support async iterators and does not always
			// properly handle when the socket close/end events are out of order.
			request_.on('socket', s => {
				let endedWithEventsCount;
				s.prependListener('end', () => {
					endedWithEventsCount = s._eventsCount;
				});
				s.prependListener('close', hadError => {
					// if end happened before close but the socket didn't emit an error, do it now
					if (response && endedWithEventsCount < s._eventsCount && !hadError) {
						const error = new Error('Premature close');
						error.code = 'ERR_STREAM_PREMATURE_CLOSE';
						response.body.emit('error', error);
					}
				});
			});
		}

		request_.on('response', response_ => {
			request_.setTimeout(0);
			const headers = (0,_headers_js__WEBPACK_IMPORTED_MODULE_8__.fromRawHeaders)(response_.rawHeaders);

			// HTTP fetch step 5
			if ((0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)(response_.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL(location, request.url);
				} catch {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// Nothing to do
						break;
					case 'follow': {
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOptions = {
							headers: new _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"](request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: (0,_body_js__WEBPACK_IMPORTED_MODULE_14__.clone)(request),
							signal: request.signal,
							size: request.size,
							referrer: request.referrer,
							referrerPolicy: request.referrerPolicy
						};

						// when forwarding sensitive headers like "Authorization",
						// "WWW-Authenticate", and "Cookie" to untrusted targets,
						// headers will be ignored when following a redirect to a domain
						// that is not a subdomain match or exact match of the initial domain.
						// For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
						// will forward the sensitive headers, but a redirect to "bar.com" will not.
						// headers will also be ignored when following a redirect to a domain using
						// a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
						// will not forward the sensitive headers
						if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isDomainOrSubdomain)(request.url, locationURL) || !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isSameProtocol)(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOptions.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (response_.statusCode !== 303 && request.body && options_.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
							reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {
							requestOptions.method = 'GET';
							requestOptions.body = undefined;
							requestOptions.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 14
						const responseReferrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__.parseReferrerPolicyFromHeader)(headers);
						if (responseReferrerPolicy) {
							requestOptions.referrerPolicy = responseReferrerPolicy;
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](locationURL, requestOptions)));
						finalize();
						return;
					}

					default:
						return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
				}
			}

			// Prepare response
			if (signal) {
				response_.once('end', () => {
					signal.removeEventListener('abort', abortAndFinalize);
				});
			}

			let body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
				if (error) {
					reject(error);
				}
			});
			// see https://github.com/nodejs/node/pull/29376
			/* c8 ignore next 3 */
			if (process.version < 'v12.10') {
				response_.on('aborted', abortAndFinalize);
			}

			const responseOptions = {
				url: request.url,
				status: response_.statusCode,
				statusText: response_.statusMessage,
				headers,
				size: request.size,
				counter: request.counter,
				highWaterMark: request.highWaterMark
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
				response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH,
				finishFlush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH
			};

			// For gzip
			if (codings === 'gzip' || codings === 'x-gzip') {
				body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip(zlibOptions), error => {
					if (error) {
						reject(error);
					}
				});
				response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// For deflate
			if (codings === 'deflate' || codings === 'x-deflate') {
				// Handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
					if (error) {
						reject(error);
					}
				});
				raw.once('data', chunk => {
					// See http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate(), error => {
							if (error) {
								reject(error);
							}
						});
					} else {
						body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflateRaw(), error => {
							if (error) {
								reject(error);
							}
						});
					}

					response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
					resolve(response);
				});
				raw.once('end', () => {
					// Some old IIS servers return zero-length OK deflate responses, so
					// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
					if (!response) {
						response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
						resolve(response);
					}
				});
				return;
			}

			// For br
			if (codings === 'br') {
				body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createBrotliDecompress(), error => {
					if (error) {
						reject(error);
					}
				});
				response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// Otherwise, use response as-is
			response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
			resolve(response);
		});

		// eslint-disable-next-line promise/prefer-await-to-then
		(0,_body_js__WEBPACK_IMPORTED_MODULE_14__.writeToStream)(request_, request).catch(reject);
	});
}

function fixResponseChunkedTransferBadEnding(request, errorCallback) {
	const LAST_CHUNK = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from('0\r\n\r\n');

	let isChunkedTransfer = false;
	let properLastChunkReceived = false;
	let previousChunk;

	request.on('response', response => {
		const {headers} = response;
		isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
	});

	request.on('socket', socket => {
		const onSocketClose = () => {
			if (isChunkedTransfer && !properLastChunkReceived) {
				const error = new Error('Premature close');
				error.code = 'ERR_STREAM_PREMATURE_CLOSE';
				errorCallback(error);
			}
		};

		const onData = buf => {
			properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

			// Sometimes final 0-length chunk and end of message code are in separate packets
			if (!properLastChunkReceived && previousChunk) {
				properLastChunkReceived = (
					node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&
					node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0
				);
			}

			previousChunk = buf;
		};

		socket.prependListener('close', onSocketClose);
		socket.on('data', onData);

		request.on('close', () => {
			socket.removeListener('close', onSocketClose);
			socket.removeListener('data', onData);
		});
	});
}


/***/ }),

/***/ "./node_modules/node-fetch/src/request.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/request.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request),
/* harmony export */   getNodeRequestOptions: () => (/* binding */ getNodeRequestOptions)
/* harmony export */ });
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/get-search.js */ "./node_modules/node-fetch/src/utils/get-search.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */









const INTERNALS = Symbol('Request internals');

/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */
const isRequest = object => {
	return (
		typeof object === 'object' &&
		typeof object[INTERNALS] === 'object'
	);
};

const doBadDataWarn = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {},
	'.data is not a valid RequestInit property, use .body instead',
	'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

/**
 * Request class
 *
 * Ref: https://fetch.spec.whatwg.org/#request-class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request extends _body_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
	constructor(input, init = {}) {
		let parsedURL;

		// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
		if (isRequest(input)) {
			parsedURL = new URL(input.url);
		} else {
			parsedURL = new URL(input);
			input = {};
		}

		if (parsedURL.username !== '' || parsedURL.password !== '') {
			throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
		}

		let method = init.method || input.method || 'GET';
		if (/^(delete|get|head|options|post|put)$/i.test(method)) {
			method = method.toUpperCase();
		}

		if (!isRequest(init) && 'data' in init) {
			doBadDataWarn();
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if ((init.body != null || (isRequest(input) && input.body !== null)) &&
			(method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		const inputBody = init.body ?
			init.body :
			(isRequest(input) && input.body !== null ?
				(0,_body_js__WEBPACK_IMPORTED_MODULE_2__.clone)(input) :
				null);

		super(inputBody, {
			size: init.size || input.size || 0
		});

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](init.headers || input.headers || {});

		if (inputBody !== null && !headers.has('Content-Type')) {
			const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.extractContentType)(inputBody, this);
			if (contentType) {
				headers.set('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ?
			input.signal :
			null;
		if ('signal' in init) {
			signal = init.signal;
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if (signal != null && !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_4__.isAbortSignal)(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
		}

		// 5.4, Request constructor steps, step 15.1
		// eslint-disable-next-line no-eq-null, eqeqeq
		let referrer = init.referrer == null ? input.referrer : init.referrer;
		if (referrer === '') {
			// 5.4, Request constructor steps, step 15.2
			referrer = 'no-referrer';
		} else if (referrer) {
			// 5.4, Request constructor steps, step 15.3.1, 15.3.2
			const parsedReferrer = new URL(referrer);
			// 5.4, Request constructor steps, step 15.3.3, 15.3.4
			referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
		} else {
			referrer = undefined;
		}

		this[INTERNALS] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal,
			referrer
		};

		// Node-fetch-only options
		this.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;
		this.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
		this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
		this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

		// 5.4, Request constructor steps, step 16.
		// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
		this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
	}

	/** @returns {string} */
	get method() {
		return this[INTERNALS].method;
	}

	/** @returns {string} */
	get url() {
		return (0,node_url__WEBPACK_IMPORTED_MODULE_0__.format)(this[INTERNALS].parsedURL);
	}

	/** @returns {Headers} */
	get headers() {
		return this[INTERNALS].headers;
	}

	get redirect() {
		return this[INTERNALS].redirect;
	}

	/** @returns {AbortSignal} */
	get signal() {
		return this[INTERNALS].signal;
	}

	// https://fetch.spec.whatwg.org/#dom-request-referrer
	get referrer() {
		if (this[INTERNALS].referrer === 'no-referrer') {
			return '';
		}

		if (this[INTERNALS].referrer === 'client') {
			return 'about:client';
		}

		if (this[INTERNALS].referrer) {
			return this[INTERNALS].referrer.toString();
		}

		return undefined;
	}

	get referrerPolicy() {
		return this[INTERNALS].referrerPolicy;
	}

	set referrerPolicy(referrerPolicy) {
		this[INTERNALS].referrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.validateReferrerPolicy)(referrerPolicy);
	}

	/**
	 * Clone this request
	 *
	 * @return  Request
	 */
	clone() {
		return new Request(this);
	}

	get [Symbol.toStringTag]() {
		return 'Request';
	}
}

Object.defineProperties(Request.prototype, {
	method: {enumerable: true},
	url: {enumerable: true},
	headers: {enumerable: true},
	redirect: {enumerable: true},
	clone: {enumerable: true},
	signal: {enumerable: true},
	referrer: {enumerable: true},
	referrerPolicy: {enumerable: true}
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param {Request} request - A Request instance
 * @return The options object to be passed to http.request
 */
const getNodeRequestOptions = request => {
	const {parsedURL} = request[INTERNALS];
	const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](request[INTERNALS].headers);

	// Fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body === null && /^(post|put)$/i.test(request.method)) {
		contentLengthValue = '0';
	}

	if (request.body !== null) {
		const totalBytes = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.getTotalBytes)(request);
		// Set Content-Length if totalBytes is a number (that is not NaN)
		if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
			contentLengthValue = String(totalBytes);
		}
	}

	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// 4.1. Main fetch, step 2.6
	// > If request's referrer policy is the empty string, then set request's referrer policy to the
	// > default referrer policy.
	if (request.referrerPolicy === '') {
		request.referrerPolicy = _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_REFERRER_POLICY;
	}

	// 4.1. Main fetch, step 2.7
	// > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
	// > determine request's referrer.
	if (request.referrer && request.referrer !== 'no-referrer') {
		request[INTERNALS].referrer = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.determineRequestsReferrer)(request);
	} else {
		request[INTERNALS].referrer = 'no-referrer';
	}

	// 4.5. HTTP-network-or-cache fetch, step 6.9
	// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
	// >  and isomorphic encoded, to httpRequest's header list.
	if (request[INTERNALS].referrer instanceof URL) {
		headers.set('Referer', request.referrer);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip, deflate, br');
	}

	let {agent} = request;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	const search = (0,_utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__.getSearch)(parsedURL);

	// Pass the full URL directly to request(), but overwrite the following
	// options:
	const options = {
		// Overwrite search to retain trailing ? (issue #776)
		path: parsedURL.pathname + search,
		// The following options are not expressed in the URL
		method: request.method,
		headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
		insecureHTTPParser: request.insecureHTTPParser,
		agent
	};

	return {
		/** @type {URL} */
		parsedURL,
		options
	};
};


/***/ }),

/***/ "./node_modules/node-fetch/src/response.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/response.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Response)
/* harmony export */ });
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/**
 * Response.js
 *
 * Response class provides content decoding
 */





const INTERNALS = Symbol('Response internals');

/**
 * Response class
 *
 * Ref: https://fetch.spec.whatwg.org/#response-class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response extends _body_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	constructor(body = null, options = {}) {
		super(body, options);

		// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
		const status = options.status != null ? options.status : 200;

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.headers);

		if (body !== null && !headers.has('Content-Type')) {
			const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_0__.extractContentType)(body, this);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS] = {
			type: 'default',
			url: options.url,
			status,
			statusText: options.statusText || '',
			headers,
			counter: options.counter,
			highWaterMark: options.highWaterMark
		};
	}

	get type() {
		return this[INTERNALS].type;
	}

	get url() {
		return this[INTERNALS].url || '';
	}

	get status() {
		return this[INTERNALS].status;
	}

	/**
	 * Convenience property representing if the request ended normally
	 */
	get ok() {
		return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
	}

	get redirected() {
		return this[INTERNALS].counter > 0;
	}

	get statusText() {
		return this[INTERNALS].statusText;
	}

	get headers() {
		return this[INTERNALS].headers;
	}

	get highWaterMark() {
		return this[INTERNALS].highWaterMark;
	}

	/**
	 * Clone this response
	 *
	 * @return  Response
	 */
	clone() {
		return new Response((0,_body_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this, this.highWaterMark), {
			type: this.type,
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected,
			size: this.size,
			highWaterMark: this.highWaterMark
		});
	}

	/**
	 * @param {string} url    The URL that the new response is to originate from.
	 * @param {number} status An optional status code for the response (e.g., 302.)
	 * @returns {Response}    A Response object.
	 */
	static redirect(url, status = 302) {
		if (!(0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__.isRedirect)(status)) {
			throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
		}

		return new Response(null, {
			headers: {
				location: new URL(url).toString()
			},
			status
		});
	}

	static error() {
		const response = new Response(null, {status: 0, statusText: ''});
		response[INTERNALS].type = 'error';
		return response;
	}

	static json(data = undefined, init = {}) {
		const body = JSON.stringify(data);

		if (body === undefined) {
			throw new TypeError('data is not JSON serializable');
		}

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](init && init.headers);

		if (!headers.has('content-type')) {
			headers.set('content-type', 'application/json');
		}

		return new Response(body, {
			...init,
			headers
		});
	}

	get [Symbol.toStringTag]() {
		return 'Response';
	}
}

Object.defineProperties(Response.prototype, {
	type: {enumerable: true},
	url: {enumerable: true},
	status: {enumerable: true},
	ok: {enumerable: true},
	redirected: {enumerable: true},
	statusText: {enumerable: true},
	headers: {enumerable: true},
	clone: {enumerable: true}
});


/***/ }),

/***/ "./node_modules/node-fetch/src/utils/get-search.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/get-search.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSearch: () => (/* binding */ getSearch)
/* harmony export */ });
const getSearch = parsedURL => {
	if (parsedURL.search) {
		return parsedURL.search;
	}

	const lastOffset = parsedURL.href.length - 1;
	const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
	return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};


/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is-redirect.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is-redirect.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRedirect: () => (/* binding */ isRedirect)
/* harmony export */ });
const redirectStatus = new Set([301, 302, 303, 307, 308]);

/**
 * Redirect code matching
 *
 * @param {number} code - Status code
 * @return {boolean}
 */
const isRedirect = code => {
	return redirectStatus.has(code);
};


/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAbortSignal: () => (/* binding */ isAbortSignal),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isDomainOrSubdomain: () => (/* binding */ isDomainOrSubdomain),
/* harmony export */   isSameProtocol: () => (/* binding */ isSameProtocol),
/* harmony export */   isURLSearchParameters: () => (/* binding */ isURLSearchParameters)
/* harmony export */ });
/**
 * Is.js
 *
 * Object type checks.
 */

const NAME = Symbol.toStringTag;

/**
 * Check if `obj` is a URLSearchParams object
 * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isURLSearchParameters = object => {
	return (
		typeof object === 'object' &&
		typeof object.append === 'function' &&
		typeof object.delete === 'function' &&
		typeof object.get === 'function' &&
		typeof object.getAll === 'function' &&
		typeof object.has === 'function' &&
		typeof object.set === 'function' &&
		typeof object.sort === 'function' &&
		object[NAME] === 'URLSearchParams'
	);
};

/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isBlob = object => {
	return (
		object &&
		typeof object === 'object' &&
		typeof object.arrayBuffer === 'function' &&
		typeof object.type === 'string' &&
		typeof object.stream === 'function' &&
		typeof object.constructor === 'function' &&
		/^(Blob|File)$/.test(object[NAME])
	);
};

/**
 * Check if `obj` is an instance of AbortSignal.
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isAbortSignal = object => {
	return (
		typeof object === 'object' && (
			object[NAME] === 'AbortSignal' ||
			object[NAME] === 'EventTarget'
		)
	);
};

/**
 * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
 * the parent domain.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isDomainOrSubdomain = (destination, original) => {
	const orig = new URL(original).hostname;
	const dest = new URL(destination).hostname;

	return orig === dest || orig.endsWith(`.${dest}`);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = (destination, original) => {
	const orig = new URL(original).protocol;
	const dest = new URL(destination).protocol;

	return orig === dest;
};


/***/ }),

/***/ "./node_modules/node-fetch/src/utils/referrer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/referrer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_REFERRER_POLICY: () => (/* binding */ DEFAULT_REFERRER_POLICY),
/* harmony export */   ReferrerPolicy: () => (/* binding */ ReferrerPolicy),
/* harmony export */   determineRequestsReferrer: () => (/* binding */ determineRequestsReferrer),
/* harmony export */   isOriginPotentiallyTrustworthy: () => (/* binding */ isOriginPotentiallyTrustworthy),
/* harmony export */   isUrlPotentiallyTrustworthy: () => (/* binding */ isUrlPotentiallyTrustworthy),
/* harmony export */   parseReferrerPolicyFromHeader: () => (/* binding */ parseReferrerPolicyFromHeader),
/* harmony export */   stripURLForUseAsAReferrer: () => (/* binding */ stripURLForUseAsAReferrer),
/* harmony export */   validateReferrerPolicy: () => (/* binding */ validateReferrerPolicy)
/* harmony export */ });
/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:net */ "node:net");


/**
 * @external URL
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
 */

/**
 * @module utils/referrer
 * @private
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy 8.4. Strip url for use as a referrer}
 * @param {string} URL
 * @param {boolean} [originOnly=false]
 */
function stripURLForUseAsAReferrer(url, originOnly = false) {
	// 1. If url is null, return no referrer.
	if (url == null) { // eslint-disable-line no-eq-null, eqeqeq
		return 'no-referrer';
	}

	url = new URL(url);

	// 2. If url's scheme is a local scheme, then return no referrer.
	if (/^(about|blob|data):$/.test(url.protocol)) {
		return 'no-referrer';
	}

	// 3. Set url's username to the empty string.
	url.username = '';

	// 4. Set url's password to null.
	// Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
	url.password = '';

	// 5. Set url's fragment to null.
	// Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
	url.hash = '';

	// 6. If the origin-only flag is true, then:
	if (originOnly) {
		// 6.1. Set url's path to null.
		// Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
		url.pathname = '';

		// 6.2. Set url's query to null.
		// Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
		url.search = '';
	}

	// 7. Return url.
	return url;
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
 */
const ReferrerPolicy = new Set([
	'',
	'no-referrer',
	'no-referrer-when-downgrade',
	'same-origin',
	'origin',
	'strict-origin',
	'origin-when-cross-origin',
	'strict-origin-when-cross-origin',
	'unsafe-url'
]);

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
 */
const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy 3. Referrer Policies}
 * @param {string} referrerPolicy
 * @returns {string} referrerPolicy
 */
function validateReferrerPolicy(referrerPolicy) {
	if (!ReferrerPolicy.has(referrerPolicy)) {
		throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
	}

	return referrerPolicy;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy 3.2. Is origin potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isOriginPotentiallyTrustworthy(url) {
	// 1. If origin is an opaque origin, return "Not Trustworthy".
	// Not applicable

	// 2. Assert: origin is a tuple origin.
	// Not for implementations

	// 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
	if (/^(http|ws)s:$/.test(url.protocol)) {
		return true;
	}

	// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
	const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
	const hostIPVersion = (0,node_net__WEBPACK_IMPORTED_MODULE_0__.isIP)(hostIp);

	if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
		return true;
	}

	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
		return true;
	}

	// 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
	// We are returning FALSE here because we cannot ensure conformance to
	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
		return false;
	}

	// 6. If origin's scheme component is file, return "Potentially Trustworthy".
	if (url.protocol === 'file:') {
		return true;
	}

	// 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
	// Not supported

	// 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
	// Not supported

	// 9. Return "Not Trustworthy".
	return false;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy 3.3. Is url potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isUrlPotentiallyTrustworthy(url) {
	// 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
	if (/^about:(blank|srcdoc)$/.test(url)) {
		return true;
	}

	// 2. If url's scheme is "data", return "Potentially Trustworthy".
	if (url.protocol === 'data:') {
		return true;
	}

	// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
	// created. Therefore, blobs created in a trustworthy origin will themselves be potentially
	// trustworthy.
	if (/^(blob|filesystem):$/.test(url.protocol)) {
		return true;
	}

	// 3. Return the result of executing 3.2 Is origin potentially trustworthy? on url's origin.
	return isOriginPotentiallyTrustworthy(url);
}

/**
 * Modifies the referrerURL to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerURLCallback
 * @param {external:URL} referrerURL
 * @returns {external:URL} modified referrerURL
 */

/**
 * Modifies the referrerOrigin to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerOriginCallback
 * @param {external:URL} referrerOrigin
 * @returns {external:URL} modified referrerOrigin
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}
 * @param {Request} request
 * @param {object} o
 * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
 * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
 * @returns {external:URL} Request's referrer
 */
function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {
	// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
	// these cases:
	// > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
	// > Note: If request's referrer policy is the empty string, Fetch will not call into this
	// > algorithm.
	if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
		return null;
	}

	// 1. Let policy be request's associated referrer policy.
	const policy = request.referrerPolicy;

	// 2. Let environment be request's client.
	// not applicable to node.js

	// 3. Switch on request's referrer:
	if (request.referrer === 'about:client') {
		return 'no-referrer';
	}

	// "a URL": Let referrerSource be request's referrer.
	const referrerSource = request.referrer;

	// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
	let referrerURL = stripURLForUseAsAReferrer(referrerSource);

	// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
	//    origin-only flag set to true.
	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

	// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
	//    referrerURL to referrerOrigin.
	if (referrerURL.toString().length > 4096) {
		referrerURL = referrerOrigin;
	}

	// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
	//    policy considerations in the interests of minimizing data leakage. For example, the user
	//    agent could strip the URL down to an origin, modify its host, replace it with an empty
	//    string, etc.
	if (referrerURLCallback) {
		referrerURL = referrerURLCallback(referrerURL);
	}

	if (referrerOriginCallback) {
		referrerOrigin = referrerOriginCallback(referrerOrigin);
	}

	// 8.Execute the statements corresponding to the value of policy:
	const currentURL = new URL(request.url);

	switch (policy) {
		case 'no-referrer':
			return 'no-referrer';

		case 'origin':
			return referrerOrigin;

		case 'unsafe-url':
			return referrerURL;

		case 'strict-origin':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerOrigin.
			return referrerOrigin.toString();

		case 'strict-origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 3. Return referrerOrigin.
			return referrerOrigin;

		case 'same-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. Return no referrer.
			return 'no-referrer';

		case 'origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// Return referrerOrigin.
			return referrerOrigin;

		case 'no-referrer-when-downgrade':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerURL.
			return referrerURL;

		default:
			throw new TypeError(`Invalid referrerPolicy: ${policy}`);
	}
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy 8.1. Parse a referrer policy from a Referrer-Policy header}
 * @param {Headers} headers Response headers
 * @returns {string} policy
 */
function parseReferrerPolicyFromHeader(headers) {
	// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
	//    and responses header list.
	const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

	// 2. Let policy be the empty string.
	let policy = '';

	// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
	//    string, then set policy to token.
	// Note: This algorithm loops over multiple policy values to allow deployment of new policy
	// values with fallbacks for older user agents, as described in  11.1 Unknown Policy Values.
	for (const token of policyTokens) {
		if (token && ReferrerPolicy.has(token)) {
			policy = token;
		}
	}

	// 4. Return policy.
	return policy;
}


/***/ }),

/***/ "./node_modules/vscode-languageserver-textdocument/lib/esm/main.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-textdocument/lib/esm/main.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextDocument: () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (const change of changes) {
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
            return lineOffset;
        }
        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
            offset--;
        }
        return offset;
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            const diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
            const startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        const ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
        const ch = text.charCodeAt(i);
        if (isEOL(ch)) {
            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function isEOL(char) {
    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}


/***/ }),

/***/ "./node_modules/binary-extensions/binary-extensions.json":
/*!***************************************************************!*\
  !*** ./node_modules/binary-extensions/binary-extensions.json ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/big5-added.json":
/*!******************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/big5-added.json ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp936.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp936.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp949.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp949.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp950.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp950.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/eucjp.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/eucjp.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json":
/*!**********************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/gbk-added.json":
/*!*****************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/gbk-added.json ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]');

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/shiftjis.json":
/*!****************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/shiftjis.json ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');

/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./node_modules/mime/types.json":
/*!**************************************!*\
  !*** ./node_modules/mime/types.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":[],"application/font-woff2":[],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/prs.cww":["cww"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":[],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":[],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":[],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":[],"application/x-msdownload":["com","bat"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":[],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":[],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":[],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/wav":["wav"],"audio/wave":[],"audio/webm":["weba"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":[],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":[],"audio/x-wav":[],"audio/xm":["xm"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/prs.btif":["btif"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":[],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/webp":["webp"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":[],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/hjson":["hjson"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/prs.lines.tag":["dsc"],"text/richtext":["rtx"],"text/rtf":[],"text/sgml":["sgml","sgm"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/vtt":["vtt"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":[],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"text/xml":[],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/webm":["webm"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}');

/***/ }),

/***/ "./node_modules/statuses/codes.json":
/*!******************************************!*\
  !*** ./node_modules/statuses/codes.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".index.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map
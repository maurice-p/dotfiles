#!/usr/bin/env node
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs"));
var tty = __importStar(require("tty"));
var chalk_1 = __importDefault(require("chalk"));
var commander_1 = __importDefault(require("commander"));
var glob_1 = __importDefault(require("glob"));
var vscode_tmgrammar_test_helper_1 = require("vscode-tmgrammar-test-helper");
// * don't forget the '' vscode-tmgrammar-test -s source.dhall -g testcase/dhall.tmLanguage.json -t '**/*.dhall'
commander_1.default
    .version('0.0.1')
    .description("Run Textmate grammar test cases using vscode-textmate")
    .option('-s, --scope <scope>', 'Language scope, e.g. source.dhall')
    .option('-g, --grammar <grammar>', 'Path to a grammar file, either .json or .xml')
    .option('-t, --testcases <glob>', 'A glob pattern which specifies testcases to run, e.g. \'./tests/**/test*.dhall\'. Quotes are important!')
    .option('-c, --compact', 'Display output in the compact format, which is easier to use with VSCode problem matchers')
    .parse(process.argv);
if (commander_1.default.scope === undefined || commander_1.default.grammar === undefined || commander_1.default.testcases === undefined) {
    commander_1.default.help();
}
var isatty = tty.isatty(1) && tty.isatty(2);
var symbols = {
    ok: '✓',
    err: '✖',
    dot: '․',
    comma: ',',
    bang: '!'
};
if (process.platform === 'win32') {
    symbols.ok = '\u221A';
    symbols.err = '\u00D7';
    symbols.dot = '.';
}
var terminalWidth = 75;
if (isatty) {
    terminalWidth = process.stdout.getWindowSize()[0];
}
var TestFailed = -1;
var TestSuccessful = 0;
var Padding = "  ";
var grammarPaths = {};
grammarPaths[commander_1.default.scope] = commander_1.default.grammar;
var registry = vscode_tmgrammar_test_helper_1.createRegistry(grammarPaths);
function printSourceLine(testCase, failure) {
    var line = testCase.source[failure.srcLine];
    var pos = (failure.line + 1) + ": ";
    var accents = " ".repeat(failure.start) + "^".repeat(failure.end - failure.start);
    var termWidth = terminalWidth - pos.length - Padding.length - 5;
    var trimLeft = failure.end > termWidth ? Math.max(0, failure.start - 8) : 0;
    var line1 = line.substr(trimLeft);
    var accents1 = accents.substr(trimLeft);
    console.log(Padding + chalk_1.default.gray(pos) + line1.substr(0, termWidth));
    console.log(Padding + " ".repeat(pos.length) + accents1.substr(0, termWidth));
}
function printReason(testCase, failure) {
    if (failure.missing && failure.missing.length > 0) {
        console.log(chalk_1.default.red(Padding + "missing required scopes: ") + chalk_1.default.gray(failure.missing.join(" ")));
    }
    if (failure.unexpected && failure.unexpected.length > 0) {
        console.log(chalk_1.default.red(Padding + "prohibited scopes: ") + chalk_1.default.gray(failure.unexpected.join(" ")));
    }
    if (failure.actual !== undefined) {
        console.log(chalk_1.default.red(Padding + "actual: ") + chalk_1.default.gray(failure.actual.join(" ")));
    }
}
function displayTestResultFull(filename, testCase, failures) {
    if (failures.length === 0) {
        console.log(chalk_1.default.green(symbols.ok) + " " + chalk_1.default.whiteBright(filename) + " run successfuly.");
        return TestSuccessful;
    }
    else {
        console.log(chalk_1.default.red(symbols.err + " " + filename + " failed"));
        failures.forEach(function (failure) {
            var _a = getCorrectedOffsets(failure), l = _a.l, s = _a.s, e = _a.e;
            console.log(Padding + "at [" + chalk_1.default.whiteBright(filename + ":" + l + ":" + s + ":" + e) + "]: ");
            printSourceLine(testCase, failure);
            printReason(testCase, failure);
            console.log("\n");
        });
        console.log("");
        return TestFailed;
    }
}
function renderCompactErrorMsg(testCase, failure) {
    var res = "";
    if (failure.missing && failure.missing.length > 0) {
        res += "Missing required scopes: [ " + failure.missing.join(" ") + " ] ";
    }
    if (failure.unexpected && failure.unexpected.length > 0) {
        res += "Prohibited scopes: [ " + failure.unexpected.join(" ") + " ] ";
    }
    if (failure.actual !== undefined) {
        res += "actual scopes: [" + failure.actual.join(" ") + "]";
    }
    return res;
}
function displayTestResultCompact(filename, testCase, failures) {
    if (failures.length === 0) {
        console.log(chalk_1.default.green(symbols.ok) + " " + chalk_1.default.whiteBright(filename) + " run successfuly.");
        return TestSuccessful;
    }
    else {
        failures.forEach(function (failure) {
            console.log("ERROR " + filename + ":" + (failure.line + 1) + ":" + (failure.start + 1) + ":" + (failure.end + 1) + " " + renderCompactErrorMsg(testCase, failure));
        });
        return TestFailed;
    }
}
function handleGrammarTestError(filename, testCase, reason) {
    console.log(chalk_1.default.red(symbols.err) + " testcase " + chalk_1.default.gray(filename) + " aborted due to an error");
    console.log(reason);
    return TestFailed;
}
var displayTestResult = commander_1.default.compact ? displayTestResultCompact : displayTestResultFull;
glob_1.default(commander_1.default.testcases, function (err, files) {
    if (err !== null) {
        console.log(chalk_1.default.red("ERROR") + " glob pattern is incorrect: '" + chalk_1.default.gray(commander_1.default.testcases) + "'");
        console.log(err);
        process.exit(-1);
    }
    var testResults = Promise.all(files.map(function (filename) {
        var tc = undefined;
        try {
            tc = vscode_tmgrammar_test_helper_1.parseGrammarTestCase(fs.readFileSync(filename).toString());
        }
        catch (error) {
            console.log(chalk_1.default.red("ERROR") + " can't parse testcase: " + chalk_1.default.whiteBright(filename) + "");
            console.log(error);
            return new Promise(function (resolve, reject) { resolve(TestFailed); });
        }
        var testCase = tc;
        return vscode_tmgrammar_test_helper_1.runGrammarTestCase(registry, testCase).then(function (failures) {
            return displayTestResult(filename, testCase, failures);
        }).catch(function (error) {
            return handleGrammarTestError(filename, testCase, error);
        });
    }));
    testResults.then(function (xs) {
        var result = xs.reduce(function (a, b) { return a + b; }, 0);
        if (result === TestSuccessful) {
            process.exit(0);
        }
        else {
            process.exit(-1);
        }
    });
});
function getCorrectedOffsets(failure) {
    return {
        l: failure.line + 1,
        s: failure.start + 1,
        e: failure.end + 1
    };
}
//# sourceMappingURL=index.js.map
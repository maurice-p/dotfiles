"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var os_1 = require("os");
var leftArrowAssertRegex = /^(\s*)<([~]*)([-]+)((?:\s*\w[-\w.]*)*)(?:\s*-)?((?:\s*\w[-\w.]*)*)\s*$/;
var upArrowAssertRegex = /^\s*((?:(?:\^+)\s*)+)((?:\s*\w[-\w.]*)*)(?:\s*-)?((?:\s*\w[-\w.]*)*)\s*$/;
function parseScopeAssertion(testCaseLineNumber, commentLength, as) {
    var s = as.slice(commentLength);
    if (s.trim().startsWith('^')) {
        var upArrowMatch = upArrowAssertRegex.exec(s);
        if (upArrowMatch !== null) {
            var _a = upArrowMatch[2], scopes = _a === void 0 ? '' : _a, _b = upArrowMatch[3], exclusions = _b === void 0 ? '' : _b;
            if (scopes === '' && exclusions === '') {
                throw new Error("Inalid assertion at line " + testCaseLineNumber + ":" + os_1.EOL + as + os_1.EOL + " Missing both required and prohibited scopes");
            }
            else {
                var result = [];
                var startIdx = s.indexOf('^');
                while (startIdx !== -1) {
                    var endIndx = startIdx;
                    while (s[endIndx + 1] === '^') {
                        endIndx++;
                    }
                    result.push({
                        from: commentLength + startIdx,
                        to: commentLength + endIndx + 1,
                        scopes: scopes.split(/\s+/).filter(function (x) { return x; }),
                        exclude: exclusions.split(/\s+/).filter(function (x) { return x; })
                    });
                    startIdx = s.indexOf('^', endIndx + 1);
                }
                return result;
            }
        }
        else {
            throw new Error("Inalid assertion at line " + testCaseLineNumber + ":" + os_1.EOL + as + os_1.EOL);
        }
    }
    var leftArrowMatch = leftArrowAssertRegex.exec(s);
    if (leftArrowMatch !== null) {
        var tildas = leftArrowMatch[2], dashes = leftArrowMatch[3], _c = leftArrowMatch[4], scopes = _c === void 0 ? '' : _c, _d = leftArrowMatch[5], exclusions = _d === void 0 ? '' : _d;
        if (scopes === '' && exclusions === '') {
            throw new Error("Inalid assertion at line " + testCaseLineNumber + ":" + os_1.EOL + as + os_1.EOL + " Missing both required and prohibited scopes");
        }
        else {
            return [
                {
                    from: tildas.length,
                    to: tildas.length + dashes.length,
                    scopes: scopes.split(/\s+/).filter(function (x) { return x; }),
                    exclude: exclusions.split(/\s+/).filter(function (x) { return x; })
                }
            ];
        }
    }
    return [];
}
exports.parseScopeAssertion = parseScopeAssertion;
var headerErrorMessage = "Expecting the first line in the syntax test file to be in the following format:" + os_1.EOL +
    ("<comment character(s)> SYNTAX TEST \"<language identifier>\"  (\"description\")?(+AllowMiddleLineAssertions)?" + os_1.EOL);
var headerRegex = /^([^\s]+)\s+SYNTAX\s+TEST\s+"([^"]+)"(?:\s+\"([^"]+)\")?\s*(\+AllowMiddleLineAssertions)?\s*$/;
/**
 * parse the first line with the format:
 * <comment character(s)> SYNTAX TEST "<language identifier>" <"description">? ([+-]<flag>)*
 */
function parseHeader(as) {
    if (as.length < 1) {
        throw new Error(headerErrorMessage);
    }
    var matchResult = headerRegex.exec(as[0]);
    if (matchResult === null) {
        throw new Error(headerErrorMessage);
    }
    else {
        var commentToken = matchResult[1], scope = matchResult[2], _a = matchResult[3], description = _a === void 0 ? '' : _a, _b = matchResult[4], allowMiddleLineAssertions = _b === void 0 ? '' : _b;
        return {
            commentToken: commentToken,
            scope: scope,
            description: description,
            allowMiddleLineAssertions: allowMiddleLineAssertions !== ''
        };
    }
}
exports.parseHeader = parseHeader;
function parseGrammarTestCase(str) {
    var headerLength = 1;
    var lines = str.split(/\r\n|\n/);
    var metadata = parseHeader(lines);
    var commentToken = metadata.commentToken, allowMiddleLineAssertions = metadata.allowMiddleLineAssertions;
    var rest = lines.slice(headerLength);
    function emptyLineAssertion(tcLineNumber, srcLineNumber) {
        return {
            testCaseLineNumber: tcLineNumber,
            sourceLineNumber: srcLineNumber,
            scopeAssertions: []
        };
    }
    var sourceLineNumber = 0;
    var lineAssertions = [];
    var currentLineAssertion = emptyLineAssertion(headerLength, 0);
    var source = [];
    rest.forEach(function (s, i) {
        var tcLineNumber = headerLength + i;
        if (allowMiddleLineAssertions && s.trim().startsWith(commentToken)) {
            var indent = s.indexOf(commentToken) + commentToken.length; // FIXME: a bit ugly here
            var as = parseScopeAssertion(tcLineNumber, indent, s);
            currentLineAssertion.scopeAssertions = __spreadArrays(currentLineAssertion.scopeAssertions, as);
        }
        else if (s.startsWith(commentToken)) {
            var as = parseScopeAssertion(tcLineNumber, commentToken.length, s);
            currentLineAssertion.scopeAssertions = __spreadArrays(currentLineAssertion.scopeAssertions, as);
        }
        else {
            if (currentLineAssertion.scopeAssertions.length !== 0) {
                lineAssertions.push(currentLineAssertion);
            }
            currentLineAssertion = emptyLineAssertion(tcLineNumber, sourceLineNumber);
            source.push(s);
            sourceLineNumber++;
        }
    });
    if (currentLineAssertion.scopeAssertions.length !== 0) {
        lineAssertions.push(currentLineAssertion);
    }
    return {
        metadata: metadata,
        source: source,
        assertions: lineAssertions
    };
}
exports.parseGrammarTestCase = parseGrammarTestCase;
//# sourceMappingURL=parsing.js.map
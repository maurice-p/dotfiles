#!/usr/bin/env node
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs"));
var tty = __importStar(require("tty"));
var chalk_1 = __importDefault(require("chalk"));
var commander_1 = __importDefault(require("commander"));
var glob_1 = __importDefault(require("glob"));
var index_1 = require("./unit/index");
var os_1 = require("os");
var index_2 = require("./snapshot/index");
var parsing_1 = require("./snapshot/parsing");
var diff = __importStar(require("diff"));
var packageJson = require('../../package.json');
function collectGrammarOpts(value, previous) {
    return previous.concat([value]);
}
commander_1.default
    .version(packageJson.version)
    .description('Run VSCode textmate grammar snapshot tests')
    .option('-s, --scope <scope>', 'Language scope, e.g. source.dhall')
    .option('-g, --grammar <grammar>', 'Path to a grammar file, either .json or .xml. This option can be specified multiple times if multiple grammar needed.', collectGrammarOpts, [])
    .option('-t, --testcases <glob>', 'A glob pattern which specifies testcases to run, e.g. "./tests/**/test*.dhall". Quotes are important!')
    .option('-u, --updateSnapshot', 'overwrite all snap files with new changes')
    .option('--printNotModified', 'include not modified scopes in the output', false)
    .option('--expandDiff', 'produce each diff on two lines prefixed with "++" and "--"', false)
    .parse(process.argv);
if (commander_1.default.scope === undefined ||
    commander_1.default.grammar === undefined ||
    commander_1.default.grammar.length === 0 ||
    commander_1.default.testcases === undefined) {
    commander_1.default.help();
}
var isatty = tty.isatty(1) && tty.isatty(2);
var symbols = {
    ok: '✓',
    err: '✖',
    dot: '․',
    comma: ',',
    bang: '!'
};
if (process.platform === 'win32') {
    symbols.ok = '\u221A';
    symbols.err = '\u00D7';
    symbols.dot = '.';
}
var terminalWidth = 75;
if (isatty) {
    terminalWidth = process.stdout.getWindowSize()[0];
}
var TestFailed = -1;
var TestSuccessful = 0;
var Padding = '  ';
var registry = index_1.createRegistry(commander_1.default.grammar);
glob_1.default(commander_1.default.testcases, function (err, files0) {
    if (err !== null) {
        console.log(chalk_1.default.red('ERROR') +
            " glob pattern is incorrect: '" +
            chalk_1.default.gray(commander_1.default.testcases) +
            "'");
        console.log(err);
        process.exit(-1);
    }
    var files = files0.filter(function (x) { return !x.endsWith('.snap'); });
    if (files.length === 0) {
        console.log(chalk_1.default.red('ERROR') + ' no test cases found');
        process.exit(-1);
    }
    var testResults = Promise.all(files.map(function (filename) {
        var src = fs.readFileSync(filename).toString();
        return index_2.getVSCodeTokens(registry, commander_1.default.scope, src)
            .then(function (tokens) {
            if (fs.existsSync(filename + '.snap')) {
                if (commander_1.default.updateSnapshot) {
                    console.log(chalk_1.default.yellowBright('Updating snapshot for') +
                        chalk_1.default.whiteBright(filename + '.snap'));
                    fs.writeFileSync(filename + '.snap', parsing_1.renderSnap(tokens), 'utf8');
                    return TestSuccessful;
                }
                else {
                    var expectedTokens = parsing_1.parseSnap(fs.readFileSync(filename + '.snap').toString());
                    return renderTestResult(filename, expectedTokens, tokens);
                }
            }
            else {
                console.log(chalk_1.default.yellowBright('Generating snapshot ') +
                    chalk_1.default.whiteBright(filename + '.snap'));
                fs.writeFileSync(filename + '.snap', parsing_1.renderSnap(tokens));
                return TestSuccessful;
            }
        })
            .catch(function (error) {
            console.log(chalk_1.default.red('ERROR') +
                " can't run testcase: " +
                chalk_1.default.whiteBright(filename));
            console.log(error);
            return TestFailed;
        });
    }));
    testResults.then(function (xs) {
        var result = xs.reduce(function (a, b) { return a + b; }, 0);
        if (result === TestSuccessful) {
            process.exit(0);
        }
        else {
            process.exit(-1);
        }
    });
});
function renderTestResult(filename, expected, actual) {
    if (expected.length !== actual.length) {
        console.log(chalk_1.default.red('ERROR running testcase ') +
            chalk_1.default.whiteBright(filename) +
            chalk_1.default.red(" snapshot and actual file contain different number of lines." + os_1.EOL));
        return TestFailed;
    }
    for (var i = 0; i < expected.length; i++) {
        var exp = expected[i];
        var act = actual[i];
        if (exp.src !== act.src) {
            console.log(chalk_1.default.red('ERROR running testcase ') +
                chalk_1.default.whiteBright(filename) +
                chalk_1.default.red(" source different snapshot at line " + (i + 1) + "." + os_1.EOL + " expected: " + exp.src + os_1.EOL + " actual: " + act.src + os_1.EOL));
            return TestFailed;
        }
    }
    // renderSnap won't produce assertions for empty lines, so we'll remove them here
    // for both actual end expected
    var actual1 = actual.filter(function (a) { return a.src.trim().length > 0; });
    var expected1 = expected.filter(function (a) { return a.src.trim().length > 0; });
    var wrongLines = flatten(expected1.map(function (exp, i) {
        var act = actual1[i];
        var expTokenMap = toMap(function (t) { return t.startIndex + ":" + t.startIndex; }, exp.tokens);
        var actTokenMap = toMap(function (t) { return t.startIndex + ":" + t.startIndex; }, act.tokens);
        var removed = exp.tokens
            .filter(function (t) { return actTokenMap[t.startIndex + ":" + t.startIndex] === undefined; })
            .map(function (t) {
            return {
                changes: [
                    {
                        text: t.scopes.join(' '),
                        changeType: Removed
                    }
                ],
                from: t.startIndex,
                to: t.endIndex
            };
        });
        var added = act.tokens
            .filter(function (t) { return expTokenMap[t.startIndex + ":" + t.startIndex] === undefined; })
            .map(function (t) {
            return {
                changes: [
                    {
                        text: t.scopes.join(' '),
                        changeType: Added
                    }
                ],
                from: t.startIndex,
                to: t.endIndex
            };
        });
        var modified = flatten(act.tokens.map(function (a) {
            var e = expTokenMap[a.startIndex + ":" + a.startIndex];
            if (e !== undefined) {
                var changes = diff.diffArrays(e.scopes, a.scopes);
                if (changes.length === 1 &&
                    !changes[0].added &&
                    !changes[0].removed) {
                    return [];
                }
                var tchanges = changes.map(function (change) {
                    var changeType = change.added
                        ? Added
                        : change.removed
                            ? Removed
                            : NotModified;
                    return {
                        text: change.value.join(' '),
                        changeType: changeType
                    };
                });
                return [
                    {
                        changes: tchanges,
                        from: a.startIndex,
                        to: a.endIndex
                    }
                ];
            }
            else {
                return [];
            }
        }));
        var allChanges = modified
            .concat(added)
            .concat(removed)
            .sort(function (x, y) { return (x.from - y.from) * 10000 + (x.to - y.to); });
        if (allChanges.length > 0) {
            return [[allChanges, exp.src, i]];
        }
        else {
            return [];
        }
    }));
    if (wrongLines.length > 0) {
        console.log(chalk_1.default.red('ERROR in test case ') + chalk_1.default.whiteBright(filename));
        console.log(Padding + Padding + chalk_1.default.red('-- existing snapshot'));
        console.log(Padding + Padding + chalk_1.default.green('++ new changes'));
        console.log();
        if (commander_1.default.expandDiff) {
            printDiffOnTwoLines(wrongLines);
        }
        else {
            printDiffInline(wrongLines);
        }
        console.log();
        return TestFailed;
    }
    else {
        console.log(chalk_1.default.green(symbols.ok) +
            ' ' +
            chalk_1.default.whiteBright(filename) +
            ' run successfully.');
        return TestSuccessful;
    }
}
function printDiffInline(wrongLines) {
    wrongLines.forEach(function (_a) {
        var changes = _a[0], src = _a[1], i = _a[2];
        var lineNumberOffset = printSourceLine(src, i);
        changes.forEach(function (tchanges) {
            var change = tchanges.changes
                .filter(function (c) { return commander_1.default.printNotModified || c.changeType !== NotModified; })
                .map(function (c) {
                var color = c.changeType === Added
                    ? chalk_1.default.green
                    : c.changeType === Removed
                        ? chalk_1.default.red
                        : chalk_1.default.gray;
                return color(c.text);
            })
                .join(' ');
            printAccents(lineNumberOffset, tchanges.from, tchanges.to, change);
        });
        console.log();
    });
}
function printDiffOnTwoLines(wrongLines) {
    wrongLines.forEach(function (_a) {
        var changes = _a[0], src = _a[1], i = _a[2];
        var lineNumberOffset = printSourceLine(src, i);
        changes.forEach(function (tchanges) {
            var removed = tchanges.changes
                .filter(function (c) {
                return c.changeType === Removed ||
                    (c.changeType === NotModified && commander_1.default.printNotModified);
            })
                .map(function (c) {
                return chalk_1.default.red(c.text);
            })
                .join(' ');
            var added = tchanges.changes
                .filter(function (c) {
                return c.changeType === Added ||
                    (c.changeType === NotModified && commander_1.default.printNotModified);
            })
                .map(function (c) {
                return chalk_1.default.green(c.text);
            })
                .join(' ');
            printAccents1(lineNumberOffset, tchanges.from, tchanges.to, chalk_1.default.red('-- ') + removed, Removed);
            printAccents1(lineNumberOffset, tchanges.from, tchanges.to, chalk_1.default.green('++ ') + added, Added);
        });
        console.log();
    });
}
function toMap(f, xs) {
    return xs.reduce(function (m, x) {
        m[f(x)] = x;
        return m;
    }, {});
}
function flatten(arr) {
    return arr.reduce(function (acc, val) { return acc.concat(val); }, []);
}
var NotModified = 0;
var Removed = 1;
var Added = 2;
function printSourceLine(line, n) {
    var pos = n + 1 + ': ';
    console.log(Padding + chalk_1.default.gray(pos) + line);
    return pos.length;
}
function printAccents(offset, from, to, diff) {
    var accents = ' '.repeat(from) + '^'.repeat(to - from);
    console.log(Padding + ' '.repeat(offset) + accents + ' ' + diff);
}
function printAccents1(offset, from, to, diff, change) {
    var color = change === Added
        ? chalk_1.default.green
        : change === Removed
            ? chalk_1.default.red
            : chalk_1.default.gray;
    var prefix = change === Added ? '++' : change === Removed ? '--' : '  ';
    var accents = color(' '.repeat(from) + '^'.repeat(to - from));
    console.log(color(prefix) + ' '.repeat(offset) + accents + ' ' + diff);
}
//# sourceMappingURL=snapshot.js.map
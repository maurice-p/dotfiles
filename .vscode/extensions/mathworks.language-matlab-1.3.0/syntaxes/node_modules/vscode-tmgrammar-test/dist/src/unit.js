#!/usr/bin/env node
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs"));
var tty = __importStar(require("tty"));
var chalk_1 = __importDefault(require("chalk"));
var commander_1 = __importDefault(require("commander"));
var glob_1 = __importDefault(require("glob"));
var os_1 = require("os");
var index_1 = require("./unit/index");
var packageJson = require('../../package.json');
function collectGrammarOpts(value, previous) {
    return previous.concat([value]);
}
// * don't forget the '' vscode-tmgrammar-test -s source.dhall -g testcase/dhall.tmLanguage.json -t '**/*.dhall'
commander_1.default
    .version(packageJson.version)
    .description('Run Textmate grammar test cases using vscode-textmate')
    .option('-s, --scope <scope>', 'Language scope, e.g. source.dhall')
    .option('-g, --grammar <grammar>', 'Path to a grammar file, either .json or .xml. This option can be specified multiple times if multiple grammar needed.', collectGrammarOpts, [])
    .option('-t, --testcases <glob>', 'A glob pattern which specifies testcases to run, e.g. "./tests/**/test*.dhall". Quotes are important!')
    .option('-c, --compact', 'Display output in the compact format, which is easier to use with VSCode problem matchers')
    .parse(process.argv);
if (commander_1.default.scope === undefined ||
    commander_1.default.grammar === undefined ||
    commander_1.default.grammar.length === 0 ||
    commander_1.default.testcases === undefined) {
    commander_1.default.help();
}
var isatty = tty.isatty(1) && tty.isatty(2);
var symbols = {
    ok: '✓',
    err: '✖',
    dot: '․',
    comma: ',',
    bang: '!'
};
if (process.platform === 'win32') {
    symbols.ok = '\u221A';
    symbols.err = '\u00D7';
    symbols.dot = '.';
}
var terminalWidth = 75;
if (isatty) {
    terminalWidth = process.stdout.getWindowSize()[0];
}
var TestFailed = -1;
var TestSuccessful = 0;
var Padding = '  ';
var registry = index_1.createRegistry(commander_1.default.grammar);
function printSourceLine(testCase, failure) {
    var line = testCase.source[failure.srcLine];
    var pos = failure.line + 1 + ': ';
    var accents = ' '.repeat(failure.start) + '^'.repeat(failure.end - failure.start);
    var termWidth = terminalWidth - pos.length - Padding.length - 5;
    var trimLeft = failure.end > termWidth ? Math.max(0, failure.start - 8) : 0;
    var line1 = line.substr(trimLeft);
    var accents1 = accents.substr(trimLeft);
    console.log(Padding + chalk_1.default.gray(pos) + line1.substr(0, termWidth));
    console.log(Padding + ' '.repeat(pos.length) + accents1.substr(0, termWidth));
}
function printReason(testCase, failure) {
    if (failure.missing && failure.missing.length > 0) {
        console.log(chalk_1.default.red(Padding + 'missing required scopes: ') +
            chalk_1.default.gray(failure.missing.join(' ')));
    }
    if (failure.unexpected && failure.unexpected.length > 0) {
        console.log(chalk_1.default.red(Padding + 'prohibited scopes: ') +
            chalk_1.default.gray(failure.unexpected.join(' ')));
    }
    if (failure.actual !== undefined) {
        console.log(chalk_1.default.red(Padding + 'actual: ') + chalk_1.default.gray(failure.actual.join(' ')));
    }
}
function displayTestResultFull(filename, testCase, failures) {
    if (failures.length === 0) {
        console.log(chalk_1.default.green(symbols.ok) +
            ' ' +
            chalk_1.default.whiteBright(filename) +
            " run successfuly.");
        return TestSuccessful;
    }
    else {
        console.log(chalk_1.default.red(symbols.err + ' ' + filename + ' failed'));
        failures.forEach(function (failure) {
            var _a = getCorrectedOffsets(failure), l = _a.l, s = _a.s, e = _a.e;
            console.log(Padding +
                'at [' +
                chalk_1.default.whiteBright(filename + ":" + l + ":" + s + ":" + e) +
                ']:');
            printSourceLine(testCase, failure);
            printReason(testCase, failure);
            console.log(os_1.EOL);
        });
        console.log('');
        return TestFailed;
    }
}
function renderCompactErrorMsg(testCase, failure) {
    var res = '';
    if (failure.missing && failure.missing.length > 0) {
        res += "Missing required scopes: [ " + failure.missing.join(' ') + " ] ";
    }
    if (failure.unexpected && failure.unexpected.length > 0) {
        res += "Prohibited scopes: [ " + failure.unexpected.join(' ') + " ] ";
    }
    if (failure.actual !== undefined) {
        res += "actual scopes: [" + failure.actual.join(' ') + "]";
    }
    return res;
}
function displayTestResultCompact(filename, testCase, failures) {
    if (failures.length === 0) {
        console.log(chalk_1.default.green(symbols.ok) +
            ' ' +
            chalk_1.default.whiteBright(filename) +
            " run successfuly.");
        return TestSuccessful;
    }
    else {
        failures.forEach(function (failure) {
            console.log("ERROR " + filename + ":" + (failure.line + 1) + ":" + (failure.start + 1) + ":" + (failure.end + 1) + " " + renderCompactErrorMsg(testCase, failure));
        });
        return TestFailed;
    }
}
function handleGrammarTestError(filename, testCase, reason) {
    console.log(chalk_1.default.red(symbols.err) +
        ' testcase ' +
        chalk_1.default.gray(filename) +
        ' aborted due to an error');
    console.log(reason);
    return TestFailed;
}
var displayTestResult = commander_1.default.compact
    ? displayTestResultCompact
    : displayTestResultFull;
glob_1.default(commander_1.default.testcases, function (err, files) {
    if (err !== null) {
        console.log(chalk_1.default.red('ERROR') +
            " glob pattern is incorrect: '" +
            chalk_1.default.gray(commander_1.default.testcases) +
            "'");
        console.log(err);
        process.exit(-1);
    }
    if (files.length === 0) {
        console.log(chalk_1.default.red('ERROR') + ' no test cases found');
        process.exit(-1);
    }
    var testResults = Promise.all(files.map(function (filename) {
        var tc = undefined;
        try {
            tc = index_1.parseGrammarTestCase(fs.readFileSync(filename).toString());
        }
        catch (error) {
            console.log(chalk_1.default.red('ERROR') +
                " can't parse testcase: " +
                chalk_1.default.whiteBright(filename) +
                '');
            console.log(error);
            return new Promise(function (resolve, reject) {
                resolve(TestFailed);
            });
        }
        var testCase = tc;
        return index_1.runGrammarTestCase(registry, testCase)
            .then(function (failures) {
            return displayTestResult(filename, testCase, failures);
        })
            .catch(function (error) {
            return handleGrammarTestError(filename, testCase, error);
        });
    }));
    testResults.then(function (xs) {
        var result = xs.reduce(function (a, b) { return a + b; }, 0);
        if (result === TestSuccessful) {
            process.exit(0);
        }
        else {
            process.exit(-1);
        }
    });
});
function getCorrectedOffsets(failure) {
    return {
        l: failure.line + 1,
        s: failure.start + 1,
        e: failure.end + 1
    };
}
//# sourceMappingURL=unit.js.map